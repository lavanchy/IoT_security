
node-auth-basic.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00015c38  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  00015c38  00015c38  00025c38  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     000001e8  20000000  00015c40  00030000  2**2
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          0000169c  200001e8  00015e28  000301e8  2**2
                  ALLOC
  4 .stack        00002004  20001884  000174c4  000301e8  2**0
                  ALLOC
  5 .ARM.attributes 00000028  00000000  00000000  000301e8  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00030210  2**0
                  CONTENTS, READONLY
  7 .debug_info   000343f1  00000000  00000000  00030269  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000546e  00000000  00000000  0006465a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00001630  00000000  00000000  00069ac8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_macro  00022876  00000000  00000000  0006b0f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0001bfce  00000000  00000000  0008d96e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00098f59  00000000  00000000  000a993c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000795e  00000000  00000000  00142895  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00001308  00000000  00000000  0014a1f3  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00005654  00000000  00000000  0014b4fc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_sfixed>:
       0:	20003888 	.word	0x20003888
       4:	00011f79 	.word	0x00011f79
       8:	00012071 	.word	0x00012071
       c:	00012071 	.word	0x00012071
	...
      2c:	00012071 	.word	0x00012071
	...
      38:	00012071 	.word	0x00012071
      3c:	00012071 	.word	0x00012071
      40:	00012071 	.word	0x00012071
      44:	00012071 	.word	0x00012071
      48:	00012071 	.word	0x00012071
      4c:	00012071 	.word	0x00012071
      50:	00010f59 	.word	0x00010f59
      54:	00012071 	.word	0x00012071
      58:	00012071 	.word	0x00012071
      5c:	00010ad5 	.word	0x00010ad5
      60:	00012071 	.word	0x00012071
      64:	00012071 	.word	0x00012071
      68:	00012071 	.word	0x00012071
      6c:	00012071 	.word	0x00012071
      70:	00012071 	.word	0x00012071
      74:	00012071 	.word	0x00012071
      78:	00012071 	.word	0x00012071
      7c:	00012071 	.word	0x00012071
      80:	00012071 	.word	0x00012071
      84:	00012071 	.word	0x00012071
      88:	00012071 	.word	0x00012071
      8c:	00012071 	.word	0x00012071
      90:	00012071 	.word	0x00012071
      94:	00012071 	.word	0x00012071
      98:	00012071 	.word	0x00012071
      9c:	00012071 	.word	0x00012071
      a0:	00012071 	.word	0x00012071
      a4:	00012071 	.word	0x00012071
      a8:	00012071 	.word	0x00012071
      ac:	00012071 	.word	0x00012071

000000b0 <__do_global_dtors_aux>:
      b0:	b510      	push	{r4, lr}
      b2:	4c06      	ldr	r4, [pc, #24]	; (cc <__do_global_dtors_aux+0x1c>)
      b4:	7823      	ldrb	r3, [r4, #0]
      b6:	2b00      	cmp	r3, #0
      b8:	d107      	bne.n	ca <__do_global_dtors_aux+0x1a>
      ba:	4b05      	ldr	r3, [pc, #20]	; (d0 <__do_global_dtors_aux+0x20>)
      bc:	2b00      	cmp	r3, #0
      be:	d002      	beq.n	c6 <__do_global_dtors_aux+0x16>
      c0:	4804      	ldr	r0, [pc, #16]	; (d4 <__do_global_dtors_aux+0x24>)
      c2:	e000      	b.n	c6 <__do_global_dtors_aux+0x16>
      c4:	bf00      	nop
      c6:	2301      	movs	r3, #1
      c8:	7023      	strb	r3, [r4, #0]
      ca:	bd10      	pop	{r4, pc}
      cc:	200001e8 	.word	0x200001e8
      d0:	00000000 	.word	0x00000000
      d4:	00015c40 	.word	0x00015c40

000000d8 <frame_dummy>:
      d8:	4b08      	ldr	r3, [pc, #32]	; (fc <frame_dummy+0x24>)
      da:	b510      	push	{r4, lr}
      dc:	2b00      	cmp	r3, #0
      de:	d003      	beq.n	e8 <frame_dummy+0x10>
      e0:	4907      	ldr	r1, [pc, #28]	; (100 <frame_dummy+0x28>)
      e2:	4808      	ldr	r0, [pc, #32]	; (104 <frame_dummy+0x2c>)
      e4:	e000      	b.n	e8 <frame_dummy+0x10>
      e6:	bf00      	nop
      e8:	4807      	ldr	r0, [pc, #28]	; (108 <frame_dummy+0x30>)
      ea:	6803      	ldr	r3, [r0, #0]
      ec:	2b00      	cmp	r3, #0
      ee:	d100      	bne.n	f2 <frame_dummy+0x1a>
      f0:	bd10      	pop	{r4, pc}
      f2:	4b06      	ldr	r3, [pc, #24]	; (10c <frame_dummy+0x34>)
      f4:	2b00      	cmp	r3, #0
      f6:	d0fb      	beq.n	f0 <frame_dummy+0x18>
      f8:	4798      	blx	r3
      fa:	e7f9      	b.n	f0 <frame_dummy+0x18>
      fc:	00000000 	.word	0x00000000
     100:	200001ec 	.word	0x200001ec
     104:	00015c40 	.word	0x00015c40
     108:	00015c40 	.word	0x00015c40
     10c:	00000000 	.word	0x00000000

00000110 <sw_sha256_process>:
 * \param[in] ctx          SAH256 hash context
 * \param[in] blocks       Raw blocks to be processed
 * \param[in] block_count  Number of 64-byte blocks to process
 */
static void sw_sha256_process(sw_sha256_ctx* ctx, const uint8_t* blocks, uint32_t block_count)
{
     110:	b580      	push	{r7, lr}
     112:	b0d8      	sub	sp, #352	; 0x160
     114:	af00      	add	r7, sp, #0
     116:	60f8      	str	r0, [r7, #12]
     118:	60b9      	str	r1, [r7, #8]
     11a:	607a      	str	r2, [r7, #4]
	int i = 0;
     11c:	2300      	movs	r3, #0
     11e:	22ae      	movs	r2, #174	; 0xae
     120:	0052      	lsls	r2, r2, #1
     122:	18ba      	adds	r2, r7, r2
     124:	6013      	str	r3, [r2, #0]
	uint32_t block = 0;
     126:	2300      	movs	r3, #0
     128:	22ac      	movs	r2, #172	; 0xac
     12a:	0052      	lsls	r2, r2, #1
     12c:	18ba      	adds	r2, r7, r2
     12e:	6013      	str	r3, [r2, #0]
		0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
		0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	};

	// Loop through all the blocks to process
	for (block = 0; block < block_count; block++) {
     130:	2300      	movs	r3, #0
     132:	22ac      	movs	r2, #172	; 0xac
     134:	0052      	lsls	r2, r2, #1
     136:	18ba      	adds	r2, r7, r2
     138:	6013      	str	r3, [r2, #0]
     13a:	e2dd      	b.n	6f8 <sw_sha256_process+0x5e8>
		uint32_t word_value;
		uint32_t s0, s1;
		uint32_t t1, t2;
		uint32_t maj, ch;
		uint32_t rotate_register[8];
		const uint8_t* cur_msg_block = &blocks[block * SHA256_BLOCK_SIZE];
     13c:	23ac      	movs	r3, #172	; 0xac
     13e:	005b      	lsls	r3, r3, #1
     140:	18fb      	adds	r3, r7, r3
     142:	681b      	ldr	r3, [r3, #0]
     144:	019b      	lsls	r3, r3, #6
     146:	68ba      	ldr	r2, [r7, #8]
     148:	18d3      	adds	r3, r2, r3
     14a:	22a8      	movs	r2, #168	; 0xa8
     14c:	0052      	lsls	r2, r2, #1
     14e:	18ba      	adds	r2, r7, r2
     150:	6013      	str	r3, [r2, #0]

		// Swap word bytes
		for (i = 0; i < SHA256_BLOCK_SIZE; i += 4) {
     152:	2300      	movs	r3, #0
     154:	22ae      	movs	r2, #174	; 0xae
     156:	0052      	lsls	r2, r2, #1
     158:	18ba      	adds	r2, r7, r2
     15a:	6013      	str	r3, [r2, #0]
     15c:	e063      	b.n	226 <sw_sha256_process+0x116>
			w_union.w_byte[i + 3] = cur_msg_block[i + 0];
     15e:	23ae      	movs	r3, #174	; 0xae
     160:	005b      	lsls	r3, r3, #1
     162:	18fb      	adds	r3, r7, r3
     164:	681b      	ldr	r3, [r3, #0]
     166:	3303      	adds	r3, #3
     168:	22ae      	movs	r2, #174	; 0xae
     16a:	0052      	lsls	r2, r2, #1
     16c:	18ba      	adds	r2, r7, r2
     16e:	6812      	ldr	r2, [r2, #0]
     170:	21a8      	movs	r1, #168	; 0xa8
     172:	0049      	lsls	r1, r1, #1
     174:	1879      	adds	r1, r7, r1
     176:	6809      	ldr	r1, [r1, #0]
     178:	188a      	adds	r2, r1, r2
     17a:	7811      	ldrb	r1, [r2, #0]
     17c:	4a92      	ldr	r2, [pc, #584]	; (3c8 <sw_sha256_process+0x2b8>)
     17e:	20b0      	movs	r0, #176	; 0xb0
     180:	0040      	lsls	r0, r0, #1
     182:	4684      	mov	ip, r0
     184:	44bc      	add	ip, r7
     186:	4462      	add	r2, ip
     188:	54d1      	strb	r1, [r2, r3]
			w_union.w_byte[i + 2] = cur_msg_block[i + 1];
     18a:	23ae      	movs	r3, #174	; 0xae
     18c:	005b      	lsls	r3, r3, #1
     18e:	18fb      	adds	r3, r7, r3
     190:	681b      	ldr	r3, [r3, #0]
     192:	3302      	adds	r3, #2
     194:	22ae      	movs	r2, #174	; 0xae
     196:	0052      	lsls	r2, r2, #1
     198:	18ba      	adds	r2, r7, r2
     19a:	6812      	ldr	r2, [r2, #0]
     19c:	3201      	adds	r2, #1
     19e:	21a8      	movs	r1, #168	; 0xa8
     1a0:	0049      	lsls	r1, r1, #1
     1a2:	1879      	adds	r1, r7, r1
     1a4:	6809      	ldr	r1, [r1, #0]
     1a6:	188a      	adds	r2, r1, r2
     1a8:	7811      	ldrb	r1, [r2, #0]
     1aa:	4a87      	ldr	r2, [pc, #540]	; (3c8 <sw_sha256_process+0x2b8>)
     1ac:	20b0      	movs	r0, #176	; 0xb0
     1ae:	0040      	lsls	r0, r0, #1
     1b0:	4684      	mov	ip, r0
     1b2:	44bc      	add	ip, r7
     1b4:	4462      	add	r2, ip
     1b6:	54d1      	strb	r1, [r2, r3]
			w_union.w_byte[i + 1] = cur_msg_block[i + 2];
     1b8:	23ae      	movs	r3, #174	; 0xae
     1ba:	005b      	lsls	r3, r3, #1
     1bc:	18fb      	adds	r3, r7, r3
     1be:	681b      	ldr	r3, [r3, #0]
     1c0:	3301      	adds	r3, #1
     1c2:	22ae      	movs	r2, #174	; 0xae
     1c4:	0052      	lsls	r2, r2, #1
     1c6:	18ba      	adds	r2, r7, r2
     1c8:	6812      	ldr	r2, [r2, #0]
     1ca:	3202      	adds	r2, #2
     1cc:	21a8      	movs	r1, #168	; 0xa8
     1ce:	0049      	lsls	r1, r1, #1
     1d0:	1879      	adds	r1, r7, r1
     1d2:	6809      	ldr	r1, [r1, #0]
     1d4:	188a      	adds	r2, r1, r2
     1d6:	7811      	ldrb	r1, [r2, #0]
     1d8:	4a7b      	ldr	r2, [pc, #492]	; (3c8 <sw_sha256_process+0x2b8>)
     1da:	20b0      	movs	r0, #176	; 0xb0
     1dc:	0040      	lsls	r0, r0, #1
     1de:	4684      	mov	ip, r0
     1e0:	44bc      	add	ip, r7
     1e2:	4462      	add	r2, ip
     1e4:	54d1      	strb	r1, [r2, r3]
			w_union.w_byte[i + 0] = cur_msg_block[i + 3];
     1e6:	23ae      	movs	r3, #174	; 0xae
     1e8:	005b      	lsls	r3, r3, #1
     1ea:	18fb      	adds	r3, r7, r3
     1ec:	681b      	ldr	r3, [r3, #0]
     1ee:	3303      	adds	r3, #3
     1f0:	22a8      	movs	r2, #168	; 0xa8
     1f2:	0052      	lsls	r2, r2, #1
     1f4:	18ba      	adds	r2, r7, r2
     1f6:	6812      	ldr	r2, [r2, #0]
     1f8:	18d3      	adds	r3, r2, r3
     1fa:	7819      	ldrb	r1, [r3, #0]
     1fc:	4b72      	ldr	r3, [pc, #456]	; (3c8 <sw_sha256_process+0x2b8>)
     1fe:	22b0      	movs	r2, #176	; 0xb0
     200:	0052      	lsls	r2, r2, #1
     202:	18ba      	adds	r2, r7, r2
     204:	18d2      	adds	r2, r2, r3
     206:	23ae      	movs	r3, #174	; 0xae
     208:	005b      	lsls	r3, r3, #1
     20a:	18fb      	adds	r3, r7, r3
     20c:	681b      	ldr	r3, [r3, #0]
     20e:	18d3      	adds	r3, r2, r3
     210:	1c0a      	adds	r2, r1, #0
     212:	701a      	strb	r2, [r3, #0]
		uint32_t maj, ch;
		uint32_t rotate_register[8];
		const uint8_t* cur_msg_block = &blocks[block * SHA256_BLOCK_SIZE];

		// Swap word bytes
		for (i = 0; i < SHA256_BLOCK_SIZE; i += 4) {
     214:	23ae      	movs	r3, #174	; 0xae
     216:	005b      	lsls	r3, r3, #1
     218:	18fb      	adds	r3, r7, r3
     21a:	681b      	ldr	r3, [r3, #0]
     21c:	3304      	adds	r3, #4
     21e:	22ae      	movs	r2, #174	; 0xae
     220:	0052      	lsls	r2, r2, #1
     222:	18ba      	adds	r2, r7, r2
     224:	6013      	str	r3, [r2, #0]
     226:	23ae      	movs	r3, #174	; 0xae
     228:	005b      	lsls	r3, r3, #1
     22a:	18fb      	adds	r3, r7, r3
     22c:	681b      	ldr	r3, [r3, #0]
     22e:	2b3f      	cmp	r3, #63	; 0x3f
     230:	dd95      	ble.n	15e <sw_sha256_process+0x4e>
			w_union.w_byte[i + 2] = cur_msg_block[i + 1];
			w_union.w_byte[i + 1] = cur_msg_block[i + 2];
			w_union.w_byte[i + 0] = cur_msg_block[i + 3];
		}

		w_index = 16;
     232:	2310      	movs	r3, #16
     234:	22aa      	movs	r2, #170	; 0xaa
     236:	0052      	lsls	r2, r2, #1
     238:	18ba      	adds	r2, r7, r2
     23a:	6013      	str	r3, [r2, #0]
		while (w_index < SHA256_BLOCK_SIZE) {
     23c:	e08d      	b.n	35a <sw_sha256_process+0x24a>
			// right rotate for 32-bit variable in C: (value >> places) | (value << 32 - places)
			word_value = w_union.w_word[w_index - 15];
     23e:	23aa      	movs	r3, #170	; 0xaa
     240:	005b      	lsls	r3, r3, #1
     242:	18fb      	adds	r3, r7, r3
     244:	681b      	ldr	r3, [r3, #0]
     246:	3b0f      	subs	r3, #15
     248:	001a      	movs	r2, r3
     24a:	4b5f      	ldr	r3, [pc, #380]	; (3c8 <sw_sha256_process+0x2b8>)
     24c:	21b0      	movs	r1, #176	; 0xb0
     24e:	0049      	lsls	r1, r1, #1
     250:	468c      	mov	ip, r1
     252:	44bc      	add	ip, r7
     254:	4463      	add	r3, ip
     256:	0092      	lsls	r2, r2, #2
     258:	58d3      	ldr	r3, [r2, r3]
     25a:	22a6      	movs	r2, #166	; 0xa6
     25c:	0052      	lsls	r2, r2, #1
     25e:	18ba      	adds	r2, r7, r2
     260:	6013      	str	r3, [r2, #0]
			s0 = rotate_right(word_value, 7) ^ rotate_right(word_value, 18) ^ (word_value >> 3);
     262:	23a6      	movs	r3, #166	; 0xa6
     264:	005b      	lsls	r3, r3, #1
     266:	18fb      	adds	r3, r7, r3
     268:	681b      	ldr	r3, [r3, #0]
     26a:	2207      	movs	r2, #7
     26c:	41d3      	rors	r3, r2
     26e:	001a      	movs	r2, r3
     270:	23a6      	movs	r3, #166	; 0xa6
     272:	005b      	lsls	r3, r3, #1
     274:	18fb      	adds	r3, r7, r3
     276:	681b      	ldr	r3, [r3, #0]
     278:	2112      	movs	r1, #18
     27a:	41cb      	rors	r3, r1
     27c:	405a      	eors	r2, r3
     27e:	23a6      	movs	r3, #166	; 0xa6
     280:	005b      	lsls	r3, r3, #1
     282:	18fb      	adds	r3, r7, r3
     284:	681b      	ldr	r3, [r3, #0]
     286:	08db      	lsrs	r3, r3, #3
     288:	4053      	eors	r3, r2
     28a:	22a4      	movs	r2, #164	; 0xa4
     28c:	0052      	lsls	r2, r2, #1
     28e:	18ba      	adds	r2, r7, r2
     290:	6013      	str	r3, [r2, #0]

			word_value = w_union.w_word[w_index - 2];
     292:	23aa      	movs	r3, #170	; 0xaa
     294:	005b      	lsls	r3, r3, #1
     296:	18fb      	adds	r3, r7, r3
     298:	681b      	ldr	r3, [r3, #0]
     29a:	1e9a      	subs	r2, r3, #2
     29c:	4b4a      	ldr	r3, [pc, #296]	; (3c8 <sw_sha256_process+0x2b8>)
     29e:	21b0      	movs	r1, #176	; 0xb0
     2a0:	0049      	lsls	r1, r1, #1
     2a2:	468c      	mov	ip, r1
     2a4:	44bc      	add	ip, r7
     2a6:	4463      	add	r3, ip
     2a8:	0092      	lsls	r2, r2, #2
     2aa:	58d3      	ldr	r3, [r2, r3]
     2ac:	22a6      	movs	r2, #166	; 0xa6
     2ae:	0052      	lsls	r2, r2, #1
     2b0:	18ba      	adds	r2, r7, r2
     2b2:	6013      	str	r3, [r2, #0]
			s1 = rotate_right(word_value, 17) ^ rotate_right(word_value, 19) ^ (word_value >> 10);
     2b4:	23a6      	movs	r3, #166	; 0xa6
     2b6:	005b      	lsls	r3, r3, #1
     2b8:	18fb      	adds	r3, r7, r3
     2ba:	681b      	ldr	r3, [r3, #0]
     2bc:	2211      	movs	r2, #17
     2be:	41d3      	rors	r3, r2
     2c0:	001a      	movs	r2, r3
     2c2:	23a6      	movs	r3, #166	; 0xa6
     2c4:	005b      	lsls	r3, r3, #1
     2c6:	18fb      	adds	r3, r7, r3
     2c8:	681b      	ldr	r3, [r3, #0]
     2ca:	2113      	movs	r1, #19
     2cc:	41cb      	rors	r3, r1
     2ce:	405a      	eors	r2, r3
     2d0:	23a6      	movs	r3, #166	; 0xa6
     2d2:	005b      	lsls	r3, r3, #1
     2d4:	18fb      	adds	r3, r7, r3
     2d6:	681b      	ldr	r3, [r3, #0]
     2d8:	0a9b      	lsrs	r3, r3, #10
     2da:	4053      	eors	r3, r2
     2dc:	22a2      	movs	r2, #162	; 0xa2
     2de:	0052      	lsls	r2, r2, #1
     2e0:	18ba      	adds	r2, r7, r2
     2e2:	6013      	str	r3, [r2, #0]

			w_union.w_word[w_index] = w_union.w_word[w_index - 16] + s0 + w_union.w_word[w_index - 7] + s1;
     2e4:	23aa      	movs	r3, #170	; 0xaa
     2e6:	005b      	lsls	r3, r3, #1
     2e8:	18fb      	adds	r3, r7, r3
     2ea:	681b      	ldr	r3, [r3, #0]
     2ec:	3b10      	subs	r3, #16
     2ee:	001a      	movs	r2, r3
     2f0:	4b35      	ldr	r3, [pc, #212]	; (3c8 <sw_sha256_process+0x2b8>)
     2f2:	21b0      	movs	r1, #176	; 0xb0
     2f4:	0049      	lsls	r1, r1, #1
     2f6:	468c      	mov	ip, r1
     2f8:	44bc      	add	ip, r7
     2fa:	4463      	add	r3, ip
     2fc:	0092      	lsls	r2, r2, #2
     2fe:	58d2      	ldr	r2, [r2, r3]
     300:	23a4      	movs	r3, #164	; 0xa4
     302:	005b      	lsls	r3, r3, #1
     304:	18fb      	adds	r3, r7, r3
     306:	681b      	ldr	r3, [r3, #0]
     308:	18d2      	adds	r2, r2, r3
     30a:	23aa      	movs	r3, #170	; 0xaa
     30c:	005b      	lsls	r3, r3, #1
     30e:	18fb      	adds	r3, r7, r3
     310:	681b      	ldr	r3, [r3, #0]
     312:	1fd9      	subs	r1, r3, #7
     314:	4b2c      	ldr	r3, [pc, #176]	; (3c8 <sw_sha256_process+0x2b8>)
     316:	20b0      	movs	r0, #176	; 0xb0
     318:	0040      	lsls	r0, r0, #1
     31a:	4684      	mov	ip, r0
     31c:	44bc      	add	ip, r7
     31e:	4463      	add	r3, ip
     320:	0089      	lsls	r1, r1, #2
     322:	58cb      	ldr	r3, [r1, r3]
     324:	18d2      	adds	r2, r2, r3
     326:	23a2      	movs	r3, #162	; 0xa2
     328:	005b      	lsls	r3, r3, #1
     32a:	18fb      	adds	r3, r7, r3
     32c:	681b      	ldr	r3, [r3, #0]
     32e:	18d1      	adds	r1, r2, r3
     330:	4b25      	ldr	r3, [pc, #148]	; (3c8 <sw_sha256_process+0x2b8>)
     332:	22b0      	movs	r2, #176	; 0xb0
     334:	0052      	lsls	r2, r2, #1
     336:	4694      	mov	ip, r2
     338:	44bc      	add	ip, r7
     33a:	4463      	add	r3, ip
     33c:	22aa      	movs	r2, #170	; 0xaa
     33e:	0052      	lsls	r2, r2, #1
     340:	18ba      	adds	r2, r7, r2
     342:	6812      	ldr	r2, [r2, #0]
     344:	0092      	lsls	r2, r2, #2
     346:	50d1      	str	r1, [r2, r3]

			w_index++;
     348:	23aa      	movs	r3, #170	; 0xaa
     34a:	005b      	lsls	r3, r3, #1
     34c:	18fb      	adds	r3, r7, r3
     34e:	681b      	ldr	r3, [r3, #0]
     350:	3301      	adds	r3, #1
     352:	22aa      	movs	r2, #170	; 0xaa
     354:	0052      	lsls	r2, r2, #1
     356:	18ba      	adds	r2, r7, r2
     358:	6013      	str	r3, [r2, #0]
			w_union.w_byte[i + 1] = cur_msg_block[i + 2];
			w_union.w_byte[i + 0] = cur_msg_block[i + 3];
		}

		w_index = 16;
		while (w_index < SHA256_BLOCK_SIZE) {
     35a:	23aa      	movs	r3, #170	; 0xaa
     35c:	005b      	lsls	r3, r3, #1
     35e:	18fb      	adds	r3, r7, r3
     360:	681b      	ldr	r3, [r3, #0]
     362:	2b3f      	cmp	r3, #63	; 0x3f
     364:	d800      	bhi.n	368 <sw_sha256_process+0x258>
     366:	e76a      	b.n	23e <sw_sha256_process+0x12e>

			w_index++;
		}

		// Initialize hash value for this chunk.
		for (i = 0; i < 8; i++)
     368:	2300      	movs	r3, #0
     36a:	22ae      	movs	r2, #174	; 0xae
     36c:	0052      	lsls	r2, r2, #1
     36e:	18ba      	adds	r2, r7, r2
     370:	6013      	str	r3, [r2, #0]
     372:	e01c      	b.n	3ae <sw_sha256_process+0x29e>
			rotate_register[i] = ctx->hash[i];
     374:	68fb      	ldr	r3, [r7, #12]
     376:	22ae      	movs	r2, #174	; 0xae
     378:	0052      	lsls	r2, r2, #1
     37a:	18ba      	adds	r2, r7, r2
     37c:	6812      	ldr	r2, [r2, #0]
     37e:	3222      	adds	r2, #34	; 0x22
     380:	0092      	lsls	r2, r2, #2
     382:	58d1      	ldr	r1, [r2, r3]
     384:	4b11      	ldr	r3, [pc, #68]	; (3cc <sw_sha256_process+0x2bc>)
     386:	22b0      	movs	r2, #176	; 0xb0
     388:	0052      	lsls	r2, r2, #1
     38a:	4694      	mov	ip, r2
     38c:	44bc      	add	ip, r7
     38e:	4463      	add	r3, ip
     390:	22ae      	movs	r2, #174	; 0xae
     392:	0052      	lsls	r2, r2, #1
     394:	18ba      	adds	r2, r7, r2
     396:	6812      	ldr	r2, [r2, #0]
     398:	0092      	lsls	r2, r2, #2
     39a:	50d1      	str	r1, [r2, r3]

			w_index++;
		}

		// Initialize hash value for this chunk.
		for (i = 0; i < 8; i++)
     39c:	23ae      	movs	r3, #174	; 0xae
     39e:	005b      	lsls	r3, r3, #1
     3a0:	18fb      	adds	r3, r7, r3
     3a2:	681b      	ldr	r3, [r3, #0]
     3a4:	3301      	adds	r3, #1
     3a6:	22ae      	movs	r2, #174	; 0xae
     3a8:	0052      	lsls	r2, r2, #1
     3aa:	18ba      	adds	r2, r7, r2
     3ac:	6013      	str	r3, [r2, #0]
     3ae:	23ae      	movs	r3, #174	; 0xae
     3b0:	005b      	lsls	r3, r3, #1
     3b2:	18fb      	adds	r3, r7, r3
     3b4:	681b      	ldr	r3, [r3, #0]
     3b6:	2b07      	cmp	r3, #7
     3b8:	dddc      	ble.n	374 <sw_sha256_process+0x264>
			rotate_register[i] = ctx->hash[i];

		// hash calculation loop
		for (i = 0; i < SHA256_BLOCK_SIZE; i++) {
     3ba:	2300      	movs	r3, #0
     3bc:	22ae      	movs	r2, #174	; 0xae
     3be:	0052      	lsls	r2, r2, #1
     3c0:	18ba      	adds	r2, r7, r2
     3c2:	6013      	str	r3, [r2, #0]
     3c4:	e156      	b.n	674 <sw_sha256_process+0x564>
     3c6:	46c0      	nop			; (mov r8, r8)
     3c8:	fffffed4 	.word	0xfffffed4
     3cc:	fffffeb4 	.word	0xfffffeb4
			s0 = rotate_right(rotate_register[0], 2)
     3d0:	4bcf      	ldr	r3, [pc, #828]	; (710 <sw_sha256_process+0x600>)
     3d2:	22b0      	movs	r2, #176	; 0xb0
     3d4:	0052      	lsls	r2, r2, #1
     3d6:	4694      	mov	ip, r2
     3d8:	44bc      	add	ip, r7
     3da:	4463      	add	r3, ip
     3dc:	681b      	ldr	r3, [r3, #0]
     3de:	2202      	movs	r2, #2
     3e0:	41d3      	rors	r3, r2
     3e2:	001a      	movs	r2, r3
			     ^ rotate_right(rotate_register[0], 13)
     3e4:	4bca      	ldr	r3, [pc, #808]	; (710 <sw_sha256_process+0x600>)
     3e6:	21b0      	movs	r1, #176	; 0xb0
     3e8:	0049      	lsls	r1, r1, #1
     3ea:	468c      	mov	ip, r1
     3ec:	44bc      	add	ip, r7
     3ee:	4463      	add	r3, ip
     3f0:	681b      	ldr	r3, [r3, #0]
     3f2:	210d      	movs	r1, #13
     3f4:	41cb      	rors	r3, r1
     3f6:	405a      	eors	r2, r3
			     ^ rotate_right(rotate_register[0], 22);
     3f8:	4bc5      	ldr	r3, [pc, #788]	; (710 <sw_sha256_process+0x600>)
     3fa:	21b0      	movs	r1, #176	; 0xb0
     3fc:	0049      	lsls	r1, r1, #1
     3fe:	468c      	mov	ip, r1
     400:	44bc      	add	ip, r7
     402:	4463      	add	r3, ip
     404:	681b      	ldr	r3, [r3, #0]
     406:	2116      	movs	r1, #22
     408:	41cb      	rors	r3, r1
		for (i = 0; i < 8; i++)
			rotate_register[i] = ctx->hash[i];

		// hash calculation loop
		for (i = 0; i < SHA256_BLOCK_SIZE; i++) {
			s0 = rotate_right(rotate_register[0], 2)
     40a:	4053      	eors	r3, r2
     40c:	22a4      	movs	r2, #164	; 0xa4
     40e:	0052      	lsls	r2, r2, #1
     410:	18ba      	adds	r2, r7, r2
     412:	6013      	str	r3, [r2, #0]
			     ^ rotate_right(rotate_register[0], 13)
			     ^ rotate_right(rotate_register[0], 22);
			maj = (rotate_register[0] & rotate_register[1])
     414:	4bbe      	ldr	r3, [pc, #760]	; (710 <sw_sha256_process+0x600>)
     416:	22b0      	movs	r2, #176	; 0xb0
     418:	0052      	lsls	r2, r2, #1
     41a:	4694      	mov	ip, r2
     41c:	44bc      	add	ip, r7
     41e:	4463      	add	r3, ip
     420:	681a      	ldr	r2, [r3, #0]
     422:	4bbb      	ldr	r3, [pc, #748]	; (710 <sw_sha256_process+0x600>)
     424:	21b0      	movs	r1, #176	; 0xb0
     426:	0049      	lsls	r1, r1, #1
     428:	468c      	mov	ip, r1
     42a:	44bc      	add	ip, r7
     42c:	4463      	add	r3, ip
     42e:	685b      	ldr	r3, [r3, #4]
     430:	401a      	ands	r2, r3
			      ^ (rotate_register[0] & rotate_register[2])
     432:	4bb7      	ldr	r3, [pc, #732]	; (710 <sw_sha256_process+0x600>)
     434:	21b0      	movs	r1, #176	; 0xb0
     436:	0049      	lsls	r1, r1, #1
     438:	468c      	mov	ip, r1
     43a:	44bc      	add	ip, r7
     43c:	4463      	add	r3, ip
     43e:	6819      	ldr	r1, [r3, #0]
     440:	4bb3      	ldr	r3, [pc, #716]	; (710 <sw_sha256_process+0x600>)
     442:	20b0      	movs	r0, #176	; 0xb0
     444:	0040      	lsls	r0, r0, #1
     446:	4684      	mov	ip, r0
     448:	44bc      	add	ip, r7
     44a:	4463      	add	r3, ip
     44c:	689b      	ldr	r3, [r3, #8]
     44e:	400b      	ands	r3, r1
     450:	405a      	eors	r2, r3
			      ^ (rotate_register[1] & rotate_register[2]);
     452:	4baf      	ldr	r3, [pc, #700]	; (710 <sw_sha256_process+0x600>)
     454:	21b0      	movs	r1, #176	; 0xb0
     456:	0049      	lsls	r1, r1, #1
     458:	468c      	mov	ip, r1
     45a:	44bc      	add	ip, r7
     45c:	4463      	add	r3, ip
     45e:	6859      	ldr	r1, [r3, #4]
     460:	4bab      	ldr	r3, [pc, #684]	; (710 <sw_sha256_process+0x600>)
     462:	20b0      	movs	r0, #176	; 0xb0
     464:	0040      	lsls	r0, r0, #1
     466:	4684      	mov	ip, r0
     468:	44bc      	add	ip, r7
     46a:	4463      	add	r3, ip
     46c:	689b      	ldr	r3, [r3, #8]
     46e:	400b      	ands	r3, r1
		// hash calculation loop
		for (i = 0; i < SHA256_BLOCK_SIZE; i++) {
			s0 = rotate_right(rotate_register[0], 2)
			     ^ rotate_right(rotate_register[0], 13)
			     ^ rotate_right(rotate_register[0], 22);
			maj = (rotate_register[0] & rotate_register[1])
     470:	4053      	eors	r3, r2
     472:	22a0      	movs	r2, #160	; 0xa0
     474:	0052      	lsls	r2, r2, #1
     476:	18ba      	adds	r2, r7, r2
     478:	6013      	str	r3, [r2, #0]
			      ^ (rotate_register[0] & rotate_register[2])
			      ^ (rotate_register[1] & rotate_register[2]);
			t2 = s0 + maj;
     47a:	23a4      	movs	r3, #164	; 0xa4
     47c:	005b      	lsls	r3, r3, #1
     47e:	18fb      	adds	r3, r7, r3
     480:	681a      	ldr	r2, [r3, #0]
     482:	23a0      	movs	r3, #160	; 0xa0
     484:	005b      	lsls	r3, r3, #1
     486:	18fb      	adds	r3, r7, r3
     488:	681b      	ldr	r3, [r3, #0]
     48a:	18d3      	adds	r3, r2, r3
     48c:	229e      	movs	r2, #158	; 0x9e
     48e:	0052      	lsls	r2, r2, #1
     490:	18ba      	adds	r2, r7, r2
     492:	6013      	str	r3, [r2, #0]
			s1 = rotate_right(rotate_register[4], 6)
     494:	4b9e      	ldr	r3, [pc, #632]	; (710 <sw_sha256_process+0x600>)
     496:	22b0      	movs	r2, #176	; 0xb0
     498:	0052      	lsls	r2, r2, #1
     49a:	4694      	mov	ip, r2
     49c:	44bc      	add	ip, r7
     49e:	4463      	add	r3, ip
     4a0:	691b      	ldr	r3, [r3, #16]
     4a2:	2206      	movs	r2, #6
     4a4:	41d3      	rors	r3, r2
     4a6:	001a      	movs	r2, r3
			     ^ rotate_right(rotate_register[4], 11)
     4a8:	4b99      	ldr	r3, [pc, #612]	; (710 <sw_sha256_process+0x600>)
     4aa:	21b0      	movs	r1, #176	; 0xb0
     4ac:	0049      	lsls	r1, r1, #1
     4ae:	468c      	mov	ip, r1
     4b0:	44bc      	add	ip, r7
     4b2:	4463      	add	r3, ip
     4b4:	691b      	ldr	r3, [r3, #16]
     4b6:	210b      	movs	r1, #11
     4b8:	41cb      	rors	r3, r1
     4ba:	405a      	eors	r2, r3
			     ^ rotate_right(rotate_register[4], 25);
     4bc:	4b94      	ldr	r3, [pc, #592]	; (710 <sw_sha256_process+0x600>)
     4be:	21b0      	movs	r1, #176	; 0xb0
     4c0:	0049      	lsls	r1, r1, #1
     4c2:	468c      	mov	ip, r1
     4c4:	44bc      	add	ip, r7
     4c6:	4463      	add	r3, ip
     4c8:	691b      	ldr	r3, [r3, #16]
     4ca:	2119      	movs	r1, #25
     4cc:	41cb      	rors	r3, r1
			     ^ rotate_right(rotate_register[0], 22);
			maj = (rotate_register[0] & rotate_register[1])
			      ^ (rotate_register[0] & rotate_register[2])
			      ^ (rotate_register[1] & rotate_register[2]);
			t2 = s0 + maj;
			s1 = rotate_right(rotate_register[4], 6)
     4ce:	4053      	eors	r3, r2
     4d0:	22a2      	movs	r2, #162	; 0xa2
     4d2:	0052      	lsls	r2, r2, #1
     4d4:	18ba      	adds	r2, r7, r2
     4d6:	6013      	str	r3, [r2, #0]
			     ^ rotate_right(rotate_register[4], 11)
			     ^ rotate_right(rotate_register[4], 25);
			ch = (rotate_register[4] & rotate_register[5])
     4d8:	4b8d      	ldr	r3, [pc, #564]	; (710 <sw_sha256_process+0x600>)
     4da:	22b0      	movs	r2, #176	; 0xb0
     4dc:	0052      	lsls	r2, r2, #1
     4de:	4694      	mov	ip, r2
     4e0:	44bc      	add	ip, r7
     4e2:	4463      	add	r3, ip
     4e4:	691a      	ldr	r2, [r3, #16]
     4e6:	4b8a      	ldr	r3, [pc, #552]	; (710 <sw_sha256_process+0x600>)
     4e8:	21b0      	movs	r1, #176	; 0xb0
     4ea:	0049      	lsls	r1, r1, #1
     4ec:	468c      	mov	ip, r1
     4ee:	44bc      	add	ip, r7
     4f0:	4463      	add	r3, ip
     4f2:	695b      	ldr	r3, [r3, #20]
     4f4:	401a      	ands	r2, r3
			     ^ (~rotate_register[4] & rotate_register[6]);
     4f6:	4b86      	ldr	r3, [pc, #536]	; (710 <sw_sha256_process+0x600>)
     4f8:	21b0      	movs	r1, #176	; 0xb0
     4fa:	0049      	lsls	r1, r1, #1
     4fc:	468c      	mov	ip, r1
     4fe:	44bc      	add	ip, r7
     500:	4463      	add	r3, ip
     502:	691b      	ldr	r3, [r3, #16]
     504:	43d9      	mvns	r1, r3
     506:	4b82      	ldr	r3, [pc, #520]	; (710 <sw_sha256_process+0x600>)
     508:	20b0      	movs	r0, #176	; 0xb0
     50a:	0040      	lsls	r0, r0, #1
     50c:	4684      	mov	ip, r0
     50e:	44bc      	add	ip, r7
     510:	4463      	add	r3, ip
     512:	699b      	ldr	r3, [r3, #24]
     514:	400b      	ands	r3, r1
			      ^ (rotate_register[1] & rotate_register[2]);
			t2 = s0 + maj;
			s1 = rotate_right(rotate_register[4], 6)
			     ^ rotate_right(rotate_register[4], 11)
			     ^ rotate_right(rotate_register[4], 25);
			ch = (rotate_register[4] & rotate_register[5])
     516:	4053      	eors	r3, r2
     518:	229c      	movs	r2, #156	; 0x9c
     51a:	0052      	lsls	r2, r2, #1
     51c:	18ba      	adds	r2, r7, r2
     51e:	6013      	str	r3, [r2, #0]
			     ^ (~rotate_register[4] & rotate_register[6]);
			t1 = rotate_register[7] + s1 + ch + k[i] + w_union.w_word[i];
     520:	4b7b      	ldr	r3, [pc, #492]	; (710 <sw_sha256_process+0x600>)
     522:	22b0      	movs	r2, #176	; 0xb0
     524:	0052      	lsls	r2, r2, #1
     526:	4694      	mov	ip, r2
     528:	44bc      	add	ip, r7
     52a:	4463      	add	r3, ip
     52c:	69da      	ldr	r2, [r3, #28]
     52e:	23a2      	movs	r3, #162	; 0xa2
     530:	005b      	lsls	r3, r3, #1
     532:	18fb      	adds	r3, r7, r3
     534:	681b      	ldr	r3, [r3, #0]
     536:	18d2      	adds	r2, r2, r3
     538:	239c      	movs	r3, #156	; 0x9c
     53a:	005b      	lsls	r3, r3, #1
     53c:	18fb      	adds	r3, r7, r3
     53e:	681b      	ldr	r3, [r3, #0]
     540:	18d2      	adds	r2, r2, r3
     542:	4b74      	ldr	r3, [pc, #464]	; (714 <sw_sha256_process+0x604>)
     544:	21ae      	movs	r1, #174	; 0xae
     546:	0049      	lsls	r1, r1, #1
     548:	1879      	adds	r1, r7, r1
     54a:	6809      	ldr	r1, [r1, #0]
     54c:	0089      	lsls	r1, r1, #2
     54e:	58cb      	ldr	r3, [r1, r3]
     550:	18d2      	adds	r2, r2, r3
     552:	4b71      	ldr	r3, [pc, #452]	; (718 <sw_sha256_process+0x608>)
     554:	21b0      	movs	r1, #176	; 0xb0
     556:	0049      	lsls	r1, r1, #1
     558:	468c      	mov	ip, r1
     55a:	44bc      	add	ip, r7
     55c:	4463      	add	r3, ip
     55e:	21ae      	movs	r1, #174	; 0xae
     560:	0049      	lsls	r1, r1, #1
     562:	1879      	adds	r1, r7, r1
     564:	6809      	ldr	r1, [r1, #0]
     566:	0089      	lsls	r1, r1, #2
     568:	58cb      	ldr	r3, [r1, r3]
     56a:	18d3      	adds	r3, r2, r3
     56c:	229a      	movs	r2, #154	; 0x9a
     56e:	0052      	lsls	r2, r2, #1
     570:	18ba      	adds	r2, r7, r2
     572:	6013      	str	r3, [r2, #0]

			rotate_register[7] = rotate_register[6];
     574:	4b66      	ldr	r3, [pc, #408]	; (710 <sw_sha256_process+0x600>)
     576:	22b0      	movs	r2, #176	; 0xb0
     578:	0052      	lsls	r2, r2, #1
     57a:	4694      	mov	ip, r2
     57c:	44bc      	add	ip, r7
     57e:	4463      	add	r3, ip
     580:	699a      	ldr	r2, [r3, #24]
     582:	4b63      	ldr	r3, [pc, #396]	; (710 <sw_sha256_process+0x600>)
     584:	21b0      	movs	r1, #176	; 0xb0
     586:	0049      	lsls	r1, r1, #1
     588:	468c      	mov	ip, r1
     58a:	44bc      	add	ip, r7
     58c:	4463      	add	r3, ip
     58e:	61da      	str	r2, [r3, #28]
			rotate_register[6] = rotate_register[5];
     590:	4b5f      	ldr	r3, [pc, #380]	; (710 <sw_sha256_process+0x600>)
     592:	22b0      	movs	r2, #176	; 0xb0
     594:	0052      	lsls	r2, r2, #1
     596:	4694      	mov	ip, r2
     598:	44bc      	add	ip, r7
     59a:	4463      	add	r3, ip
     59c:	695a      	ldr	r2, [r3, #20]
     59e:	4b5c      	ldr	r3, [pc, #368]	; (710 <sw_sha256_process+0x600>)
     5a0:	21b0      	movs	r1, #176	; 0xb0
     5a2:	0049      	lsls	r1, r1, #1
     5a4:	468c      	mov	ip, r1
     5a6:	44bc      	add	ip, r7
     5a8:	4463      	add	r3, ip
     5aa:	619a      	str	r2, [r3, #24]
			rotate_register[5] = rotate_register[4];
     5ac:	4b58      	ldr	r3, [pc, #352]	; (710 <sw_sha256_process+0x600>)
     5ae:	22b0      	movs	r2, #176	; 0xb0
     5b0:	0052      	lsls	r2, r2, #1
     5b2:	4694      	mov	ip, r2
     5b4:	44bc      	add	ip, r7
     5b6:	4463      	add	r3, ip
     5b8:	691a      	ldr	r2, [r3, #16]
     5ba:	4b55      	ldr	r3, [pc, #340]	; (710 <sw_sha256_process+0x600>)
     5bc:	21b0      	movs	r1, #176	; 0xb0
     5be:	0049      	lsls	r1, r1, #1
     5c0:	468c      	mov	ip, r1
     5c2:	44bc      	add	ip, r7
     5c4:	4463      	add	r3, ip
     5c6:	615a      	str	r2, [r3, #20]
			rotate_register[4] = rotate_register[3] + t1;
     5c8:	4b51      	ldr	r3, [pc, #324]	; (710 <sw_sha256_process+0x600>)
     5ca:	22b0      	movs	r2, #176	; 0xb0
     5cc:	0052      	lsls	r2, r2, #1
     5ce:	4694      	mov	ip, r2
     5d0:	44bc      	add	ip, r7
     5d2:	4463      	add	r3, ip
     5d4:	68da      	ldr	r2, [r3, #12]
     5d6:	239a      	movs	r3, #154	; 0x9a
     5d8:	005b      	lsls	r3, r3, #1
     5da:	18fb      	adds	r3, r7, r3
     5dc:	681b      	ldr	r3, [r3, #0]
     5de:	18d2      	adds	r2, r2, r3
     5e0:	4b4b      	ldr	r3, [pc, #300]	; (710 <sw_sha256_process+0x600>)
     5e2:	21b0      	movs	r1, #176	; 0xb0
     5e4:	0049      	lsls	r1, r1, #1
     5e6:	468c      	mov	ip, r1
     5e8:	44bc      	add	ip, r7
     5ea:	4463      	add	r3, ip
     5ec:	611a      	str	r2, [r3, #16]
			rotate_register[3] = rotate_register[2];
     5ee:	4b48      	ldr	r3, [pc, #288]	; (710 <sw_sha256_process+0x600>)
     5f0:	22b0      	movs	r2, #176	; 0xb0
     5f2:	0052      	lsls	r2, r2, #1
     5f4:	4694      	mov	ip, r2
     5f6:	44bc      	add	ip, r7
     5f8:	4463      	add	r3, ip
     5fa:	689a      	ldr	r2, [r3, #8]
     5fc:	4b44      	ldr	r3, [pc, #272]	; (710 <sw_sha256_process+0x600>)
     5fe:	21b0      	movs	r1, #176	; 0xb0
     600:	0049      	lsls	r1, r1, #1
     602:	468c      	mov	ip, r1
     604:	44bc      	add	ip, r7
     606:	4463      	add	r3, ip
     608:	60da      	str	r2, [r3, #12]
			rotate_register[2] = rotate_register[1];
     60a:	4b41      	ldr	r3, [pc, #260]	; (710 <sw_sha256_process+0x600>)
     60c:	22b0      	movs	r2, #176	; 0xb0
     60e:	0052      	lsls	r2, r2, #1
     610:	4694      	mov	ip, r2
     612:	44bc      	add	ip, r7
     614:	4463      	add	r3, ip
     616:	685a      	ldr	r2, [r3, #4]
     618:	4b3d      	ldr	r3, [pc, #244]	; (710 <sw_sha256_process+0x600>)
     61a:	21b0      	movs	r1, #176	; 0xb0
     61c:	0049      	lsls	r1, r1, #1
     61e:	468c      	mov	ip, r1
     620:	44bc      	add	ip, r7
     622:	4463      	add	r3, ip
     624:	609a      	str	r2, [r3, #8]
			rotate_register[1] = rotate_register[0];
     626:	4b3a      	ldr	r3, [pc, #232]	; (710 <sw_sha256_process+0x600>)
     628:	22b0      	movs	r2, #176	; 0xb0
     62a:	0052      	lsls	r2, r2, #1
     62c:	4694      	mov	ip, r2
     62e:	44bc      	add	ip, r7
     630:	4463      	add	r3, ip
     632:	681a      	ldr	r2, [r3, #0]
     634:	4b36      	ldr	r3, [pc, #216]	; (710 <sw_sha256_process+0x600>)
     636:	21b0      	movs	r1, #176	; 0xb0
     638:	0049      	lsls	r1, r1, #1
     63a:	468c      	mov	ip, r1
     63c:	44bc      	add	ip, r7
     63e:	4463      	add	r3, ip
     640:	605a      	str	r2, [r3, #4]
			rotate_register[0] = t1 + t2;
     642:	239a      	movs	r3, #154	; 0x9a
     644:	005b      	lsls	r3, r3, #1
     646:	18fb      	adds	r3, r7, r3
     648:	681a      	ldr	r2, [r3, #0]
     64a:	239e      	movs	r3, #158	; 0x9e
     64c:	005b      	lsls	r3, r3, #1
     64e:	18fb      	adds	r3, r7, r3
     650:	681b      	ldr	r3, [r3, #0]
     652:	18d2      	adds	r2, r2, r3
     654:	4b2e      	ldr	r3, [pc, #184]	; (710 <sw_sha256_process+0x600>)
     656:	21b0      	movs	r1, #176	; 0xb0
     658:	0049      	lsls	r1, r1, #1
     65a:	468c      	mov	ip, r1
     65c:	44bc      	add	ip, r7
     65e:	4463      	add	r3, ip
     660:	601a      	str	r2, [r3, #0]
		// Initialize hash value for this chunk.
		for (i = 0; i < 8; i++)
			rotate_register[i] = ctx->hash[i];

		// hash calculation loop
		for (i = 0; i < SHA256_BLOCK_SIZE; i++) {
     662:	23ae      	movs	r3, #174	; 0xae
     664:	005b      	lsls	r3, r3, #1
     666:	18fb      	adds	r3, r7, r3
     668:	681b      	ldr	r3, [r3, #0]
     66a:	3301      	adds	r3, #1
     66c:	22ae      	movs	r2, #174	; 0xae
     66e:	0052      	lsls	r2, r2, #1
     670:	18ba      	adds	r2, r7, r2
     672:	6013      	str	r3, [r2, #0]
     674:	23ae      	movs	r3, #174	; 0xae
     676:	005b      	lsls	r3, r3, #1
     678:	18fb      	adds	r3, r7, r3
     67a:	681b      	ldr	r3, [r3, #0]
     67c:	2b3f      	cmp	r3, #63	; 0x3f
     67e:	dc00      	bgt.n	682 <sw_sha256_process+0x572>
     680:	e6a6      	b.n	3d0 <sw_sha256_process+0x2c0>
			rotate_register[1] = rotate_register[0];
			rotate_register[0] = t1 + t2;
		}

		// Add the hash of this block to current result.
		for (i = 0; i < 8; i++)
     682:	2300      	movs	r3, #0
     684:	22ae      	movs	r2, #174	; 0xae
     686:	0052      	lsls	r2, r2, #1
     688:	18ba      	adds	r2, r7, r2
     68a:	6013      	str	r3, [r2, #0]
     68c:	e025      	b.n	6da <sw_sha256_process+0x5ca>
			ctx->hash[i] += rotate_register[i];
     68e:	68fb      	ldr	r3, [r7, #12]
     690:	22ae      	movs	r2, #174	; 0xae
     692:	0052      	lsls	r2, r2, #1
     694:	18ba      	adds	r2, r7, r2
     696:	6812      	ldr	r2, [r2, #0]
     698:	3222      	adds	r2, #34	; 0x22
     69a:	0092      	lsls	r2, r2, #2
     69c:	58d2      	ldr	r2, [r2, r3]
     69e:	4b1c      	ldr	r3, [pc, #112]	; (710 <sw_sha256_process+0x600>)
     6a0:	21b0      	movs	r1, #176	; 0xb0
     6a2:	0049      	lsls	r1, r1, #1
     6a4:	468c      	mov	ip, r1
     6a6:	44bc      	add	ip, r7
     6a8:	4463      	add	r3, ip
     6aa:	21ae      	movs	r1, #174	; 0xae
     6ac:	0049      	lsls	r1, r1, #1
     6ae:	1879      	adds	r1, r7, r1
     6b0:	6809      	ldr	r1, [r1, #0]
     6b2:	0089      	lsls	r1, r1, #2
     6b4:	58cb      	ldr	r3, [r1, r3]
     6b6:	18d1      	adds	r1, r2, r3
     6b8:	68fb      	ldr	r3, [r7, #12]
     6ba:	22ae      	movs	r2, #174	; 0xae
     6bc:	0052      	lsls	r2, r2, #1
     6be:	18ba      	adds	r2, r7, r2
     6c0:	6812      	ldr	r2, [r2, #0]
     6c2:	3222      	adds	r2, #34	; 0x22
     6c4:	0092      	lsls	r2, r2, #2
     6c6:	50d1      	str	r1, [r2, r3]
			rotate_register[1] = rotate_register[0];
			rotate_register[0] = t1 + t2;
		}

		// Add the hash of this block to current result.
		for (i = 0; i < 8; i++)
     6c8:	23ae      	movs	r3, #174	; 0xae
     6ca:	005b      	lsls	r3, r3, #1
     6cc:	18fb      	adds	r3, r7, r3
     6ce:	681b      	ldr	r3, [r3, #0]
     6d0:	3301      	adds	r3, #1
     6d2:	22ae      	movs	r2, #174	; 0xae
     6d4:	0052      	lsls	r2, r2, #1
     6d6:	18ba      	adds	r2, r7, r2
     6d8:	6013      	str	r3, [r2, #0]
     6da:	23ae      	movs	r3, #174	; 0xae
     6dc:	005b      	lsls	r3, r3, #1
     6de:	18fb      	adds	r3, r7, r3
     6e0:	681b      	ldr	r3, [r3, #0]
     6e2:	2b07      	cmp	r3, #7
     6e4:	ddd3      	ble.n	68e <sw_sha256_process+0x57e>
		0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
		0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	};

	// Loop through all the blocks to process
	for (block = 0; block < block_count; block++) {
     6e6:	23ac      	movs	r3, #172	; 0xac
     6e8:	005b      	lsls	r3, r3, #1
     6ea:	18fb      	adds	r3, r7, r3
     6ec:	681b      	ldr	r3, [r3, #0]
     6ee:	3301      	adds	r3, #1
     6f0:	22ac      	movs	r2, #172	; 0xac
     6f2:	0052      	lsls	r2, r2, #1
     6f4:	18ba      	adds	r2, r7, r2
     6f6:	6013      	str	r3, [r2, #0]
     6f8:	23ac      	movs	r3, #172	; 0xac
     6fa:	005b      	lsls	r3, r3, #1
     6fc:	18fb      	adds	r3, r7, r3
     6fe:	681a      	ldr	r2, [r3, #0]
     700:	687b      	ldr	r3, [r7, #4]
     702:	429a      	cmp	r2, r3
     704:	d200      	bcs.n	708 <sw_sha256_process+0x5f8>
     706:	e519      	b.n	13c <sw_sha256_process+0x2c>

		// Add the hash of this block to current result.
		for (i = 0; i < 8; i++)
			ctx->hash[i] += rotate_register[i];
	}
}
     708:	46c0      	nop			; (mov r8, r8)
     70a:	46bd      	mov	sp, r7
     70c:	b058      	add	sp, #352	; 0x160
     70e:	bd80      	pop	{r7, pc}
     710:	fffffeb4 	.word	0xfffffeb4
     714:	00014d0c 	.word	0x00014d0c
     718:	fffffed4 	.word	0xfffffed4

0000071c <sw_sha256_init>:

void sw_sha256_init(sw_sha256_ctx* ctx)
{
     71c:	b580      	push	{r7, lr}
     71e:	b084      	sub	sp, #16
     720:	af00      	add	r7, sp, #0
     722:	6078      	str	r0, [r7, #4]
		0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
		0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
	};
	int i;

	memset(ctx, 0, sizeof(*ctx));
     724:	687b      	ldr	r3, [r7, #4]
     726:	22a8      	movs	r2, #168	; 0xa8
     728:	2100      	movs	r1, #0
     72a:	0018      	movs	r0, r3
     72c:	4b0b      	ldr	r3, [pc, #44]	; (75c <sw_sha256_init+0x40>)
     72e:	4798      	blx	r3
	for (i = 0; i < 8; i++)
     730:	2300      	movs	r3, #0
     732:	60fb      	str	r3, [r7, #12]
     734:	e00b      	b.n	74e <sw_sha256_init+0x32>
		ctx->hash[i] = hash_init[i];
     736:	4b0a      	ldr	r3, [pc, #40]	; (760 <sw_sha256_init+0x44>)
     738:	68fa      	ldr	r2, [r7, #12]
     73a:	0092      	lsls	r2, r2, #2
     73c:	58d1      	ldr	r1, [r2, r3]
     73e:	687b      	ldr	r3, [r7, #4]
     740:	68fa      	ldr	r2, [r7, #12]
     742:	3222      	adds	r2, #34	; 0x22
     744:	0092      	lsls	r2, r2, #2
     746:	50d1      	str	r1, [r2, r3]
		0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
	};
	int i;

	memset(ctx, 0, sizeof(*ctx));
	for (i = 0; i < 8; i++)
     748:	68fb      	ldr	r3, [r7, #12]
     74a:	3301      	adds	r3, #1
     74c:	60fb      	str	r3, [r7, #12]
     74e:	68fb      	ldr	r3, [r7, #12]
     750:	2b07      	cmp	r3, #7
     752:	ddf0      	ble.n	736 <sw_sha256_init+0x1a>
		ctx->hash[i] = hash_init[i];
}
     754:	46c0      	nop			; (mov r8, r8)
     756:	46bd      	mov	sp, r7
     758:	b004      	add	sp, #16
     75a:	bd80      	pop	{r7, pc}
     75c:	00012823 	.word	0x00012823
     760:	00014e0c 	.word	0x00014e0c

00000764 <sw_sha256_update>:

void sw_sha256_update(sw_sha256_ctx* ctx, const uint8_t* msg, uint32_t msg_size)
{
     764:	b580      	push	{r7, lr}
     766:	b088      	sub	sp, #32
     768:	af00      	add	r7, sp, #0
     76a:	60f8      	str	r0, [r7, #12]
     76c:	60b9      	str	r1, [r7, #8]
     76e:	607a      	str	r2, [r7, #4]
	uint32_t block_count;
	uint32_t rem_size = SHA256_BLOCK_SIZE - ctx->block_size;
     770:	68fb      	ldr	r3, [r7, #12]
     772:	685b      	ldr	r3, [r3, #4]
     774:	2240      	movs	r2, #64	; 0x40
     776:	1ad3      	subs	r3, r2, r3
     778:	61fb      	str	r3, [r7, #28]
	uint32_t copy_size = msg_size > rem_size ? rem_size : msg_size;
     77a:	69fa      	ldr	r2, [r7, #28]
     77c:	687b      	ldr	r3, [r7, #4]
     77e:	4293      	cmp	r3, r2
     780:	d900      	bls.n	784 <sw_sha256_update+0x20>
     782:	0013      	movs	r3, r2
     784:	61bb      	str	r3, [r7, #24]

	// Copy data into current block
	memcpy(&ctx->block[ctx->block_size], msg, copy_size);
     786:	68fb      	ldr	r3, [r7, #12]
     788:	685b      	ldr	r3, [r3, #4]
     78a:	3308      	adds	r3, #8
     78c:	68fa      	ldr	r2, [r7, #12]
     78e:	18d3      	adds	r3, r2, r3
     790:	69ba      	ldr	r2, [r7, #24]
     792:	68b9      	ldr	r1, [r7, #8]
     794:	0018      	movs	r0, r3
     796:	4b22      	ldr	r3, [pc, #136]	; (820 <sw_sha256_update+0xbc>)
     798:	4798      	blx	r3

	if (ctx->block_size + msg_size < SHA256_BLOCK_SIZE) {
     79a:	68fb      	ldr	r3, [r7, #12]
     79c:	685a      	ldr	r2, [r3, #4]
     79e:	687b      	ldr	r3, [r7, #4]
     7a0:	18d3      	adds	r3, r2, r3
     7a2:	2b3f      	cmp	r3, #63	; 0x3f
     7a4:	d806      	bhi.n	7b4 <sw_sha256_update+0x50>
		// Not enough data to finish off the current block
		ctx->block_size += msg_size;
     7a6:	68fb      	ldr	r3, [r7, #12]
     7a8:	685a      	ldr	r2, [r3, #4]
     7aa:	687b      	ldr	r3, [r7, #4]
     7ac:	18d2      	adds	r2, r2, r3
     7ae:	68fb      	ldr	r3, [r7, #12]
     7b0:	605a      	str	r2, [r3, #4]
		return;
     7b2:	e031      	b.n	818 <sw_sha256_update+0xb4>
	}

	// Process the current block
	sw_sha256_process(ctx, ctx->block, 1);
     7b4:	68fb      	ldr	r3, [r7, #12]
     7b6:	3308      	adds	r3, #8
     7b8:	0019      	movs	r1, r3
     7ba:	68fb      	ldr	r3, [r7, #12]
     7bc:	2201      	movs	r2, #1
     7be:	0018      	movs	r0, r3
     7c0:	4b18      	ldr	r3, [pc, #96]	; (824 <sw_sha256_update+0xc0>)
     7c2:	4798      	blx	r3

	// Process any additional blocks
	msg_size -= copy_size; // Adjust to the remaining message bytes
     7c4:	687a      	ldr	r2, [r7, #4]
     7c6:	69bb      	ldr	r3, [r7, #24]
     7c8:	1ad3      	subs	r3, r2, r3
     7ca:	607b      	str	r3, [r7, #4]
	block_count = msg_size / SHA256_BLOCK_SIZE;
     7cc:	687b      	ldr	r3, [r7, #4]
     7ce:	099b      	lsrs	r3, r3, #6
     7d0:	617b      	str	r3, [r7, #20]
	sw_sha256_process(ctx, &msg[copy_size], block_count);
     7d2:	68ba      	ldr	r2, [r7, #8]
     7d4:	69bb      	ldr	r3, [r7, #24]
     7d6:	18d1      	adds	r1, r2, r3
     7d8:	697a      	ldr	r2, [r7, #20]
     7da:	68fb      	ldr	r3, [r7, #12]
     7dc:	0018      	movs	r0, r3
     7de:	4b11      	ldr	r3, [pc, #68]	; (824 <sw_sha256_update+0xc0>)
     7e0:	4798      	blx	r3

	// Save any remaining data
	ctx->total_msg_size += (block_count + 1) * SHA256_BLOCK_SIZE;
     7e2:	68fb      	ldr	r3, [r7, #12]
     7e4:	681a      	ldr	r2, [r3, #0]
     7e6:	697b      	ldr	r3, [r7, #20]
     7e8:	3301      	adds	r3, #1
     7ea:	019b      	lsls	r3, r3, #6
     7ec:	18d2      	adds	r2, r2, r3
     7ee:	68fb      	ldr	r3, [r7, #12]
     7f0:	601a      	str	r2, [r3, #0]
	ctx->block_size = msg_size % SHA256_BLOCK_SIZE;
     7f2:	687b      	ldr	r3, [r7, #4]
     7f4:	223f      	movs	r2, #63	; 0x3f
     7f6:	401a      	ands	r2, r3
     7f8:	68fb      	ldr	r3, [r7, #12]
     7fa:	605a      	str	r2, [r3, #4]
	memcpy(ctx->block, &msg[copy_size + block_count * SHA256_BLOCK_SIZE], ctx->block_size);
     7fc:	68fb      	ldr	r3, [r7, #12]
     7fe:	3308      	adds	r3, #8
     800:	0018      	movs	r0, r3
     802:	697b      	ldr	r3, [r7, #20]
     804:	019a      	lsls	r2, r3, #6
     806:	69bb      	ldr	r3, [r7, #24]
     808:	18d3      	adds	r3, r2, r3
     80a:	68ba      	ldr	r2, [r7, #8]
     80c:	18d1      	adds	r1, r2, r3
     80e:	68fb      	ldr	r3, [r7, #12]
     810:	685b      	ldr	r3, [r3, #4]
     812:	001a      	movs	r2, r3
     814:	4b02      	ldr	r3, [pc, #8]	; (820 <sw_sha256_update+0xbc>)
     816:	4798      	blx	r3
}
     818:	46bd      	mov	sp, r7
     81a:	b008      	add	sp, #32
     81c:	bd80      	pop	{r7, pc}
     81e:	46c0      	nop			; (mov r8, r8)
     820:	000127e7 	.word	0x000127e7
     824:	00000111 	.word	0x00000111

00000828 <sw_sha256_final>:

void sw_sha256_final(sw_sha256_ctx* ctx, uint8_t digest[SHA256_DIGEST_SIZE])
{
     828:	b580      	push	{r7, lr}
     82a:	b086      	sub	sp, #24
     82c:	af00      	add	r7, sp, #0
     82e:	6078      	str	r0, [r7, #4]
     830:	6039      	str	r1, [r7, #0]
	int i, j;
	uint32_t msg_size_bits;
	uint32_t pad_zero_count;

	// Calculate the total message size in bits
	ctx->total_msg_size += ctx->block_size;
     832:	687b      	ldr	r3, [r7, #4]
     834:	681a      	ldr	r2, [r3, #0]
     836:	687b      	ldr	r3, [r7, #4]
     838:	685b      	ldr	r3, [r3, #4]
     83a:	18d2      	adds	r2, r2, r3
     83c:	687b      	ldr	r3, [r7, #4]
     83e:	601a      	str	r2, [r3, #0]
	msg_size_bits = ctx->total_msg_size * 8;
     840:	687b      	ldr	r3, [r7, #4]
     842:	681b      	ldr	r3, [r3, #0]
     844:	00db      	lsls	r3, r3, #3
     846:	60fb      	str	r3, [r7, #12]

	// Calculate the number of padding zero bytes required between the 1 bit byte and the 64 bit message size in bits.
	pad_zero_count = (SHA256_BLOCK_SIZE - ((ctx->block_size + 9) % SHA256_BLOCK_SIZE)) % SHA256_BLOCK_SIZE;
     848:	687b      	ldr	r3, [r7, #4]
     84a:	685b      	ldr	r3, [r3, #4]
     84c:	2209      	movs	r2, #9
     84e:	4252      	negs	r2, r2
     850:	1ad3      	subs	r3, r2, r3
     852:	223f      	movs	r2, #63	; 0x3f
     854:	4013      	ands	r3, r2
     856:	60bb      	str	r3, [r7, #8]

	// Append a single 1 bit
	ctx->block[ctx->block_size++] = 0x80;
     858:	687b      	ldr	r3, [r7, #4]
     85a:	685b      	ldr	r3, [r3, #4]
     85c:	1c59      	adds	r1, r3, #1
     85e:	687a      	ldr	r2, [r7, #4]
     860:	6051      	str	r1, [r2, #4]
     862:	687a      	ldr	r2, [r7, #4]
     864:	18d3      	adds	r3, r2, r3
     866:	2280      	movs	r2, #128	; 0x80
     868:	721a      	strb	r2, [r3, #8]

	// Add padding zeros plus upper 4 bytes of total msg size in bits (only supporting 32bit message bit counts)
	memset(&ctx->block[ctx->block_size], 0, pad_zero_count + 4);
     86a:	687b      	ldr	r3, [r7, #4]
     86c:	685b      	ldr	r3, [r3, #4]
     86e:	3308      	adds	r3, #8
     870:	687a      	ldr	r2, [r7, #4]
     872:	18d0      	adds	r0, r2, r3
     874:	68bb      	ldr	r3, [r7, #8]
     876:	3304      	adds	r3, #4
     878:	001a      	movs	r2, r3
     87a:	2100      	movs	r1, #0
     87c:	4b37      	ldr	r3, [pc, #220]	; (95c <sw_sha256_final+0x134>)
     87e:	4798      	blx	r3
	ctx->block_size += pad_zero_count + 4;
     880:	687b      	ldr	r3, [r7, #4]
     882:	685a      	ldr	r2, [r3, #4]
     884:	68bb      	ldr	r3, [r7, #8]
     886:	18d3      	adds	r3, r2, r3
     888:	1d1a      	adds	r2, r3, #4
     88a:	687b      	ldr	r3, [r7, #4]
     88c:	605a      	str	r2, [r3, #4]

	// Add the total message size in bits to the end of the current block. Technically this is
	// supposed to be 8 bytes. This shortcut will reduce the max message size to 536,870,911 bytes.
	ctx->block[ctx->block_size++] = (uint8_t)(msg_size_bits >> 24);
     88e:	687b      	ldr	r3, [r7, #4]
     890:	685b      	ldr	r3, [r3, #4]
     892:	1c59      	adds	r1, r3, #1
     894:	687a      	ldr	r2, [r7, #4]
     896:	6051      	str	r1, [r2, #4]
     898:	68fa      	ldr	r2, [r7, #12]
     89a:	0e12      	lsrs	r2, r2, #24
     89c:	b2d1      	uxtb	r1, r2
     89e:	687a      	ldr	r2, [r7, #4]
     8a0:	18d3      	adds	r3, r2, r3
     8a2:	1c0a      	adds	r2, r1, #0
     8a4:	721a      	strb	r2, [r3, #8]
	ctx->block[ctx->block_size++] = (uint8_t)(msg_size_bits >> 16);
     8a6:	687b      	ldr	r3, [r7, #4]
     8a8:	685b      	ldr	r3, [r3, #4]
     8aa:	1c59      	adds	r1, r3, #1
     8ac:	687a      	ldr	r2, [r7, #4]
     8ae:	6051      	str	r1, [r2, #4]
     8b0:	68fa      	ldr	r2, [r7, #12]
     8b2:	0c12      	lsrs	r2, r2, #16
     8b4:	b2d1      	uxtb	r1, r2
     8b6:	687a      	ldr	r2, [r7, #4]
     8b8:	18d3      	adds	r3, r2, r3
     8ba:	1c0a      	adds	r2, r1, #0
     8bc:	721a      	strb	r2, [r3, #8]
	ctx->block[ctx->block_size++] = (uint8_t)(msg_size_bits >> 8);
     8be:	687b      	ldr	r3, [r7, #4]
     8c0:	685b      	ldr	r3, [r3, #4]
     8c2:	1c59      	adds	r1, r3, #1
     8c4:	687a      	ldr	r2, [r7, #4]
     8c6:	6051      	str	r1, [r2, #4]
     8c8:	68fa      	ldr	r2, [r7, #12]
     8ca:	0a12      	lsrs	r2, r2, #8
     8cc:	b2d1      	uxtb	r1, r2
     8ce:	687a      	ldr	r2, [r7, #4]
     8d0:	18d3      	adds	r3, r2, r3
     8d2:	1c0a      	adds	r2, r1, #0
     8d4:	721a      	strb	r2, [r3, #8]
	ctx->block[ctx->block_size++] = (uint8_t)(msg_size_bits >> 0);
     8d6:	687b      	ldr	r3, [r7, #4]
     8d8:	685b      	ldr	r3, [r3, #4]
     8da:	1c59      	adds	r1, r3, #1
     8dc:	687a      	ldr	r2, [r7, #4]
     8de:	6051      	str	r1, [r2, #4]
     8e0:	68fa      	ldr	r2, [r7, #12]
     8e2:	b2d1      	uxtb	r1, r2
     8e4:	687a      	ldr	r2, [r7, #4]
     8e6:	18d3      	adds	r3, r2, r3
     8e8:	1c0a      	adds	r2, r1, #0
     8ea:	721a      	strb	r2, [r3, #8]

	sw_sha256_process(ctx, ctx->block, ctx->block_size / SHA256_BLOCK_SIZE);
     8ec:	687b      	ldr	r3, [r7, #4]
     8ee:	3308      	adds	r3, #8
     8f0:	0019      	movs	r1, r3
     8f2:	687b      	ldr	r3, [r7, #4]
     8f4:	685b      	ldr	r3, [r3, #4]
     8f6:	099a      	lsrs	r2, r3, #6
     8f8:	687b      	ldr	r3, [r7, #4]
     8fa:	0018      	movs	r0, r3
     8fc:	4b18      	ldr	r3, [pc, #96]	; (960 <sw_sha256_final+0x138>)
     8fe:	4798      	blx	r3

	// All blocks have been processed.
	// Concatenate the hashes to produce digest, MSB of every hash first.
	for (i = 0; i < 8; i++)
     900:	2300      	movs	r3, #0
     902:	617b      	str	r3, [r7, #20]
     904:	e023      	b.n	94e <sw_sha256_final+0x126>
		for (j = sizeof(int32_t) - 1; j >= 0; j--, ctx->hash[i] >>= 8)
     906:	2303      	movs	r3, #3
     908:	613b      	str	r3, [r7, #16]
     90a:	e01a      	b.n	942 <sw_sha256_final+0x11a>
			digest[i * sizeof(int32_t) + j] = ctx->hash[i] & 0xFF;
     90c:	697b      	ldr	r3, [r7, #20]
     90e:	009a      	lsls	r2, r3, #2
     910:	693b      	ldr	r3, [r7, #16]
     912:	18d3      	adds	r3, r2, r3
     914:	683a      	ldr	r2, [r7, #0]
     916:	18d3      	adds	r3, r2, r3
     918:	687a      	ldr	r2, [r7, #4]
     91a:	6979      	ldr	r1, [r7, #20]
     91c:	3122      	adds	r1, #34	; 0x22
     91e:	0089      	lsls	r1, r1, #2
     920:	588a      	ldr	r2, [r1, r2]
     922:	b2d2      	uxtb	r2, r2
     924:	701a      	strb	r2, [r3, #0]
	sw_sha256_process(ctx, ctx->block, ctx->block_size / SHA256_BLOCK_SIZE);

	// All blocks have been processed.
	// Concatenate the hashes to produce digest, MSB of every hash first.
	for (i = 0; i < 8; i++)
		for (j = sizeof(int32_t) - 1; j >= 0; j--, ctx->hash[i] >>= 8)
     926:	693b      	ldr	r3, [r7, #16]
     928:	3b01      	subs	r3, #1
     92a:	613b      	str	r3, [r7, #16]
     92c:	687b      	ldr	r3, [r7, #4]
     92e:	697a      	ldr	r2, [r7, #20]
     930:	3222      	adds	r2, #34	; 0x22
     932:	0092      	lsls	r2, r2, #2
     934:	58d3      	ldr	r3, [r2, r3]
     936:	0a19      	lsrs	r1, r3, #8
     938:	687b      	ldr	r3, [r7, #4]
     93a:	697a      	ldr	r2, [r7, #20]
     93c:	3222      	adds	r2, #34	; 0x22
     93e:	0092      	lsls	r2, r2, #2
     940:	50d1      	str	r1, [r2, r3]
     942:	693b      	ldr	r3, [r7, #16]
     944:	2b00      	cmp	r3, #0
     946:	dae1      	bge.n	90c <sw_sha256_final+0xe4>

	sw_sha256_process(ctx, ctx->block, ctx->block_size / SHA256_BLOCK_SIZE);

	// All blocks have been processed.
	// Concatenate the hashes to produce digest, MSB of every hash first.
	for (i = 0; i < 8; i++)
     948:	697b      	ldr	r3, [r7, #20]
     94a:	3301      	adds	r3, #1
     94c:	617b      	str	r3, [r7, #20]
     94e:	697b      	ldr	r3, [r7, #20]
     950:	2b07      	cmp	r3, #7
     952:	ddd8      	ble.n	906 <sw_sha256_final+0xde>
		for (j = sizeof(int32_t) - 1; j >= 0; j--, ctx->hash[i] >>= 8)
			digest[i * sizeof(int32_t) + j] = ctx->hash[i] & 0xFF;
}
     954:	46c0      	nop			; (mov r8, r8)
     956:	46bd      	mov	sp, r7
     958:	b006      	add	sp, #24
     95a:	bd80      	pop	{r7, pc}
     95c:	00012823 	.word	0x00012823
     960:	00000111 	.word	0x00000111

00000964 <client_rebuild_certs>:
 * a full X.509 cert in DER format.  Because this is an example, it prints the reconstructed cert
 * data to the console in ASCII hex format.
 */

int client_rebuild_certs(void)
{
     964:	b590      	push	{r4, r7, lr}
     966:	4c3b      	ldr	r4, [pc, #236]	; (a54 <client_rebuild_certs+0xf0>)
     968:	44a5      	add	sp, r4
     96a:	af00      	add	r7, sp, #0
    int ret = 0;
     96c:	2300      	movs	r3, #0
     96e:	4a3a      	ldr	r2, [pc, #232]	; (a58 <client_rebuild_certs+0xf4>)
     970:	18ba      	adds	r2, r7, r2
     972:	6013      	str	r3, [r2, #0]
    char disp_str[1500];
    int disp_size = sizeof(disp_str);
     974:	4b39      	ldr	r3, [pc, #228]	; (a5c <client_rebuild_certs+0xf8>)
     976:	647b      	str	r3, [r7, #68]	; 0x44
    uint8_t signer_public_key[64];
    
    g_signer_cert_size = sizeof(g_signer_cert);
     978:	4b39      	ldr	r3, [pc, #228]	; (a60 <client_rebuild_certs+0xfc>)
     97a:	2280      	movs	r2, #128	; 0x80
     97c:	00d2      	lsls	r2, r2, #3
     97e:	601a      	str	r2, [r3, #0]
	ret = atcacert_read_cert(&g_cert_def_1_signer, g_signer_ca_public_key, g_signer_cert, &g_signer_cert_size);
     980:	4b37      	ldr	r3, [pc, #220]	; (a60 <client_rebuild_certs+0xfc>)
     982:	4a38      	ldr	r2, [pc, #224]	; (a64 <client_rebuild_certs+0x100>)
     984:	4938      	ldr	r1, [pc, #224]	; (a68 <client_rebuild_certs+0x104>)
     986:	4839      	ldr	r0, [pc, #228]	; (a6c <client_rebuild_certs+0x108>)
     988:	4c39      	ldr	r4, [pc, #228]	; (a70 <client_rebuild_certs+0x10c>)
     98a:	47a0      	blx	r4
     98c:	0003      	movs	r3, r0
     98e:	4a32      	ldr	r2, [pc, #200]	; (a58 <client_rebuild_certs+0xf4>)
     990:	18ba      	adds	r2, r7, r2
     992:	6013      	str	r3, [r2, #0]
    if (ret != ATCACERT_E_SUCCESS) return ret;
     994:	4b30      	ldr	r3, [pc, #192]	; (a58 <client_rebuild_certs+0xf4>)
     996:	18fb      	adds	r3, r7, r3
     998:	681b      	ldr	r3, [r3, #0]
     99a:	2b00      	cmp	r3, #0
     99c:	d003      	beq.n	9a6 <client_rebuild_certs+0x42>
     99e:	4b2e      	ldr	r3, [pc, #184]	; (a58 <client_rebuild_certs+0xf4>)
     9a0:	18fb      	adds	r3, r7, r3
     9a2:	681b      	ldr	r3, [r3, #0]
     9a4:	e051      	b.n	a4a <client_rebuild_certs+0xe6>
    
    disp_size = sizeof(disp_str);
     9a6:	4b2d      	ldr	r3, [pc, #180]	; (a5c <client_rebuild_certs+0xf8>)
     9a8:	647b      	str	r3, [r7, #68]	; 0x44
    atcab_bin2hex( g_signer_cert, g_signer_cert_size, disp_str, &disp_size);
     9aa:	4b2d      	ldr	r3, [pc, #180]	; (a60 <client_rebuild_certs+0xfc>)
     9ac:	681b      	ldr	r3, [r3, #0]
     9ae:	0019      	movs	r1, r3
     9b0:	2344      	movs	r3, #68	; 0x44
     9b2:	18fb      	adds	r3, r7, r3
     9b4:	2248      	movs	r2, #72	; 0x48
     9b6:	18ba      	adds	r2, r7, r2
     9b8:	482a      	ldr	r0, [pc, #168]	; (a64 <client_rebuild_certs+0x100>)
     9ba:	4c2e      	ldr	r4, [pc, #184]	; (a74 <client_rebuild_certs+0x110>)
     9bc:	47a0      	blx	r4
    printf("CLIENT: Rebuilt Signer Certificate:\r\n%s\r\n", disp_str);
     9be:	2348      	movs	r3, #72	; 0x48
     9c0:	18fa      	adds	r2, r7, r3
     9c2:	4b2d      	ldr	r3, [pc, #180]	; (a78 <client_rebuild_certs+0x114>)
     9c4:	0011      	movs	r1, r2
     9c6:	0018      	movs	r0, r3
     9c8:	4b2c      	ldr	r3, [pc, #176]	; (a7c <client_rebuild_certs+0x118>)
     9ca:	4798      	blx	r3
    
    ret = atcacert_get_subj_public_key(&g_cert_def_1_signer, g_signer_cert, g_signer_cert_size, signer_public_key);
     9cc:	4b24      	ldr	r3, [pc, #144]	; (a60 <client_rebuild_certs+0xfc>)
     9ce:	681a      	ldr	r2, [r3, #0]
     9d0:	1d3b      	adds	r3, r7, #4
     9d2:	4924      	ldr	r1, [pc, #144]	; (a64 <client_rebuild_certs+0x100>)
     9d4:	4825      	ldr	r0, [pc, #148]	; (a6c <client_rebuild_certs+0x108>)
     9d6:	4c2a      	ldr	r4, [pc, #168]	; (a80 <client_rebuild_certs+0x11c>)
     9d8:	47a0      	blx	r4
     9da:	0003      	movs	r3, r0
     9dc:	4a1e      	ldr	r2, [pc, #120]	; (a58 <client_rebuild_certs+0xf4>)
     9de:	18ba      	adds	r2, r7, r2
     9e0:	6013      	str	r3, [r2, #0]
    if (ret != ATCACERT_E_SUCCESS) return ret;
     9e2:	4b1d      	ldr	r3, [pc, #116]	; (a58 <client_rebuild_certs+0xf4>)
     9e4:	18fb      	adds	r3, r7, r3
     9e6:	681b      	ldr	r3, [r3, #0]
     9e8:	2b00      	cmp	r3, #0
     9ea:	d003      	beq.n	9f4 <client_rebuild_certs+0x90>
     9ec:	4b1a      	ldr	r3, [pc, #104]	; (a58 <client_rebuild_certs+0xf4>)
     9ee:	18fb      	adds	r3, r7, r3
     9f0:	681b      	ldr	r3, [r3, #0]
     9f2:	e02a      	b.n	a4a <client_rebuild_certs+0xe6>
    
    g_device_cert_size = sizeof(g_device_cert);
     9f4:	4b23      	ldr	r3, [pc, #140]	; (a84 <client_rebuild_certs+0x120>)
     9f6:	2280      	movs	r2, #128	; 0x80
     9f8:	00d2      	lsls	r2, r2, #3
     9fa:	601a      	str	r2, [r3, #0]
    ret = atcacert_read_cert(&g_cert_def_2_device, signer_public_key, g_device_cert, &g_device_cert_size);
     9fc:	4b21      	ldr	r3, [pc, #132]	; (a84 <client_rebuild_certs+0x120>)
     9fe:	4a22      	ldr	r2, [pc, #136]	; (a88 <client_rebuild_certs+0x124>)
     a00:	1d39      	adds	r1, r7, #4
     a02:	4822      	ldr	r0, [pc, #136]	; (a8c <client_rebuild_certs+0x128>)
     a04:	4c1a      	ldr	r4, [pc, #104]	; (a70 <client_rebuild_certs+0x10c>)
     a06:	47a0      	blx	r4
     a08:	0003      	movs	r3, r0
     a0a:	4a13      	ldr	r2, [pc, #76]	; (a58 <client_rebuild_certs+0xf4>)
     a0c:	18ba      	adds	r2, r7, r2
     a0e:	6013      	str	r3, [r2, #0]
    if (ret != ATCACERT_E_SUCCESS) return ret;
     a10:	4b11      	ldr	r3, [pc, #68]	; (a58 <client_rebuild_certs+0xf4>)
     a12:	18fb      	adds	r3, r7, r3
     a14:	681b      	ldr	r3, [r3, #0]
     a16:	2b00      	cmp	r3, #0
     a18:	d003      	beq.n	a22 <client_rebuild_certs+0xbe>
     a1a:	4b0f      	ldr	r3, [pc, #60]	; (a58 <client_rebuild_certs+0xf4>)
     a1c:	18fb      	adds	r3, r7, r3
     a1e:	681b      	ldr	r3, [r3, #0]
     a20:	e013      	b.n	a4a <client_rebuild_certs+0xe6>
    
    disp_size = sizeof(disp_str);
     a22:	4b0e      	ldr	r3, [pc, #56]	; (a5c <client_rebuild_certs+0xf8>)
     a24:	647b      	str	r3, [r7, #68]	; 0x44
    atcab_bin2hex( g_device_cert, g_device_cert_size, disp_str, &disp_size);
     a26:	4b17      	ldr	r3, [pc, #92]	; (a84 <client_rebuild_certs+0x120>)
     a28:	681b      	ldr	r3, [r3, #0]
     a2a:	0019      	movs	r1, r3
     a2c:	2344      	movs	r3, #68	; 0x44
     a2e:	18fb      	adds	r3, r7, r3
     a30:	2248      	movs	r2, #72	; 0x48
     a32:	18ba      	adds	r2, r7, r2
     a34:	4814      	ldr	r0, [pc, #80]	; (a88 <client_rebuild_certs+0x124>)
     a36:	4c0f      	ldr	r4, [pc, #60]	; (a74 <client_rebuild_certs+0x110>)
     a38:	47a0      	blx	r4
    printf("CLIENT: Rebuilt Device Certificate:\r\n%s\r\n", disp_str);
     a3a:	2348      	movs	r3, #72	; 0x48
     a3c:	18fa      	adds	r2, r7, r3
     a3e:	4b14      	ldr	r3, [pc, #80]	; (a90 <client_rebuild_certs+0x12c>)
     a40:	0011      	movs	r1, r2
     a42:	0018      	movs	r0, r3
     a44:	4b0d      	ldr	r3, [pc, #52]	; (a7c <client_rebuild_certs+0x118>)
     a46:	4798      	blx	r3
    
    return 0;
     a48:	2300      	movs	r3, #0
}
     a4a:	0018      	movs	r0, r3
     a4c:	46bd      	mov	sp, r7
     a4e:	4b11      	ldr	r3, [pc, #68]	; (a94 <client_rebuild_certs+0x130>)
     a50:	449d      	add	sp, r3
     a52:	bd90      	pop	{r4, r7, pc}
     a54:	fffff9d4 	.word	0xfffff9d4
     a58:	00000624 	.word	0x00000624
     a5c:	000005dc 	.word	0x000005dc
     a60:	2000001c 	.word	0x2000001c
     a64:	2000098c 	.word	0x2000098c
     a68:	200011cc 	.word	0x200011cc
     a6c:	00014ac0 	.word	0x00014ac0
     a70:	00005a49 	.word	0x00005a49
     a74:	0000d0dd 	.word	0x0000d0dd
     a78:	00014e2c 	.word	0x00014e2c
     a7c:	0001296d 	.word	0x0001296d
     a80:	0000894d 	.word	0x0000894d
     a84:	20000020 	.word	0x20000020
     a88:	20000d8c 	.word	0x20000d8c
     a8c:	00014cc0 	.word	0x00014cc0
     a90:	00014e58 	.word	0x00014e58
     a94:	0000062c 	.word	0x0000062c

00000a98 <host_verify_cert_chain>:
 * performs an ECDSA verification of each link in the cert chain.  This verifies that the device has been
 * properly signed into the chain starting from the CA root of trust (RoT).
 */

int host_verify_cert_chain(void)
{
     a98:	b590      	push	{r4, r7, lr}
     a9a:	b093      	sub	sp, #76	; 0x4c
     a9c:	af00      	add	r7, sp, #0
    int ret = 0;
     a9e:	2300      	movs	r3, #0
     aa0:	647b      	str	r3, [r7, #68]	; 0x44
    uint8_t signer_public_key[64];
    
    // Validate signer cert against its certificate authority (CA) public key
    ret = atcacert_verify_cert_hw(&g_cert_def_1_signer,  g_signer_cert, g_signer_cert_size, g_signer_ca_public_key);
     aa2:	4b1b      	ldr	r3, [pc, #108]	; (b10 <host_verify_cert_chain+0x78>)
     aa4:	681a      	ldr	r2, [r3, #0]
     aa6:	4b1b      	ldr	r3, [pc, #108]	; (b14 <host_verify_cert_chain+0x7c>)
     aa8:	491b      	ldr	r1, [pc, #108]	; (b18 <host_verify_cert_chain+0x80>)
     aaa:	481c      	ldr	r0, [pc, #112]	; (b1c <host_verify_cert_chain+0x84>)
     aac:	4c1c      	ldr	r4, [pc, #112]	; (b20 <host_verify_cert_chain+0x88>)
     aae:	47a0      	blx	r4
     ab0:	0003      	movs	r3, r0
     ab2:	647b      	str	r3, [r7, #68]	; 0x44
    if (ret != ATCACERT_E_SUCCESS) return ret;
     ab4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     ab6:	2b00      	cmp	r3, #0
     ab8:	d001      	beq.n	abe <host_verify_cert_chain+0x26>
     aba:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     abc:	e024      	b.n	b08 <host_verify_cert_chain+0x70>
    printf("HOST: Signer certificate verified against signer certificate authority (CA) public key!\r\n");
     abe:	4b19      	ldr	r3, [pc, #100]	; (b24 <host_verify_cert_chain+0x8c>)
     ac0:	0018      	movs	r0, r3
     ac2:	4b19      	ldr	r3, [pc, #100]	; (b28 <host_verify_cert_chain+0x90>)
     ac4:	4798      	blx	r3
    
    // Get the signer's public key from its certificate
    ret = atcacert_get_subj_public_key(&g_cert_def_1_signer, g_signer_cert, g_signer_cert_size, signer_public_key);
     ac6:	4b12      	ldr	r3, [pc, #72]	; (b10 <host_verify_cert_chain+0x78>)
     ac8:	681a      	ldr	r2, [r3, #0]
     aca:	1d3b      	adds	r3, r7, #4
     acc:	4912      	ldr	r1, [pc, #72]	; (b18 <host_verify_cert_chain+0x80>)
     ace:	4813      	ldr	r0, [pc, #76]	; (b1c <host_verify_cert_chain+0x84>)
     ad0:	4c16      	ldr	r4, [pc, #88]	; (b2c <host_verify_cert_chain+0x94>)
     ad2:	47a0      	blx	r4
     ad4:	0003      	movs	r3, r0
     ad6:	647b      	str	r3, [r7, #68]	; 0x44
    if (ret != ATCACERT_E_SUCCESS) return ret;
     ad8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     ada:	2b00      	cmp	r3, #0
     adc:	d001      	beq.n	ae2 <host_verify_cert_chain+0x4a>
     ade:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     ae0:	e012      	b.n	b08 <host_verify_cert_chain+0x70>
    
    // Validate the device cert against its certificate authority (CA) which is the signer
    ret = atcacert_verify_cert_hw(&g_cert_def_2_device, g_device_cert, g_device_cert_size, signer_public_key);
     ae2:	4b13      	ldr	r3, [pc, #76]	; (b30 <host_verify_cert_chain+0x98>)
     ae4:	681a      	ldr	r2, [r3, #0]
     ae6:	1d3b      	adds	r3, r7, #4
     ae8:	4912      	ldr	r1, [pc, #72]	; (b34 <host_verify_cert_chain+0x9c>)
     aea:	4813      	ldr	r0, [pc, #76]	; (b38 <host_verify_cert_chain+0xa0>)
     aec:	4c0c      	ldr	r4, [pc, #48]	; (b20 <host_verify_cert_chain+0x88>)
     aee:	47a0      	blx	r4
     af0:	0003      	movs	r3, r0
     af2:	647b      	str	r3, [r7, #68]	; 0x44
    if (ret != ATCACERT_E_SUCCESS) return ret;
     af4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     af6:	2b00      	cmp	r3, #0
     af8:	d001      	beq.n	afe <host_verify_cert_chain+0x66>
     afa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     afc:	e004      	b.n	b08 <host_verify_cert_chain+0x70>
    printf("HOST: Device certificate verified against signer public key!\r\n");
     afe:	4b0f      	ldr	r3, [pc, #60]	; (b3c <host_verify_cert_chain+0xa4>)
     b00:	0018      	movs	r0, r3
     b02:	4b09      	ldr	r3, [pc, #36]	; (b28 <host_verify_cert_chain+0x90>)
     b04:	4798      	blx	r3
    
    return 0;
     b06:	2300      	movs	r3, #0
}
     b08:	0018      	movs	r0, r3
     b0a:	46bd      	mov	sp, r7
     b0c:	b013      	add	sp, #76	; 0x4c
     b0e:	bd90      	pop	{r4, r7, pc}
     b10:	2000001c 	.word	0x2000001c
     b14:	200011cc 	.word	0x200011cc
     b18:	2000098c 	.word	0x2000098c
     b1c:	00014ac0 	.word	0x00014ac0
     b20:	0000a279 	.word	0x0000a279
     b24:	00014e84 	.word	0x00014e84
     b28:	00012a8d 	.word	0x00012a8d
     b2c:	0000894d 	.word	0x0000894d
     b30:	20000020 	.word	0x20000020
     b34:	20000d8c 	.word	0x20000d8c
     b38:	00014cc0 	.word	0x00014cc0
     b3c:	00014ee0 	.word	0x00014ee0

00000b40 <host_generate_challenge>:
/** \brief This host role method generates a challenge to be signed by the CryptoAuth device.  This challenge is
 * basically a random number that once signed can be verified by the host.
 */

int host_generate_challenge(void)
{
     b40:	b590      	push	{r4, r7, lr}
     b42:	b0c3      	sub	sp, #268	; 0x10c
     b44:	af00      	add	r7, sp, #0
    int ret = 0;
     b46:	2300      	movs	r3, #0
     b48:	1d7a      	adds	r2, r7, #5
     b4a:	32ff      	adds	r2, #255	; 0xff
     b4c:	6013      	str	r3, [r2, #0]
    char disp_str[256];
    int disp_size = sizeof(disp_str);
     b4e:	2380      	movs	r3, #128	; 0x80
     b50:	005b      	lsls	r3, r3, #1
     b52:	603b      	str	r3, [r7, #0]
    
    ret = atcacert_gen_challenge_hw(g_challenge);
     b54:	4b12      	ldr	r3, [pc, #72]	; (ba0 <host_generate_challenge+0x60>)
     b56:	0018      	movs	r0, r3
     b58:	4b12      	ldr	r3, [pc, #72]	; (ba4 <host_generate_challenge+0x64>)
     b5a:	4798      	blx	r3
     b5c:	0003      	movs	r3, r0
     b5e:	1d7a      	adds	r2, r7, #5
     b60:	32ff      	adds	r2, #255	; 0xff
     b62:	6013      	str	r3, [r2, #0]
    if (ret != ATCACERT_E_SUCCESS) return ret;
     b64:	1d7b      	adds	r3, r7, #5
     b66:	33ff      	adds	r3, #255	; 0xff
     b68:	681b      	ldr	r3, [r3, #0]
     b6a:	2b00      	cmp	r3, #0
     b6c:	d003      	beq.n	b76 <host_generate_challenge+0x36>
     b6e:	1d7b      	adds	r3, r7, #5
     b70:	33ff      	adds	r3, #255	; 0xff
     b72:	681b      	ldr	r3, [r3, #0]
     b74:	e00f      	b.n	b96 <host_generate_challenge+0x56>
    disp_size = sizeof(disp_str);
     b76:	2380      	movs	r3, #128	; 0x80
     b78:	005b      	lsls	r3, r3, #1
     b7a:	603b      	str	r3, [r7, #0]
    atcab_bin2hex(g_challenge, sizeof(g_challenge), disp_str, &disp_size);
     b7c:	003b      	movs	r3, r7
     b7e:	1d3a      	adds	r2, r7, #4
     b80:	4807      	ldr	r0, [pc, #28]	; (ba0 <host_generate_challenge+0x60>)
     b82:	2120      	movs	r1, #32
     b84:	4c08      	ldr	r4, [pc, #32]	; (ba8 <host_generate_challenge+0x68>)
     b86:	47a0      	blx	r4
    printf("HOST: Generated challenge:\r\n%s\r\n", disp_str);
     b88:	1d3a      	adds	r2, r7, #4
     b8a:	4b08      	ldr	r3, [pc, #32]	; (bac <host_generate_challenge+0x6c>)
     b8c:	0011      	movs	r1, r2
     b8e:	0018      	movs	r0, r3
     b90:	4b07      	ldr	r3, [pc, #28]	; (bb0 <host_generate_challenge+0x70>)
     b92:	4798      	blx	r3
    
    return 0;
     b94:	2300      	movs	r3, #0
}
     b96:	0018      	movs	r0, r3
     b98:	46bd      	mov	sp, r7
     b9a:	b043      	add	sp, #268	; 0x10c
     b9c:	bd90      	pop	{r4, r7, pc}
     b9e:	46c0      	nop			; (mov r8, r8)
     ba0:	2000096c 	.word	0x2000096c
     ba4:	0000a329 	.word	0x0000a329
     ba8:	0000d0dd 	.word	0x0000d0dd
     bac:	00014f20 	.word	0x00014f20
     bb0:	0001296d 	.word	0x0001296d

00000bb4 <client_generate_response>:
/** \brief This client role method signs the challenge and returns the signature to the host.  For
 * example purposes, the signature is contained in a global variable g_response.
 */

int client_generate_response(void)
{
     bb4:	b590      	push	{r4, r7, lr}
     bb6:	b0c3      	sub	sp, #268	; 0x10c
     bb8:	af00      	add	r7, sp, #0
    int ret = 0;
     bba:	2300      	movs	r3, #0
     bbc:	1d7a      	adds	r2, r7, #5
     bbe:	32ff      	adds	r2, #255	; 0xff
     bc0:	6013      	str	r3, [r2, #0]
    char disp_str[256];
    int disp_size = sizeof(disp_str);
     bc2:	2380      	movs	r3, #128	; 0x80
     bc4:	005b      	lsls	r3, r3, #1
     bc6:	603b      	str	r3, [r7, #0]
    
    ret = atcacert_get_response(g_cert_def_2_device.private_key_slot, g_challenge, g_response);
     bc8:	4b13      	ldr	r3, [pc, #76]	; (c18 <client_generate_response+0x64>)
     bca:	78db      	ldrb	r3, [r3, #3]
     bcc:	4a13      	ldr	r2, [pc, #76]	; (c1c <client_generate_response+0x68>)
     bce:	4914      	ldr	r1, [pc, #80]	; (c20 <client_generate_response+0x6c>)
     bd0:	0018      	movs	r0, r3
     bd2:	4b14      	ldr	r3, [pc, #80]	; (c24 <client_generate_response+0x70>)
     bd4:	4798      	blx	r3
     bd6:	0003      	movs	r3, r0
     bd8:	1d7a      	adds	r2, r7, #5
     bda:	32ff      	adds	r2, #255	; 0xff
     bdc:	6013      	str	r3, [r2, #0]
    if (ret != ATCACERT_E_SUCCESS) return ret;
     bde:	1d7b      	adds	r3, r7, #5
     be0:	33ff      	adds	r3, #255	; 0xff
     be2:	681b      	ldr	r3, [r3, #0]
     be4:	2b00      	cmp	r3, #0
     be6:	d003      	beq.n	bf0 <client_generate_response+0x3c>
     be8:	1d7b      	adds	r3, r7, #5
     bea:	33ff      	adds	r3, #255	; 0xff
     bec:	681b      	ldr	r3, [r3, #0]
     bee:	e00f      	b.n	c10 <client_generate_response+0x5c>
    disp_size = sizeof(disp_str);
     bf0:	2380      	movs	r3, #128	; 0x80
     bf2:	005b      	lsls	r3, r3, #1
     bf4:	603b      	str	r3, [r7, #0]
    atcab_bin2hex(g_response, sizeof(g_response), disp_str, &disp_size);
     bf6:	003b      	movs	r3, r7
     bf8:	1d3a      	adds	r2, r7, #4
     bfa:	4808      	ldr	r0, [pc, #32]	; (c1c <client_generate_response+0x68>)
     bfc:	2140      	movs	r1, #64	; 0x40
     bfe:	4c0a      	ldr	r4, [pc, #40]	; (c28 <client_generate_response+0x74>)
     c00:	47a0      	blx	r4
    printf("CLIENT: Calculated response to host challenge:\r\n%s\r\n", disp_str);
     c02:	1d3a      	adds	r2, r7, #4
     c04:	4b09      	ldr	r3, [pc, #36]	; (c2c <client_generate_response+0x78>)
     c06:	0011      	movs	r1, r2
     c08:	0018      	movs	r0, r3
     c0a:	4b09      	ldr	r3, [pc, #36]	; (c30 <client_generate_response+0x7c>)
     c0c:	4798      	blx	r3
    
    return 0;
     c0e:	2300      	movs	r3, #0
}
     c10:	0018      	movs	r0, r3
     c12:	46bd      	mov	sp, r7
     c14:	b043      	add	sp, #268	; 0x10c
     c16:	bd90      	pop	{r4, r7, pc}
     c18:	00014cc0 	.word	0x00014cc0
     c1c:	2000118c 	.word	0x2000118c
     c20:	2000096c 	.word	0x2000096c
     c24:	00005da5 	.word	0x00005da5
     c28:	0000d0dd 	.word	0x0000d0dd
     c2c:	00014f44 	.word	0x00014f44
     c30:	0001296d 	.word	0x0001296d

00000c34 <host_verify_response>:
 * the device can prove it owns the private key associated with the public key of its certificate.
 * Since the certificate is verified to be in a root of trust certificate chain, this ECDSA verification
 * step makes sure the public key the device says it has is truly owned by the device and not a forgery.
 */
int host_verify_response(void)
{
     c34:	b590      	push	{r4, r7, lr}
     c36:	b0d3      	sub	sp, #332	; 0x14c
     c38:	af00      	add	r7, sp, #0
    int ret = 0;
     c3a:	2300      	movs	r3, #0
     c3c:	22a2      	movs	r2, #162	; 0xa2
     c3e:	0052      	lsls	r2, r2, #1
     c40:	18ba      	adds	r2, r7, r2
     c42:	6013      	str	r3, [r2, #0]
    uint8_t device_public_key[64];
    char disp_str[256];
    int disp_size = sizeof(disp_str);
     c44:	2380      	movs	r3, #128	; 0x80
     c46:	005b      	lsls	r3, r3, #1
     c48:	603b      	str	r3, [r7, #0]
    
    ret = atcacert_get_subj_public_key(&g_cert_def_2_device, g_device_cert, g_device_cert_size, device_public_key);
     c4a:	4b1e      	ldr	r3, [pc, #120]	; (cc4 <host_verify_response+0x90>)
     c4c:	681a      	ldr	r2, [r3, #0]
     c4e:	1d7b      	adds	r3, r7, #5
     c50:	33ff      	adds	r3, #255	; 0xff
     c52:	491d      	ldr	r1, [pc, #116]	; (cc8 <host_verify_response+0x94>)
     c54:	481d      	ldr	r0, [pc, #116]	; (ccc <host_verify_response+0x98>)
     c56:	4c1e      	ldr	r4, [pc, #120]	; (cd0 <host_verify_response+0x9c>)
     c58:	47a0      	blx	r4
     c5a:	0003      	movs	r3, r0
     c5c:	22a2      	movs	r2, #162	; 0xa2
     c5e:	0052      	lsls	r2, r2, #1
     c60:	18ba      	adds	r2, r7, r2
     c62:	6013      	str	r3, [r2, #0]
  //  if (ret != ATCACERT_E_SUCCESS) return ret;
    disp_size = sizeof(disp_str);
     c64:	2380      	movs	r3, #128	; 0x80
     c66:	005b      	lsls	r3, r3, #1
     c68:	603b      	str	r3, [r7, #0]
    atcab_bin2hex(device_public_key, sizeof(device_public_key), disp_str, &disp_size);
     c6a:	003b      	movs	r3, r7
     c6c:	1d3a      	adds	r2, r7, #4
     c6e:	1d78      	adds	r0, r7, #5
     c70:	30ff      	adds	r0, #255	; 0xff
     c72:	2140      	movs	r1, #64	; 0x40
     c74:	4c17      	ldr	r4, [pc, #92]	; (cd4 <host_verify_response+0xa0>)
     c76:	47a0      	blx	r4
    printf("HOST: Device public key from certificate:\r\n%s\r\n", disp_str);
     c78:	1d3a      	adds	r2, r7, #4
     c7a:	4b17      	ldr	r3, [pc, #92]	; (cd8 <host_verify_response+0xa4>)
     c7c:	0011      	movs	r1, r2
     c7e:	0018      	movs	r0, r3
     c80:	4b16      	ldr	r3, [pc, #88]	; (cdc <host_verify_response+0xa8>)
     c82:	4798      	blx	r3
    
    ret = atcacert_verify_response_hw(device_public_key, g_challenge, g_response);
     c84:	4a16      	ldr	r2, [pc, #88]	; (ce0 <host_verify_response+0xac>)
     c86:	4917      	ldr	r1, [pc, #92]	; (ce4 <host_verify_response+0xb0>)
     c88:	1d7b      	adds	r3, r7, #5
     c8a:	33ff      	adds	r3, #255	; 0xff
     c8c:	0018      	movs	r0, r3
     c8e:	4b16      	ldr	r3, [pc, #88]	; (ce8 <host_verify_response+0xb4>)
     c90:	4798      	blx	r3
     c92:	0003      	movs	r3, r0
     c94:	22a2      	movs	r2, #162	; 0xa2
     c96:	0052      	lsls	r2, r2, #1
     c98:	18ba      	adds	r2, r7, r2
     c9a:	6013      	str	r3, [r2, #0]
    if (ret != ATCACERT_E_SUCCESS) return ret;
     c9c:	23a2      	movs	r3, #162	; 0xa2
     c9e:	005b      	lsls	r3, r3, #1
     ca0:	18fb      	adds	r3, r7, r3
     ca2:	681b      	ldr	r3, [r3, #0]
     ca4:	2b00      	cmp	r3, #0
     ca6:	d004      	beq.n	cb2 <host_verify_response+0x7e>
     ca8:	23a2      	movs	r3, #162	; 0xa2
     caa:	005b      	lsls	r3, r3, #1
     cac:	18fb      	adds	r3, r7, r3
     cae:	681b      	ldr	r3, [r3, #0]
     cb0:	e004      	b.n	cbc <host_verify_response+0x88>
    printf("HOST: Device response to challenge verified!\r\n");
     cb2:	4b0e      	ldr	r3, [pc, #56]	; (cec <host_verify_response+0xb8>)
     cb4:	0018      	movs	r0, r3
     cb6:	4b0e      	ldr	r3, [pc, #56]	; (cf0 <host_verify_response+0xbc>)
     cb8:	4798      	blx	r3
    
    return 0;
     cba:	2300      	movs	r3, #0
}
     cbc:	0018      	movs	r0, r3
     cbe:	46bd      	mov	sp, r7
     cc0:	b053      	add	sp, #332	; 0x14c
     cc2:	bd90      	pop	{r4, r7, pc}
     cc4:	20000020 	.word	0x20000020
     cc8:	20000d8c 	.word	0x20000d8c
     ccc:	00014cc0 	.word	0x00014cc0
     cd0:	0000894d 	.word	0x0000894d
     cd4:	0000d0dd 	.word	0x0000d0dd
     cd8:	00014f7c 	.word	0x00014f7c
     cdc:	0001296d 	.word	0x0001296d
     ce0:	2000118c 	.word	0x2000118c
     ce4:	2000096c 	.word	0x2000096c
     ce8:	0000a351 	.word	0x0000a351
     cec:	00014fac 	.word	0x00014fac
     cf0:	00012a8d 	.word	0x00012a8d

00000cf4 <build_and_save_cert>:
    const uint8_t            public_key[64],
    const uint8_t            signer_id[2],
    const atcacert_tm_utc_t* issue_date,
    const uint8_t            config32[32],
    uint8_t                  ca_slot)
{
     cf4:	b590      	push	{r4, r7, lr}
     cf6:	b0d5      	sub	sp, #340	; 0x154
     cf8:	af02      	add	r7, sp, #8
     cfa:	60f8      	str	r0, [r7, #12]
     cfc:	60b9      	str	r1, [r7, #8]
     cfe:	607a      	str	r2, [r7, #4]
     d00:	603b      	str	r3, [r7, #0]
    int ret;
    atcacert_build_state_t build_state;
    uint8_t tbs_digest[32];
    uint8_t signature[64];
    size_t max_cert_size = *cert_size;
     d02:	687b      	ldr	r3, [r7, #4]
     d04:	681b      	ldr	r3, [r3, #0]
     d06:	229e      	movs	r2, #158	; 0x9e
     d08:	0052      	lsls	r2, r2, #1
     d0a:	18ba      	adds	r2, r7, r2
     d0c:	6013      	str	r3, [r2, #0]
    atcacert_tm_utc_t expire_date = {
     d0e:	239c      	movs	r3, #156	; 0x9c
     d10:	18fb      	adds	r3, r7, r3
     d12:	2200      	movs	r2, #0
     d14:	601a      	str	r2, [r3, #0]
     d16:	239c      	movs	r3, #156	; 0x9c
     d18:	18fb      	adds	r3, r7, r3
     d1a:	2200      	movs	r2, #0
     d1c:	605a      	str	r2, [r3, #4]
        .tm_year = issue_date->tm_year + cert_def->expire_years,
        .tm_mon  = issue_date->tm_mon,
        .tm_mday = issue_date->tm_mday,
        .tm_hour = issue_date->tm_hour,
     d1e:	23b0      	movs	r3, #176	; 0xb0
     d20:	005b      	lsls	r3, r3, #1
     d22:	18fb      	adds	r3, r7, r3
     d24:	681b      	ldr	r3, [r3, #0]
     d26:	689a      	ldr	r2, [r3, #8]
    int ret;
    atcacert_build_state_t build_state;
    uint8_t tbs_digest[32];
    uint8_t signature[64];
    size_t max_cert_size = *cert_size;
    atcacert_tm_utc_t expire_date = {
     d28:	239c      	movs	r3, #156	; 0x9c
     d2a:	18fb      	adds	r3, r7, r3
     d2c:	609a      	str	r2, [r3, #8]
        .tm_year = issue_date->tm_year + cert_def->expire_years,
        .tm_mon  = issue_date->tm_mon,
        .tm_mday = issue_date->tm_mday,
     d2e:	23b0      	movs	r3, #176	; 0xb0
     d30:	005b      	lsls	r3, r3, #1
     d32:	18fb      	adds	r3, r7, r3
     d34:	681b      	ldr	r3, [r3, #0]
     d36:	68da      	ldr	r2, [r3, #12]
    int ret;
    atcacert_build_state_t build_state;
    uint8_t tbs_digest[32];
    uint8_t signature[64];
    size_t max_cert_size = *cert_size;
    atcacert_tm_utc_t expire_date = {
     d38:	239c      	movs	r3, #156	; 0x9c
     d3a:	18fb      	adds	r3, r7, r3
     d3c:	60da      	str	r2, [r3, #12]
        .tm_year = issue_date->tm_year + cert_def->expire_years,
        .tm_mon  = issue_date->tm_mon,
     d3e:	23b0      	movs	r3, #176	; 0xb0
     d40:	005b      	lsls	r3, r3, #1
     d42:	18fb      	adds	r3, r7, r3
     d44:	681b      	ldr	r3, [r3, #0]
     d46:	691a      	ldr	r2, [r3, #16]
    int ret;
    atcacert_build_state_t build_state;
    uint8_t tbs_digest[32];
    uint8_t signature[64];
    size_t max_cert_size = *cert_size;
    atcacert_tm_utc_t expire_date = {
     d48:	239c      	movs	r3, #156	; 0x9c
     d4a:	18fb      	adds	r3, r7, r3
     d4c:	611a      	str	r2, [r3, #16]
        .tm_year = issue_date->tm_year + cert_def->expire_years,
     d4e:	23b0      	movs	r3, #176	; 0xb0
     d50:	005b      	lsls	r3, r3, #1
     d52:	18fb      	adds	r3, r7, r3
     d54:	681b      	ldr	r3, [r3, #0]
     d56:	695b      	ldr	r3, [r3, #20]
     d58:	68fa      	ldr	r2, [r7, #12]
     d5a:	7c92      	ldrb	r2, [r2, #18]
     d5c:	189a      	adds	r2, r3, r2
    int ret;
    atcacert_build_state_t build_state;
    uint8_t tbs_digest[32];
    uint8_t signature[64];
    size_t max_cert_size = *cert_size;
    atcacert_tm_utc_t expire_date = {
     d5e:	239c      	movs	r3, #156	; 0x9c
     d60:	18fb      	adds	r3, r7, r3
     d62:	615a      	str	r2, [r3, #20]
        .tm_mday = issue_date->tm_mday,
        .tm_hour = issue_date->tm_hour,
        .tm_min  = 0,
        .tm_sec  = 0
    };
    const atcacert_device_loc_t config32_dev_loc = {
     d64:	2394      	movs	r3, #148	; 0x94
     d66:	18fb      	adds	r3, r7, r3
     d68:	0018      	movs	r0, r3
     d6a:	2307      	movs	r3, #7
     d6c:	001a      	movs	r2, r3
     d6e:	2100      	movs	r1, #0
     d70:	4be5      	ldr	r3, [pc, #916]	; (1108 <build_and_save_cert+0x414>)
     d72:	4798      	blx	r3
     d74:	2394      	movs	r3, #148	; 0x94
     d76:	18fb      	adds	r3, r7, r3
     d78:	3305      	adds	r3, #5
     d7a:	781a      	ldrb	r2, [r3, #0]
     d7c:	2100      	movs	r1, #0
     d7e:	400a      	ands	r2, r1
     d80:	1c11      	adds	r1, r2, #0
     d82:	2220      	movs	r2, #32
     d84:	430a      	orrs	r2, r1
     d86:	701a      	strb	r2, [r3, #0]
     d88:	785a      	ldrb	r2, [r3, #1]
     d8a:	2100      	movs	r1, #0
     d8c:	400a      	ands	r2, r1
     d8e:	705a      	strb	r2, [r3, #1]
        .zone = DEVZONE_CONFIG,
        .offset = 0,
        .count = 32
    };
    atcacert_device_loc_t device_locs[4];
    size_t device_locs_count = 0;
     d90:	2300      	movs	r3, #0
     d92:	677b      	str	r3, [r7, #116]	; 0x74
    size_t i;
    
    if (cert_def->expire_years == 0)
     d94:	68fb      	ldr	r3, [r7, #12]
     d96:	7c9b      	ldrb	r3, [r3, #18]
     d98:	2b00      	cmp	r3, #0
     d9a:	d117      	bne.n	dcc <build_and_save_cert+0xd8>
    {
        ret = atcacert_date_get_max_date(cert_def->expire_date_format, &expire_date);
     d9c:	68fb      	ldr	r3, [r7, #12]
     d9e:	7b5b      	ldrb	r3, [r3, #13]
     da0:	229c      	movs	r2, #156	; 0x9c
     da2:	18ba      	adds	r2, r7, r2
     da4:	0011      	movs	r1, r2
     da6:	0018      	movs	r0, r3
     da8:	4bd8      	ldr	r3, [pc, #864]	; (110c <build_and_save_cert+0x418>)
     daa:	4798      	blx	r3
     dac:	0003      	movs	r3, r0
     dae:	229c      	movs	r2, #156	; 0x9c
     db0:	0052      	lsls	r2, r2, #1
     db2:	18ba      	adds	r2, r7, r2
     db4:	6013      	str	r3, [r2, #0]
        if (ret != ATCACERT_E_SUCCESS) return ret;
     db6:	239c      	movs	r3, #156	; 0x9c
     db8:	005b      	lsls	r3, r3, #1
     dba:	18fb      	adds	r3, r7, r3
     dbc:	681b      	ldr	r3, [r3, #0]
     dbe:	2b00      	cmp	r3, #0
     dc0:	d004      	beq.n	dcc <build_and_save_cert+0xd8>
     dc2:	239c      	movs	r3, #156	; 0x9c
     dc4:	005b      	lsls	r3, r3, #1
     dc6:	18fb      	adds	r3, r7, r3
     dc8:	681b      	ldr	r3, [r3, #0]
     dca:	e269      	b.n	12a0 <build_and_save_cert+0x5ac>
    }
    
    ret = atcacert_cert_build_start(&build_state, cert_def, cert, cert_size, ca_public_key);
     dcc:	687c      	ldr	r4, [r7, #4]
     dce:	68ba      	ldr	r2, [r7, #8]
     dd0:	68f9      	ldr	r1, [r7, #12]
     dd2:	238a      	movs	r3, #138	; 0x8a
     dd4:	005b      	lsls	r3, r3, #1
     dd6:	18f8      	adds	r0, r7, r3
     dd8:	683b      	ldr	r3, [r7, #0]
     dda:	9300      	str	r3, [sp, #0]
     ddc:	0023      	movs	r3, r4
     dde:	4ccc      	ldr	r4, [pc, #816]	; (1110 <build_and_save_cert+0x41c>)
     de0:	47a0      	blx	r4
     de2:	0003      	movs	r3, r0
     de4:	229c      	movs	r2, #156	; 0x9c
     de6:	0052      	lsls	r2, r2, #1
     de8:	18ba      	adds	r2, r7, r2
     dea:	6013      	str	r3, [r2, #0]
    if (ret != ATCACERT_E_SUCCESS) return ret;
     dec:	239c      	movs	r3, #156	; 0x9c
     dee:	005b      	lsls	r3, r3, #1
     df0:	18fb      	adds	r3, r7, r3
     df2:	681b      	ldr	r3, [r3, #0]
     df4:	2b00      	cmp	r3, #0
     df6:	d004      	beq.n	e02 <build_and_save_cert+0x10e>
     df8:	239c      	movs	r3, #156	; 0x9c
     dfa:	005b      	lsls	r3, r3, #1
     dfc:	18fb      	adds	r3, r7, r3
     dfe:	681b      	ldr	r3, [r3, #0]
     e00:	e24e      	b.n	12a0 <build_and_save_cert+0x5ac>
    
    ret = atcacert_set_subj_public_key(build_state.cert_def, build_state.cert, *build_state.cert_size, public_key);
     e02:	238a      	movs	r3, #138	; 0x8a
     e04:	005b      	lsls	r3, r3, #1
     e06:	18fb      	adds	r3, r7, r3
     e08:	6818      	ldr	r0, [r3, #0]
     e0a:	238a      	movs	r3, #138	; 0x8a
     e0c:	005b      	lsls	r3, r3, #1
     e0e:	18fb      	adds	r3, r7, r3
     e10:	6859      	ldr	r1, [r3, #4]
     e12:	238a      	movs	r3, #138	; 0x8a
     e14:	005b      	lsls	r3, r3, #1
     e16:	18fb      	adds	r3, r7, r3
     e18:	689b      	ldr	r3, [r3, #8]
     e1a:	681a      	ldr	r2, [r3, #0]
     e1c:	23ac      	movs	r3, #172	; 0xac
     e1e:	005b      	lsls	r3, r3, #1
     e20:	18fb      	adds	r3, r7, r3
     e22:	681b      	ldr	r3, [r3, #0]
     e24:	4cbb      	ldr	r4, [pc, #748]	; (1114 <build_and_save_cert+0x420>)
     e26:	47a0      	blx	r4
     e28:	0003      	movs	r3, r0
     e2a:	229c      	movs	r2, #156	; 0x9c
     e2c:	0052      	lsls	r2, r2, #1
     e2e:	18ba      	adds	r2, r7, r2
     e30:	6013      	str	r3, [r2, #0]
    if (ret != ATCACERT_E_SUCCESS) return ret;
     e32:	239c      	movs	r3, #156	; 0x9c
     e34:	005b      	lsls	r3, r3, #1
     e36:	18fb      	adds	r3, r7, r3
     e38:	681b      	ldr	r3, [r3, #0]
     e3a:	2b00      	cmp	r3, #0
     e3c:	d004      	beq.n	e48 <build_and_save_cert+0x154>
     e3e:	239c      	movs	r3, #156	; 0x9c
     e40:	005b      	lsls	r3, r3, #1
     e42:	18fb      	adds	r3, r7, r3
     e44:	681b      	ldr	r3, [r3, #0]
     e46:	e22b      	b.n	12a0 <build_and_save_cert+0x5ac>
    ret = atcacert_set_issue_date(build_state.cert_def, build_state.cert, *build_state.cert_size, issue_date);
     e48:	238a      	movs	r3, #138	; 0x8a
     e4a:	005b      	lsls	r3, r3, #1
     e4c:	18fb      	adds	r3, r7, r3
     e4e:	6818      	ldr	r0, [r3, #0]
     e50:	238a      	movs	r3, #138	; 0x8a
     e52:	005b      	lsls	r3, r3, #1
     e54:	18fb      	adds	r3, r7, r3
     e56:	6859      	ldr	r1, [r3, #4]
     e58:	238a      	movs	r3, #138	; 0x8a
     e5a:	005b      	lsls	r3, r3, #1
     e5c:	18fb      	adds	r3, r7, r3
     e5e:	689b      	ldr	r3, [r3, #8]
     e60:	681a      	ldr	r2, [r3, #0]
     e62:	23b0      	movs	r3, #176	; 0xb0
     e64:	005b      	lsls	r3, r3, #1
     e66:	18fb      	adds	r3, r7, r3
     e68:	681b      	ldr	r3, [r3, #0]
     e6a:	4cab      	ldr	r4, [pc, #684]	; (1118 <build_and_save_cert+0x424>)
     e6c:	47a0      	blx	r4
     e6e:	0003      	movs	r3, r0
     e70:	229c      	movs	r2, #156	; 0x9c
     e72:	0052      	lsls	r2, r2, #1
     e74:	18ba      	adds	r2, r7, r2
     e76:	6013      	str	r3, [r2, #0]
    if (ret != ATCACERT_E_SUCCESS) return ret;
     e78:	239c      	movs	r3, #156	; 0x9c
     e7a:	005b      	lsls	r3, r3, #1
     e7c:	18fb      	adds	r3, r7, r3
     e7e:	681b      	ldr	r3, [r3, #0]
     e80:	2b00      	cmp	r3, #0
     e82:	d004      	beq.n	e8e <build_and_save_cert+0x19a>
     e84:	239c      	movs	r3, #156	; 0x9c
     e86:	005b      	lsls	r3, r3, #1
     e88:	18fb      	adds	r3, r7, r3
     e8a:	681b      	ldr	r3, [r3, #0]
     e8c:	e208      	b.n	12a0 <build_and_save_cert+0x5ac>
    ret = atcacert_set_expire_date(build_state.cert_def, build_state.cert, *build_state.cert_size, &expire_date);
     e8e:	238a      	movs	r3, #138	; 0x8a
     e90:	005b      	lsls	r3, r3, #1
     e92:	18fb      	adds	r3, r7, r3
     e94:	6818      	ldr	r0, [r3, #0]
     e96:	238a      	movs	r3, #138	; 0x8a
     e98:	005b      	lsls	r3, r3, #1
     e9a:	18fb      	adds	r3, r7, r3
     e9c:	6859      	ldr	r1, [r3, #4]
     e9e:	238a      	movs	r3, #138	; 0x8a
     ea0:	005b      	lsls	r3, r3, #1
     ea2:	18fb      	adds	r3, r7, r3
     ea4:	689b      	ldr	r3, [r3, #8]
     ea6:	681a      	ldr	r2, [r3, #0]
     ea8:	239c      	movs	r3, #156	; 0x9c
     eaa:	18fb      	adds	r3, r7, r3
     eac:	4c9b      	ldr	r4, [pc, #620]	; (111c <build_and_save_cert+0x428>)
     eae:	47a0      	blx	r4
     eb0:	0003      	movs	r3, r0
     eb2:	229c      	movs	r2, #156	; 0x9c
     eb4:	0052      	lsls	r2, r2, #1
     eb6:	18ba      	adds	r2, r7, r2
     eb8:	6013      	str	r3, [r2, #0]
    if (ret != ATCACERT_E_SUCCESS) return ret;
     eba:	239c      	movs	r3, #156	; 0x9c
     ebc:	005b      	lsls	r3, r3, #1
     ebe:	18fb      	adds	r3, r7, r3
     ec0:	681b      	ldr	r3, [r3, #0]
     ec2:	2b00      	cmp	r3, #0
     ec4:	d004      	beq.n	ed0 <build_and_save_cert+0x1dc>
     ec6:	239c      	movs	r3, #156	; 0x9c
     ec8:	005b      	lsls	r3, r3, #1
     eca:	18fb      	adds	r3, r7, r3
     ecc:	681b      	ldr	r3, [r3, #0]
     ece:	e1e7      	b.n	12a0 <build_and_save_cert+0x5ac>
    ret = atcacert_set_signer_id(build_state.cert_def, build_state.cert, *build_state.cert_size, signer_id);
     ed0:	238a      	movs	r3, #138	; 0x8a
     ed2:	005b      	lsls	r3, r3, #1
     ed4:	18fb      	adds	r3, r7, r3
     ed6:	6818      	ldr	r0, [r3, #0]
     ed8:	238a      	movs	r3, #138	; 0x8a
     eda:	005b      	lsls	r3, r3, #1
     edc:	18fb      	adds	r3, r7, r3
     ede:	6859      	ldr	r1, [r3, #4]
     ee0:	238a      	movs	r3, #138	; 0x8a
     ee2:	005b      	lsls	r3, r3, #1
     ee4:	18fb      	adds	r3, r7, r3
     ee6:	689b      	ldr	r3, [r3, #8]
     ee8:	681a      	ldr	r2, [r3, #0]
     eea:	23ae      	movs	r3, #174	; 0xae
     eec:	005b      	lsls	r3, r3, #1
     eee:	18fb      	adds	r3, r7, r3
     ef0:	681b      	ldr	r3, [r3, #0]
     ef2:	4c8b      	ldr	r4, [pc, #556]	; (1120 <build_and_save_cert+0x42c>)
     ef4:	47a0      	blx	r4
     ef6:	0003      	movs	r3, r0
     ef8:	229c      	movs	r2, #156	; 0x9c
     efa:	0052      	lsls	r2, r2, #1
     efc:	18ba      	adds	r2, r7, r2
     efe:	6013      	str	r3, [r2, #0]
    if (ret != ATCACERT_E_SUCCESS) return ret;
     f00:	239c      	movs	r3, #156	; 0x9c
     f02:	005b      	lsls	r3, r3, #1
     f04:	18fb      	adds	r3, r7, r3
     f06:	681b      	ldr	r3, [r3, #0]
     f08:	2b00      	cmp	r3, #0
     f0a:	d004      	beq.n	f16 <build_and_save_cert+0x222>
     f0c:	239c      	movs	r3, #156	; 0x9c
     f0e:	005b      	lsls	r3, r3, #1
     f10:	18fb      	adds	r3, r7, r3
     f12:	681b      	ldr	r3, [r3, #0]
     f14:	e1c4      	b.n	12a0 <build_and_save_cert+0x5ac>
    ret = atcacert_cert_build_process(&build_state, &config32_dev_loc, config32);
     f16:	23b2      	movs	r3, #178	; 0xb2
     f18:	005b      	lsls	r3, r3, #1
     f1a:	18fb      	adds	r3, r7, r3
     f1c:	681a      	ldr	r2, [r3, #0]
     f1e:	2394      	movs	r3, #148	; 0x94
     f20:	18f9      	adds	r1, r7, r3
     f22:	238a      	movs	r3, #138	; 0x8a
     f24:	005b      	lsls	r3, r3, #1
     f26:	18fb      	adds	r3, r7, r3
     f28:	0018      	movs	r0, r3
     f2a:	4b7e      	ldr	r3, [pc, #504]	; (1124 <build_and_save_cert+0x430>)
     f2c:	4798      	blx	r3
     f2e:	0003      	movs	r3, r0
     f30:	229c      	movs	r2, #156	; 0x9c
     f32:	0052      	lsls	r2, r2, #1
     f34:	18ba      	adds	r2, r7, r2
     f36:	6013      	str	r3, [r2, #0]
    if (ret != ATCACERT_E_SUCCESS) return ret;
     f38:	239c      	movs	r3, #156	; 0x9c
     f3a:	005b      	lsls	r3, r3, #1
     f3c:	18fb      	adds	r3, r7, r3
     f3e:	681b      	ldr	r3, [r3, #0]
     f40:	2b00      	cmp	r3, #0
     f42:	d004      	beq.n	f4e <build_and_save_cert+0x25a>
     f44:	239c      	movs	r3, #156	; 0x9c
     f46:	005b      	lsls	r3, r3, #1
     f48:	18fb      	adds	r3, r7, r3
     f4a:	681b      	ldr	r3, [r3, #0]
     f4c:	e1a8      	b.n	12a0 <build_and_save_cert+0x5ac>
    
    ret = atcacert_cert_build_finish(&build_state);
     f4e:	238a      	movs	r3, #138	; 0x8a
     f50:	005b      	lsls	r3, r3, #1
     f52:	18fb      	adds	r3, r7, r3
     f54:	0018      	movs	r0, r3
     f56:	4b74      	ldr	r3, [pc, #464]	; (1128 <build_and_save_cert+0x434>)
     f58:	4798      	blx	r3
     f5a:	0003      	movs	r3, r0
     f5c:	229c      	movs	r2, #156	; 0x9c
     f5e:	0052      	lsls	r2, r2, #1
     f60:	18ba      	adds	r2, r7, r2
     f62:	6013      	str	r3, [r2, #0]
    if (ret != ATCACERT_E_SUCCESS) return ret;
     f64:	239c      	movs	r3, #156	; 0x9c
     f66:	005b      	lsls	r3, r3, #1
     f68:	18fb      	adds	r3, r7, r3
     f6a:	681b      	ldr	r3, [r3, #0]
     f6c:	2b00      	cmp	r3, #0
     f6e:	d004      	beq.n	f7a <build_and_save_cert+0x286>
     f70:	239c      	movs	r3, #156	; 0x9c
     f72:	005b      	lsls	r3, r3, #1
     f74:	18fb      	adds	r3, r7, r3
     f76:	681b      	ldr	r3, [r3, #0]
     f78:	e192      	b.n	12a0 <build_and_save_cert+0x5ac>
    
    ret = atcacert_get_tbs_digest(build_state.cert_def, build_state.cert, *build_state.cert_size, tbs_digest);
     f7a:	238a      	movs	r3, #138	; 0x8a
     f7c:	005b      	lsls	r3, r3, #1
     f7e:	18fb      	adds	r3, r7, r3
     f80:	6818      	ldr	r0, [r3, #0]
     f82:	238a      	movs	r3, #138	; 0x8a
     f84:	005b      	lsls	r3, r3, #1
     f86:	18fb      	adds	r3, r7, r3
     f88:	6859      	ldr	r1, [r3, #4]
     f8a:	238a      	movs	r3, #138	; 0x8a
     f8c:	005b      	lsls	r3, r3, #1
     f8e:	18fb      	adds	r3, r7, r3
     f90:	689b      	ldr	r3, [r3, #8]
     f92:	681a      	ldr	r2, [r3, #0]
     f94:	23f4      	movs	r3, #244	; 0xf4
     f96:	18fb      	adds	r3, r7, r3
     f98:	4c64      	ldr	r4, [pc, #400]	; (112c <build_and_save_cert+0x438>)
     f9a:	47a0      	blx	r4
     f9c:	0003      	movs	r3, r0
     f9e:	229c      	movs	r2, #156	; 0x9c
     fa0:	0052      	lsls	r2, r2, #1
     fa2:	18ba      	adds	r2, r7, r2
     fa4:	6013      	str	r3, [r2, #0]
    if (ret != ATCACERT_E_SUCCESS) return ret;
     fa6:	239c      	movs	r3, #156	; 0x9c
     fa8:	005b      	lsls	r3, r3, #1
     faa:	18fb      	adds	r3, r7, r3
     fac:	681b      	ldr	r3, [r3, #0]
     fae:	2b00      	cmp	r3, #0
     fb0:	d004      	beq.n	fbc <build_and_save_cert+0x2c8>
     fb2:	239c      	movs	r3, #156	; 0x9c
     fb4:	005b      	lsls	r3, r3, #1
     fb6:	18fb      	adds	r3, r7, r3
     fb8:	681b      	ldr	r3, [r3, #0]
     fba:	e171      	b.n	12a0 <build_and_save_cert+0x5ac>
    
    ret = atcab_sign(ca_slot, tbs_digest, signature);
     fbc:	23b4      	movs	r3, #180	; 0xb4
     fbe:	005b      	lsls	r3, r3, #1
     fc0:	18fb      	adds	r3, r7, r3
     fc2:	781b      	ldrb	r3, [r3, #0]
     fc4:	b29b      	uxth	r3, r3
     fc6:	22b4      	movs	r2, #180	; 0xb4
     fc8:	18ba      	adds	r2, r7, r2
     fca:	21f4      	movs	r1, #244	; 0xf4
     fcc:	1879      	adds	r1, r7, r1
     fce:	0018      	movs	r0, r3
     fd0:	4b57      	ldr	r3, [pc, #348]	; (1130 <build_and_save_cert+0x43c>)
     fd2:	4798      	blx	r3
     fd4:	0003      	movs	r3, r0
     fd6:	229c      	movs	r2, #156	; 0x9c
     fd8:	0052      	lsls	r2, r2, #1
     fda:	18ba      	adds	r2, r7, r2
     fdc:	6013      	str	r3, [r2, #0]
    if (ret != ATCA_SUCCESS) return ret;
     fde:	239c      	movs	r3, #156	; 0x9c
     fe0:	005b      	lsls	r3, r3, #1
     fe2:	18fb      	adds	r3, r7, r3
     fe4:	681b      	ldr	r3, [r3, #0]
     fe6:	2b00      	cmp	r3, #0
     fe8:	d004      	beq.n	ff4 <build_and_save_cert+0x300>
     fea:	239c      	movs	r3, #156	; 0x9c
     fec:	005b      	lsls	r3, r3, #1
     fee:	18fb      	adds	r3, r7, r3
     ff0:	681b      	ldr	r3, [r3, #0]
     ff2:	e155      	b.n	12a0 <build_and_save_cert+0x5ac>
    
    ret = atcacert_set_signature(cert_def, cert, cert_size, max_cert_size, signature);
     ff4:	239e      	movs	r3, #158	; 0x9e
     ff6:	005b      	lsls	r3, r3, #1
     ff8:	18fb      	adds	r3, r7, r3
     ffa:	681c      	ldr	r4, [r3, #0]
     ffc:	687a      	ldr	r2, [r7, #4]
     ffe:	68b9      	ldr	r1, [r7, #8]
    1000:	68f8      	ldr	r0, [r7, #12]
    1002:	23b4      	movs	r3, #180	; 0xb4
    1004:	18fb      	adds	r3, r7, r3
    1006:	9300      	str	r3, [sp, #0]
    1008:	0023      	movs	r3, r4
    100a:	4c4a      	ldr	r4, [pc, #296]	; (1134 <build_and_save_cert+0x440>)
    100c:	47a0      	blx	r4
    100e:	0003      	movs	r3, r0
    1010:	229c      	movs	r2, #156	; 0x9c
    1012:	0052      	lsls	r2, r2, #1
    1014:	18ba      	adds	r2, r7, r2
    1016:	6013      	str	r3, [r2, #0]
    if (ret != ATCACERT_E_SUCCESS) return ret;
    1018:	239c      	movs	r3, #156	; 0x9c
    101a:	005b      	lsls	r3, r3, #1
    101c:	18fb      	adds	r3, r7, r3
    101e:	681b      	ldr	r3, [r3, #0]
    1020:	2b00      	cmp	r3, #0
    1022:	d004      	beq.n	102e <build_and_save_cert+0x33a>
    1024:	239c      	movs	r3, #156	; 0x9c
    1026:	005b      	lsls	r3, r3, #1
    1028:	18fb      	adds	r3, r7, r3
    102a:	681b      	ldr	r3, [r3, #0]
    102c:	e138      	b.n	12a0 <build_and_save_cert+0x5ac>
    
    ret = atcacert_get_device_locs(cert_def, device_locs, &device_locs_count, sizeof(device_locs) / sizeof(device_locs[0]), 32);
    102e:	2374      	movs	r3, #116	; 0x74
    1030:	18fa      	adds	r2, r7, r3
    1032:	2378      	movs	r3, #120	; 0x78
    1034:	18f9      	adds	r1, r7, r3
    1036:	68f8      	ldr	r0, [r7, #12]
    1038:	2320      	movs	r3, #32
    103a:	9300      	str	r3, [sp, #0]
    103c:	2304      	movs	r3, #4
    103e:	4c3e      	ldr	r4, [pc, #248]	; (1138 <build_and_save_cert+0x444>)
    1040:	47a0      	blx	r4
    1042:	0003      	movs	r3, r0
    1044:	229c      	movs	r2, #156	; 0x9c
    1046:	0052      	lsls	r2, r2, #1
    1048:	18ba      	adds	r2, r7, r2
    104a:	6013      	str	r3, [r2, #0]
    if (ret != ATCACERT_E_SUCCESS) return ret;
    104c:	239c      	movs	r3, #156	; 0x9c
    104e:	005b      	lsls	r3, r3, #1
    1050:	18fb      	adds	r3, r7, r3
    1052:	681b      	ldr	r3, [r3, #0]
    1054:	2b00      	cmp	r3, #0
    1056:	d004      	beq.n	1062 <build_and_save_cert+0x36e>
    1058:	239c      	movs	r3, #156	; 0x9c
    105a:	005b      	lsls	r3, r3, #1
    105c:	18fb      	adds	r3, r7, r3
    105e:	681b      	ldr	r3, [r3, #0]
    1060:	e11e      	b.n	12a0 <build_and_save_cert+0x5ac>
    
    for (i = 0; i < device_locs_count; i++)
    1062:	2300      	movs	r3, #0
    1064:	22a2      	movs	r2, #162	; 0xa2
    1066:	0052      	lsls	r2, r2, #1
    1068:	18ba      	adds	r2, r7, r2
    106a:	6013      	str	r3, [r2, #0]
    106c:	e10f      	b.n	128e <build_and_save_cert+0x59a>
        size_t end_block;
        size_t start_block;
        uint8_t data[96];
        uint8_t block;
        
        if (device_locs[i].zone == DEVZONE_CONFIG)
    106e:	2378      	movs	r3, #120	; 0x78
    1070:	18f9      	adds	r1, r7, r3
    1072:	23a2      	movs	r3, #162	; 0xa2
    1074:	005b      	lsls	r3, r3, #1
    1076:	18fb      	adds	r3, r7, r3
    1078:	681a      	ldr	r2, [r3, #0]
    107a:	0013      	movs	r3, r2
    107c:	00db      	lsls	r3, r3, #3
    107e:	1a9b      	subs	r3, r3, r2
    1080:	5c5b      	ldrb	r3, [r3, r1]
    1082:	2b00      	cmp	r3, #0
    1084:	d100      	bne.n	1088 <build_and_save_cert+0x394>
    1086:	e0f6      	b.n	1276 <build_and_save_cert+0x582>
            continue;
        if (device_locs[i].zone == DEVZONE_DATA && device_locs[i].is_genkey)
    1088:	2378      	movs	r3, #120	; 0x78
    108a:	18f9      	adds	r1, r7, r3
    108c:	23a2      	movs	r3, #162	; 0xa2
    108e:	005b      	lsls	r3, r3, #1
    1090:	18fb      	adds	r3, r7, r3
    1092:	681a      	ldr	r2, [r3, #0]
    1094:	0013      	movs	r3, r2
    1096:	00db      	lsls	r3, r3, #3
    1098:	1a9b      	subs	r3, r3, r2
    109a:	5c5b      	ldrb	r3, [r3, r1]
    109c:	2b02      	cmp	r3, #2
    109e:	d10e      	bne.n	10be <build_and_save_cert+0x3ca>
    10a0:	2378      	movs	r3, #120	; 0x78
    10a2:	18f9      	adds	r1, r7, r3
    10a4:	23a2      	movs	r3, #162	; 0xa2
    10a6:	005b      	lsls	r3, r3, #1
    10a8:	18fb      	adds	r3, r7, r3
    10aa:	681a      	ldr	r2, [r3, #0]
    10ac:	0013      	movs	r3, r2
    10ae:	00db      	lsls	r3, r3, #3
    10b0:	1a9b      	subs	r3, r3, r2
    10b2:	18cb      	adds	r3, r1, r3
    10b4:	3302      	adds	r3, #2
    10b6:	781b      	ldrb	r3, [r3, #0]
    10b8:	2b00      	cmp	r3, #0
    10ba:	d000      	beq.n	10be <build_and_save_cert+0x3ca>
    10bc:	e0dd      	b.n	127a <build_and_save_cert+0x586>
            continue;
        
        ret = atcacert_get_device_data(cert_def, cert, *cert_size, &device_locs[i], data);
    10be:	687b      	ldr	r3, [r7, #4]
    10c0:	681c      	ldr	r4, [r3, #0]
    10c2:	2378      	movs	r3, #120	; 0x78
    10c4:	18f9      	adds	r1, r7, r3
    10c6:	23a2      	movs	r3, #162	; 0xa2
    10c8:	005b      	lsls	r3, r3, #1
    10ca:	18fb      	adds	r3, r7, r3
    10cc:	681a      	ldr	r2, [r3, #0]
    10ce:	0013      	movs	r3, r2
    10d0:	00db      	lsls	r3, r3, #3
    10d2:	1a9b      	subs	r3, r3, r2
    10d4:	18ca      	adds	r2, r1, r3
    10d6:	68b9      	ldr	r1, [r7, #8]
    10d8:	68f8      	ldr	r0, [r7, #12]
    10da:	2314      	movs	r3, #20
    10dc:	18fb      	adds	r3, r7, r3
    10de:	9300      	str	r3, [sp, #0]
    10e0:	0013      	movs	r3, r2
    10e2:	0022      	movs	r2, r4
    10e4:	4c15      	ldr	r4, [pc, #84]	; (113c <build_and_save_cert+0x448>)
    10e6:	47a0      	blx	r4
    10e8:	0003      	movs	r3, r0
    10ea:	229c      	movs	r2, #156	; 0x9c
    10ec:	0052      	lsls	r2, r2, #1
    10ee:	18ba      	adds	r2, r7, r2
    10f0:	6013      	str	r3, [r2, #0]
        if (ret != ATCACERT_E_SUCCESS) return ret;
    10f2:	239c      	movs	r3, #156	; 0x9c
    10f4:	005b      	lsls	r3, r3, #1
    10f6:	18fb      	adds	r3, r7, r3
    10f8:	681b      	ldr	r3, [r3, #0]
    10fa:	2b00      	cmp	r3, #0
    10fc:	d020      	beq.n	1140 <build_and_save_cert+0x44c>
    10fe:	239c      	movs	r3, #156	; 0x9c
    1100:	005b      	lsls	r3, r3, #1
    1102:	18fb      	adds	r3, r7, r3
    1104:	681b      	ldr	r3, [r3, #0]
    1106:	e0cb      	b.n	12a0 <build_and_save_cert+0x5ac>
    1108:	00012823 	.word	0x00012823
    110c:	00005fc1 	.word	0x00005fc1
    1110:	00007959 	.word	0x00007959
    1114:	000088ad 	.word	0x000088ad
    1118:	00008bb9 	.word	0x00008bb9
    111c:	00008d01 	.word	0x00008d01
    1120:	00008e2d 	.word	0x00008e2d
    1124:	00007d35 	.word	0x00007d35
    1128:	000082f5 	.word	0x000082f5
    112c:	000097f9 	.word	0x000097f9
    1130:	0000c6b1 	.word	0x0000c6b1
    1134:	00008995 	.word	0x00008995
    1138:	00007681 	.word	0x00007681
    113c:	000084f9 	.word	0x000084f9
        
        start_block = device_locs[i].offset / 32;
    1140:	2378      	movs	r3, #120	; 0x78
    1142:	18fa      	adds	r2, r7, r3
    1144:	23a2      	movs	r3, #162	; 0xa2
    1146:	005b      	lsls	r3, r3, #1
    1148:	18fb      	adds	r3, r7, r3
    114a:	6819      	ldr	r1, [r3, #0]
    114c:	000b      	movs	r3, r1
    114e:	00db      	lsls	r3, r3, #3
    1150:	1a5b      	subs	r3, r3, r1
    1152:	18d1      	adds	r1, r2, r3
    1154:	78c9      	ldrb	r1, [r1, #3]
    1156:	18d3      	adds	r3, r2, r3
    1158:	791b      	ldrb	r3, [r3, #4]
    115a:	021b      	lsls	r3, r3, #8
    115c:	430b      	orrs	r3, r1
    115e:	b29b      	uxth	r3, r3
    1160:	095b      	lsrs	r3, r3, #5
    1162:	b29b      	uxth	r3, r3
    1164:	229a      	movs	r2, #154	; 0x9a
    1166:	0052      	lsls	r2, r2, #1
    1168:	18ba      	adds	r2, r7, r2
    116a:	6013      	str	r3, [r2, #0]
        end_block = (device_locs[i].offset + device_locs[i].count) / 32;
    116c:	2378      	movs	r3, #120	; 0x78
    116e:	18fa      	adds	r2, r7, r3
    1170:	23a2      	movs	r3, #162	; 0xa2
    1172:	005b      	lsls	r3, r3, #1
    1174:	18fb      	adds	r3, r7, r3
    1176:	6819      	ldr	r1, [r3, #0]
    1178:	000b      	movs	r3, r1
    117a:	00db      	lsls	r3, r3, #3
    117c:	1a5b      	subs	r3, r3, r1
    117e:	18d1      	adds	r1, r2, r3
    1180:	78c9      	ldrb	r1, [r1, #3]
    1182:	18d3      	adds	r3, r2, r3
    1184:	791b      	ldrb	r3, [r3, #4]
    1186:	021b      	lsls	r3, r3, #8
    1188:	430b      	orrs	r3, r1
    118a:	b29b      	uxth	r3, r3
    118c:	0018      	movs	r0, r3
    118e:	2378      	movs	r3, #120	; 0x78
    1190:	18fa      	adds	r2, r7, r3
    1192:	23a2      	movs	r3, #162	; 0xa2
    1194:	005b      	lsls	r3, r3, #1
    1196:	18fb      	adds	r3, r7, r3
    1198:	6819      	ldr	r1, [r3, #0]
    119a:	000b      	movs	r3, r1
    119c:	00db      	lsls	r3, r3, #3
    119e:	1a5b      	subs	r3, r3, r1
    11a0:	18d1      	adds	r1, r2, r3
    11a2:	7949      	ldrb	r1, [r1, #5]
    11a4:	18d3      	adds	r3, r2, r3
    11a6:	799b      	ldrb	r3, [r3, #6]
    11a8:	021b      	lsls	r3, r3, #8
    11aa:	430b      	orrs	r3, r1
    11ac:	b29b      	uxth	r3, r3
    11ae:	18c3      	adds	r3, r0, r3
    11b0:	2b00      	cmp	r3, #0
    11b2:	da00      	bge.n	11b6 <build_and_save_cert+0x4c2>
    11b4:	331f      	adds	r3, #31
    11b6:	115b      	asrs	r3, r3, #5
    11b8:	2298      	movs	r2, #152	; 0x98
    11ba:	0052      	lsls	r2, r2, #1
    11bc:	18ba      	adds	r2, r7, r2
    11be:	6013      	str	r3, [r2, #0]
        for (block = start_block; block < end_block; block++)
    11c0:	2344      	movs	r3, #68	; 0x44
    11c2:	33ff      	adds	r3, #255	; 0xff
    11c4:	18fb      	adds	r3, r7, r3
    11c6:	229a      	movs	r2, #154	; 0x9a
    11c8:	0052      	lsls	r2, r2, #1
    11ca:	18ba      	adds	r2, r7, r2
    11cc:	6812      	ldr	r2, [r2, #0]
    11ce:	701a      	strb	r2, [r3, #0]
    11d0:	e046      	b.n	1260 <build_and_save_cert+0x56c>
        {
            ret = atcab_write_zone(device_locs[i].zone, device_locs[i].slot, block, 0, &data[(block - start_block) * 32], 32);
    11d2:	2378      	movs	r3, #120	; 0x78
    11d4:	18f9      	adds	r1, r7, r3
    11d6:	23a2      	movs	r3, #162	; 0xa2
    11d8:	005b      	lsls	r3, r3, #1
    11da:	18fb      	adds	r3, r7, r3
    11dc:	681a      	ldr	r2, [r3, #0]
    11de:	0013      	movs	r3, r2
    11e0:	00db      	lsls	r3, r3, #3
    11e2:	1a9b      	subs	r3, r3, r2
    11e4:	5c58      	ldrb	r0, [r3, r1]
    11e6:	2378      	movs	r3, #120	; 0x78
    11e8:	18f9      	adds	r1, r7, r3
    11ea:	23a2      	movs	r3, #162	; 0xa2
    11ec:	005b      	lsls	r3, r3, #1
    11ee:	18fb      	adds	r3, r7, r3
    11f0:	681a      	ldr	r2, [r3, #0]
    11f2:	0013      	movs	r3, r2
    11f4:	00db      	lsls	r3, r3, #3
    11f6:	1a9b      	subs	r3, r3, r2
    11f8:	18cb      	adds	r3, r1, r3
    11fa:	3301      	adds	r3, #1
    11fc:	7819      	ldrb	r1, [r3, #0]
    11fe:	2344      	movs	r3, #68	; 0x44
    1200:	33ff      	adds	r3, #255	; 0xff
    1202:	18fb      	adds	r3, r7, r3
    1204:	781a      	ldrb	r2, [r3, #0]
    1206:	239a      	movs	r3, #154	; 0x9a
    1208:	005b      	lsls	r3, r3, #1
    120a:	18fb      	adds	r3, r7, r3
    120c:	681b      	ldr	r3, [r3, #0]
    120e:	1ad3      	subs	r3, r2, r3
    1210:	015b      	lsls	r3, r3, #5
    1212:	2214      	movs	r2, #20
    1214:	18ba      	adds	r2, r7, r2
    1216:	18d3      	adds	r3, r2, r3
    1218:	2244      	movs	r2, #68	; 0x44
    121a:	32ff      	adds	r2, #255	; 0xff
    121c:	18ba      	adds	r2, r7, r2
    121e:	7814      	ldrb	r4, [r2, #0]
    1220:	2220      	movs	r2, #32
    1222:	9201      	str	r2, [sp, #4]
    1224:	9300      	str	r3, [sp, #0]
    1226:	2300      	movs	r3, #0
    1228:	0022      	movs	r2, r4
    122a:	4c1f      	ldr	r4, [pc, #124]	; (12a8 <build_and_save_cert+0x5b4>)
    122c:	47a0      	blx	r4
    122e:	0003      	movs	r3, r0
    1230:	229c      	movs	r2, #156	; 0x9c
    1232:	0052      	lsls	r2, r2, #1
    1234:	18ba      	adds	r2, r7, r2
    1236:	6013      	str	r3, [r2, #0]
            if (ret != ATCA_SUCCESS) return ret;
    1238:	239c      	movs	r3, #156	; 0x9c
    123a:	005b      	lsls	r3, r3, #1
    123c:	18fb      	adds	r3, r7, r3
    123e:	681b      	ldr	r3, [r3, #0]
    1240:	2b00      	cmp	r3, #0
    1242:	d004      	beq.n	124e <build_and_save_cert+0x55a>
    1244:	239c      	movs	r3, #156	; 0x9c
    1246:	005b      	lsls	r3, r3, #1
    1248:	18fb      	adds	r3, r7, r3
    124a:	681b      	ldr	r3, [r3, #0]
    124c:	e028      	b.n	12a0 <build_and_save_cert+0x5ac>
        ret = atcacert_get_device_data(cert_def, cert, *cert_size, &device_locs[i], data);
        if (ret != ATCACERT_E_SUCCESS) return ret;
        
        start_block = device_locs[i].offset / 32;
        end_block = (device_locs[i].offset + device_locs[i].count) / 32;
        for (block = start_block; block < end_block; block++)
    124e:	2344      	movs	r3, #68	; 0x44
    1250:	33ff      	adds	r3, #255	; 0xff
    1252:	18fb      	adds	r3, r7, r3
    1254:	781a      	ldrb	r2, [r3, #0]
    1256:	2344      	movs	r3, #68	; 0x44
    1258:	33ff      	adds	r3, #255	; 0xff
    125a:	18fb      	adds	r3, r7, r3
    125c:	3201      	adds	r2, #1
    125e:	701a      	strb	r2, [r3, #0]
    1260:	2344      	movs	r3, #68	; 0x44
    1262:	33ff      	adds	r3, #255	; 0xff
    1264:	18fb      	adds	r3, r7, r3
    1266:	781a      	ldrb	r2, [r3, #0]
    1268:	2398      	movs	r3, #152	; 0x98
    126a:	005b      	lsls	r3, r3, #1
    126c:	18fb      	adds	r3, r7, r3
    126e:	681b      	ldr	r3, [r3, #0]
    1270:	429a      	cmp	r2, r3
    1272:	d3ae      	bcc.n	11d2 <build_and_save_cert+0x4de>
    1274:	e002      	b.n	127c <build_and_save_cert+0x588>
        size_t start_block;
        uint8_t data[96];
        uint8_t block;
        
        if (device_locs[i].zone == DEVZONE_CONFIG)
            continue;
    1276:	46c0      	nop			; (mov r8, r8)
    1278:	e000      	b.n	127c <build_and_save_cert+0x588>
        if (device_locs[i].zone == DEVZONE_DATA && device_locs[i].is_genkey)
            continue;
    127a:	46c0      	nop			; (mov r8, r8)
    if (ret != ATCACERT_E_SUCCESS) return ret;
    
    ret = atcacert_get_device_locs(cert_def, device_locs, &device_locs_count, sizeof(device_locs) / sizeof(device_locs[0]), 32);
    if (ret != ATCACERT_E_SUCCESS) return ret;
    
    for (i = 0; i < device_locs_count; i++)
    127c:	23a2      	movs	r3, #162	; 0xa2
    127e:	005b      	lsls	r3, r3, #1
    1280:	18fb      	adds	r3, r7, r3
    1282:	681b      	ldr	r3, [r3, #0]
    1284:	3301      	adds	r3, #1
    1286:	22a2      	movs	r2, #162	; 0xa2
    1288:	0052      	lsls	r2, r2, #1
    128a:	18ba      	adds	r2, r7, r2
    128c:	6013      	str	r3, [r2, #0]
    128e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    1290:	22a2      	movs	r2, #162	; 0xa2
    1292:	0052      	lsls	r2, r2, #1
    1294:	18ba      	adds	r2, r7, r2
    1296:	6812      	ldr	r2, [r2, #0]
    1298:	429a      	cmp	r2, r3
    129a:	d200      	bcs.n	129e <build_and_save_cert+0x5aa>
    129c:	e6e7      	b.n	106e <build_and_save_cert+0x37a>
            ret = atcab_write_zone(device_locs[i].zone, device_locs[i].slot, block, 0, &data[(block - start_block) * 32], 32);
            if (ret != ATCA_SUCCESS) return ret;
        }
    }
    
    return 0;
    129e:	2300      	movs	r3, #0
}
    12a0:	0018      	movs	r0, r3
    12a2:	46bd      	mov	sp, r7
    12a4:	b053      	add	sp, #332	; 0x14c
    12a6:	bd90      	pop	{r4, r7, pc}
    12a8:	0000bb09 	.word	0x0000bb09

000012ac <client_provision>:
 * modules (HSM) and production facilities.  This is functional code which can be used to self-provisioin a device for
 * illustration, example, or demo purposes.
 */

int client_provision(void)
{
    12ac:	b590      	push	{r4, r7, lr}
    12ae:	4ce4      	ldr	r4, [pc, #912]	; (1640 <client_provision+0x394>)
    12b0:	44a5      	add	sp, r4
    12b2:	af06      	add	r7, sp, #24
    int ret = 0;
    12b4:	2300      	movs	r3, #0
    12b6:	4ae3      	ldr	r2, [pc, #908]	; (1644 <client_provision+0x398>)
    12b8:	18ba      	adds	r2, r7, r2
    12ba:	6013      	str	r3, [r2, #0]
    bool lockstate = 0;
    12bc:	4be2      	ldr	r3, [pc, #904]	; (1648 <client_provision+0x39c>)
    12be:	18fb      	adds	r3, r7, r3
    12c0:	2200      	movs	r2, #0
    12c2:	701a      	strb	r2, [r3, #0]
    uint8_t signer_ca_private_key_slot = 7;
    12c4:	4be1      	ldr	r3, [pc, #900]	; (164c <client_provision+0x3a0>)
    12c6:	18fb      	adds	r3, r7, r3
    12c8:	2207      	movs	r2, #7
    12ca:	701a      	strb	r2, [r3, #0]
    uint8_t signer_private_key_slot = 2;
    12cc:	4be0      	ldr	r3, [pc, #896]	; (1650 <client_provision+0x3a4>)
    12ce:	18fb      	adds	r3, r7, r3
    12d0:	2202      	movs	r2, #2
    12d2:	701a      	strb	r2, [r3, #0]
    uint8_t signer_id[2] = {0xC4, 0x8B};
    12d4:	4bdf      	ldr	r3, [pc, #892]	; (1654 <client_provision+0x3a8>)
    12d6:	18fa      	adds	r2, r7, r3
    12d8:	4bdf      	ldr	r3, [pc, #892]	; (1658 <client_provision+0x3ac>)
    12da:	0010      	movs	r0, r2
    12dc:	0019      	movs	r1, r3
    12de:	2302      	movs	r3, #2
    12e0:	001a      	movs	r2, r3
    12e2:	4bde      	ldr	r3, [pc, #888]	; (165c <client_provision+0x3b0>)
    12e4:	4798      	blx	r3
    const atcacert_tm_utc_t signer_issue_date = {
    12e6:	4bde      	ldr	r3, [pc, #888]	; (1660 <client_provision+0x3b4>)
    12e8:	18fb      	adds	r3, r7, r3
    12ea:	4ade      	ldr	r2, [pc, #888]	; (1664 <client_provision+0x3b8>)
    12ec:	ca13      	ldmia	r2!, {r0, r1, r4}
    12ee:	c313      	stmia	r3!, {r0, r1, r4}
    12f0:	ca13      	ldmia	r2!, {r0, r1, r4}
    12f2:	c313      	stmia	r3!, {r0, r1, r4}
        .tm_mday = 2,
        .tm_hour = 20,
        .tm_min  = 0,
        .tm_sec  = 0
    };
    uint8_t device_private_key_slot = 0;
    12f4:	4bdc      	ldr	r3, [pc, #880]	; (1668 <client_provision+0x3bc>)
    12f6:	18fb      	adds	r3, r7, r3
    12f8:	2200      	movs	r2, #0
    12fa:	701a      	strb	r2, [r3, #0]
    const atcacert_tm_utc_t device_issue_date = {
    12fc:	4bdb      	ldr	r3, [pc, #876]	; (166c <client_provision+0x3c0>)
    12fe:	18fb      	adds	r3, r7, r3
    1300:	4adb      	ldr	r2, [pc, #876]	; (1670 <client_provision+0x3c4>)
    1302:	ca13      	ldmia	r2!, {r0, r1, r4}
    1304:	c313      	stmia	r3!, {r0, r1, r4}
    1306:	ca13      	ldmia	r2!, {r0, r1, r4}
    1308:	c313      	stmia	r3!, {r0, r1, r4}
        .tm_hour = 21,
        .tm_min  = 0,
        .tm_sec  = 0
    };
	static const uint8_t access_key_slot = 4;
	const uint8_t access_key[] = {
    130a:	4bda      	ldr	r3, [pc, #872]	; (1674 <client_provision+0x3c8>)
    130c:	18fa      	adds	r2, r7, r3
    130e:	4bda      	ldr	r3, [pc, #872]	; (1678 <client_provision+0x3cc>)
    1310:	0010      	movs	r0, r2
    1312:	0019      	movs	r1, r3
    1314:	2320      	movs	r3, #32
    1316:	001a      	movs	r2, r3
    1318:	4bd0      	ldr	r3, [pc, #832]	; (165c <client_provision+0x3b0>)
    131a:	4798      	blx	r3
		0x32, 0x12, 0xd0, 0x66, 0xf5, 0xed, 0x52, 0xc7, 0x79, 0x98, 0xff, 0xaa, 0xac, 0x43, 0x22, 0x60,
		0xdd, 0xff, 0x9c, 0x10, 0x99, 0x6f, 0x41, 0x66, 0x3a, 0x60, 0x23, 0xfa, 0xf6, 0xaa, 0x3e, 0xc5
	};
    uint8_t config64[64];
	bool is_signer_ca_slot_ext_sig    = false;
    131c:	23b0      	movs	r3, #176	; 0xb0
    131e:	011b      	lsls	r3, r3, #4
    1320:	18fb      	adds	r3, r7, r3
    1322:	2200      	movs	r2, #0
    1324:	701a      	strb	r2, [r3, #0]
	bool is_signer_ca_slot_priv_write = false;
    1326:	4bd5      	ldr	r3, [pc, #852]	; (167c <client_provision+0x3d0>)
    1328:	18fb      	adds	r3, r7, r3
    132a:	2200      	movs	r2, #0
    132c:	701a      	strb	r2, [r3, #0]
    char disp_str[1500];
    int disp_size = sizeof(disp_str);
    132e:	4bd4      	ldr	r3, [pc, #848]	; (1680 <client_provision+0x3d4>)
    1330:	4ad4      	ldr	r2, [pc, #848]	; (1684 <client_provision+0x3d8>)
    1332:	18ba      	adds	r2, r7, r2
    1334:	6013      	str	r3, [r2, #0]
    uint8_t lock_response;
    uint8_t signer_public_key[64];
    uint8_t device_public_key[64];
    uint8_t signer_cert_ref[512];
    size_t  signer_cert_ref_size = 0;
    1336:	2300      	movs	r3, #0
    1338:	2281      	movs	r2, #129	; 0x81
    133a:	0092      	lsls	r2, r2, #2
    133c:	18ba      	adds	r2, r7, r2
    133e:	6013      	str	r3, [r2, #0]
    uint8_t device_cert_ref[512];
    size_t  device_cert_ref_size = 0;
    1340:	2300      	movs	r3, #0
    1342:	603b      	str	r3, [r7, #0]
    
    atcab_sleep();
    1344:	4bd0      	ldr	r3, [pc, #832]	; (1688 <client_provision+0x3dc>)
    1346:	4798      	blx	r3
    
    ret = atcab_is_locked(LOCK_ZONE_CONFIG, &lockstate);
    1348:	4bbf      	ldr	r3, [pc, #764]	; (1648 <client_provision+0x39c>)
    134a:	18fb      	adds	r3, r7, r3
    134c:	0019      	movs	r1, r3
    134e:	2000      	movs	r0, #0
    1350:	4bce      	ldr	r3, [pc, #824]	; (168c <client_provision+0x3e0>)
    1352:	4798      	blx	r3
    1354:	0003      	movs	r3, r0
    1356:	4abb      	ldr	r2, [pc, #748]	; (1644 <client_provision+0x398>)
    1358:	18ba      	adds	r2, r7, r2
    135a:	6013      	str	r3, [r2, #0]
    if (ret != ATCA_SUCCESS) return ret;
    135c:	4bb9      	ldr	r3, [pc, #740]	; (1644 <client_provision+0x398>)
    135e:	18fb      	adds	r3, r7, r3
    1360:	681b      	ldr	r3, [r3, #0]
    1362:	2b00      	cmp	r3, #0
    1364:	d003      	beq.n	136e <client_provision+0xc2>
    1366:	4bb7      	ldr	r3, [pc, #732]	; (1644 <client_provision+0x398>)
    1368:	18fb      	adds	r3, r7, r3
    136a:	681b      	ldr	r3, [r3, #0]
    136c:	e2ad      	b.n	18ca <client_provision+0x61e>
    if (!lockstate)
    136e:	4bb6      	ldr	r3, [pc, #728]	; (1648 <client_provision+0x39c>)
    1370:	18fb      	adds	r3, r7, r3
    1372:	781b      	ldrb	r3, [r3, #0]
    1374:	2201      	movs	r2, #1
    1376:	4053      	eors	r3, r2
    1378:	b2db      	uxtb	r3, r3
    137a:	2b00      	cmp	r3, #0
    137c:	d022      	beq.n	13c4 <client_provision+0x118>
    {
        ret = atcab_write_ecc_config_zone(g_ecc_configdata);
    137e:	4bc4      	ldr	r3, [pc, #784]	; (1690 <client_provision+0x3e4>)
    1380:	0018      	movs	r0, r3
    1382:	4bc4      	ldr	r3, [pc, #784]	; (1694 <client_provision+0x3e8>)
    1384:	4798      	blx	r3
    1386:	0003      	movs	r3, r0
    1388:	4aae      	ldr	r2, [pc, #696]	; (1644 <client_provision+0x398>)
    138a:	18ba      	adds	r2, r7, r2
    138c:	6013      	str	r3, [r2, #0]
        if (ret != ATCA_SUCCESS) return ret;
    138e:	4bad      	ldr	r3, [pc, #692]	; (1644 <client_provision+0x398>)
    1390:	18fb      	adds	r3, r7, r3
    1392:	681b      	ldr	r3, [r3, #0]
    1394:	2b00      	cmp	r3, #0
    1396:	d003      	beq.n	13a0 <client_provision+0xf4>
    1398:	4baa      	ldr	r3, [pc, #680]	; (1644 <client_provision+0x398>)
    139a:	18fb      	adds	r3, r7, r3
    139c:	681b      	ldr	r3, [r3, #0]
    139e:	e294      	b.n	18ca <client_provision+0x61e>
        
        ret = atcab_lock_config_zone(&lock_response);
    13a0:	4bbd      	ldr	r3, [pc, #756]	; (1698 <client_provision+0x3ec>)
    13a2:	18fb      	adds	r3, r7, r3
    13a4:	0018      	movs	r0, r3
    13a6:	4bbd      	ldr	r3, [pc, #756]	; (169c <client_provision+0x3f0>)
    13a8:	4798      	blx	r3
    13aa:	0003      	movs	r3, r0
    13ac:	4aa5      	ldr	r2, [pc, #660]	; (1644 <client_provision+0x398>)
    13ae:	18ba      	adds	r2, r7, r2
    13b0:	6013      	str	r3, [r2, #0]
        if (ret != ATCA_SUCCESS) return ret;
    13b2:	4ba4      	ldr	r3, [pc, #656]	; (1644 <client_provision+0x398>)
    13b4:	18fb      	adds	r3, r7, r3
    13b6:	681b      	ldr	r3, [r3, #0]
    13b8:	2b00      	cmp	r3, #0
    13ba:	d003      	beq.n	13c4 <client_provision+0x118>
    13bc:	4ba1      	ldr	r3, [pc, #644]	; (1644 <client_provision+0x398>)
    13be:	18fb      	adds	r3, r7, r3
    13c0:	681b      	ldr	r3, [r3, #0]
    13c2:	e282      	b.n	18ca <client_provision+0x61e>
    }

	// Read the first 64 bytes of the config zone to get the slot config at least
	ret = atcab_read_zone(ATCA_ZONE_CONFIG, 0, 0, 0, &config64[0], 32);
    13c4:	2320      	movs	r3, #32
    13c6:	9301      	str	r3, [sp, #4]
    13c8:	4bb5      	ldr	r3, [pc, #724]	; (16a0 <client_provision+0x3f4>)
    13ca:	18fb      	adds	r3, r7, r3
    13cc:	9300      	str	r3, [sp, #0]
    13ce:	2300      	movs	r3, #0
    13d0:	2200      	movs	r2, #0
    13d2:	2100      	movs	r1, #0
    13d4:	2000      	movs	r0, #0
    13d6:	4cb3      	ldr	r4, [pc, #716]	; (16a4 <client_provision+0x3f8>)
    13d8:	47a0      	blx	r4
    13da:	0003      	movs	r3, r0
    13dc:	4a99      	ldr	r2, [pc, #612]	; (1644 <client_provision+0x398>)
    13de:	18ba      	adds	r2, r7, r2
    13e0:	6013      	str	r3, [r2, #0]
    if (ret != ATCA_SUCCESS) return ret;
    13e2:	4b98      	ldr	r3, [pc, #608]	; (1644 <client_provision+0x398>)
    13e4:	18fb      	adds	r3, r7, r3
    13e6:	681b      	ldr	r3, [r3, #0]
    13e8:	2b00      	cmp	r3, #0
    13ea:	d003      	beq.n	13f4 <client_provision+0x148>
    13ec:	4b95      	ldr	r3, [pc, #596]	; (1644 <client_provision+0x398>)
    13ee:	18fb      	adds	r3, r7, r3
    13f0:	681b      	ldr	r3, [r3, #0]
    13f2:	e26a      	b.n	18ca <client_provision+0x61e>
	ret = atcab_read_zone(ATCA_ZONE_CONFIG, 0, 1, 0, &config64[32], 32);
    13f4:	2320      	movs	r3, #32
    13f6:	9301      	str	r3, [sp, #4]
    13f8:	4ba9      	ldr	r3, [pc, #676]	; (16a0 <client_provision+0x3f4>)
    13fa:	18fb      	adds	r3, r7, r3
    13fc:	3320      	adds	r3, #32
    13fe:	9300      	str	r3, [sp, #0]
    1400:	2300      	movs	r3, #0
    1402:	2201      	movs	r2, #1
    1404:	2100      	movs	r1, #0
    1406:	2000      	movs	r0, #0
    1408:	4ca6      	ldr	r4, [pc, #664]	; (16a4 <client_provision+0x3f8>)
    140a:	47a0      	blx	r4
    140c:	0003      	movs	r3, r0
    140e:	4a8d      	ldr	r2, [pc, #564]	; (1644 <client_provision+0x398>)
    1410:	18ba      	adds	r2, r7, r2
    1412:	6013      	str	r3, [r2, #0]
    if (ret != ATCA_SUCCESS) return ret;
    1414:	4b8b      	ldr	r3, [pc, #556]	; (1644 <client_provision+0x398>)
    1416:	18fb      	adds	r3, r7, r3
    1418:	681b      	ldr	r3, [r3, #0]
    141a:	2b00      	cmp	r3, #0
    141c:	d003      	beq.n	1426 <client_provision+0x17a>
    141e:	4b89      	ldr	r3, [pc, #548]	; (1644 <client_provision+0x398>)
    1420:	18fb      	adds	r3, r7, r3
    1422:	681b      	ldr	r3, [r3, #0]
    1424:	e251      	b.n	18ca <client_provision+0x61e>
	
	is_signer_ca_slot_ext_sig    = (config64[20 + signer_ca_private_key_slot*2] & 0x01);
    1426:	4b89      	ldr	r3, [pc, #548]	; (164c <client_provision+0x3a0>)
    1428:	18fb      	adds	r3, r7, r3
    142a:	781b      	ldrb	r3, [r3, #0]
    142c:	330a      	adds	r3, #10
    142e:	005b      	lsls	r3, r3, #1
    1430:	4a9b      	ldr	r2, [pc, #620]	; (16a0 <client_provision+0x3f4>)
    1432:	18ba      	adds	r2, r7, r2
    1434:	5cd3      	ldrb	r3, [r2, r3]
    1436:	001a      	movs	r2, r3
    1438:	2301      	movs	r3, #1
    143a:	401a      	ands	r2, r3
    143c:	23b0      	movs	r3, #176	; 0xb0
    143e:	011b      	lsls	r3, r3, #4
    1440:	18fb      	adds	r3, r7, r3
    1442:	1e51      	subs	r1, r2, #1
    1444:	418a      	sbcs	r2, r1
    1446:	701a      	strb	r2, [r3, #0]
	is_signer_ca_slot_priv_write = (config64[20 + signer_ca_private_key_slot*2 + 1] & 0x40);
    1448:	4b80      	ldr	r3, [pc, #512]	; (164c <client_provision+0x3a0>)
    144a:	18fb      	adds	r3, r7, r3
    144c:	781b      	ldrb	r3, [r3, #0]
    144e:	330a      	adds	r3, #10
    1450:	005b      	lsls	r3, r3, #1
    1452:	3301      	adds	r3, #1
    1454:	4a92      	ldr	r2, [pc, #584]	; (16a0 <client_provision+0x3f4>)
    1456:	18ba      	adds	r2, r7, r2
    1458:	5cd3      	ldrb	r3, [r2, r3]
    145a:	001a      	movs	r2, r3
    145c:	2340      	movs	r3, #64	; 0x40
    145e:	401a      	ands	r2, r3
    1460:	4b86      	ldr	r3, [pc, #536]	; (167c <client_provision+0x3d0>)
    1462:	18fb      	adds	r3, r7, r3
    1464:	1e51      	subs	r1, r2, #1
    1466:	418a      	sbcs	r2, r1
    1468:	701a      	strb	r2, [r3, #0]
	
    ret = atcab_is_locked(LOCK_ZONE_DATA, &lockstate);
    146a:	4b77      	ldr	r3, [pc, #476]	; (1648 <client_provision+0x39c>)
    146c:	18fb      	adds	r3, r7, r3
    146e:	0019      	movs	r1, r3
    1470:	2001      	movs	r0, #1
    1472:	4b86      	ldr	r3, [pc, #536]	; (168c <client_provision+0x3e0>)
    1474:	4798      	blx	r3
    1476:	0003      	movs	r3, r0
    1478:	4a72      	ldr	r2, [pc, #456]	; (1644 <client_provision+0x398>)
    147a:	18ba      	adds	r2, r7, r2
    147c:	6013      	str	r3, [r2, #0]
    if (ret != ATCA_SUCCESS) return ret;
    147e:	4b71      	ldr	r3, [pc, #452]	; (1644 <client_provision+0x398>)
    1480:	18fb      	adds	r3, r7, r3
    1482:	681b      	ldr	r3, [r3, #0]
    1484:	2b00      	cmp	r3, #0
    1486:	d003      	beq.n	1490 <client_provision+0x1e4>
    1488:	4b6e      	ldr	r3, [pc, #440]	; (1644 <client_provision+0x398>)
    148a:	18fb      	adds	r3, r7, r3
    148c:	681b      	ldr	r3, [r3, #0]
    148e:	e21c      	b.n	18ca <client_provision+0x61e>
    if (!lockstate)
    1490:	4b6d      	ldr	r3, [pc, #436]	; (1648 <client_provision+0x39c>)
    1492:	18fb      	adds	r3, r7, r3
    1494:	781b      	ldrb	r3, [r3, #0]
    1496:	2201      	movs	r2, #1
    1498:	4053      	eors	r3, r2
    149a:	b2db      	uxtb	r3, r3
    149c:	2b00      	cmp	r3, #0
    149e:	d03f      	beq.n	1520 <client_provision+0x274>
    {
        ret = atcab_priv_write(signer_ca_private_key_slot, g_signer_ca_private_key, 0, NULL);
    14a0:	4981      	ldr	r1, [pc, #516]	; (16a8 <client_provision+0x3fc>)
    14a2:	4b6a      	ldr	r3, [pc, #424]	; (164c <client_provision+0x3a0>)
    14a4:	18fb      	adds	r3, r7, r3
    14a6:	7818      	ldrb	r0, [r3, #0]
    14a8:	2300      	movs	r3, #0
    14aa:	2200      	movs	r2, #0
    14ac:	4c7f      	ldr	r4, [pc, #508]	; (16ac <client_provision+0x400>)
    14ae:	47a0      	blx	r4
    14b0:	0003      	movs	r3, r0
    14b2:	4a64      	ldr	r2, [pc, #400]	; (1644 <client_provision+0x398>)
    14b4:	18ba      	adds	r2, r7, r2
    14b6:	6013      	str	r3, [r2, #0]
        if (ret != ATCA_SUCCESS) return ret;
    14b8:	4b62      	ldr	r3, [pc, #392]	; (1644 <client_provision+0x398>)
    14ba:	18fb      	adds	r3, r7, r3
    14bc:	681b      	ldr	r3, [r3, #0]
    14be:	2b00      	cmp	r3, #0
    14c0:	d003      	beq.n	14ca <client_provision+0x21e>
    14c2:	4b60      	ldr	r3, [pc, #384]	; (1644 <client_provision+0x398>)
    14c4:	18fb      	adds	r3, r7, r3
    14c6:	681b      	ldr	r3, [r3, #0]
    14c8:	e1ff      	b.n	18ca <client_provision+0x61e>
		
		ret = atcab_write_zone(DEVZONE_DATA, access_key_slot, 0, 0, access_key, 32);
    14ca:	4b79      	ldr	r3, [pc, #484]	; (16b0 <client_provision+0x404>)
    14cc:	7819      	ldrb	r1, [r3, #0]
    14ce:	2320      	movs	r3, #32
    14d0:	9301      	str	r3, [sp, #4]
    14d2:	4b68      	ldr	r3, [pc, #416]	; (1674 <client_provision+0x3c8>)
    14d4:	18fb      	adds	r3, r7, r3
    14d6:	9300      	str	r3, [sp, #0]
    14d8:	2300      	movs	r3, #0
    14da:	2200      	movs	r2, #0
    14dc:	2002      	movs	r0, #2
    14de:	4c75      	ldr	r4, [pc, #468]	; (16b4 <client_provision+0x408>)
    14e0:	47a0      	blx	r4
    14e2:	0003      	movs	r3, r0
    14e4:	4a57      	ldr	r2, [pc, #348]	; (1644 <client_provision+0x398>)
    14e6:	18ba      	adds	r2, r7, r2
    14e8:	6013      	str	r3, [r2, #0]
        if (ret != ATCA_SUCCESS) return ret;
    14ea:	4b56      	ldr	r3, [pc, #344]	; (1644 <client_provision+0x398>)
    14ec:	18fb      	adds	r3, r7, r3
    14ee:	681b      	ldr	r3, [r3, #0]
    14f0:	2b00      	cmp	r3, #0
    14f2:	d003      	beq.n	14fc <client_provision+0x250>
    14f4:	4b53      	ldr	r3, [pc, #332]	; (1644 <client_provision+0x398>)
    14f6:	18fb      	adds	r3, r7, r3
    14f8:	681b      	ldr	r3, [r3, #0]
    14fa:	e1e6      	b.n	18ca <client_provision+0x61e>
        
        ret = atcab_lock_data_zone(&lock_response);
    14fc:	4b66      	ldr	r3, [pc, #408]	; (1698 <client_provision+0x3ec>)
    14fe:	18fb      	adds	r3, r7, r3
    1500:	0018      	movs	r0, r3
    1502:	4b6d      	ldr	r3, [pc, #436]	; (16b8 <client_provision+0x40c>)
    1504:	4798      	blx	r3
    1506:	0003      	movs	r3, r0
    1508:	4a4e      	ldr	r2, [pc, #312]	; (1644 <client_provision+0x398>)
    150a:	18ba      	adds	r2, r7, r2
    150c:	6013      	str	r3, [r2, #0]
        if (ret != ATCA_SUCCESS) return ret;
    150e:	4b4d      	ldr	r3, [pc, #308]	; (1644 <client_provision+0x398>)
    1510:	18fb      	adds	r3, r7, r3
    1512:	681b      	ldr	r3, [r3, #0]
    1514:	2b00      	cmp	r3, #0
    1516:	d038      	beq.n	158a <client_provision+0x2de>
    1518:	4b4a      	ldr	r3, [pc, #296]	; (1644 <client_provision+0x398>)
    151a:	18fb      	adds	r3, r7, r3
    151c:	681b      	ldr	r3, [r3, #0]
    151e:	e1d4      	b.n	18ca <client_provision+0x61e>
    }
	else if (!is_signer_ca_slot_ext_sig)
    1520:	23b0      	movs	r3, #176	; 0xb0
    1522:	011b      	lsls	r3, r3, #4
    1524:	18fb      	adds	r3, r7, r3
    1526:	781b      	ldrb	r3, [r3, #0]
    1528:	2201      	movs	r2, #1
    152a:	4053      	eors	r3, r2
    152c:	b2db      	uxtb	r3, r3
    152e:	2b00      	cmp	r3, #0
    1530:	d00e      	beq.n	1550 <client_provision+0x2a4>
	{
		// The signer CA slot can't perform external signs.
		// Use the signer slot for both. A little weird, but it lets the example run.
		printf("Signer CA slot %d not available. Signer CA and signer will be sharing a key.\r\n", signer_ca_private_key_slot);
    1532:	4b46      	ldr	r3, [pc, #280]	; (164c <client_provision+0x3a0>)
    1534:	18fb      	adds	r3, r7, r3
    1536:	781a      	ldrb	r2, [r3, #0]
    1538:	4b60      	ldr	r3, [pc, #384]	; (16bc <client_provision+0x410>)
    153a:	0011      	movs	r1, r2
    153c:	0018      	movs	r0, r3
    153e:	4b60      	ldr	r3, [pc, #384]	; (16c0 <client_provision+0x414>)
    1540:	4798      	blx	r3
		signer_ca_private_key_slot = signer_private_key_slot;
    1542:	4b42      	ldr	r3, [pc, #264]	; (164c <client_provision+0x3a0>)
    1544:	18fb      	adds	r3, r7, r3
    1546:	4a42      	ldr	r2, [pc, #264]	; (1650 <client_provision+0x3a4>)
    1548:	18ba      	adds	r2, r7, r2
    154a:	7812      	ldrb	r2, [r2, #0]
    154c:	701a      	strb	r2, [r3, #0]
    154e:	e01c      	b.n	158a <client_provision+0x2de>
	}
	else if (is_signer_ca_slot_priv_write)
    1550:	4b4a      	ldr	r3, [pc, #296]	; (167c <client_provision+0x3d0>)
    1552:	18fb      	adds	r3, r7, r3
    1554:	781b      	ldrb	r3, [r3, #0]
    1556:	2b00      	cmp	r3, #0
    1558:	d017      	beq.n	158a <client_provision+0x2de>
	{
		ret = atcab_priv_write(signer_ca_private_key_slot, g_signer_ca_private_key, access_key_slot, access_key);
    155a:	4b55      	ldr	r3, [pc, #340]	; (16b0 <client_provision+0x404>)
    155c:	781a      	ldrb	r2, [r3, #0]
    155e:	4b45      	ldr	r3, [pc, #276]	; (1674 <client_provision+0x3c8>)
    1560:	18fc      	adds	r4, r7, r3
    1562:	4951      	ldr	r1, [pc, #324]	; (16a8 <client_provision+0x3fc>)
    1564:	4b39      	ldr	r3, [pc, #228]	; (164c <client_provision+0x3a0>)
    1566:	18fb      	adds	r3, r7, r3
    1568:	7818      	ldrb	r0, [r3, #0]
    156a:	0023      	movs	r3, r4
    156c:	4c4f      	ldr	r4, [pc, #316]	; (16ac <client_provision+0x400>)
    156e:	47a0      	blx	r4
    1570:	0003      	movs	r3, r0
    1572:	4a34      	ldr	r2, [pc, #208]	; (1644 <client_provision+0x398>)
    1574:	18ba      	adds	r2, r7, r2
    1576:	6013      	str	r3, [r2, #0]
		if (ret != ATCA_SUCCESS) return ret;
    1578:	4b32      	ldr	r3, [pc, #200]	; (1644 <client_provision+0x398>)
    157a:	18fb      	adds	r3, r7, r3
    157c:	681b      	ldr	r3, [r3, #0]
    157e:	2b00      	cmp	r3, #0
    1580:	d003      	beq.n	158a <client_provision+0x2de>
    1582:	4b30      	ldr	r3, [pc, #192]	; (1644 <client_provision+0x398>)
    1584:	18fb      	adds	r3, r7, r3
    1586:	681b      	ldr	r3, [r3, #0]
    1588:	e19f      	b.n	18ca <client_provision+0x61e>
	}
    
	if (signer_ca_private_key_slot != signer_private_key_slot)
    158a:	4b30      	ldr	r3, [pc, #192]	; (164c <client_provision+0x3a0>)
    158c:	18fa      	adds	r2, r7, r3
    158e:	4b30      	ldr	r3, [pc, #192]	; (1650 <client_provision+0x3a4>)
    1590:	18fb      	adds	r3, r7, r3
    1592:	7812      	ldrb	r2, [r2, #0]
    1594:	781b      	ldrb	r3, [r3, #0]
    1596:	429a      	cmp	r2, r3
    1598:	d03a      	beq.n	1610 <client_provision+0x364>
	{
		ret = atcab_get_pubkey(signer_ca_private_key_slot, g_signer_ca_public_key);
    159a:	4a4a      	ldr	r2, [pc, #296]	; (16c4 <client_provision+0x418>)
    159c:	4b2b      	ldr	r3, [pc, #172]	; (164c <client_provision+0x3a0>)
    159e:	18fb      	adds	r3, r7, r3
    15a0:	781b      	ldrb	r3, [r3, #0]
    15a2:	0011      	movs	r1, r2
    15a4:	0018      	movs	r0, r3
    15a6:	4b48      	ldr	r3, [pc, #288]	; (16c8 <client_provision+0x41c>)
    15a8:	4798      	blx	r3
    15aa:	0003      	movs	r3, r0
    15ac:	4a25      	ldr	r2, [pc, #148]	; (1644 <client_provision+0x398>)
    15ae:	18ba      	adds	r2, r7, r2
    15b0:	6013      	str	r3, [r2, #0]
		if (ret == ATCA_EXECUTION_ERROR)
    15b2:	4b24      	ldr	r3, [pc, #144]	; (1644 <client_provision+0x398>)
    15b4:	18fb      	adds	r3, r7, r3
    15b6:	681b      	ldr	r3, [r3, #0]
    15b8:	2bf4      	cmp	r3, #244	; 0xf4
    15ba:	d10b      	bne.n	15d4 <client_provision+0x328>
			ret = atcab_genkey(signer_ca_private_key_slot, g_signer_ca_public_key);
    15bc:	4b23      	ldr	r3, [pc, #140]	; (164c <client_provision+0x3a0>)
    15be:	18fb      	adds	r3, r7, r3
    15c0:	781b      	ldrb	r3, [r3, #0]
    15c2:	4a40      	ldr	r2, [pc, #256]	; (16c4 <client_provision+0x418>)
    15c4:	0011      	movs	r1, r2
    15c6:	0018      	movs	r0, r3
    15c8:	4b40      	ldr	r3, [pc, #256]	; (16cc <client_provision+0x420>)
    15ca:	4798      	blx	r3
    15cc:	0003      	movs	r3, r0
    15ce:	4a1d      	ldr	r2, [pc, #116]	; (1644 <client_provision+0x398>)
    15d0:	18ba      	adds	r2, r7, r2
    15d2:	6013      	str	r3, [r2, #0]
		if (ret != ATCA_SUCCESS) return ret;
    15d4:	4b1b      	ldr	r3, [pc, #108]	; (1644 <client_provision+0x398>)
    15d6:	18fb      	adds	r3, r7, r3
    15d8:	681b      	ldr	r3, [r3, #0]
    15da:	2b00      	cmp	r3, #0
    15dc:	d003      	beq.n	15e6 <client_provision+0x33a>
    15de:	4b19      	ldr	r3, [pc, #100]	; (1644 <client_provision+0x398>)
    15e0:	18fb      	adds	r3, r7, r3
    15e2:	681b      	ldr	r3, [r3, #0]
    15e4:	e171      	b.n	18ca <client_provision+0x61e>
		disp_size = sizeof(disp_str);
    15e6:	4b26      	ldr	r3, [pc, #152]	; (1680 <client_provision+0x3d4>)
    15e8:	4a26      	ldr	r2, [pc, #152]	; (1684 <client_provision+0x3d8>)
    15ea:	18ba      	adds	r2, r7, r2
    15ec:	6013      	str	r3, [r2, #0]
		atcab_bin2hex( g_signer_ca_public_key, ATCA_PUB_KEY_SIZE, disp_str, &disp_size);
    15ee:	4b25      	ldr	r3, [pc, #148]	; (1684 <client_provision+0x3d8>)
    15f0:	18fb      	adds	r3, r7, r3
    15f2:	2292      	movs	r2, #146	; 0x92
    15f4:	00d2      	lsls	r2, r2, #3
    15f6:	18ba      	adds	r2, r7, r2
    15f8:	4832      	ldr	r0, [pc, #200]	; (16c4 <client_provision+0x418>)
    15fa:	2140      	movs	r1, #64	; 0x40
    15fc:	4c34      	ldr	r4, [pc, #208]	; (16d0 <client_provision+0x424>)
    15fe:	47a0      	blx	r4
		printf("Signer CA Public Key:\r\n%s\r\n", disp_str);
    1600:	2392      	movs	r3, #146	; 0x92
    1602:	00db      	lsls	r3, r3, #3
    1604:	18fa      	adds	r2, r7, r3
    1606:	4b33      	ldr	r3, [pc, #204]	; (16d4 <client_provision+0x428>)
    1608:	0011      	movs	r1, r2
    160a:	0018      	movs	r0, r3
    160c:	4b2c      	ldr	r3, [pc, #176]	; (16c0 <client_provision+0x414>)
    160e:	4798      	blx	r3
	}
    
    ret = atcab_genkey(signer_private_key_slot, signer_public_key);
    1610:	4b0f      	ldr	r3, [pc, #60]	; (1650 <client_provision+0x3a4>)
    1612:	18fb      	adds	r3, r7, r3
    1614:	781b      	ldrb	r3, [r3, #0]
    1616:	2289      	movs	r2, #137	; 0x89
    1618:	00d2      	lsls	r2, r2, #3
    161a:	18ba      	adds	r2, r7, r2
    161c:	0011      	movs	r1, r2
    161e:	0018      	movs	r0, r3
    1620:	4b2a      	ldr	r3, [pc, #168]	; (16cc <client_provision+0x420>)
    1622:	4798      	blx	r3
    1624:	0003      	movs	r3, r0
    1626:	4a07      	ldr	r2, [pc, #28]	; (1644 <client_provision+0x398>)
    1628:	18ba      	adds	r2, r7, r2
    162a:	6013      	str	r3, [r2, #0]
    if (ret != ATCA_SUCCESS) return ret;
    162c:	4b05      	ldr	r3, [pc, #20]	; (1644 <client_provision+0x398>)
    162e:	18fb      	adds	r3, r7, r3
    1630:	681b      	ldr	r3, [r3, #0]
    1632:	2b00      	cmp	r3, #0
    1634:	d050      	beq.n	16d8 <client_provision+0x42c>
    1636:	4b03      	ldr	r3, [pc, #12]	; (1644 <client_provision+0x398>)
    1638:	18fb      	adds	r3, r7, r3
    163a:	681b      	ldr	r3, [r3, #0]
    163c:	e145      	b.n	18ca <client_provision+0x61e>
    163e:	46c0      	nop			; (mov r8, r8)
    1640:	fffff4dc 	.word	0xfffff4dc
    1644:	00000b04 	.word	0x00000b04
    1648:	00000afe 	.word	0x00000afe
    164c:	00000b03 	.word	0x00000b03
    1650:	00000b02 	.word	0x00000b02
    1654:	00000afc 	.word	0x00000afc
    1658:	0001515c 	.word	0x0001515c
    165c:	000127e7 	.word	0x000127e7
    1660:	00000ae4 	.word	0x00000ae4
    1664:	00015160 	.word	0x00015160
    1668:	00000b01 	.word	0x00000b01
    166c:	00000acc 	.word	0x00000acc
    1670:	00015178 	.word	0x00015178
    1674:	00000aac 	.word	0x00000aac
    1678:	00015190 	.word	0x00015190
    167c:	00000aff 	.word	0x00000aff
    1680:	000005dc 	.word	0x000005dc
    1684:	0000048c 	.word	0x0000048c
    1688:	0000adfd 	.word	0x0000adfd
    168c:	0000ba6d 	.word	0x0000ba6d
    1690:	00014fdc 	.word	0x00014fdc
    1694:	0000bf59 	.word	0x0000bf59
    1698:	0000048b 	.word	0x0000048b
    169c:	0000c3d9 	.word	0x0000c3d9
    16a0:	00000a6c 	.word	0x00000a6c
    16a4:	0000bd1d 	.word	0x0000bd1d
    16a8:	0001505c 	.word	0x0001505c
    16ac:	0000cc09 	.word	0x0000cc09
    16b0:	000151b0 	.word	0x000151b0
    16b4:	0000bb09 	.word	0x0000bb09
    16b8:	0000c549 	.word	0x0000c549
    16bc:	00015080 	.word	0x00015080
    16c0:	0001296d 	.word	0x0001296d
    16c4:	200011cc 	.word	0x200011cc
    16c8:	0000ca7d 	.word	0x0000ca7d
    16cc:	0000b155 	.word	0x0000b155
    16d0:	0000d0dd 	.word	0x0000d0dd
    16d4:	000150d0 	.word	0x000150d0
	if (signer_ca_private_key_slot == signer_private_key_slot)
    16d8:	4b7e      	ldr	r3, [pc, #504]	; (18d4 <client_provision+0x628>)
    16da:	18fa      	adds	r2, r7, r3
    16dc:	4b7e      	ldr	r3, [pc, #504]	; (18d8 <client_provision+0x62c>)
    16de:	18fb      	adds	r3, r7, r3
    16e0:	7812      	ldrb	r2, [r2, #0]
    16e2:	781b      	ldrb	r3, [r3, #0]
    16e4:	429a      	cmp	r2, r3
    16e6:	d120      	bne.n	172a <client_provision+0x47e>
	{
		memcpy(g_signer_ca_public_key, signer_public_key, sizeof(g_signer_ca_public_key));
    16e8:	4a7c      	ldr	r2, [pc, #496]	; (18dc <client_provision+0x630>)
    16ea:	4b7d      	ldr	r3, [pc, #500]	; (18e0 <client_provision+0x634>)
    16ec:	497d      	ldr	r1, [pc, #500]	; (18e4 <client_provision+0x638>)
    16ee:	468c      	mov	ip, r1
    16f0:	44bc      	add	ip, r7
    16f2:	4463      	add	r3, ip
    16f4:	0010      	movs	r0, r2
    16f6:	0019      	movs	r1, r3
    16f8:	2340      	movs	r3, #64	; 0x40
    16fa:	001a      	movs	r2, r3
    16fc:	4b7a      	ldr	r3, [pc, #488]	; (18e8 <client_provision+0x63c>)
    16fe:	4798      	blx	r3
		disp_size = sizeof(disp_str);
    1700:	4b7a      	ldr	r3, [pc, #488]	; (18ec <client_provision+0x640>)
    1702:	4a7b      	ldr	r2, [pc, #492]	; (18f0 <client_provision+0x644>)
    1704:	18ba      	adds	r2, r7, r2
    1706:	6013      	str	r3, [r2, #0]
		atcab_bin2hex( g_signer_ca_public_key, ATCA_PUB_KEY_SIZE, disp_str, &disp_size);
    1708:	4b79      	ldr	r3, [pc, #484]	; (18f0 <client_provision+0x644>)
    170a:	18fb      	adds	r3, r7, r3
    170c:	2292      	movs	r2, #146	; 0x92
    170e:	00d2      	lsls	r2, r2, #3
    1710:	18ba      	adds	r2, r7, r2
    1712:	4872      	ldr	r0, [pc, #456]	; (18dc <client_provision+0x630>)
    1714:	2140      	movs	r1, #64	; 0x40
    1716:	4c77      	ldr	r4, [pc, #476]	; (18f4 <client_provision+0x648>)
    1718:	47a0      	blx	r4
		printf("Signer CA Public Key:\r\n%s\r\n", disp_str);
    171a:	2392      	movs	r3, #146	; 0x92
    171c:	00db      	lsls	r3, r3, #3
    171e:	18fa      	adds	r2, r7, r3
    1720:	4b75      	ldr	r3, [pc, #468]	; (18f8 <client_provision+0x64c>)
    1722:	0011      	movs	r1, r2
    1724:	0018      	movs	r0, r3
    1726:	4b75      	ldr	r3, [pc, #468]	; (18fc <client_provision+0x650>)
    1728:	4798      	blx	r3
	}
    disp_size = sizeof(disp_str);
    172a:	4b70      	ldr	r3, [pc, #448]	; (18ec <client_provision+0x640>)
    172c:	4a70      	ldr	r2, [pc, #448]	; (18f0 <client_provision+0x644>)
    172e:	18ba      	adds	r2, r7, r2
    1730:	6013      	str	r3, [r2, #0]
    atcab_bin2hex( signer_public_key, ATCA_PUB_KEY_SIZE, disp_str, &disp_size);
    1732:	4b6f      	ldr	r3, [pc, #444]	; (18f0 <client_provision+0x644>)
    1734:	18fb      	adds	r3, r7, r3
    1736:	2292      	movs	r2, #146	; 0x92
    1738:	00d2      	lsls	r2, r2, #3
    173a:	18ba      	adds	r2, r7, r2
    173c:	2189      	movs	r1, #137	; 0x89
    173e:	00c9      	lsls	r1, r1, #3
    1740:	1878      	adds	r0, r7, r1
    1742:	2140      	movs	r1, #64	; 0x40
    1744:	4c6b      	ldr	r4, [pc, #428]	; (18f4 <client_provision+0x648>)
    1746:	47a0      	blx	r4
    printf("Signer Public Key:\r\n%s\r\n", disp_str);
    1748:	2392      	movs	r3, #146	; 0x92
    174a:	00db      	lsls	r3, r3, #3
    174c:	18fa      	adds	r2, r7, r3
    174e:	4b6c      	ldr	r3, [pc, #432]	; (1900 <client_provision+0x654>)
    1750:	0011      	movs	r1, r2
    1752:	0018      	movs	r0, r3
    1754:	4b69      	ldr	r3, [pc, #420]	; (18fc <client_provision+0x650>)
    1756:	4798      	blx	r3
        
    ret = atcab_genkey(device_private_key_slot, device_public_key);
    1758:	4b6a      	ldr	r3, [pc, #424]	; (1904 <client_provision+0x658>)
    175a:	18fb      	adds	r3, r7, r3
    175c:	781b      	ldrb	r3, [r3, #0]
    175e:	2281      	movs	r2, #129	; 0x81
    1760:	00d2      	lsls	r2, r2, #3
    1762:	18ba      	adds	r2, r7, r2
    1764:	0011      	movs	r1, r2
    1766:	0018      	movs	r0, r3
    1768:	4b67      	ldr	r3, [pc, #412]	; (1908 <client_provision+0x65c>)
    176a:	4798      	blx	r3
    176c:	0003      	movs	r3, r0
    176e:	4a67      	ldr	r2, [pc, #412]	; (190c <client_provision+0x660>)
    1770:	18ba      	adds	r2, r7, r2
    1772:	6013      	str	r3, [r2, #0]
    if (ret != ATCA_SUCCESS) return ret;
    1774:	4b65      	ldr	r3, [pc, #404]	; (190c <client_provision+0x660>)
    1776:	18fb      	adds	r3, r7, r3
    1778:	681b      	ldr	r3, [r3, #0]
    177a:	2b00      	cmp	r3, #0
    177c:	d003      	beq.n	1786 <client_provision+0x4da>
    177e:	4b63      	ldr	r3, [pc, #396]	; (190c <client_provision+0x660>)
    1780:	18fb      	adds	r3, r7, r3
    1782:	681b      	ldr	r3, [r3, #0]
    1784:	e0a1      	b.n	18ca <client_provision+0x61e>
    disp_size = sizeof(disp_str);
    1786:	4b59      	ldr	r3, [pc, #356]	; (18ec <client_provision+0x640>)
    1788:	4a59      	ldr	r2, [pc, #356]	; (18f0 <client_provision+0x644>)
    178a:	18ba      	adds	r2, r7, r2
    178c:	6013      	str	r3, [r2, #0]
    atcab_bin2hex( device_public_key, ATCA_PUB_KEY_SIZE, disp_str, &disp_size);
    178e:	4b58      	ldr	r3, [pc, #352]	; (18f0 <client_provision+0x644>)
    1790:	18fb      	adds	r3, r7, r3
    1792:	2292      	movs	r2, #146	; 0x92
    1794:	00d2      	lsls	r2, r2, #3
    1796:	18ba      	adds	r2, r7, r2
    1798:	2181      	movs	r1, #129	; 0x81
    179a:	00c9      	lsls	r1, r1, #3
    179c:	1878      	adds	r0, r7, r1
    179e:	2140      	movs	r1, #64	; 0x40
    17a0:	4c54      	ldr	r4, [pc, #336]	; (18f4 <client_provision+0x648>)
    17a2:	47a0      	blx	r4
    printf("Device Public Key:\r\n%s\r\n", disp_str);
    17a4:	2392      	movs	r3, #146	; 0x92
    17a6:	00db      	lsls	r3, r3, #3
    17a8:	18fa      	adds	r2, r7, r3
    17aa:	4b59      	ldr	r3, [pc, #356]	; (1910 <client_provision+0x664>)
    17ac:	0011      	movs	r1, r2
    17ae:	0018      	movs	r0, r3
    17b0:	4b52      	ldr	r3, [pc, #328]	; (18fc <client_provision+0x650>)
    17b2:	4798      	blx	r3
    
    // Build signer cert
    signer_cert_ref_size = sizeof(signer_cert_ref);
    17b4:	2380      	movs	r3, #128	; 0x80
    17b6:	009b      	lsls	r3, r3, #2
    17b8:	2281      	movs	r2, #129	; 0x81
    17ba:	0092      	lsls	r2, r2, #2
    17bc:	18ba      	adds	r2, r7, r2
    17be:	6013      	str	r3, [r2, #0]
    ret = build_and_save_cert(
    17c0:	4c46      	ldr	r4, [pc, #280]	; (18dc <client_provision+0x630>)
    17c2:	2381      	movs	r3, #129	; 0x81
    17c4:	009b      	lsls	r3, r3, #2
    17c6:	18fa      	adds	r2, r7, r3
    17c8:	2382      	movs	r3, #130	; 0x82
    17ca:	009b      	lsls	r3, r3, #2
    17cc:	18f9      	adds	r1, r7, r3
    17ce:	4851      	ldr	r0, [pc, #324]	; (1914 <client_provision+0x668>)
    17d0:	4b40      	ldr	r3, [pc, #256]	; (18d4 <client_provision+0x628>)
    17d2:	18fb      	adds	r3, r7, r3
    17d4:	781b      	ldrb	r3, [r3, #0]
    17d6:	9304      	str	r3, [sp, #16]
    17d8:	4b4f      	ldr	r3, [pc, #316]	; (1918 <client_provision+0x66c>)
    17da:	18fb      	adds	r3, r7, r3
    17dc:	9303      	str	r3, [sp, #12]
    17de:	4b4f      	ldr	r3, [pc, #316]	; (191c <client_provision+0x670>)
    17e0:	18fb      	adds	r3, r7, r3
    17e2:	9302      	str	r3, [sp, #8]
    17e4:	4b4e      	ldr	r3, [pc, #312]	; (1920 <client_provision+0x674>)
    17e6:	18fb      	adds	r3, r7, r3
    17e8:	9301      	str	r3, [sp, #4]
    17ea:	2389      	movs	r3, #137	; 0x89
    17ec:	00db      	lsls	r3, r3, #3
    17ee:	18fb      	adds	r3, r7, r3
    17f0:	9300      	str	r3, [sp, #0]
    17f2:	0023      	movs	r3, r4
    17f4:	4c4b      	ldr	r4, [pc, #300]	; (1924 <client_provision+0x678>)
    17f6:	47a0      	blx	r4
    17f8:	0003      	movs	r3, r0
    17fa:	4a44      	ldr	r2, [pc, #272]	; (190c <client_provision+0x660>)
    17fc:	18ba      	adds	r2, r7, r2
    17fe:	6013      	str	r3, [r2, #0]
        signer_public_key,
        signer_id,
        &signer_issue_date,
        config64,
        signer_ca_private_key_slot);
    if (ret != ATCA_SUCCESS) return ret;
    1800:	4b42      	ldr	r3, [pc, #264]	; (190c <client_provision+0x660>)
    1802:	18fb      	adds	r3, r7, r3
    1804:	681b      	ldr	r3, [r3, #0]
    1806:	2b00      	cmp	r3, #0
    1808:	d003      	beq.n	1812 <client_provision+0x566>
    180a:	4b40      	ldr	r3, [pc, #256]	; (190c <client_provision+0x660>)
    180c:	18fb      	adds	r3, r7, r3
    180e:	681b      	ldr	r3, [r3, #0]
    1810:	e05b      	b.n	18ca <client_provision+0x61e>
    
    disp_size = sizeof(disp_str);
    1812:	4b36      	ldr	r3, [pc, #216]	; (18ec <client_provision+0x640>)
    1814:	4a36      	ldr	r2, [pc, #216]	; (18f0 <client_provision+0x644>)
    1816:	18ba      	adds	r2, r7, r2
    1818:	6013      	str	r3, [r2, #0]
    atcab_bin2hex( signer_cert_ref, signer_cert_ref_size, disp_str, &disp_size);
    181a:	2381      	movs	r3, #129	; 0x81
    181c:	009b      	lsls	r3, r3, #2
    181e:	18fb      	adds	r3, r7, r3
    1820:	681b      	ldr	r3, [r3, #0]
    1822:	0019      	movs	r1, r3
    1824:	4b32      	ldr	r3, [pc, #200]	; (18f0 <client_provision+0x644>)
    1826:	18fb      	adds	r3, r7, r3
    1828:	2292      	movs	r2, #146	; 0x92
    182a:	00d2      	lsls	r2, r2, #3
    182c:	18ba      	adds	r2, r7, r2
    182e:	2082      	movs	r0, #130	; 0x82
    1830:	0080      	lsls	r0, r0, #2
    1832:	1838      	adds	r0, r7, r0
    1834:	4c2f      	ldr	r4, [pc, #188]	; (18f4 <client_provision+0x648>)
    1836:	47a0      	blx	r4
    printf("Signer Certificate:\r\n%s\r\n", disp_str);
    1838:	2392      	movs	r3, #146	; 0x92
    183a:	00db      	lsls	r3, r3, #3
    183c:	18fa      	adds	r2, r7, r3
    183e:	4b3a      	ldr	r3, [pc, #232]	; (1928 <client_provision+0x67c>)
    1840:	0011      	movs	r1, r2
    1842:	0018      	movs	r0, r3
    1844:	4b2d      	ldr	r3, [pc, #180]	; (18fc <client_provision+0x650>)
    1846:	4798      	blx	r3
        
    device_cert_ref_size = sizeof(device_cert_ref);
    1848:	2380      	movs	r3, #128	; 0x80
    184a:	009b      	lsls	r3, r3, #2
    184c:	603b      	str	r3, [r7, #0]
    ret = build_and_save_cert(
    184e:	2389      	movs	r3, #137	; 0x89
    1850:	00db      	lsls	r3, r3, #3
    1852:	18fc      	adds	r4, r7, r3
    1854:	003a      	movs	r2, r7
    1856:	1d39      	adds	r1, r7, #4
    1858:	4834      	ldr	r0, [pc, #208]	; (192c <client_provision+0x680>)
    185a:	4b1f      	ldr	r3, [pc, #124]	; (18d8 <client_provision+0x62c>)
    185c:	18fb      	adds	r3, r7, r3
    185e:	781b      	ldrb	r3, [r3, #0]
    1860:	9304      	str	r3, [sp, #16]
    1862:	4b2d      	ldr	r3, [pc, #180]	; (1918 <client_provision+0x66c>)
    1864:	18fb      	adds	r3, r7, r3
    1866:	9303      	str	r3, [sp, #12]
    1868:	4b31      	ldr	r3, [pc, #196]	; (1930 <client_provision+0x684>)
    186a:	18fb      	adds	r3, r7, r3
    186c:	9302      	str	r3, [sp, #8]
    186e:	4b2c      	ldr	r3, [pc, #176]	; (1920 <client_provision+0x674>)
    1870:	18fb      	adds	r3, r7, r3
    1872:	9301      	str	r3, [sp, #4]
    1874:	2381      	movs	r3, #129	; 0x81
    1876:	00db      	lsls	r3, r3, #3
    1878:	18fb      	adds	r3, r7, r3
    187a:	9300      	str	r3, [sp, #0]
    187c:	0023      	movs	r3, r4
    187e:	4c29      	ldr	r4, [pc, #164]	; (1924 <client_provision+0x678>)
    1880:	47a0      	blx	r4
    1882:	0003      	movs	r3, r0
    1884:	4a21      	ldr	r2, [pc, #132]	; (190c <client_provision+0x660>)
    1886:	18ba      	adds	r2, r7, r2
    1888:	6013      	str	r3, [r2, #0]
        device_public_key,
        signer_id,
        &device_issue_date,
        config64,
        signer_private_key_slot);
    if (ret != ATCA_SUCCESS) return ret;
    188a:	4b20      	ldr	r3, [pc, #128]	; (190c <client_provision+0x660>)
    188c:	18fb      	adds	r3, r7, r3
    188e:	681b      	ldr	r3, [r3, #0]
    1890:	2b00      	cmp	r3, #0
    1892:	d003      	beq.n	189c <client_provision+0x5f0>
    1894:	4b1d      	ldr	r3, [pc, #116]	; (190c <client_provision+0x660>)
    1896:	18fb      	adds	r3, r7, r3
    1898:	681b      	ldr	r3, [r3, #0]
    189a:	e016      	b.n	18ca <client_provision+0x61e>
    
    disp_size = sizeof(disp_str);
    189c:	4b13      	ldr	r3, [pc, #76]	; (18ec <client_provision+0x640>)
    189e:	4a14      	ldr	r2, [pc, #80]	; (18f0 <client_provision+0x644>)
    18a0:	18ba      	adds	r2, r7, r2
    18a2:	6013      	str	r3, [r2, #0]
    atcab_bin2hex( device_cert_ref, device_cert_ref_size, disp_str, &disp_size);
    18a4:	683b      	ldr	r3, [r7, #0]
    18a6:	0019      	movs	r1, r3
    18a8:	4b11      	ldr	r3, [pc, #68]	; (18f0 <client_provision+0x644>)
    18aa:	18fb      	adds	r3, r7, r3
    18ac:	2292      	movs	r2, #146	; 0x92
    18ae:	00d2      	lsls	r2, r2, #3
    18b0:	18ba      	adds	r2, r7, r2
    18b2:	1d38      	adds	r0, r7, #4
    18b4:	4c0f      	ldr	r4, [pc, #60]	; (18f4 <client_provision+0x648>)
    18b6:	47a0      	blx	r4
    printf("Device Certificate:\r\n%s\r\n", disp_str);
    18b8:	2392      	movs	r3, #146	; 0x92
    18ba:	00db      	lsls	r3, r3, #3
    18bc:	18fa      	adds	r2, r7, r3
    18be:	4b1d      	ldr	r3, [pc, #116]	; (1934 <client_provision+0x688>)
    18c0:	0011      	movs	r1, r2
    18c2:	0018      	movs	r0, r3
    18c4:	4b0d      	ldr	r3, [pc, #52]	; (18fc <client_provision+0x650>)
    18c6:	4798      	blx	r3
    
    return 0;
    18c8:	2300      	movs	r3, #0
}
    18ca:	0018      	movs	r0, r3
    18cc:	46bd      	mov	sp, r7
    18ce:	4b1a      	ldr	r3, [pc, #104]	; (1938 <client_provision+0x68c>)
    18d0:	449d      	add	sp, r3
    18d2:	bd90      	pop	{r4, r7, pc}
    18d4:	00000b03 	.word	0x00000b03
    18d8:	00000b02 	.word	0x00000b02
    18dc:	200011cc 	.word	0x200011cc
    18e0:	fffff940 	.word	0xfffff940
    18e4:	00000b08 	.word	0x00000b08
    18e8:	000127e7 	.word	0x000127e7
    18ec:	000005dc 	.word	0x000005dc
    18f0:	0000048c 	.word	0x0000048c
    18f4:	0000d0dd 	.word	0x0000d0dd
    18f8:	000150d0 	.word	0x000150d0
    18fc:	0001296d 	.word	0x0001296d
    1900:	000150ec 	.word	0x000150ec
    1904:	00000b01 	.word	0x00000b01
    1908:	0000b155 	.word	0x0000b155
    190c:	00000b04 	.word	0x00000b04
    1910:	00015108 	.word	0x00015108
    1914:	00014ac0 	.word	0x00014ac0
    1918:	00000a6c 	.word	0x00000a6c
    191c:	00000ae4 	.word	0x00000ae4
    1920:	00000afc 	.word	0x00000afc
    1924:	00000cf5 	.word	0x00000cf5
    1928:	00015124 	.word	0x00015124
    192c:	00014cc0 	.word	0x00014cc0
    1930:	00000acc 	.word	0x00000acc
    1934:	00015140 	.word	0x00015140
    1938:	00000b0c 	.word	0x00000b0c

0000193c <cpu_irq_save>:

static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
    193c:	b580      	push	{r7, lr}
    193e:	b082      	sub	sp, #8
    1940:	af00      	add	r7, sp, #0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    1942:	f3ef 8310 	mrs	r3, PRIMASK
    1946:	603b      	str	r3, [r7, #0]
  return(result);
    1948:	683b      	ldr	r3, [r7, #0]
	irqflags_t flags = cpu_irq_is_enabled();
    194a:	425a      	negs	r2, r3
    194c:	4153      	adcs	r3, r2
    194e:	b2db      	uxtb	r3, r3
    1950:	607b      	str	r3, [r7, #4]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    1952:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    1954:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
    1958:	4b03      	ldr	r3, [pc, #12]	; (1968 <cpu_irq_save+0x2c>)
    195a:	2200      	movs	r2, #0
    195c:	701a      	strb	r2, [r3, #0]
	return flags;
    195e:	687b      	ldr	r3, [r7, #4]
}
    1960:	0018      	movs	r0, r3
    1962:	46bd      	mov	sp, r7
    1964:	b002      	add	sp, #8
    1966:	bd80      	pop	{r7, pc}
    1968:	2000017c 	.word	0x2000017c

0000196c <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
    196c:	b580      	push	{r7, lr}
    196e:	b082      	sub	sp, #8
    1970:	af00      	add	r7, sp, #0
    1972:	6078      	str	r0, [r7, #4]
	return (flags);
    1974:	687b      	ldr	r3, [r7, #4]
    1976:	1e5a      	subs	r2, r3, #1
    1978:	4193      	sbcs	r3, r2
    197a:	b2db      	uxtb	r3, r3
}
    197c:	0018      	movs	r0, r3
    197e:	46bd      	mov	sp, r7
    1980:	b002      	add	sp, #8
    1982:	bd80      	pop	{r7, pc}

00001984 <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
    1984:	b580      	push	{r7, lr}
    1986:	b082      	sub	sp, #8
    1988:	af00      	add	r7, sp, #0
    198a:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
    198c:	687b      	ldr	r3, [r7, #4]
    198e:	0018      	movs	r0, r3
    1990:	4b06      	ldr	r3, [pc, #24]	; (19ac <cpu_irq_restore+0x28>)
    1992:	4798      	blx	r3
    1994:	1e03      	subs	r3, r0, #0
    1996:	d005      	beq.n	19a4 <cpu_irq_restore+0x20>
		cpu_irq_enable();
    1998:	4b05      	ldr	r3, [pc, #20]	; (19b0 <cpu_irq_restore+0x2c>)
    199a:	2201      	movs	r2, #1
    199c:	701a      	strb	r2, [r3, #0]
    199e:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    19a2:	b662      	cpsie	i
}
    19a4:	46c0      	nop			; (mov r8, r8)
    19a6:	46bd      	mov	sp, r7
    19a8:	b002      	add	sp, #8
    19aa:	bd80      	pop	{r7, pc}
    19ac:	0000196d 	.word	0x0000196d
    19b0:	2000017c 	.word	0x2000017c

000019b4 <udi_cdc_comm_enable>:
static volatile bool udi_cdc_tx_both_buf_to_send[UDI_CDC_PORT_NB];

//@}

bool udi_cdc_comm_enable(void)
{
    19b4:	b590      	push	{r4, r7, lr}
    19b6:	b083      	sub	sp, #12
    19b8:	af00      	add	r7, sp, #0
	uint8_t port;
	uint8_t iface_comm_num;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
    19ba:	1dbb      	adds	r3, r7, #6
    19bc:	2200      	movs	r2, #0
    19be:	701a      	strb	r2, [r3, #0]
	udi_cdc_nb_comm_enabled = 0;
    19c0:	4b56      	ldr	r3, [pc, #344]	; (1b1c <udi_cdc_comm_enable+0x168>)
    19c2:	2200      	movs	r2, #0
    19c4:	701a      	strb	r2, [r3, #0]
	}
	port = udi_cdc_nb_comm_enabled;
#endif

	// Initialize control signal management
	udi_cdc_state[port] = CPU_TO_LE16(0);
    19c6:	1dbb      	adds	r3, r7, #6
    19c8:	781a      	ldrb	r2, [r3, #0]
    19ca:	4b55      	ldr	r3, [pc, #340]	; (1b20 <udi_cdc_comm_enable+0x16c>)
    19cc:	0052      	lsls	r2, r2, #1
    19ce:	2100      	movs	r1, #0
    19d0:	52d1      	strh	r1, [r2, r3]

	uid_cdc_state_msg[port].header.bmRequestType =
    19d2:	1dbb      	adds	r3, r7, #6
    19d4:	781a      	ldrb	r2, [r3, #0]
    19d6:	4953      	ldr	r1, [pc, #332]	; (1b24 <udi_cdc_comm_enable+0x170>)
    19d8:	0013      	movs	r3, r2
    19da:	009b      	lsls	r3, r3, #2
    19dc:	189b      	adds	r3, r3, r2
    19de:	005b      	lsls	r3, r3, #1
    19e0:	22a1      	movs	r2, #161	; 0xa1
    19e2:	545a      	strb	r2, [r3, r1]
			USB_REQ_DIR_IN | USB_REQ_TYPE_CLASS |
			USB_REQ_RECIP_INTERFACE;
	uid_cdc_state_msg[port].header.bNotification = USB_REQ_CDC_NOTIFY_SERIAL_STATE;
    19e4:	1dbb      	adds	r3, r7, #6
    19e6:	781a      	ldrb	r2, [r3, #0]
    19e8:	494e      	ldr	r1, [pc, #312]	; (1b24 <udi_cdc_comm_enable+0x170>)
    19ea:	0013      	movs	r3, r2
    19ec:	009b      	lsls	r3, r3, #2
    19ee:	189b      	adds	r3, r3, r2
    19f0:	005b      	lsls	r3, r3, #1
    19f2:	18cb      	adds	r3, r1, r3
    19f4:	3301      	adds	r3, #1
    19f6:	2220      	movs	r2, #32
    19f8:	701a      	strb	r2, [r3, #0]
	uid_cdc_state_msg[port].header.wValue = LE16(0);
    19fa:	1dbb      	adds	r3, r7, #6
    19fc:	781a      	ldrb	r2, [r3, #0]
    19fe:	4949      	ldr	r1, [pc, #292]	; (1b24 <udi_cdc_comm_enable+0x170>)
    1a00:	0013      	movs	r3, r2
    1a02:	009b      	lsls	r3, r3, #2
    1a04:	189b      	adds	r3, r3, r2
    1a06:	005b      	lsls	r3, r3, #1
    1a08:	18cb      	adds	r3, r1, r3
    1a0a:	3302      	adds	r3, #2
    1a0c:	2200      	movs	r2, #0
    1a0e:	801a      	strh	r2, [r3, #0]

	switch (port) {
    1a10:	1dbb      	adds	r3, r7, #6
    1a12:	781b      	ldrb	r3, [r3, #0]
    1a14:	2b00      	cmp	r3, #0
    1a16:	d103      	bne.n	1a20 <udi_cdc_comm_enable+0x6c>
#define UDI_CDC_PORT_TO_IFACE_COMM(index, unused) \
	case index: \
		iface_comm_num = UDI_CDC_COMM_IFACE_NUMBER_##index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_IFACE_COMM, ~)
    1a18:	1dfb      	adds	r3, r7, #7
    1a1a:	2200      	movs	r2, #0
    1a1c:	701a      	strb	r2, [r3, #0]
    1a1e:	e003      	b.n	1a28 <udi_cdc_comm_enable+0x74>
#undef UDI_CDC_PORT_TO_IFACE_COMM
	default:
		iface_comm_num = UDI_CDC_COMM_IFACE_NUMBER_0;
    1a20:	1dfb      	adds	r3, r7, #7
    1a22:	2200      	movs	r2, #0
    1a24:	701a      	strb	r2, [r3, #0]
		break;
    1a26:	46c0      	nop			; (mov r8, r8)
	}

	uid_cdc_state_msg[port].header.wIndex = LE16(iface_comm_num);
    1a28:	1dbb      	adds	r3, r7, #6
    1a2a:	781a      	ldrb	r2, [r3, #0]
    1a2c:	1dfb      	adds	r3, r7, #7
    1a2e:	781b      	ldrb	r3, [r3, #0]
    1a30:	b298      	uxth	r0, r3
    1a32:	493c      	ldr	r1, [pc, #240]	; (1b24 <udi_cdc_comm_enable+0x170>)
    1a34:	0013      	movs	r3, r2
    1a36:	009b      	lsls	r3, r3, #2
    1a38:	189b      	adds	r3, r3, r2
    1a3a:	005b      	lsls	r3, r3, #1
    1a3c:	18cb      	adds	r3, r1, r3
    1a3e:	3304      	adds	r3, #4
    1a40:	1c02      	adds	r2, r0, #0
    1a42:	801a      	strh	r2, [r3, #0]
	uid_cdc_state_msg[port].header.wLength = LE16(2);
    1a44:	1dbb      	adds	r3, r7, #6
    1a46:	781a      	ldrb	r2, [r3, #0]
    1a48:	4936      	ldr	r1, [pc, #216]	; (1b24 <udi_cdc_comm_enable+0x170>)
    1a4a:	0013      	movs	r3, r2
    1a4c:	009b      	lsls	r3, r3, #2
    1a4e:	189b      	adds	r3, r3, r2
    1a50:	005b      	lsls	r3, r3, #1
    1a52:	18cb      	adds	r3, r1, r3
    1a54:	3306      	adds	r3, #6
    1a56:	2202      	movs	r2, #2
    1a58:	801a      	strh	r2, [r3, #0]
	uid_cdc_state_msg[port].value = CPU_TO_LE16(0);
    1a5a:	1dbb      	adds	r3, r7, #6
    1a5c:	781a      	ldrb	r2, [r3, #0]
    1a5e:	4931      	ldr	r1, [pc, #196]	; (1b24 <udi_cdc_comm_enable+0x170>)
    1a60:	0013      	movs	r3, r2
    1a62:	009b      	lsls	r3, r3, #2
    1a64:	189b      	adds	r3, r3, r2
    1a66:	005b      	lsls	r3, r3, #1
    1a68:	18cb      	adds	r3, r1, r3
    1a6a:	3308      	adds	r3, #8
    1a6c:	2200      	movs	r2, #0
    1a6e:	801a      	strh	r2, [r3, #0]

	udi_cdc_line_coding[port].dwDTERate = CPU_TO_LE32(UDI_CDC_DEFAULT_RATE);
    1a70:	1dbb      	adds	r3, r7, #6
    1a72:	7819      	ldrb	r1, [r3, #0]
    1a74:	4a2c      	ldr	r2, [pc, #176]	; (1b28 <udi_cdc_comm_enable+0x174>)
    1a76:	000b      	movs	r3, r1
    1a78:	00db      	lsls	r3, r3, #3
    1a7a:	1a5b      	subs	r3, r3, r1
    1a7c:	5c99      	ldrb	r1, [r3, r2]
    1a7e:	2000      	movs	r0, #0
    1a80:	4001      	ands	r1, r0
    1a82:	5499      	strb	r1, [r3, r2]
    1a84:	18d1      	adds	r1, r2, r3
    1a86:	7848      	ldrb	r0, [r1, #1]
    1a88:	2400      	movs	r4, #0
    1a8a:	4020      	ands	r0, r4
    1a8c:	1c04      	adds	r4, r0, #0
    1a8e:	203e      	movs	r0, #62	; 0x3e
    1a90:	4240      	negs	r0, r0
    1a92:	4320      	orrs	r0, r4
    1a94:	7048      	strb	r0, [r1, #1]
    1a96:	18d1      	adds	r1, r2, r3
    1a98:	7888      	ldrb	r0, [r1, #2]
    1a9a:	2400      	movs	r4, #0
    1a9c:	4020      	ands	r0, r4
    1a9e:	1c04      	adds	r4, r0, #0
    1aa0:	2001      	movs	r0, #1
    1aa2:	4320      	orrs	r0, r4
    1aa4:	7088      	strb	r0, [r1, #2]
    1aa6:	18d3      	adds	r3, r2, r3
    1aa8:	78da      	ldrb	r2, [r3, #3]
    1aaa:	2100      	movs	r1, #0
    1aac:	400a      	ands	r2, r1
    1aae:	70da      	strb	r2, [r3, #3]
	udi_cdc_line_coding[port].bCharFormat = UDI_CDC_DEFAULT_STOPBITS;
    1ab0:	1dbb      	adds	r3, r7, #6
    1ab2:	781a      	ldrb	r2, [r3, #0]
    1ab4:	491c      	ldr	r1, [pc, #112]	; (1b28 <udi_cdc_comm_enable+0x174>)
    1ab6:	0013      	movs	r3, r2
    1ab8:	00db      	lsls	r3, r3, #3
    1aba:	1a9b      	subs	r3, r3, r2
    1abc:	18cb      	adds	r3, r1, r3
    1abe:	3304      	adds	r3, #4
    1ac0:	2200      	movs	r2, #0
    1ac2:	701a      	strb	r2, [r3, #0]
	udi_cdc_line_coding[port].bParityType = UDI_CDC_DEFAULT_PARITY;
    1ac4:	1dbb      	adds	r3, r7, #6
    1ac6:	781a      	ldrb	r2, [r3, #0]
    1ac8:	4917      	ldr	r1, [pc, #92]	; (1b28 <udi_cdc_comm_enable+0x174>)
    1aca:	0013      	movs	r3, r2
    1acc:	00db      	lsls	r3, r3, #3
    1ace:	1a9b      	subs	r3, r3, r2
    1ad0:	18cb      	adds	r3, r1, r3
    1ad2:	3305      	adds	r3, #5
    1ad4:	2200      	movs	r2, #0
    1ad6:	701a      	strb	r2, [r3, #0]
	udi_cdc_line_coding[port].bDataBits = UDI_CDC_DEFAULT_DATABITS;
    1ad8:	1dbb      	adds	r3, r7, #6
    1ada:	781a      	ldrb	r2, [r3, #0]
    1adc:	4912      	ldr	r1, [pc, #72]	; (1b28 <udi_cdc_comm_enable+0x174>)
    1ade:	0013      	movs	r3, r2
    1ae0:	00db      	lsls	r3, r3, #3
    1ae2:	1a9b      	subs	r3, r3, r2
    1ae4:	18cb      	adds	r3, r1, r3
    1ae6:	3306      	adds	r3, #6
    1ae8:	2208      	movs	r2, #8
    1aea:	701a      	strb	r2, [r3, #0]
	// Call application callback
	// to initialize memories or indicate that interface is enabled
	UDI_CDC_SET_CODING_EXT(port,(&udi_cdc_line_coding[port]));
	if (!UDI_CDC_ENABLE_EXT(port)) {
    1aec:	4b0f      	ldr	r3, [pc, #60]	; (1b2c <udi_cdc_comm_enable+0x178>)
    1aee:	4798      	blx	r3
    1af0:	0003      	movs	r3, r0
    1af2:	001a      	movs	r2, r3
    1af4:	2301      	movs	r3, #1
    1af6:	4053      	eors	r3, r2
    1af8:	b2db      	uxtb	r3, r3
    1afa:	2b00      	cmp	r3, #0
    1afc:	d001      	beq.n	1b02 <udi_cdc_comm_enable+0x14e>
		return false;
    1afe:	2300      	movs	r3, #0
    1b00:	e007      	b.n	1b12 <udi_cdc_comm_enable+0x15e>
	}
	udi_cdc_nb_comm_enabled++;
    1b02:	4b06      	ldr	r3, [pc, #24]	; (1b1c <udi_cdc_comm_enable+0x168>)
    1b04:	781b      	ldrb	r3, [r3, #0]
    1b06:	b2db      	uxtb	r3, r3
    1b08:	3301      	adds	r3, #1
    1b0a:	b2da      	uxtb	r2, r3
    1b0c:	4b03      	ldr	r3, [pc, #12]	; (1b1c <udi_cdc_comm_enable+0x168>)
    1b0e:	701a      	strb	r2, [r3, #0]
	return true;
    1b10:	2301      	movs	r3, #1
}
    1b12:	0018      	movs	r0, r3
    1b14:	46bd      	mov	sp, r7
    1b16:	b003      	add	sp, #12
    1b18:	bd90      	pop	{r4, r7, pc}
    1b1a:	46c0      	nop			; (mov r8, r8)
    1b1c:	2000021a 	.word	0x2000021a
    1b20:	2000020c 	.word	0x2000020c
    1b24:	20000210 	.word	0x20000210
    1b28:	20000204 	.word	0x20000204
    1b2c:	00003405 	.word	0x00003405

00001b30 <udi_cdc_data_enable>:

bool udi_cdc_data_enable(void)
{
    1b30:	b580      	push	{r7, lr}
    1b32:	b082      	sub	sp, #8
    1b34:	af00      	add	r7, sp, #0
	uint8_t port;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
    1b36:	1dfb      	adds	r3, r7, #7
    1b38:	2200      	movs	r2, #0
    1b3a:	701a      	strb	r2, [r3, #0]
	udi_cdc_nb_data_enabled = 0;
    1b3c:	4b35      	ldr	r3, [pc, #212]	; (1c14 <udi_cdc_data_enable+0xe4>)
    1b3e:	2200      	movs	r2, #0
    1b40:	701a      	strb	r2, [r3, #0]
	}
	port = udi_cdc_nb_data_enabled;
#endif

	// Initialize TX management
	udi_cdc_tx_trans_ongoing[port] = false;
    1b42:	1dfb      	adds	r3, r7, #7
    1b44:	781b      	ldrb	r3, [r3, #0]
    1b46:	4a34      	ldr	r2, [pc, #208]	; (1c18 <udi_cdc_data_enable+0xe8>)
    1b48:	2100      	movs	r1, #0
    1b4a:	54d1      	strb	r1, [r2, r3]
	udi_cdc_tx_both_buf_to_send[port] = false;
    1b4c:	1dfb      	adds	r3, r7, #7
    1b4e:	781b      	ldrb	r3, [r3, #0]
    1b50:	4a32      	ldr	r2, [pc, #200]	; (1c1c <udi_cdc_data_enable+0xec>)
    1b52:	2100      	movs	r1, #0
    1b54:	54d1      	strb	r1, [r2, r3]
	udi_cdc_tx_buf_sel[port] = 0;
    1b56:	1dfb      	adds	r3, r7, #7
    1b58:	781b      	ldrb	r3, [r3, #0]
    1b5a:	4a31      	ldr	r2, [pc, #196]	; (1c20 <udi_cdc_data_enable+0xf0>)
    1b5c:	2100      	movs	r1, #0
    1b5e:	54d1      	strb	r1, [r2, r3]
	udi_cdc_tx_buf_nb[port][0] = 0;
    1b60:	1dfb      	adds	r3, r7, #7
    1b62:	781a      	ldrb	r2, [r3, #0]
    1b64:	4b2f      	ldr	r3, [pc, #188]	; (1c24 <udi_cdc_data_enable+0xf4>)
    1b66:	0092      	lsls	r2, r2, #2
    1b68:	2100      	movs	r1, #0
    1b6a:	52d1      	strh	r1, [r2, r3]
	udi_cdc_tx_buf_nb[port][1] = 0;
    1b6c:	1dfb      	adds	r3, r7, #7
    1b6e:	781b      	ldrb	r3, [r3, #0]
    1b70:	4a2c      	ldr	r2, [pc, #176]	; (1c24 <udi_cdc_data_enable+0xf4>)
    1b72:	009b      	lsls	r3, r3, #2
    1b74:	18d3      	adds	r3, r2, r3
    1b76:	3302      	adds	r3, #2
    1b78:	2200      	movs	r2, #0
    1b7a:	801a      	strh	r2, [r3, #0]
	udi_cdc_tx_sof_num[port] = 0;
    1b7c:	1dfb      	adds	r3, r7, #7
    1b7e:	781a      	ldrb	r2, [r3, #0]
    1b80:	4b29      	ldr	r3, [pc, #164]	; (1c28 <udi_cdc_data_enable+0xf8>)
    1b82:	0052      	lsls	r2, r2, #1
    1b84:	2100      	movs	r1, #0
    1b86:	52d1      	strh	r1, [r2, r3]
	udi_cdc_tx_send(port);
    1b88:	1dfb      	adds	r3, r7, #7
    1b8a:	781b      	ldrb	r3, [r3, #0]
    1b8c:	0018      	movs	r0, r3
    1b8e:	4b27      	ldr	r3, [pc, #156]	; (1c2c <udi_cdc_data_enable+0xfc>)
    1b90:	4798      	blx	r3

	// Initialize RX management
	udi_cdc_rx_trans_ongoing[port] = false;
    1b92:	1dfb      	adds	r3, r7, #7
    1b94:	781b      	ldrb	r3, [r3, #0]
    1b96:	4a26      	ldr	r2, [pc, #152]	; (1c30 <udi_cdc_data_enable+0x100>)
    1b98:	2100      	movs	r1, #0
    1b9a:	54d1      	strb	r1, [r2, r3]
	udi_cdc_rx_buf_sel[port] = 0;
    1b9c:	1dfb      	adds	r3, r7, #7
    1b9e:	781b      	ldrb	r3, [r3, #0]
    1ba0:	4a24      	ldr	r2, [pc, #144]	; (1c34 <udi_cdc_data_enable+0x104>)
    1ba2:	2100      	movs	r1, #0
    1ba4:	54d1      	strb	r1, [r2, r3]
	udi_cdc_rx_buf_nb[port][0] = 0;
    1ba6:	1dfb      	adds	r3, r7, #7
    1ba8:	781a      	ldrb	r2, [r3, #0]
    1baa:	4b23      	ldr	r3, [pc, #140]	; (1c38 <udi_cdc_data_enable+0x108>)
    1bac:	0092      	lsls	r2, r2, #2
    1bae:	2100      	movs	r1, #0
    1bb0:	52d1      	strh	r1, [r2, r3]
	udi_cdc_rx_buf_nb[port][1] = 0;
    1bb2:	1dfb      	adds	r3, r7, #7
    1bb4:	781b      	ldrb	r3, [r3, #0]
    1bb6:	4a20      	ldr	r2, [pc, #128]	; (1c38 <udi_cdc_data_enable+0x108>)
    1bb8:	009b      	lsls	r3, r3, #2
    1bba:	18d3      	adds	r3, r2, r3
    1bbc:	3302      	adds	r3, #2
    1bbe:	2200      	movs	r2, #0
    1bc0:	801a      	strh	r2, [r3, #0]
	udi_cdc_rx_pos[port] = 0;
    1bc2:	1dfb      	adds	r3, r7, #7
    1bc4:	781a      	ldrb	r2, [r3, #0]
    1bc6:	4b1d      	ldr	r3, [pc, #116]	; (1c3c <udi_cdc_data_enable+0x10c>)
    1bc8:	0052      	lsls	r2, r2, #1
    1bca:	2100      	movs	r1, #0
    1bcc:	52d1      	strh	r1, [r2, r3]
	if (!udi_cdc_rx_start(port)) {
    1bce:	1dfb      	adds	r3, r7, #7
    1bd0:	781b      	ldrb	r3, [r3, #0]
    1bd2:	0018      	movs	r0, r3
    1bd4:	4b1a      	ldr	r3, [pc, #104]	; (1c40 <udi_cdc_data_enable+0x110>)
    1bd6:	4798      	blx	r3
    1bd8:	0003      	movs	r3, r0
    1bda:	001a      	movs	r2, r3
    1bdc:	2301      	movs	r3, #1
    1bde:	4053      	eors	r3, r2
    1be0:	b2db      	uxtb	r3, r3
    1be2:	2b00      	cmp	r3, #0
    1be4:	d001      	beq.n	1bea <udi_cdc_data_enable+0xba>
		return false;
    1be6:	2300      	movs	r3, #0
    1be8:	e00f      	b.n	1c0a <udi_cdc_data_enable+0xda>
	}
	udi_cdc_nb_data_enabled++;
    1bea:	4b0a      	ldr	r3, [pc, #40]	; (1c14 <udi_cdc_data_enable+0xe4>)
    1bec:	781b      	ldrb	r3, [r3, #0]
    1bee:	b2db      	uxtb	r3, r3
    1bf0:	3301      	adds	r3, #1
    1bf2:	b2da      	uxtb	r2, r3
    1bf4:	4b07      	ldr	r3, [pc, #28]	; (1c14 <udi_cdc_data_enable+0xe4>)
    1bf6:	701a      	strb	r2, [r3, #0]
	if (udi_cdc_nb_data_enabled == UDI_CDC_PORT_NB) {
    1bf8:	4b06      	ldr	r3, [pc, #24]	; (1c14 <udi_cdc_data_enable+0xe4>)
    1bfa:	781b      	ldrb	r3, [r3, #0]
    1bfc:	b2db      	uxtb	r3, r3
    1bfe:	2b01      	cmp	r3, #1
    1c00:	d102      	bne.n	1c08 <udi_cdc_data_enable+0xd8>
		udi_cdc_data_running = true;
    1c02:	4b10      	ldr	r3, [pc, #64]	; (1c44 <udi_cdc_data_enable+0x114>)
    1c04:	2201      	movs	r2, #1
    1c06:	701a      	strb	r2, [r3, #0]
	}
	return true;
    1c08:	2301      	movs	r3, #1
}
    1c0a:	0018      	movs	r0, r3
    1c0c:	46bd      	mov	sp, r7
    1c0e:	b002      	add	sp, #8
    1c10:	bd80      	pop	{r7, pc}
    1c12:	46c0      	nop			; (mov r8, r8)
    1c14:	2000021b 	.word	0x2000021b
    1c18:	2000073c 	.word	0x2000073c
    1c1c:	20000740 	.word	0x20000740
    1c20:	20000734 	.word	0x20000734
    1c24:	20000730 	.word	0x20000730
    1c28:	20000738 	.word	0x20000738
    1c2c:	000020ad 	.word	0x000020ad
    1c30:	200004ac 	.word	0x200004ac
    1c34:	200004a4 	.word	0x200004a4
    1c38:	200004a0 	.word	0x200004a0
    1c3c:	200004a8 	.word	0x200004a8
    1c40:	00001df1 	.word	0x00001df1
    1c44:	2000021c 	.word	0x2000021c

00001c48 <udi_cdc_comm_disable>:

void udi_cdc_comm_disable(void)
{
    1c48:	b580      	push	{r7, lr}
    1c4a:	af00      	add	r7, sp, #0
	Assert(udi_cdc_nb_comm_enabled != 0);
	udi_cdc_nb_comm_enabled--;
    1c4c:	4b04      	ldr	r3, [pc, #16]	; (1c60 <udi_cdc_comm_disable+0x18>)
    1c4e:	781b      	ldrb	r3, [r3, #0]
    1c50:	b2db      	uxtb	r3, r3
    1c52:	3b01      	subs	r3, #1
    1c54:	b2da      	uxtb	r2, r3
    1c56:	4b02      	ldr	r3, [pc, #8]	; (1c60 <udi_cdc_comm_disable+0x18>)
    1c58:	701a      	strb	r2, [r3, #0]
}
    1c5a:	46c0      	nop			; (mov r8, r8)
    1c5c:	46bd      	mov	sp, r7
    1c5e:	bd80      	pop	{r7, pc}
    1c60:	2000021a 	.word	0x2000021a

00001c64 <udi_cdc_data_disable>:

void udi_cdc_data_disable(void)
{
    1c64:	b580      	push	{r7, lr}
    1c66:	b082      	sub	sp, #8
    1c68:	af00      	add	r7, sp, #0
	uint8_t port;

	Assert(udi_cdc_nb_data_enabled != 0);
	udi_cdc_nb_data_enabled--;
    1c6a:	4b0a      	ldr	r3, [pc, #40]	; (1c94 <udi_cdc_data_disable+0x30>)
    1c6c:	781b      	ldrb	r3, [r3, #0]
    1c6e:	b2db      	uxtb	r3, r3
    1c70:	3b01      	subs	r3, #1
    1c72:	b2da      	uxtb	r2, r3
    1c74:	4b07      	ldr	r3, [pc, #28]	; (1c94 <udi_cdc_data_disable+0x30>)
    1c76:	701a      	strb	r2, [r3, #0]
	port = udi_cdc_nb_data_enabled;
    1c78:	1dfb      	adds	r3, r7, #7
    1c7a:	4a06      	ldr	r2, [pc, #24]	; (1c94 <udi_cdc_data_disable+0x30>)
    1c7c:	7812      	ldrb	r2, [r2, #0]
    1c7e:	701a      	strb	r2, [r3, #0]
	UDI_CDC_DISABLE_EXT(port);
    1c80:	4b05      	ldr	r3, [pc, #20]	; (1c98 <udi_cdc_data_disable+0x34>)
    1c82:	4798      	blx	r3
	udi_cdc_data_running = false;
    1c84:	4b05      	ldr	r3, [pc, #20]	; (1c9c <udi_cdc_data_disable+0x38>)
    1c86:	2200      	movs	r2, #0
    1c88:	701a      	strb	r2, [r3, #0]
}
    1c8a:	46c0      	nop			; (mov r8, r8)
    1c8c:	46bd      	mov	sp, r7
    1c8e:	b002      	add	sp, #8
    1c90:	bd80      	pop	{r7, pc}
    1c92:	46c0      	nop			; (mov r8, r8)
    1c94:	2000021b 	.word	0x2000021b
    1c98:	0000341d 	.word	0x0000341d
    1c9c:	2000021c 	.word	0x2000021c

00001ca0 <udi_cdc_comm_setup>:

bool udi_cdc_comm_setup(void)
{
    1ca0:	b590      	push	{r4, r7, lr}
    1ca2:	b083      	sub	sp, #12
    1ca4:	af00      	add	r7, sp, #0
	uint8_t port = udi_cdc_setup_to_port();
    1ca6:	1dfc      	adds	r4, r7, #7
    1ca8:	4b2c      	ldr	r3, [pc, #176]	; (1d5c <udi_cdc_comm_setup+0xbc>)
    1caa:	4798      	blx	r3
    1cac:	0003      	movs	r3, r0
    1cae:	7023      	strb	r3, [r4, #0]

	if (Udd_setup_is_in()) {
    1cb0:	4b2b      	ldr	r3, [pc, #172]	; (1d60 <udi_cdc_comm_setup+0xc0>)
    1cb2:	781b      	ldrb	r3, [r3, #0]
    1cb4:	b25b      	sxtb	r3, r3
    1cb6:	2b00      	cmp	r3, #0
    1cb8:	da1e      	bge.n	1cf8 <udi_cdc_comm_setup+0x58>
		// GET Interface Requests
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
    1cba:	4b29      	ldr	r3, [pc, #164]	; (1d60 <udi_cdc_comm_setup+0xc0>)
    1cbc:	781b      	ldrb	r3, [r3, #0]
    1cbe:	001a      	movs	r2, r3
    1cc0:	2360      	movs	r3, #96	; 0x60
    1cc2:	4013      	ands	r3, r2
    1cc4:	2b20      	cmp	r3, #32
    1cc6:	d117      	bne.n	1cf8 <udi_cdc_comm_setup+0x58>
			// Requests Class Interface Get
			switch (udd_g_ctrlreq.req.bRequest) {
    1cc8:	4b25      	ldr	r3, [pc, #148]	; (1d60 <udi_cdc_comm_setup+0xc0>)
    1cca:	785b      	ldrb	r3, [r3, #1]
    1ccc:	2b21      	cmp	r3, #33	; 0x21
    1cce:	d113      	bne.n	1cf8 <udi_cdc_comm_setup+0x58>
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
    1cd0:	4b23      	ldr	r3, [pc, #140]	; (1d60 <udi_cdc_comm_setup+0xc0>)
    1cd2:	88db      	ldrh	r3, [r3, #6]
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
			// Requests Class Interface Get
			switch (udd_g_ctrlreq.req.bRequest) {
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
    1cd4:	2b07      	cmp	r3, #7
    1cd6:	d001      	beq.n	1cdc <udi_cdc_comm_setup+0x3c>
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
    1cd8:	2300      	movs	r3, #0
    1cda:	e03a      	b.n	1d52 <udi_cdc_comm_setup+0xb2>
				udd_g_ctrlreq.payload =
						(uint8_t *) &
						udi_cdc_line_coding[port];
    1cdc:	1dfb      	adds	r3, r7, #7
    1cde:	781a      	ldrb	r2, [r3, #0]
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
				udd_g_ctrlreq.payload =
						(uint8_t *) &
    1ce0:	0013      	movs	r3, r2
    1ce2:	00db      	lsls	r3, r3, #3
    1ce4:	1a9b      	subs	r3, r3, r2
    1ce6:	4a1f      	ldr	r2, [pc, #124]	; (1d64 <udi_cdc_comm_setup+0xc4>)
    1ce8:	189a      	adds	r2, r3, r2
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
				udd_g_ctrlreq.payload =
    1cea:	4b1d      	ldr	r3, [pc, #116]	; (1d60 <udi_cdc_comm_setup+0xc0>)
    1cec:	609a      	str	r2, [r3, #8]
						(uint8_t *) &
						udi_cdc_line_coding[port];
				udd_g_ctrlreq.payload_size =
    1cee:	4b1c      	ldr	r3, [pc, #112]	; (1d60 <udi_cdc_comm_setup+0xc0>)
    1cf0:	2207      	movs	r2, #7
    1cf2:	819a      	strh	r2, [r3, #12]
						sizeof(usb_cdc_line_coding_t);
				return true;
    1cf4:	2301      	movs	r3, #1
    1cf6:	e02c      	b.n	1d52 <udi_cdc_comm_setup+0xb2>
			}
		}
	}
	if (Udd_setup_is_out()) {
    1cf8:	4b19      	ldr	r3, [pc, #100]	; (1d60 <udi_cdc_comm_setup+0xc0>)
    1cfa:	781b      	ldrb	r3, [r3, #0]
    1cfc:	b25b      	sxtb	r3, r3
    1cfe:	2b00      	cmp	r3, #0
    1d00:	db26      	blt.n	1d50 <udi_cdc_comm_setup+0xb0>
		// SET Interface Requests
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
    1d02:	4b17      	ldr	r3, [pc, #92]	; (1d60 <udi_cdc_comm_setup+0xc0>)
    1d04:	781b      	ldrb	r3, [r3, #0]
    1d06:	001a      	movs	r2, r3
    1d08:	2360      	movs	r3, #96	; 0x60
    1d0a:	4013      	ands	r3, r2
    1d0c:	2b20      	cmp	r3, #32
    1d0e:	d11f      	bne.n	1d50 <udi_cdc_comm_setup+0xb0>
			// Requests Class Interface Set
			switch (udd_g_ctrlreq.req.bRequest) {
    1d10:	4b13      	ldr	r3, [pc, #76]	; (1d60 <udi_cdc_comm_setup+0xc0>)
    1d12:	785b      	ldrb	r3, [r3, #1]
    1d14:	2b20      	cmp	r3, #32
    1d16:	d002      	beq.n	1d1e <udi_cdc_comm_setup+0x7e>
    1d18:	2b22      	cmp	r3, #34	; 0x22
    1d1a:	d017      	beq.n	1d4c <udi_cdc_comm_setup+0xac>
    1d1c:	e018      	b.n	1d50 <udi_cdc_comm_setup+0xb0>
			case USB_REQ_CDC_SET_LINE_CODING:
				// Change configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
    1d1e:	4b10      	ldr	r3, [pc, #64]	; (1d60 <udi_cdc_comm_setup+0xc0>)
    1d20:	88db      	ldrh	r3, [r3, #6]
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
			// Requests Class Interface Set
			switch (udd_g_ctrlreq.req.bRequest) {
			case USB_REQ_CDC_SET_LINE_CODING:
				// Change configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
    1d22:	2b07      	cmp	r3, #7
    1d24:	d001      	beq.n	1d2a <udi_cdc_comm_setup+0x8a>
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
    1d26:	2300      	movs	r3, #0
    1d28:	e013      	b.n	1d52 <udi_cdc_comm_setup+0xb2>
				udd_g_ctrlreq.callback =
    1d2a:	4b0d      	ldr	r3, [pc, #52]	; (1d60 <udi_cdc_comm_setup+0xc0>)
    1d2c:	4a0e      	ldr	r2, [pc, #56]	; (1d68 <udi_cdc_comm_setup+0xc8>)
    1d2e:	611a      	str	r2, [r3, #16]
						udi_cdc_line_coding_received;
				udd_g_ctrlreq.payload =
						(uint8_t *) &
						udi_cdc_line_coding[port];
    1d30:	1dfb      	adds	r3, r7, #7
    1d32:	781a      	ldrb	r2, [r3, #0]
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
				udd_g_ctrlreq.callback =
						udi_cdc_line_coding_received;
				udd_g_ctrlreq.payload =
						(uint8_t *) &
    1d34:	0013      	movs	r3, r2
    1d36:	00db      	lsls	r3, r3, #3
    1d38:	1a9b      	subs	r3, r3, r2
    1d3a:	4a0a      	ldr	r2, [pc, #40]	; (1d64 <udi_cdc_comm_setup+0xc4>)
    1d3c:	189a      	adds	r2, r3, r2
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
				udd_g_ctrlreq.callback =
						udi_cdc_line_coding_received;
				udd_g_ctrlreq.payload =
    1d3e:	4b08      	ldr	r3, [pc, #32]	; (1d60 <udi_cdc_comm_setup+0xc0>)
    1d40:	609a      	str	r2, [r3, #8]
						(uint8_t *) &
						udi_cdc_line_coding[port];
				udd_g_ctrlreq.payload_size =
    1d42:	4b07      	ldr	r3, [pc, #28]	; (1d60 <udi_cdc_comm_setup+0xc0>)
    1d44:	2207      	movs	r2, #7
    1d46:	819a      	strh	r2, [r3, #12]
						sizeof(usb_cdc_line_coding_t);
				return true;
    1d48:	2301      	movs	r3, #1
    1d4a:	e002      	b.n	1d52 <udi_cdc_comm_setup+0xb2>
						(udd_g_ctrlreq.req.wValue
						 & CDC_CTRL_SIGNAL_DTE_PRESENT)));
				UDI_CDC_SET_RTS_EXT(port, (0 !=
						(udd_g_ctrlreq.req.wValue
						 & CDC_CTRL_SIGNAL_ACTIVATE_CARRIER)));
				return true;
    1d4c:	2301      	movs	r3, #1
    1d4e:	e000      	b.n	1d52 <udi_cdc_comm_setup+0xb2>
			}
		}
	}
	return false;  // request Not supported
    1d50:	2300      	movs	r3, #0
}
    1d52:	0018      	movs	r0, r3
    1d54:	46bd      	mov	sp, r7
    1d56:	b003      	add	sp, #12
    1d58:	bd90      	pop	{r4, r7, pc}
    1d5a:	46c0      	nop			; (mov r8, r8)
    1d5c:	00001da1 	.word	0x00001da1
    1d60:	2000147c 	.word	0x2000147c
    1d64:	20000204 	.word	0x20000204
    1d68:	00001dd5 	.word	0x00001dd5

00001d6c <udi_cdc_data_setup>:

bool udi_cdc_data_setup(void)
{
    1d6c:	b580      	push	{r7, lr}
    1d6e:	af00      	add	r7, sp, #0
	return false;  // request Not supported
    1d70:	2300      	movs	r3, #0
}
    1d72:	0018      	movs	r0, r3
    1d74:	46bd      	mov	sp, r7
    1d76:	bd80      	pop	{r7, pc}

00001d78 <udi_cdc_getsetting>:

uint8_t udi_cdc_getsetting(void)
{
    1d78:	b580      	push	{r7, lr}
    1d7a:	af00      	add	r7, sp, #0
	return 0;      // CDC don't have multiple alternate setting
    1d7c:	2300      	movs	r3, #0
}
    1d7e:	0018      	movs	r0, r3
    1d80:	46bd      	mov	sp, r7
    1d82:	bd80      	pop	{r7, pc}

00001d84 <udi_cdc_data_sof_notify>:

void udi_cdc_data_sof_notify(void)
{
    1d84:	b580      	push	{r7, lr}
    1d86:	af00      	add	r7, sp, #0
	static uint8_t port_notify = 0;

	// A call of udi_cdc_data_sof_notify() is done for each port
	udi_cdc_tx_send(port_notify);
    1d88:	4b03      	ldr	r3, [pc, #12]	; (1d98 <udi_cdc_data_sof_notify+0x14>)
    1d8a:	781b      	ldrb	r3, [r3, #0]
    1d8c:	0018      	movs	r0, r3
    1d8e:	4b03      	ldr	r3, [pc, #12]	; (1d9c <udi_cdc_data_sof_notify+0x18>)
    1d90:	4798      	blx	r3
	port_notify++;
	if (port_notify >= UDI_CDC_PORT_NB) {
		port_notify = 0;
	}
#endif
}
    1d92:	46c0      	nop			; (mov r8, r8)
    1d94:	46bd      	mov	sp, r7
    1d96:	bd80      	pop	{r7, pc}
    1d98:	20000741 	.word	0x20000741
    1d9c:	000020ad 	.word	0x000020ad

00001da0 <udi_cdc_setup_to_port>:

//-------------------------------------------------
//------- Internal routines to control serial line

static uint8_t udi_cdc_setup_to_port(void)
{
    1da0:	b580      	push	{r7, lr}
    1da2:	b082      	sub	sp, #8
    1da4:	af00      	add	r7, sp, #0
	uint8_t port;

	switch (udd_g_ctrlreq.req.wIndex & 0xFF) {
    1da6:	4b0a      	ldr	r3, [pc, #40]	; (1dd0 <udi_cdc_setup_to_port+0x30>)
    1da8:	889b      	ldrh	r3, [r3, #4]
    1daa:	001a      	movs	r2, r3
    1dac:	23ff      	movs	r3, #255	; 0xff
    1dae:	4013      	ands	r3, r2
    1db0:	d103      	bne.n	1dba <udi_cdc_setup_to_port+0x1a>
#define UDI_CDC_IFACE_COMM_TO_PORT(iface, unused) \
	case UDI_CDC_COMM_IFACE_NUMBER_##iface: \
		port = iface; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_IFACE_COMM_TO_PORT, ~)
    1db2:	1dfb      	adds	r3, r7, #7
    1db4:	2200      	movs	r2, #0
    1db6:	701a      	strb	r2, [r3, #0]
    1db8:	e003      	b.n	1dc2 <udi_cdc_setup_to_port+0x22>
#undef UDI_CDC_IFACE_COMM_TO_PORT
	default:
		port = 0;
    1dba:	1dfb      	adds	r3, r7, #7
    1dbc:	2200      	movs	r2, #0
    1dbe:	701a      	strb	r2, [r3, #0]
		break;
    1dc0:	46c0      	nop			; (mov r8, r8)
	}
	return port;
    1dc2:	1dfb      	adds	r3, r7, #7
    1dc4:	781b      	ldrb	r3, [r3, #0]
}
    1dc6:	0018      	movs	r0, r3
    1dc8:	46bd      	mov	sp, r7
    1dca:	b002      	add	sp, #8
    1dcc:	bd80      	pop	{r7, pc}
    1dce:	46c0      	nop			; (mov r8, r8)
    1dd0:	2000147c 	.word	0x2000147c

00001dd4 <udi_cdc_line_coding_received>:

static void udi_cdc_line_coding_received(void)
{
    1dd4:	b590      	push	{r4, r7, lr}
    1dd6:	b083      	sub	sp, #12
    1dd8:	af00      	add	r7, sp, #0
	uint8_t port = udi_cdc_setup_to_port();
    1dda:	1dfc      	adds	r4, r7, #7
    1ddc:	4b03      	ldr	r3, [pc, #12]	; (1dec <udi_cdc_line_coding_received+0x18>)
    1dde:	4798      	blx	r3
    1de0:	0003      	movs	r3, r0
    1de2:	7023      	strb	r3, [r4, #0]
	UNUSED(port);

	UDI_CDC_SET_CODING_EXT(port, (&udi_cdc_line_coding[port]));
}
    1de4:	46c0      	nop			; (mov r8, r8)
    1de6:	46bd      	mov	sp, r7
    1de8:	b003      	add	sp, #12
    1dea:	bd90      	pop	{r4, r7, pc}
    1dec:	00001da1 	.word	0x00001da1

00001df0 <udi_cdc_rx_start>:
//-------------------------------------------------
//------- Internal routines to process data transfer


static bool udi_cdc_rx_start(uint8_t port)
{
    1df0:	b590      	push	{r4, r7, lr}
    1df2:	b089      	sub	sp, #36	; 0x24
    1df4:	af02      	add	r7, sp, #8
    1df6:	0002      	movs	r2, r0
    1df8:	1dfb      	adds	r3, r7, #7
    1dfa:	701a      	strb	r2, [r3, #0]
	irqflags_t flags;
	uint8_t buf_sel_trans;
	udd_ep_id_t ep;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
    1dfc:	1dfb      	adds	r3, r7, #7
    1dfe:	2200      	movs	r2, #0
    1e00:	701a      	strb	r2, [r3, #0]
#endif

	flags = cpu_irq_save();
    1e02:	4b3c      	ldr	r3, [pc, #240]	; (1ef4 <udi_cdc_rx_start+0x104>)
    1e04:	4798      	blx	r3
    1e06:	0003      	movs	r3, r0
    1e08:	613b      	str	r3, [r7, #16]
	buf_sel_trans = udi_cdc_rx_buf_sel[port];
    1e0a:	1dfb      	adds	r3, r7, #7
    1e0c:	781a      	ldrb	r2, [r3, #0]
    1e0e:	230f      	movs	r3, #15
    1e10:	18fb      	adds	r3, r7, r3
    1e12:	4939      	ldr	r1, [pc, #228]	; (1ef8 <udi_cdc_rx_start+0x108>)
    1e14:	5c8a      	ldrb	r2, [r1, r2]
    1e16:	701a      	strb	r2, [r3, #0]
	if (udi_cdc_rx_trans_ongoing[port] ||
    1e18:	1dfb      	adds	r3, r7, #7
    1e1a:	781b      	ldrb	r3, [r3, #0]
    1e1c:	4a37      	ldr	r2, [pc, #220]	; (1efc <udi_cdc_rx_start+0x10c>)
    1e1e:	5cd3      	ldrb	r3, [r2, r3]
    1e20:	b2db      	uxtb	r3, r3
    1e22:	2b00      	cmp	r3, #0
    1e24:	d112      	bne.n	1e4c <udi_cdc_rx_start+0x5c>
		(udi_cdc_rx_pos[port] < udi_cdc_rx_buf_nb[port][buf_sel_trans])) {
    1e26:	1dfb      	adds	r3, r7, #7
    1e28:	781a      	ldrb	r2, [r3, #0]
    1e2a:	4b35      	ldr	r3, [pc, #212]	; (1f00 <udi_cdc_rx_start+0x110>)
    1e2c:	0052      	lsls	r2, r2, #1
    1e2e:	5ad3      	ldrh	r3, [r2, r3]
    1e30:	b29a      	uxth	r2, r3
    1e32:	1dfb      	adds	r3, r7, #7
    1e34:	7818      	ldrb	r0, [r3, #0]
    1e36:	230f      	movs	r3, #15
    1e38:	18fb      	adds	r3, r7, r3
    1e3a:	7819      	ldrb	r1, [r3, #0]
    1e3c:	4b31      	ldr	r3, [pc, #196]	; (1f04 <udi_cdc_rx_start+0x114>)
    1e3e:	0040      	lsls	r0, r0, #1
    1e40:	1841      	adds	r1, r0, r1
    1e42:	0049      	lsls	r1, r1, #1
    1e44:	5acb      	ldrh	r3, [r1, r3]
    1e46:	b29b      	uxth	r3, r3
	port = 0;
#endif

	flags = cpu_irq_save();
	buf_sel_trans = udi_cdc_rx_buf_sel[port];
	if (udi_cdc_rx_trans_ongoing[port] ||
    1e48:	429a      	cmp	r2, r3
    1e4a:	d205      	bcs.n	1e58 <udi_cdc_rx_start+0x68>
		(udi_cdc_rx_pos[port] < udi_cdc_rx_buf_nb[port][buf_sel_trans])) {
		// Transfer already on-going or current buffer no empty
		cpu_irq_restore(flags);
    1e4c:	693b      	ldr	r3, [r7, #16]
    1e4e:	0018      	movs	r0, r3
    1e50:	4b2d      	ldr	r3, [pc, #180]	; (1f08 <udi_cdc_rx_start+0x118>)
    1e52:	4798      	blx	r3
		return false;
    1e54:	2300      	movs	r3, #0
    1e56:	e049      	b.n	1eec <udi_cdc_rx_start+0xfc>
	}

	// Change current buffer
	udi_cdc_rx_pos[port] = 0;
    1e58:	1dfb      	adds	r3, r7, #7
    1e5a:	781a      	ldrb	r2, [r3, #0]
    1e5c:	4b28      	ldr	r3, [pc, #160]	; (1f00 <udi_cdc_rx_start+0x110>)
    1e5e:	0052      	lsls	r2, r2, #1
    1e60:	2100      	movs	r1, #0
    1e62:	52d1      	strh	r1, [r2, r3]
	udi_cdc_rx_buf_sel[port] = (buf_sel_trans==0)?1:0;
    1e64:	1dfb      	adds	r3, r7, #7
    1e66:	781b      	ldrb	r3, [r3, #0]
    1e68:	220f      	movs	r2, #15
    1e6a:	18ba      	adds	r2, r7, r2
    1e6c:	7812      	ldrb	r2, [r2, #0]
    1e6e:	4251      	negs	r1, r2
    1e70:	414a      	adcs	r2, r1
    1e72:	b2d2      	uxtb	r2, r2
    1e74:	0011      	movs	r1, r2
    1e76:	4a20      	ldr	r2, [pc, #128]	; (1ef8 <udi_cdc_rx_start+0x108>)
    1e78:	54d1      	strb	r1, [r2, r3]

	// Start transfer on RX
	udi_cdc_rx_trans_ongoing[port] = true;
    1e7a:	1dfb      	adds	r3, r7, #7
    1e7c:	781b      	ldrb	r3, [r3, #0]
    1e7e:	4a1f      	ldr	r2, [pc, #124]	; (1efc <udi_cdc_rx_start+0x10c>)
    1e80:	2101      	movs	r1, #1
    1e82:	54d1      	strb	r1, [r2, r3]
	cpu_irq_restore(flags);
    1e84:	693b      	ldr	r3, [r7, #16]
    1e86:	0018      	movs	r0, r3
    1e88:	4b1f      	ldr	r3, [pc, #124]	; (1f08 <udi_cdc_rx_start+0x118>)
    1e8a:	4798      	blx	r3

	if (udi_cdc_multi_is_rx_ready(port)) {
    1e8c:	1dfb      	adds	r3, r7, #7
    1e8e:	781b      	ldrb	r3, [r3, #0]
    1e90:	0018      	movs	r0, r3
    1e92:	4b1e      	ldr	r3, [pc, #120]	; (1f0c <udi_cdc_rx_start+0x11c>)
    1e94:	4798      	blx	r3
		UDI_CDC_RX_NOTIFY(port);
	}
	// Send the buffer with enable of short packet
	switch (port) {
    1e96:	1dfb      	adds	r3, r7, #7
    1e98:	781b      	ldrb	r3, [r3, #0]
    1e9a:	2b00      	cmp	r3, #0
    1e9c:	d104      	bne.n	1ea8 <udi_cdc_rx_start+0xb8>
#define UDI_CDC_PORT_TO_DATA_EP_OUT(index, unused) \
	case index: \
		ep = UDI_CDC_DATA_EP_OUT_##index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_DATA_EP_OUT, ~)
    1e9e:	2317      	movs	r3, #23
    1ea0:	18fb      	adds	r3, r7, r3
    1ea2:	2202      	movs	r2, #2
    1ea4:	701a      	strb	r2, [r3, #0]
    1ea6:	e004      	b.n	1eb2 <udi_cdc_rx_start+0xc2>
#undef UDI_CDC_PORT_TO_DATA_EP_OUT
	default:
		ep = UDI_CDC_DATA_EP_OUT_0;
    1ea8:	2317      	movs	r3, #23
    1eaa:	18fb      	adds	r3, r7, r3
    1eac:	2202      	movs	r2, #2
    1eae:	701a      	strb	r2, [r3, #0]
		break;
    1eb0:	46c0      	nop			; (mov r8, r8)
	}
	return udd_ep_run(ep,
			true,
			udi_cdc_rx_buf[port][buf_sel_trans],
    1eb2:	1dfb      	adds	r3, r7, #7
    1eb4:	7819      	ldrb	r1, [r3, #0]
    1eb6:	230f      	movs	r3, #15
    1eb8:	18fb      	adds	r3, r7, r3
    1eba:	781b      	ldrb	r3, [r3, #0]
    1ebc:	001a      	movs	r2, r3
    1ebe:	0092      	lsls	r2, r2, #2
    1ec0:	18d2      	adds	r2, r2, r3
    1ec2:	0193      	lsls	r3, r2, #6
    1ec4:	001a      	movs	r2, r3
    1ec6:	000b      	movs	r3, r1
    1ec8:	009b      	lsls	r3, r3, #2
    1eca:	185b      	adds	r3, r3, r1
    1ecc:	01db      	lsls	r3, r3, #7
    1ece:	18d2      	adds	r2, r2, r3
    1ed0:	4b0f      	ldr	r3, [pc, #60]	; (1f10 <udi_cdc_rx_start+0x120>)
    1ed2:	18d2      	adds	r2, r2, r3
#undef UDI_CDC_PORT_TO_DATA_EP_OUT
	default:
		ep = UDI_CDC_DATA_EP_OUT_0;
		break;
	}
	return udd_ep_run(ep,
    1ed4:	23a0      	movs	r3, #160	; 0xa0
    1ed6:	0059      	lsls	r1, r3, #1
    1ed8:	2317      	movs	r3, #23
    1eda:	18fb      	adds	r3, r7, r3
    1edc:	7818      	ldrb	r0, [r3, #0]
    1ede:	4b0d      	ldr	r3, [pc, #52]	; (1f14 <udi_cdc_rx_start+0x124>)
    1ee0:	9300      	str	r3, [sp, #0]
    1ee2:	000b      	movs	r3, r1
    1ee4:	2101      	movs	r1, #1
    1ee6:	4c0c      	ldr	r4, [pc, #48]	; (1f18 <udi_cdc_rx_start+0x128>)
    1ee8:	47a0      	blx	r4
    1eea:	0003      	movs	r3, r0
			true,
			udi_cdc_rx_buf[port][buf_sel_trans],
			UDI_CDC_RX_BUFFERS,
			udi_cdc_data_received);
}
    1eec:	0018      	movs	r0, r3
    1eee:	46bd      	mov	sp, r7
    1ef0:	b007      	add	sp, #28
    1ef2:	bd90      	pop	{r4, r7, pc}
    1ef4:	0000193d 	.word	0x0000193d
    1ef8:	200004a4 	.word	0x200004a4
    1efc:	200004ac 	.word	0x200004ac
    1f00:	200004a8 	.word	0x200004a8
    1f04:	200004a0 	.word	0x200004a0
    1f08:	00001985 	.word	0x00001985
    1f0c:	00002361 	.word	0x00002361
    1f10:	20000220 	.word	0x20000220
    1f14:	00001f1d 	.word	0x00001f1d
    1f18:	00004e15 	.word	0x00004e15

00001f1c <udi_cdc_data_received>:


static void udi_cdc_data_received(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep)
{
    1f1c:	b590      	push	{r4, r7, lr}
    1f1e:	b087      	sub	sp, #28
    1f20:	af02      	add	r7, sp, #8
    1f22:	6039      	str	r1, [r7, #0]
    1f24:	0011      	movs	r1, r2
    1f26:	1dfb      	adds	r3, r7, #7
    1f28:	1c02      	adds	r2, r0, #0
    1f2a:	701a      	strb	r2, [r3, #0]
    1f2c:	1dbb      	adds	r3, r7, #6
    1f2e:	1c0a      	adds	r2, r1, #0
    1f30:	701a      	strb	r2, [r3, #0]
	uint8_t buf_sel_trans;
	uint8_t port;

	switch (ep) {
    1f32:	1dbb      	adds	r3, r7, #6
    1f34:	781b      	ldrb	r3, [r3, #0]
    1f36:	2b02      	cmp	r3, #2
    1f38:	d104      	bne.n	1f44 <udi_cdc_data_received+0x28>
#define UDI_CDC_DATA_EP_OUT_TO_PORT(index, unused) \
	case UDI_CDC_DATA_EP_OUT_##index: \
		port = index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DATA_EP_OUT_TO_PORT, ~)
    1f3a:	230f      	movs	r3, #15
    1f3c:	18fb      	adds	r3, r7, r3
    1f3e:	2200      	movs	r2, #0
    1f40:	701a      	strb	r2, [r3, #0]
    1f42:	e004      	b.n	1f4e <udi_cdc_data_received+0x32>
#undef UDI_CDC_DATA_EP_OUT_TO_PORT
	default:
		port = 0;
    1f44:	230f      	movs	r3, #15
    1f46:	18fb      	adds	r3, r7, r3
    1f48:	2200      	movs	r2, #0
    1f4a:	701a      	strb	r2, [r3, #0]
		break;
    1f4c:	46c0      	nop			; (mov r8, r8)
	}

	if (UDD_EP_TRANSFER_OK != status) {
    1f4e:	1dfb      	adds	r3, r7, #7
    1f50:	781b      	ldrb	r3, [r3, #0]
    1f52:	2b00      	cmp	r3, #0
    1f54:	d146      	bne.n	1fe4 <udi_cdc_data_received+0xc8>
		// Abort reception
		return;
	}
	buf_sel_trans = (udi_cdc_rx_buf_sel[port]==0)?1:0;
    1f56:	230f      	movs	r3, #15
    1f58:	18fb      	adds	r3, r7, r3
    1f5a:	781b      	ldrb	r3, [r3, #0]
    1f5c:	4a23      	ldr	r2, [pc, #140]	; (1fec <udi_cdc_data_received+0xd0>)
    1f5e:	5cd3      	ldrb	r3, [r2, r3]
    1f60:	b2db      	uxtb	r3, r3
    1f62:	425a      	negs	r2, r3
    1f64:	4153      	adcs	r3, r2
    1f66:	b2da      	uxtb	r2, r3
    1f68:	230e      	movs	r3, #14
    1f6a:	18fb      	adds	r3, r7, r3
    1f6c:	701a      	strb	r2, [r3, #0]
	if (!n) {
    1f6e:	683b      	ldr	r3, [r7, #0]
    1f70:	2b00      	cmp	r3, #0
    1f72:	d11c      	bne.n	1fae <udi_cdc_data_received+0x92>
		udd_ep_run( ep,
				true,
				udi_cdc_rx_buf[port][buf_sel_trans],
    1f74:	230f      	movs	r3, #15
    1f76:	18fb      	adds	r3, r7, r3
    1f78:	7819      	ldrb	r1, [r3, #0]
    1f7a:	230e      	movs	r3, #14
    1f7c:	18fb      	adds	r3, r7, r3
    1f7e:	781b      	ldrb	r3, [r3, #0]
    1f80:	001a      	movs	r2, r3
    1f82:	0092      	lsls	r2, r2, #2
    1f84:	18d2      	adds	r2, r2, r3
    1f86:	0193      	lsls	r3, r2, #6
    1f88:	001a      	movs	r2, r3
    1f8a:	000b      	movs	r3, r1
    1f8c:	009b      	lsls	r3, r3, #2
    1f8e:	185b      	adds	r3, r3, r1
    1f90:	01db      	lsls	r3, r3, #7
    1f92:	18d2      	adds	r2, r2, r3
    1f94:	4b16      	ldr	r3, [pc, #88]	; (1ff0 <udi_cdc_data_received+0xd4>)
    1f96:	18d2      	adds	r2, r2, r3
		// Abort reception
		return;
	}
	buf_sel_trans = (udi_cdc_rx_buf_sel[port]==0)?1:0;
	if (!n) {
		udd_ep_run( ep,
    1f98:	23a0      	movs	r3, #160	; 0xa0
    1f9a:	0059      	lsls	r1, r3, #1
    1f9c:	1dbb      	adds	r3, r7, #6
    1f9e:	7818      	ldrb	r0, [r3, #0]
    1fa0:	4b14      	ldr	r3, [pc, #80]	; (1ff4 <udi_cdc_data_received+0xd8>)
    1fa2:	9300      	str	r3, [sp, #0]
    1fa4:	000b      	movs	r3, r1
    1fa6:	2101      	movs	r1, #1
    1fa8:	4c13      	ldr	r4, [pc, #76]	; (1ff8 <udi_cdc_data_received+0xdc>)
    1faa:	47a0      	blx	r4
				true,
				udi_cdc_rx_buf[port][buf_sel_trans],
				UDI_CDC_RX_BUFFERS,
				udi_cdc_data_received);
		return;
    1fac:	e01b      	b.n	1fe6 <udi_cdc_data_received+0xca>
	}
	udi_cdc_rx_buf_nb[port][buf_sel_trans] = n;
    1fae:	230f      	movs	r3, #15
    1fb0:	18fb      	adds	r3, r7, r3
    1fb2:	7819      	ldrb	r1, [r3, #0]
    1fb4:	230e      	movs	r3, #14
    1fb6:	18fb      	adds	r3, r7, r3
    1fb8:	781a      	ldrb	r2, [r3, #0]
    1fba:	683b      	ldr	r3, [r7, #0]
    1fbc:	b298      	uxth	r0, r3
    1fbe:	4b0f      	ldr	r3, [pc, #60]	; (1ffc <udi_cdc_data_received+0xe0>)
    1fc0:	0049      	lsls	r1, r1, #1
    1fc2:	188a      	adds	r2, r1, r2
    1fc4:	0052      	lsls	r2, r2, #1
    1fc6:	1c01      	adds	r1, r0, #0
    1fc8:	52d1      	strh	r1, [r2, r3]
	udi_cdc_rx_trans_ongoing[port] = false;
    1fca:	230f      	movs	r3, #15
    1fcc:	18fb      	adds	r3, r7, r3
    1fce:	781b      	ldrb	r3, [r3, #0]
    1fd0:	4a0b      	ldr	r2, [pc, #44]	; (2000 <STACK_SIZE>)
    1fd2:	2100      	movs	r1, #0
    1fd4:	54d1      	strb	r1, [r2, r3]
	udi_cdc_rx_start(port);
    1fd6:	230f      	movs	r3, #15
    1fd8:	18fb      	adds	r3, r7, r3
    1fda:	781b      	ldrb	r3, [r3, #0]
    1fdc:	0018      	movs	r0, r3
    1fde:	4b09      	ldr	r3, [pc, #36]	; (2004 <STACK_SIZE+0x4>)
    1fe0:	4798      	blx	r3
    1fe2:	e000      	b.n	1fe6 <udi_cdc_data_received+0xca>
		break;
	}

	if (UDD_EP_TRANSFER_OK != status) {
		// Abort reception
		return;
    1fe4:	46c0      	nop			; (mov r8, r8)
		return;
	}
	udi_cdc_rx_buf_nb[port][buf_sel_trans] = n;
	udi_cdc_rx_trans_ongoing[port] = false;
	udi_cdc_rx_start(port);
}
    1fe6:	46bd      	mov	sp, r7
    1fe8:	b005      	add	sp, #20
    1fea:	bd90      	pop	{r4, r7, pc}
    1fec:	200004a4 	.word	0x200004a4
    1ff0:	20000220 	.word	0x20000220
    1ff4:	00001f1d 	.word	0x00001f1d
    1ff8:	00004e15 	.word	0x00004e15
    1ffc:	200004a0 	.word	0x200004a0
    2000:	200004ac 	.word	0x200004ac
    2004:	00001df1 	.word	0x00001df1

00002008 <udi_cdc_data_sent>:


static void udi_cdc_data_sent(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep)
{
    2008:	b580      	push	{r7, lr}
    200a:	b084      	sub	sp, #16
    200c:	af00      	add	r7, sp, #0
    200e:	6039      	str	r1, [r7, #0]
    2010:	0011      	movs	r1, r2
    2012:	1dfb      	adds	r3, r7, #7
    2014:	1c02      	adds	r2, r0, #0
    2016:	701a      	strb	r2, [r3, #0]
    2018:	1dbb      	adds	r3, r7, #6
    201a:	1c0a      	adds	r2, r1, #0
    201c:	701a      	strb	r2, [r3, #0]
	uint8_t port;
	UNUSED(n);

	switch (ep) {
    201e:	1dbb      	adds	r3, r7, #6
    2020:	781b      	ldrb	r3, [r3, #0]
    2022:	2b81      	cmp	r3, #129	; 0x81
    2024:	d104      	bne.n	2030 <udi_cdc_data_sent+0x28>
#define UDI_CDC_DATA_EP_IN_TO_PORT(index, unused) \
	case UDI_CDC_DATA_EP_IN_##index: \
		port = index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DATA_EP_IN_TO_PORT, ~)
    2026:	230f      	movs	r3, #15
    2028:	18fb      	adds	r3, r7, r3
    202a:	2200      	movs	r2, #0
    202c:	701a      	strb	r2, [r3, #0]
    202e:	e004      	b.n	203a <udi_cdc_data_sent+0x32>
#undef UDI_CDC_DATA_EP_IN_TO_PORT
	default:
		port = 0;
    2030:	230f      	movs	r3, #15
    2032:	18fb      	adds	r3, r7, r3
    2034:	2200      	movs	r2, #0
    2036:	701a      	strb	r2, [r3, #0]
		break;
    2038:	46c0      	nop			; (mov r8, r8)
	}

	if (UDD_EP_TRANSFER_OK != status) {
    203a:	1dfb      	adds	r3, r7, #7
    203c:	781b      	ldrb	r3, [r3, #0]
    203e:	2b00      	cmp	r3, #0
    2040:	d125      	bne.n	208e <udi_cdc_data_sent+0x86>
		// Abort transfer
		return;
	}
	udi_cdc_tx_buf_nb[port][(udi_cdc_tx_buf_sel[port]==0)?1:0] = 0;
    2042:	230f      	movs	r3, #15
    2044:	18fb      	adds	r3, r7, r3
    2046:	781a      	ldrb	r2, [r3, #0]
    2048:	230f      	movs	r3, #15
    204a:	18fb      	adds	r3, r7, r3
    204c:	781b      	ldrb	r3, [r3, #0]
    204e:	4912      	ldr	r1, [pc, #72]	; (2098 <udi_cdc_data_sent+0x90>)
    2050:	5ccb      	ldrb	r3, [r1, r3]
    2052:	b2db      	uxtb	r3, r3
    2054:	4259      	negs	r1, r3
    2056:	414b      	adcs	r3, r1
    2058:	b2db      	uxtb	r3, r3
    205a:	0019      	movs	r1, r3
    205c:	4b0f      	ldr	r3, [pc, #60]	; (209c <udi_cdc_data_sent+0x94>)
    205e:	0052      	lsls	r2, r2, #1
    2060:	1852      	adds	r2, r2, r1
    2062:	0052      	lsls	r2, r2, #1
    2064:	2100      	movs	r1, #0
    2066:	52d1      	strh	r1, [r2, r3]
	udi_cdc_tx_both_buf_to_send[port] = false;
    2068:	230f      	movs	r3, #15
    206a:	18fb      	adds	r3, r7, r3
    206c:	781b      	ldrb	r3, [r3, #0]
    206e:	4a0c      	ldr	r2, [pc, #48]	; (20a0 <udi_cdc_data_sent+0x98>)
    2070:	2100      	movs	r1, #0
    2072:	54d1      	strb	r1, [r2, r3]
	udi_cdc_tx_trans_ongoing[port] = false;
    2074:	230f      	movs	r3, #15
    2076:	18fb      	adds	r3, r7, r3
    2078:	781b      	ldrb	r3, [r3, #0]
    207a:	4a0a      	ldr	r2, [pc, #40]	; (20a4 <udi_cdc_data_sent+0x9c>)
    207c:	2100      	movs	r1, #0
    207e:	54d1      	strb	r1, [r2, r3]

	if (n != 0) {
		UDI_CDC_TX_EMPTY_NOTIFY(port);
	}
	udi_cdc_tx_send(port);
    2080:	230f      	movs	r3, #15
    2082:	18fb      	adds	r3, r7, r3
    2084:	781b      	ldrb	r3, [r3, #0]
    2086:	0018      	movs	r0, r3
    2088:	4b07      	ldr	r3, [pc, #28]	; (20a8 <udi_cdc_data_sent+0xa0>)
    208a:	4798      	blx	r3
    208c:	e000      	b.n	2090 <udi_cdc_data_sent+0x88>
		break;
	}

	if (UDD_EP_TRANSFER_OK != status) {
		// Abort transfer
		return;
    208e:	46c0      	nop			; (mov r8, r8)

	if (n != 0) {
		UDI_CDC_TX_EMPTY_NOTIFY(port);
	}
	udi_cdc_tx_send(port);
}
    2090:	46bd      	mov	sp, r7
    2092:	b004      	add	sp, #16
    2094:	bd80      	pop	{r7, pc}
    2096:	46c0      	nop			; (mov r8, r8)
    2098:	20000734 	.word	0x20000734
    209c:	20000730 	.word	0x20000730
    20a0:	20000740 	.word	0x20000740
    20a4:	2000073c 	.word	0x2000073c
    20a8:	000020ad 	.word	0x000020ad

000020ac <udi_cdc_tx_send>:


static void udi_cdc_tx_send(uint8_t port)
{
    20ac:	b590      	push	{r4, r7, lr}
    20ae:	b089      	sub	sp, #36	; 0x24
    20b0:	af02      	add	r7, sp, #8
    20b2:	0002      	movs	r2, r0
    20b4:	1dfb      	adds	r3, r7, #7
    20b6:	701a      	strb	r2, [r3, #0]
	bool b_short_packet;
	udd_ep_id_t ep;
	static uint16_t sof_zlp_counter = 0;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
    20b8:	1dfb      	adds	r3, r7, #7
    20ba:	2200      	movs	r2, #0
    20bc:	701a      	strb	r2, [r3, #0]
#endif

	if (udi_cdc_tx_trans_ongoing[port]) {
    20be:	1dfb      	adds	r3, r7, #7
    20c0:	781b      	ldrb	r3, [r3, #0]
    20c2:	4a7a      	ldr	r2, [pc, #488]	; (22ac <udi_cdc_tx_send+0x200>)
    20c4:	5cd3      	ldrb	r3, [r2, r3]
    20c6:	b2db      	uxtb	r3, r3
    20c8:	2b00      	cmp	r3, #0
    20ca:	d000      	beq.n	20ce <udi_cdc_tx_send+0x22>
    20cc:	e0e7      	b.n	229e <udi_cdc_tx_send+0x1f2>
		return; // Already on going or wait next SOF to send next data
	}
	if (udd_is_high_speed()) {
    20ce:	4b78      	ldr	r3, [pc, #480]	; (22b0 <udi_cdc_tx_send+0x204>)
    20d0:	4798      	blx	r3
    20d2:	1e03      	subs	r3, r0, #0
    20d4:	d00a      	beq.n	20ec <udi_cdc_tx_send+0x40>
		if (udi_cdc_tx_sof_num[port] == udd_get_micro_frame_number()) {
    20d6:	1dfb      	adds	r3, r7, #7
    20d8:	781a      	ldrb	r2, [r3, #0]
    20da:	4b76      	ldr	r3, [pc, #472]	; (22b4 <udi_cdc_tx_send+0x208>)
    20dc:	0052      	lsls	r2, r2, #1
    20de:	5ad4      	ldrh	r4, [r2, r3]
    20e0:	4b75      	ldr	r3, [pc, #468]	; (22b8 <udi_cdc_tx_send+0x20c>)
    20e2:	4798      	blx	r3
    20e4:	0003      	movs	r3, r0
    20e6:	429c      	cmp	r4, r3
    20e8:	d10b      	bne.n	2102 <udi_cdc_tx_send+0x56>
			return; // Wait next SOF to send next data
    20ea:	e0db      	b.n	22a4 <udi_cdc_tx_send+0x1f8>
		}
	}else{
		if (udi_cdc_tx_sof_num[port] == udd_get_frame_number()) {
    20ec:	1dfb      	adds	r3, r7, #7
    20ee:	781a      	ldrb	r2, [r3, #0]
    20f0:	4b70      	ldr	r3, [pc, #448]	; (22b4 <udi_cdc_tx_send+0x208>)
    20f2:	0052      	lsls	r2, r2, #1
    20f4:	5ad4      	ldrh	r4, [r2, r3]
    20f6:	4b71      	ldr	r3, [pc, #452]	; (22bc <udi_cdc_tx_send+0x210>)
    20f8:	4798      	blx	r3
    20fa:	0003      	movs	r3, r0
    20fc:	429c      	cmp	r4, r3
    20fe:	d100      	bne.n	2102 <udi_cdc_tx_send+0x56>
    2100:	e0cf      	b.n	22a2 <udi_cdc_tx_send+0x1f6>
			return; // Wait next SOF to send next data
		}
	}

	flags = cpu_irq_save(); // to protect udi_cdc_tx_buf_sel
    2102:	4b6f      	ldr	r3, [pc, #444]	; (22c0 <udi_cdc_tx_send+0x214>)
    2104:	4798      	blx	r3
    2106:	0003      	movs	r3, r0
    2108:	613b      	str	r3, [r7, #16]
	buf_sel_trans = udi_cdc_tx_buf_sel[port];
    210a:	1dfb      	adds	r3, r7, #7
    210c:	781a      	ldrb	r2, [r3, #0]
    210e:	2317      	movs	r3, #23
    2110:	18fb      	adds	r3, r7, r3
    2112:	496c      	ldr	r1, [pc, #432]	; (22c4 <udi_cdc_tx_send+0x218>)
    2114:	5c8a      	ldrb	r2, [r1, r2]
    2116:	701a      	strb	r2, [r3, #0]
	if (udi_cdc_tx_buf_nb[port][buf_sel_trans] == 0) {
    2118:	1dfb      	adds	r3, r7, #7
    211a:	7819      	ldrb	r1, [r3, #0]
    211c:	2317      	movs	r3, #23
    211e:	18fb      	adds	r3, r7, r3
    2120:	781a      	ldrb	r2, [r3, #0]
    2122:	4b69      	ldr	r3, [pc, #420]	; (22c8 <udi_cdc_tx_send+0x21c>)
    2124:	0049      	lsls	r1, r1, #1
    2126:	188a      	adds	r2, r1, r2
    2128:	0052      	lsls	r2, r2, #1
    212a:	5ad3      	ldrh	r3, [r2, r3]
    212c:	2b00      	cmp	r3, #0
    212e:	d120      	bne.n	2172 <udi_cdc_tx_send+0xc6>
		sof_zlp_counter++;
    2130:	4b66      	ldr	r3, [pc, #408]	; (22cc <udi_cdc_tx_send+0x220>)
    2132:	881b      	ldrh	r3, [r3, #0]
    2134:	3301      	adds	r3, #1
    2136:	b29a      	uxth	r2, r3
    2138:	4b64      	ldr	r3, [pc, #400]	; (22cc <udi_cdc_tx_send+0x220>)
    213a:	801a      	strh	r2, [r3, #0]
		if (((!udd_is_high_speed()) && (sof_zlp_counter < 100))
    213c:	4b5c      	ldr	r3, [pc, #368]	; (22b0 <udi_cdc_tx_send+0x204>)
    213e:	4798      	blx	r3
    2140:	0003      	movs	r3, r0
    2142:	001a      	movs	r2, r3
    2144:	2301      	movs	r3, #1
    2146:	4053      	eors	r3, r2
    2148:	b2db      	uxtb	r3, r3
    214a:	2b00      	cmp	r3, #0
    214c:	d003      	beq.n	2156 <udi_cdc_tx_send+0xaa>
    214e:	4b5f      	ldr	r3, [pc, #380]	; (22cc <udi_cdc_tx_send+0x220>)
    2150:	881b      	ldrh	r3, [r3, #0]
    2152:	2b63      	cmp	r3, #99	; 0x63
    2154:	d908      	bls.n	2168 <udi_cdc_tx_send+0xbc>
				|| (udd_is_high_speed() && (sof_zlp_counter < 800))) {
    2156:	4b56      	ldr	r3, [pc, #344]	; (22b0 <udi_cdc_tx_send+0x204>)
    2158:	4798      	blx	r3
    215a:	1e03      	subs	r3, r0, #0
    215c:	d009      	beq.n	2172 <udi_cdc_tx_send+0xc6>
    215e:	4b5b      	ldr	r3, [pc, #364]	; (22cc <udi_cdc_tx_send+0x220>)
    2160:	881b      	ldrh	r3, [r3, #0]
    2162:	4a5b      	ldr	r2, [pc, #364]	; (22d0 <udi_cdc_tx_send+0x224>)
    2164:	4293      	cmp	r3, r2
    2166:	d804      	bhi.n	2172 <udi_cdc_tx_send+0xc6>
			cpu_irq_restore(flags);
    2168:	693b      	ldr	r3, [r7, #16]
    216a:	0018      	movs	r0, r3
    216c:	4b59      	ldr	r3, [pc, #356]	; (22d4 <udi_cdc_tx_send+0x228>)
    216e:	4798      	blx	r3
			return;
    2170:	e098      	b.n	22a4 <udi_cdc_tx_send+0x1f8>
		}
	}
	sof_zlp_counter = 0;
    2172:	4b56      	ldr	r3, [pc, #344]	; (22cc <udi_cdc_tx_send+0x220>)
    2174:	2200      	movs	r2, #0
    2176:	801a      	strh	r2, [r3, #0]

	if (!udi_cdc_tx_both_buf_to_send[port]) {
    2178:	1dfb      	adds	r3, r7, #7
    217a:	781b      	ldrb	r3, [r3, #0]
    217c:	4a56      	ldr	r2, [pc, #344]	; (22d8 <udi_cdc_tx_send+0x22c>)
    217e:	5cd3      	ldrb	r3, [r2, r3]
    2180:	b2db      	uxtb	r3, r3
    2182:	2201      	movs	r2, #1
    2184:	4053      	eors	r3, r2
    2186:	b2db      	uxtb	r3, r3
    2188:	2b00      	cmp	r3, #0
    218a:	d00b      	beq.n	21a4 <udi_cdc_tx_send+0xf8>
		// Send current Buffer
		// and switch the current buffer
		udi_cdc_tx_buf_sel[port] = (buf_sel_trans==0)?1:0;
    218c:	1dfb      	adds	r3, r7, #7
    218e:	781b      	ldrb	r3, [r3, #0]
    2190:	2217      	movs	r2, #23
    2192:	18ba      	adds	r2, r7, r2
    2194:	7812      	ldrb	r2, [r2, #0]
    2196:	4251      	negs	r1, r2
    2198:	414a      	adcs	r2, r1
    219a:	b2d2      	uxtb	r2, r2
    219c:	0011      	movs	r1, r2
    219e:	4a49      	ldr	r2, [pc, #292]	; (22c4 <udi_cdc_tx_send+0x218>)
    21a0:	54d1      	strb	r1, [r2, r3]
    21a2:	e008      	b.n	21b6 <udi_cdc_tx_send+0x10a>
	}else{
		// Send the other Buffer
		// and no switch the current buffer
		buf_sel_trans = (buf_sel_trans==0)?1:0;
    21a4:	2317      	movs	r3, #23
    21a6:	18fb      	adds	r3, r7, r3
    21a8:	781b      	ldrb	r3, [r3, #0]
    21aa:	425a      	negs	r2, r3
    21ac:	4153      	adcs	r3, r2
    21ae:	b2da      	uxtb	r2, r3
    21b0:	2317      	movs	r3, #23
    21b2:	18fb      	adds	r3, r7, r3
    21b4:	701a      	strb	r2, [r3, #0]
	}
	udi_cdc_tx_trans_ongoing[port] = true;
    21b6:	1dfb      	adds	r3, r7, #7
    21b8:	781b      	ldrb	r3, [r3, #0]
    21ba:	4a3c      	ldr	r2, [pc, #240]	; (22ac <udi_cdc_tx_send+0x200>)
    21bc:	2101      	movs	r1, #1
    21be:	54d1      	strb	r1, [r2, r3]
	cpu_irq_restore(flags);
    21c0:	693b      	ldr	r3, [r7, #16]
    21c2:	0018      	movs	r0, r3
    21c4:	4b43      	ldr	r3, [pc, #268]	; (22d4 <udi_cdc_tx_send+0x228>)
    21c6:	4798      	blx	r3

	b_short_packet = (udi_cdc_tx_buf_nb[port][buf_sel_trans] != UDI_CDC_TX_BUFFERS);
    21c8:	1dfb      	adds	r3, r7, #7
    21ca:	7819      	ldrb	r1, [r3, #0]
    21cc:	2317      	movs	r3, #23
    21ce:	18fb      	adds	r3, r7, r3
    21d0:	781a      	ldrb	r2, [r3, #0]
    21d2:	4b3d      	ldr	r3, [pc, #244]	; (22c8 <udi_cdc_tx_send+0x21c>)
    21d4:	0049      	lsls	r1, r1, #1
    21d6:	188a      	adds	r2, r1, r2
    21d8:	0052      	lsls	r2, r2, #1
    21da:	5ad2      	ldrh	r2, [r2, r3]
    21dc:	230f      	movs	r3, #15
    21de:	18fb      	adds	r3, r7, r3
    21e0:	3a41      	subs	r2, #65	; 0x41
    21e2:	3aff      	subs	r2, #255	; 0xff
    21e4:	1e51      	subs	r1, r2, #1
    21e6:	418a      	sbcs	r2, r1
    21e8:	701a      	strb	r2, [r3, #0]
	if (b_short_packet) {
    21ea:	230f      	movs	r3, #15
    21ec:	18fb      	adds	r3, r7, r3
    21ee:	781b      	ldrb	r3, [r3, #0]
    21f0:	2b00      	cmp	r3, #0
    21f2:	d017      	beq.n	2224 <udi_cdc_tx_send+0x178>
		if (udd_is_high_speed()) {
    21f4:	4b2e      	ldr	r3, [pc, #184]	; (22b0 <udi_cdc_tx_send+0x204>)
    21f6:	4798      	blx	r3
    21f8:	1e03      	subs	r3, r0, #0
    21fa:	d009      	beq.n	2210 <udi_cdc_tx_send+0x164>
			udi_cdc_tx_sof_num[port] = udd_get_micro_frame_number();
    21fc:	1dfb      	adds	r3, r7, #7
    21fe:	781c      	ldrb	r4, [r3, #0]
    2200:	4b2d      	ldr	r3, [pc, #180]	; (22b8 <udi_cdc_tx_send+0x20c>)
    2202:	4798      	blx	r3
    2204:	0003      	movs	r3, r0
    2206:	0019      	movs	r1, r3
    2208:	4b2a      	ldr	r3, [pc, #168]	; (22b4 <udi_cdc_tx_send+0x208>)
    220a:	0062      	lsls	r2, r4, #1
    220c:	52d1      	strh	r1, [r2, r3]
    220e:	e00f      	b.n	2230 <udi_cdc_tx_send+0x184>
		}else{
			udi_cdc_tx_sof_num[port] = udd_get_frame_number();
    2210:	1dfb      	adds	r3, r7, #7
    2212:	781c      	ldrb	r4, [r3, #0]
    2214:	4b29      	ldr	r3, [pc, #164]	; (22bc <udi_cdc_tx_send+0x210>)
    2216:	4798      	blx	r3
    2218:	0003      	movs	r3, r0
    221a:	0019      	movs	r1, r3
    221c:	4b25      	ldr	r3, [pc, #148]	; (22b4 <udi_cdc_tx_send+0x208>)
    221e:	0062      	lsls	r2, r4, #1
    2220:	52d1      	strh	r1, [r2, r3]
    2222:	e005      	b.n	2230 <udi_cdc_tx_send+0x184>
		}
	}else{
		udi_cdc_tx_sof_num[port] = 0; // Force next transfer without wait SOF
    2224:	1dfb      	adds	r3, r7, #7
    2226:	781a      	ldrb	r2, [r3, #0]
    2228:	4b22      	ldr	r3, [pc, #136]	; (22b4 <udi_cdc_tx_send+0x208>)
    222a:	0052      	lsls	r2, r2, #1
    222c:	2100      	movs	r1, #0
    222e:	52d1      	strh	r1, [r2, r3]
	}

	// Send the buffer with enable of short packet
	switch (port) {
    2230:	1dfb      	adds	r3, r7, #7
    2232:	781b      	ldrb	r3, [r3, #0]
    2234:	2b00      	cmp	r3, #0
    2236:	d104      	bne.n	2242 <udi_cdc_tx_send+0x196>
#define UDI_CDC_PORT_TO_DATA_EP_IN(index, unused) \
	case index: \
		ep = UDI_CDC_DATA_EP_IN_##index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_DATA_EP_IN, ~)
    2238:	2316      	movs	r3, #22
    223a:	18fb      	adds	r3, r7, r3
    223c:	2281      	movs	r2, #129	; 0x81
    223e:	701a      	strb	r2, [r3, #0]
    2240:	e004      	b.n	224c <udi_cdc_tx_send+0x1a0>
#undef UDI_CDC_PORT_TO_DATA_EP_IN
	default:
		ep = UDI_CDC_DATA_EP_IN_0;
    2242:	2316      	movs	r3, #22
    2244:	18fb      	adds	r3, r7, r3
    2246:	2281      	movs	r2, #129	; 0x81
    2248:	701a      	strb	r2, [r3, #0]
		break;
    224a:	46c0      	nop			; (mov r8, r8)
	}
	udd_ep_run( ep,
			b_short_packet,
			udi_cdc_tx_buf[port][buf_sel_trans],
    224c:	1dfb      	adds	r3, r7, #7
    224e:	7819      	ldrb	r1, [r3, #0]
    2250:	2317      	movs	r3, #23
    2252:	18fb      	adds	r3, r7, r3
    2254:	781b      	ldrb	r3, [r3, #0]
    2256:	001a      	movs	r2, r3
    2258:	0092      	lsls	r2, r2, #2
    225a:	18d2      	adds	r2, r2, r3
    225c:	0193      	lsls	r3, r2, #6
    225e:	001a      	movs	r2, r3
    2260:	000b      	movs	r3, r1
    2262:	009b      	lsls	r3, r3, #2
    2264:	185b      	adds	r3, r3, r1
    2266:	01db      	lsls	r3, r3, #7
    2268:	18d2      	adds	r2, r2, r3
    226a:	4b1c      	ldr	r3, [pc, #112]	; (22dc <udi_cdc_tx_send+0x230>)
    226c:	18d4      	adds	r4, r2, r3
			udi_cdc_tx_buf_nb[port][buf_sel_trans],
    226e:	1dfb      	adds	r3, r7, #7
    2270:	7819      	ldrb	r1, [r3, #0]
    2272:	2317      	movs	r3, #23
    2274:	18fb      	adds	r3, r7, r3
    2276:	781a      	ldrb	r2, [r3, #0]
    2278:	4b13      	ldr	r3, [pc, #76]	; (22c8 <udi_cdc_tx_send+0x21c>)
    227a:	0049      	lsls	r1, r1, #1
    227c:	188a      	adds	r2, r1, r2
    227e:	0052      	lsls	r2, r2, #1
    2280:	5ad3      	ldrh	r3, [r2, r3]
#undef UDI_CDC_PORT_TO_DATA_EP_IN
	default:
		ep = UDI_CDC_DATA_EP_IN_0;
		break;
	}
	udd_ep_run( ep,
    2282:	001a      	movs	r2, r3
    2284:	230f      	movs	r3, #15
    2286:	18fb      	adds	r3, r7, r3
    2288:	7819      	ldrb	r1, [r3, #0]
    228a:	2316      	movs	r3, #22
    228c:	18fb      	adds	r3, r7, r3
    228e:	7818      	ldrb	r0, [r3, #0]
    2290:	4b13      	ldr	r3, [pc, #76]	; (22e0 <udi_cdc_tx_send+0x234>)
    2292:	9300      	str	r3, [sp, #0]
    2294:	0013      	movs	r3, r2
    2296:	0022      	movs	r2, r4
    2298:	4c12      	ldr	r4, [pc, #72]	; (22e4 <udi_cdc_tx_send+0x238>)
    229a:	47a0      	blx	r4
    229c:	e002      	b.n	22a4 <udi_cdc_tx_send+0x1f8>
#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
#endif

	if (udi_cdc_tx_trans_ongoing[port]) {
		return; // Already on going or wait next SOF to send next data
    229e:	46c0      	nop			; (mov r8, r8)
    22a0:	e000      	b.n	22a4 <udi_cdc_tx_send+0x1f8>
		if (udi_cdc_tx_sof_num[port] == udd_get_micro_frame_number()) {
			return; // Wait next SOF to send next data
		}
	}else{
		if (udi_cdc_tx_sof_num[port] == udd_get_frame_number()) {
			return; // Wait next SOF to send next data
    22a2:	46c0      	nop			; (mov r8, r8)
	udd_ep_run( ep,
			b_short_packet,
			udi_cdc_tx_buf[port][buf_sel_trans],
			udi_cdc_tx_buf_nb[port][buf_sel_trans],
			udi_cdc_data_sent);
}
    22a4:	46bd      	mov	sp, r7
    22a6:	b007      	add	sp, #28
    22a8:	bd90      	pop	{r4, r7, pc}
    22aa:	46c0      	nop			; (mov r8, r8)
    22ac:	2000073c 	.word	0x2000073c
    22b0:	00004a6d 	.word	0x00004a6d
    22b4:	20000738 	.word	0x20000738
    22b8:	00004a95 	.word	0x00004a95
    22bc:	00004a79 	.word	0x00004a79
    22c0:	0000193d 	.word	0x0000193d
    22c4:	20000734 	.word	0x20000734
    22c8:	20000730 	.word	0x20000730
    22cc:	20000742 	.word	0x20000742
    22d0:	0000031f 	.word	0x0000031f
    22d4:	00001985 	.word	0x00001985
    22d8:	20000740 	.word	0x20000740
    22dc:	200004b0 	.word	0x200004b0
    22e0:	00002009 	.word	0x00002009
    22e4:	00004e15 	.word	0x00004e15

000022e8 <udi_cdc_multi_get_nb_received_data>:
{
	udi_cdc_ctrl_state_change(port, true, CDC_SERIAL_STATE_OVERRUN);
}

iram_size_t udi_cdc_multi_get_nb_received_data(uint8_t port)
{
    22e8:	b580      	push	{r7, lr}
    22ea:	b086      	sub	sp, #24
    22ec:	af00      	add	r7, sp, #0
    22ee:	0002      	movs	r2, r0
    22f0:	1dfb      	adds	r3, r7, #7
    22f2:	701a      	strb	r2, [r3, #0]
	irqflags_t flags;
	uint16_t pos;
	iram_size_t nb_received;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
    22f4:	1dfb      	adds	r3, r7, #7
    22f6:	2200      	movs	r2, #0
    22f8:	701a      	strb	r2, [r3, #0]
#endif
	flags = cpu_irq_save();
    22fa:	4b14      	ldr	r3, [pc, #80]	; (234c <udi_cdc_multi_get_nb_received_data+0x64>)
    22fc:	4798      	blx	r3
    22fe:	0003      	movs	r3, r0
    2300:	617b      	str	r3, [r7, #20]
	pos = udi_cdc_rx_pos[port];
    2302:	1dfb      	adds	r3, r7, #7
    2304:	7819      	ldrb	r1, [r3, #0]
    2306:	2312      	movs	r3, #18
    2308:	18fb      	adds	r3, r7, r3
    230a:	4a11      	ldr	r2, [pc, #68]	; (2350 <udi_cdc_multi_get_nb_received_data+0x68>)
    230c:	0049      	lsls	r1, r1, #1
    230e:	5a8a      	ldrh	r2, [r1, r2]
    2310:	801a      	strh	r2, [r3, #0]
	nb_received = udi_cdc_rx_buf_nb[port][udi_cdc_rx_buf_sel[port]] - pos;
    2312:	1dfb      	adds	r3, r7, #7
    2314:	781a      	ldrb	r2, [r3, #0]
    2316:	1dfb      	adds	r3, r7, #7
    2318:	781b      	ldrb	r3, [r3, #0]
    231a:	490e      	ldr	r1, [pc, #56]	; (2354 <udi_cdc_multi_get_nb_received_data+0x6c>)
    231c:	5ccb      	ldrb	r3, [r1, r3]
    231e:	b2db      	uxtb	r3, r3
    2320:	0019      	movs	r1, r3
    2322:	4b0d      	ldr	r3, [pc, #52]	; (2358 <udi_cdc_multi_get_nb_received_data+0x70>)
    2324:	0052      	lsls	r2, r2, #1
    2326:	1852      	adds	r2, r2, r1
    2328:	0052      	lsls	r2, r2, #1
    232a:	5ad3      	ldrh	r3, [r2, r3]
    232c:	b29b      	uxth	r3, r3
    232e:	001a      	movs	r2, r3
    2330:	2312      	movs	r3, #18
    2332:	18fb      	adds	r3, r7, r3
    2334:	881b      	ldrh	r3, [r3, #0]
    2336:	1ad3      	subs	r3, r2, r3
    2338:	60fb      	str	r3, [r7, #12]
	cpu_irq_restore(flags);
    233a:	697b      	ldr	r3, [r7, #20]
    233c:	0018      	movs	r0, r3
    233e:	4b07      	ldr	r3, [pc, #28]	; (235c <udi_cdc_multi_get_nb_received_data+0x74>)
    2340:	4798      	blx	r3
	return nb_received;
    2342:	68fb      	ldr	r3, [r7, #12]
}
    2344:	0018      	movs	r0, r3
    2346:	46bd      	mov	sp, r7
    2348:	b006      	add	sp, #24
    234a:	bd80      	pop	{r7, pc}
    234c:	0000193d 	.word	0x0000193d
    2350:	200004a8 	.word	0x200004a8
    2354:	200004a4 	.word	0x200004a4
    2358:	200004a0 	.word	0x200004a0
    235c:	00001985 	.word	0x00001985

00002360 <udi_cdc_multi_is_rx_ready>:
{
	return udi_cdc_multi_get_nb_received_data(0);
}

bool udi_cdc_multi_is_rx_ready(uint8_t port)
{
    2360:	b580      	push	{r7, lr}
    2362:	b082      	sub	sp, #8
    2364:	af00      	add	r7, sp, #0
    2366:	0002      	movs	r2, r0
    2368:	1dfb      	adds	r3, r7, #7
    236a:	701a      	strb	r2, [r3, #0]
	return (udi_cdc_multi_get_nb_received_data(port) > 0);
    236c:	1dfb      	adds	r3, r7, #7
    236e:	781b      	ldrb	r3, [r3, #0]
    2370:	0018      	movs	r0, r3
    2372:	4b05      	ldr	r3, [pc, #20]	; (2388 <udi_cdc_multi_is_rx_ready+0x28>)
    2374:	4798      	blx	r3
    2376:	0003      	movs	r3, r0
    2378:	1e5a      	subs	r2, r3, #1
    237a:	4193      	sbcs	r3, r2
    237c:	b2db      	uxtb	r3, r3
}
    237e:	0018      	movs	r0, r3
    2380:	46bd      	mov	sp, r7
    2382:	b002      	add	sp, #8
    2384:	bd80      	pop	{r7, pc}
    2386:	46c0      	nop			; (mov r8, r8)
    2388:	000022e9 	.word	0x000022e9

0000238c <udi_cdc_is_rx_ready>:

bool udi_cdc_is_rx_ready(void)
{
    238c:	b580      	push	{r7, lr}
    238e:	af00      	add	r7, sp, #0
	return udi_cdc_multi_is_rx_ready(0);
    2390:	2000      	movs	r0, #0
    2392:	4b03      	ldr	r3, [pc, #12]	; (23a0 <udi_cdc_is_rx_ready+0x14>)
    2394:	4798      	blx	r3
    2396:	0003      	movs	r3, r0
}
    2398:	0018      	movs	r0, r3
    239a:	46bd      	mov	sp, r7
    239c:	bd80      	pop	{r7, pc}
    239e:	46c0      	nop			; (mov r8, r8)
    23a0:	00002361 	.word	0x00002361

000023a4 <udi_cdc_multi_getc>:

int udi_cdc_multi_getc(uint8_t port)
{
    23a4:	b590      	push	{r4, r7, lr}
    23a6:	b087      	sub	sp, #28
    23a8:	af00      	add	r7, sp, #0
    23aa:	0002      	movs	r2, r0
    23ac:	1dfb      	adds	r3, r7, #7
    23ae:	701a      	strb	r2, [r3, #0]
	irqflags_t flags;
	int rx_data = 0;
    23b0:	2300      	movs	r3, #0
    23b2:	617b      	str	r3, [r7, #20]
	uint16_t pos;
	uint8_t buf_sel;
	bool again;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
    23b4:	1dfb      	adds	r3, r7, #7
    23b6:	2200      	movs	r2, #0
    23b8:	701a      	strb	r2, [r3, #0]
#endif

	b_databit_9 = (9 == udi_cdc_line_coding[port].bDataBits);
    23ba:	1dfb      	adds	r3, r7, #7
    23bc:	781a      	ldrb	r2, [r3, #0]
    23be:	4944      	ldr	r1, [pc, #272]	; (24d0 <udi_cdc_multi_getc+0x12c>)
    23c0:	0013      	movs	r3, r2
    23c2:	00db      	lsls	r3, r3, #3
    23c4:	1a9b      	subs	r3, r3, r2
    23c6:	18cb      	adds	r3, r1, r3
    23c8:	3306      	adds	r3, #6
    23ca:	781a      	ldrb	r2, [r3, #0]
    23cc:	2313      	movs	r3, #19
    23ce:	18fb      	adds	r3, r7, r3
    23d0:	3a09      	subs	r2, #9
    23d2:	4251      	negs	r1, r2
    23d4:	414a      	adcs	r2, r1
    23d6:	701a      	strb	r2, [r3, #0]

udi_cdc_getc_process_one_byte:
	// Check available data
	flags = cpu_irq_save();
    23d8:	4b3e      	ldr	r3, [pc, #248]	; (24d4 <udi_cdc_multi_getc+0x130>)
    23da:	4798      	blx	r3
    23dc:	0003      	movs	r3, r0
    23de:	60fb      	str	r3, [r7, #12]
	pos = udi_cdc_rx_pos[port];
    23e0:	1dfb      	adds	r3, r7, #7
    23e2:	7819      	ldrb	r1, [r3, #0]
    23e4:	230a      	movs	r3, #10
    23e6:	18fb      	adds	r3, r7, r3
    23e8:	4a3b      	ldr	r2, [pc, #236]	; (24d8 <udi_cdc_multi_getc+0x134>)
    23ea:	0049      	lsls	r1, r1, #1
    23ec:	5a8a      	ldrh	r2, [r1, r2]
    23ee:	801a      	strh	r2, [r3, #0]
	buf_sel = udi_cdc_rx_buf_sel[port];
    23f0:	1dfb      	adds	r3, r7, #7
    23f2:	781a      	ldrb	r2, [r3, #0]
    23f4:	2309      	movs	r3, #9
    23f6:	18fb      	adds	r3, r7, r3
    23f8:	4938      	ldr	r1, [pc, #224]	; (24dc <udi_cdc_multi_getc+0x138>)
    23fa:	5c8a      	ldrb	r2, [r1, r2]
    23fc:	701a      	strb	r2, [r3, #0]
	again = pos >= udi_cdc_rx_buf_nb[port][buf_sel];
    23fe:	1dfb      	adds	r3, r7, #7
    2400:	7819      	ldrb	r1, [r3, #0]
    2402:	2309      	movs	r3, #9
    2404:	18fb      	adds	r3, r7, r3
    2406:	781a      	ldrb	r2, [r3, #0]
    2408:	4b35      	ldr	r3, [pc, #212]	; (24e0 <udi_cdc_multi_getc+0x13c>)
    240a:	0049      	lsls	r1, r1, #1
    240c:	188a      	adds	r2, r1, r2
    240e:	0052      	lsls	r2, r2, #1
    2410:	5ad3      	ldrh	r3, [r2, r3]
    2412:	b299      	uxth	r1, r3
    2414:	2308      	movs	r3, #8
    2416:	18fa      	adds	r2, r7, r3
    2418:	230a      	movs	r3, #10
    241a:	18fb      	adds	r3, r7, r3
    241c:	8818      	ldrh	r0, [r3, #0]
    241e:	2300      	movs	r3, #0
    2420:	4288      	cmp	r0, r1
    2422:	415b      	adcs	r3, r3
    2424:	7013      	strb	r3, [r2, #0]
	cpu_irq_restore(flags);
    2426:	68fb      	ldr	r3, [r7, #12]
    2428:	0018      	movs	r0, r3
    242a:	4b2e      	ldr	r3, [pc, #184]	; (24e4 <udi_cdc_multi_getc+0x140>)
    242c:	4798      	blx	r3
	while (again) {
    242e:	2308      	movs	r3, #8
    2430:	18fb      	adds	r3, r7, r3
    2432:	781b      	ldrb	r3, [r3, #0]
    2434:	2b00      	cmp	r3, #0
    2436:	d010      	beq.n	245a <udi_cdc_multi_getc+0xb6>
		if (!udi_cdc_data_running) {
    2438:	4b2b      	ldr	r3, [pc, #172]	; (24e8 <udi_cdc_multi_getc+0x144>)
    243a:	781b      	ldrb	r3, [r3, #0]
    243c:	b2db      	uxtb	r3, r3
    243e:	2201      	movs	r2, #1
    2440:	4053      	eors	r3, r2
    2442:	b2db      	uxtb	r3, r3
    2444:	2b00      	cmp	r3, #0
    2446:	d001      	beq.n	244c <udi_cdc_multi_getc+0xa8>
			return 0;
    2448:	2300      	movs	r3, #0
    244a:	e03c      	b.n	24c6 <udi_cdc_multi_getc+0x122>
    244c:	2313      	movs	r3, #19
    244e:	18fb      	adds	r3, r7, r3
    2450:	2213      	movs	r2, #19
    2452:	18ba      	adds	r2, r7, r2
    2454:	7812      	ldrb	r2, [r2, #0]
    2456:	701a      	strb	r2, [r3, #0]
		}
		goto udi_cdc_getc_process_one_byte;
    2458:	e7be      	b.n	23d8 <udi_cdc_multi_getc+0x34>
	}

	// Read data
	rx_data |= udi_cdc_rx_buf[port][buf_sel][pos];
    245a:	1dfb      	adds	r3, r7, #7
    245c:	7819      	ldrb	r1, [r3, #0]
    245e:	2309      	movs	r3, #9
    2460:	18fb      	adds	r3, r7, r3
    2462:	781b      	ldrb	r3, [r3, #0]
    2464:	220a      	movs	r2, #10
    2466:	18ba      	adds	r2, r7, r2
    2468:	8810      	ldrh	r0, [r2, #0]
    246a:	4c20      	ldr	r4, [pc, #128]	; (24ec <udi_cdc_multi_getc+0x148>)
    246c:	001a      	movs	r2, r3
    246e:	0092      	lsls	r2, r2, #2
    2470:	18d2      	adds	r2, r2, r3
    2472:	0193      	lsls	r3, r2, #6
    2474:	001a      	movs	r2, r3
    2476:	000b      	movs	r3, r1
    2478:	009b      	lsls	r3, r3, #2
    247a:	185b      	adds	r3, r3, r1
    247c:	01db      	lsls	r3, r3, #7
    247e:	18d3      	adds	r3, r2, r3
    2480:	18e3      	adds	r3, r4, r3
    2482:	5c1b      	ldrb	r3, [r3, r0]
    2484:	001a      	movs	r2, r3
    2486:	697b      	ldr	r3, [r7, #20]
    2488:	4313      	orrs	r3, r2
    248a:	617b      	str	r3, [r7, #20]
	udi_cdc_rx_pos[port] = pos+1;
    248c:	1dfb      	adds	r3, r7, #7
    248e:	781a      	ldrb	r2, [r3, #0]
    2490:	230a      	movs	r3, #10
    2492:	18fb      	adds	r3, r7, r3
    2494:	881b      	ldrh	r3, [r3, #0]
    2496:	3301      	adds	r3, #1
    2498:	b299      	uxth	r1, r3
    249a:	4b0f      	ldr	r3, [pc, #60]	; (24d8 <udi_cdc_multi_getc+0x134>)
    249c:	0052      	lsls	r2, r2, #1
    249e:	52d1      	strh	r1, [r2, r3]

	udi_cdc_rx_start(port);
    24a0:	1dfb      	adds	r3, r7, #7
    24a2:	781b      	ldrb	r3, [r3, #0]
    24a4:	0018      	movs	r0, r3
    24a6:	4b12      	ldr	r3, [pc, #72]	; (24f0 <udi_cdc_multi_getc+0x14c>)
    24a8:	4798      	blx	r3

	if (b_databit_9) {
    24aa:	2313      	movs	r3, #19
    24ac:	18fb      	adds	r3, r7, r3
    24ae:	781b      	ldrb	r3, [r3, #0]
    24b0:	2b00      	cmp	r3, #0
    24b2:	d007      	beq.n	24c4 <udi_cdc_multi_getc+0x120>
		// Receive MSB
		b_databit_9 = false;
    24b4:	2313      	movs	r3, #19
    24b6:	18fb      	adds	r3, r7, r3
    24b8:	2200      	movs	r2, #0
    24ba:	701a      	strb	r2, [r3, #0]
		rx_data = rx_data << 8;
    24bc:	697b      	ldr	r3, [r7, #20]
    24be:	021b      	lsls	r3, r3, #8
    24c0:	617b      	str	r3, [r7, #20]
		goto udi_cdc_getc_process_one_byte;
    24c2:	e789      	b.n	23d8 <udi_cdc_multi_getc+0x34>
	}
	return rx_data;
    24c4:	697b      	ldr	r3, [r7, #20]
}
    24c6:	0018      	movs	r0, r3
    24c8:	46bd      	mov	sp, r7
    24ca:	b007      	add	sp, #28
    24cc:	bd90      	pop	{r4, r7, pc}
    24ce:	46c0      	nop			; (mov r8, r8)
    24d0:	20000204 	.word	0x20000204
    24d4:	0000193d 	.word	0x0000193d
    24d8:	200004a8 	.word	0x200004a8
    24dc:	200004a4 	.word	0x200004a4
    24e0:	200004a0 	.word	0x200004a0
    24e4:	00001985 	.word	0x00001985
    24e8:	2000021c 	.word	0x2000021c
    24ec:	20000220 	.word	0x20000220
    24f0:	00001df1 	.word	0x00001df1

000024f4 <udi_cdc_getc>:

int udi_cdc_getc(void)
{
    24f4:	b580      	push	{r7, lr}
    24f6:	af00      	add	r7, sp, #0
	return udi_cdc_multi_getc(0);
    24f8:	2000      	movs	r0, #0
    24fa:	4b03      	ldr	r3, [pc, #12]	; (2508 <udi_cdc_getc+0x14>)
    24fc:	4798      	blx	r3
    24fe:	0003      	movs	r3, r0
}
    2500:	0018      	movs	r0, r3
    2502:	46bd      	mov	sp, r7
    2504:	bd80      	pop	{r7, pc}
    2506:	46c0      	nop			; (mov r8, r8)
    2508:	000023a5 	.word	0x000023a5

0000250c <udi_cdc_multi_get_free_tx_buffer>:
{
	return udi_cdc_multi_read_buf(0, buf, size);
}

iram_size_t udi_cdc_multi_get_free_tx_buffer(uint8_t port)
{
    250c:	b580      	push	{r7, lr}
    250e:	b086      	sub	sp, #24
    2510:	af00      	add	r7, sp, #0
    2512:	0002      	movs	r2, r0
    2514:	1dfb      	adds	r3, r7, #7
    2516:	701a      	strb	r2, [r3, #0]
	irqflags_t flags;
	iram_size_t buf_sel_nb, retval;
	uint8_t buf_sel;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
    2518:	1dfb      	adds	r3, r7, #7
    251a:	2200      	movs	r2, #0
    251c:	701a      	strb	r2, [r3, #0]
#endif

	flags = cpu_irq_save();
    251e:	4b27      	ldr	r3, [pc, #156]	; (25bc <udi_cdc_multi_get_free_tx_buffer+0xb0>)
    2520:	4798      	blx	r3
    2522:	0003      	movs	r3, r0
    2524:	613b      	str	r3, [r7, #16]
	buf_sel = udi_cdc_tx_buf_sel[port];
    2526:	1dfb      	adds	r3, r7, #7
    2528:	781a      	ldrb	r2, [r3, #0]
    252a:	230f      	movs	r3, #15
    252c:	18fb      	adds	r3, r7, r3
    252e:	4924      	ldr	r1, [pc, #144]	; (25c0 <udi_cdc_multi_get_free_tx_buffer+0xb4>)
    2530:	5c8a      	ldrb	r2, [r1, r2]
    2532:	701a      	strb	r2, [r3, #0]
	buf_sel_nb = udi_cdc_tx_buf_nb[port][buf_sel];
    2534:	1dfb      	adds	r3, r7, #7
    2536:	7819      	ldrb	r1, [r3, #0]
    2538:	230f      	movs	r3, #15
    253a:	18fb      	adds	r3, r7, r3
    253c:	781a      	ldrb	r2, [r3, #0]
    253e:	4b21      	ldr	r3, [pc, #132]	; (25c4 <udi_cdc_multi_get_free_tx_buffer+0xb8>)
    2540:	0049      	lsls	r1, r1, #1
    2542:	188a      	adds	r2, r1, r2
    2544:	0052      	lsls	r2, r2, #1
    2546:	5ad3      	ldrh	r3, [r2, r3]
    2548:	617b      	str	r3, [r7, #20]
	if (buf_sel_nb == UDI_CDC_TX_BUFFERS) {
    254a:	697a      	ldr	r2, [r7, #20]
    254c:	23a0      	movs	r3, #160	; 0xa0
    254e:	005b      	lsls	r3, r3, #1
    2550:	429a      	cmp	r2, r3
    2552:	d125      	bne.n	25a0 <udi_cdc_multi_get_free_tx_buffer+0x94>
		if ((!udi_cdc_tx_trans_ongoing[port])
    2554:	1dfb      	adds	r3, r7, #7
    2556:	781b      	ldrb	r3, [r3, #0]
    2558:	4a1b      	ldr	r2, [pc, #108]	; (25c8 <udi_cdc_multi_get_free_tx_buffer+0xbc>)
    255a:	5cd3      	ldrb	r3, [r2, r3]
    255c:	b2db      	uxtb	r3, r3
    255e:	2201      	movs	r2, #1
    2560:	4053      	eors	r3, r2
    2562:	b2db      	uxtb	r3, r3
    2564:	2b00      	cmp	r3, #0
    2566:	d01b      	beq.n	25a0 <udi_cdc_multi_get_free_tx_buffer+0x94>
			&& (!udi_cdc_tx_both_buf_to_send[port])) {
    2568:	1dfb      	adds	r3, r7, #7
    256a:	781b      	ldrb	r3, [r3, #0]
    256c:	4a17      	ldr	r2, [pc, #92]	; (25cc <udi_cdc_multi_get_free_tx_buffer+0xc0>)
    256e:	5cd3      	ldrb	r3, [r2, r3]
    2570:	b2db      	uxtb	r3, r3
    2572:	2201      	movs	r2, #1
    2574:	4053      	eors	r3, r2
    2576:	b2db      	uxtb	r3, r3
    2578:	2b00      	cmp	r3, #0
    257a:	d011      	beq.n	25a0 <udi_cdc_multi_get_free_tx_buffer+0x94>
			/* One buffer is full, but the other buffer is not used.
			 * (not used = transfer on-going)
			 * then move to the other buffer to store data */
			udi_cdc_tx_both_buf_to_send[port] = true;
    257c:	1dfb      	adds	r3, r7, #7
    257e:	781b      	ldrb	r3, [r3, #0]
    2580:	4a12      	ldr	r2, [pc, #72]	; (25cc <udi_cdc_multi_get_free_tx_buffer+0xc0>)
    2582:	2101      	movs	r1, #1
    2584:	54d1      	strb	r1, [r2, r3]
			udi_cdc_tx_buf_sel[port] = (buf_sel == 0)? 1 : 0;
    2586:	1dfb      	adds	r3, r7, #7
    2588:	781b      	ldrb	r3, [r3, #0]
    258a:	220f      	movs	r2, #15
    258c:	18ba      	adds	r2, r7, r2
    258e:	7812      	ldrb	r2, [r2, #0]
    2590:	4251      	negs	r1, r2
    2592:	414a      	adcs	r2, r1
    2594:	b2d2      	uxtb	r2, r2
    2596:	0011      	movs	r1, r2
    2598:	4a09      	ldr	r2, [pc, #36]	; (25c0 <udi_cdc_multi_get_free_tx_buffer+0xb4>)
    259a:	54d1      	strb	r1, [r2, r3]
			buf_sel_nb = 0;
    259c:	2300      	movs	r3, #0
    259e:	617b      	str	r3, [r7, #20]
		}
	}
	retval = UDI_CDC_TX_BUFFERS - buf_sel_nb;  
    25a0:	697b      	ldr	r3, [r7, #20]
    25a2:	22a0      	movs	r2, #160	; 0xa0
    25a4:	0052      	lsls	r2, r2, #1
    25a6:	1ad3      	subs	r3, r2, r3
    25a8:	60bb      	str	r3, [r7, #8]
	cpu_irq_restore(flags);
    25aa:	693b      	ldr	r3, [r7, #16]
    25ac:	0018      	movs	r0, r3
    25ae:	4b08      	ldr	r3, [pc, #32]	; (25d0 <udi_cdc_multi_get_free_tx_buffer+0xc4>)
    25b0:	4798      	blx	r3
	return retval;
    25b2:	68bb      	ldr	r3, [r7, #8]
}
    25b4:	0018      	movs	r0, r3
    25b6:	46bd      	mov	sp, r7
    25b8:	b006      	add	sp, #24
    25ba:	bd80      	pop	{r7, pc}
    25bc:	0000193d 	.word	0x0000193d
    25c0:	20000734 	.word	0x20000734
    25c4:	20000730 	.word	0x20000730
    25c8:	2000073c 	.word	0x2000073c
    25cc:	20000740 	.word	0x20000740
    25d0:	00001985 	.word	0x00001985

000025d4 <udi_cdc_multi_is_tx_ready>:
{
	return udi_cdc_multi_get_free_tx_buffer(0);
}

bool udi_cdc_multi_is_tx_ready(uint8_t port)
{
    25d4:	b580      	push	{r7, lr}
    25d6:	b082      	sub	sp, #8
    25d8:	af00      	add	r7, sp, #0
    25da:	0002      	movs	r2, r0
    25dc:	1dfb      	adds	r3, r7, #7
    25de:	701a      	strb	r2, [r3, #0]
	return (udi_cdc_multi_get_free_tx_buffer(port) != 0);
    25e0:	1dfb      	adds	r3, r7, #7
    25e2:	781b      	ldrb	r3, [r3, #0]
    25e4:	0018      	movs	r0, r3
    25e6:	4b05      	ldr	r3, [pc, #20]	; (25fc <udi_cdc_multi_is_tx_ready+0x28>)
    25e8:	4798      	blx	r3
    25ea:	0003      	movs	r3, r0
    25ec:	1e5a      	subs	r2, r3, #1
    25ee:	4193      	sbcs	r3, r2
    25f0:	b2db      	uxtb	r3, r3
}
    25f2:	0018      	movs	r0, r3
    25f4:	46bd      	mov	sp, r7
    25f6:	b002      	add	sp, #8
    25f8:	bd80      	pop	{r7, pc}
    25fa:	46c0      	nop			; (mov r8, r8)
    25fc:	0000250d 	.word	0x0000250d

00002600 <udi_cdc_multi_putc>:
{
	return udi_cdc_multi_is_tx_ready(0);
}

int udi_cdc_multi_putc(uint8_t port, int value)
{
    2600:	b5f0      	push	{r4, r5, r6, r7, lr}
    2602:	b087      	sub	sp, #28
    2604:	af00      	add	r7, sp, #0
    2606:	0002      	movs	r2, r0
    2608:	6039      	str	r1, [r7, #0]
    260a:	1dfb      	adds	r3, r7, #7
    260c:	701a      	strb	r2, [r3, #0]
	irqflags_t flags;
	bool b_databit_9;
	uint8_t buf_sel;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
    260e:	1dfb      	adds	r3, r7, #7
    2610:	2200      	movs	r2, #0
    2612:	701a      	strb	r2, [r3, #0]
#endif

	b_databit_9 = (9 == udi_cdc_line_coding[port].bDataBits);
    2614:	1dfb      	adds	r3, r7, #7
    2616:	781a      	ldrb	r2, [r3, #0]
    2618:	4939      	ldr	r1, [pc, #228]	; (2700 <udi_cdc_multi_putc+0x100>)
    261a:	0013      	movs	r3, r2
    261c:	00db      	lsls	r3, r3, #3
    261e:	1a9b      	subs	r3, r3, r2
    2620:	18cb      	adds	r3, r1, r3
    2622:	3306      	adds	r3, #6
    2624:	781a      	ldrb	r2, [r3, #0]
    2626:	2317      	movs	r3, #23
    2628:	18fb      	adds	r3, r7, r3
    262a:	3a09      	subs	r2, #9
    262c:	4251      	negs	r1, r2
    262e:	414a      	adcs	r2, r1
    2630:	701a      	strb	r2, [r3, #0]

udi_cdc_putc_process_one_byte:
	// Check available space
	if (!udi_cdc_multi_is_tx_ready(port)) {
    2632:	1dfb      	adds	r3, r7, #7
    2634:	781b      	ldrb	r3, [r3, #0]
    2636:	0018      	movs	r0, r3
    2638:	4b32      	ldr	r3, [pc, #200]	; (2704 <udi_cdc_multi_putc+0x104>)
    263a:	4798      	blx	r3
    263c:	0003      	movs	r3, r0
    263e:	001a      	movs	r2, r3
    2640:	2301      	movs	r3, #1
    2642:	4053      	eors	r3, r2
    2644:	b2db      	uxtb	r3, r3
    2646:	2b00      	cmp	r3, #0
    2648:	d010      	beq.n	266c <udi_cdc_multi_putc+0x6c>
		if (!udi_cdc_data_running) {
    264a:	4b2f      	ldr	r3, [pc, #188]	; (2708 <udi_cdc_multi_putc+0x108>)
    264c:	781b      	ldrb	r3, [r3, #0]
    264e:	b2db      	uxtb	r3, r3
    2650:	2201      	movs	r2, #1
    2652:	4053      	eors	r3, r2
    2654:	b2db      	uxtb	r3, r3
    2656:	2b00      	cmp	r3, #0
    2658:	d001      	beq.n	265e <udi_cdc_multi_putc+0x5e>
			return false;
    265a:	2300      	movs	r3, #0
    265c:	e04b      	b.n	26f6 <udi_cdc_multi_putc+0xf6>
    265e:	2317      	movs	r3, #23
    2660:	18fb      	adds	r3, r7, r3
    2662:	2217      	movs	r2, #23
    2664:	18ba      	adds	r2, r7, r2
    2666:	7812      	ldrb	r2, [r2, #0]
    2668:	701a      	strb	r2, [r3, #0]
		}
		goto udi_cdc_putc_process_one_byte;
    266a:	e7e2      	b.n	2632 <udi_cdc_multi_putc+0x32>
	}

	// Write value
	flags = cpu_irq_save();
    266c:	4b27      	ldr	r3, [pc, #156]	; (270c <udi_cdc_multi_putc+0x10c>)
    266e:	4798      	blx	r3
    2670:	0003      	movs	r3, r0
    2672:	613b      	str	r3, [r7, #16]
	buf_sel = udi_cdc_tx_buf_sel[port];
    2674:	1dfb      	adds	r3, r7, #7
    2676:	781a      	ldrb	r2, [r3, #0]
    2678:	230f      	movs	r3, #15
    267a:	18fb      	adds	r3, r7, r3
    267c:	4924      	ldr	r1, [pc, #144]	; (2710 <udi_cdc_multi_putc+0x110>)
    267e:	5c8a      	ldrb	r2, [r1, r2]
    2680:	701a      	strb	r2, [r3, #0]
	udi_cdc_tx_buf[port][buf_sel][udi_cdc_tx_buf_nb[port][buf_sel]++] = value;
    2682:	1dfb      	adds	r3, r7, #7
    2684:	7819      	ldrb	r1, [r3, #0]
    2686:	230f      	movs	r3, #15
    2688:	18fb      	adds	r3, r7, r3
    268a:	7818      	ldrb	r0, [r3, #0]
    268c:	1dfb      	adds	r3, r7, #7
    268e:	781a      	ldrb	r2, [r3, #0]
    2690:	230f      	movs	r3, #15
    2692:	18fb      	adds	r3, r7, r3
    2694:	781b      	ldrb	r3, [r3, #0]
    2696:	4c1f      	ldr	r4, [pc, #124]	; (2714 <udi_cdc_multi_putc+0x114>)
    2698:	0055      	lsls	r5, r2, #1
    269a:	18ed      	adds	r5, r5, r3
    269c:	006d      	lsls	r5, r5, #1
    269e:	5b2c      	ldrh	r4, [r5, r4]
    26a0:	1c65      	adds	r5, r4, #1
    26a2:	b2ae      	uxth	r6, r5
    26a4:	4d1b      	ldr	r5, [pc, #108]	; (2714 <udi_cdc_multi_putc+0x114>)
    26a6:	0052      	lsls	r2, r2, #1
    26a8:	18d3      	adds	r3, r2, r3
    26aa:	005b      	lsls	r3, r3, #1
    26ac:	1c32      	adds	r2, r6, #0
    26ae:	535a      	strh	r2, [r3, r5]
    26b0:	0025      	movs	r5, r4
    26b2:	683b      	ldr	r3, [r7, #0]
    26b4:	b2de      	uxtb	r6, r3
    26b6:	4c18      	ldr	r4, [pc, #96]	; (2718 <udi_cdc_multi_putc+0x118>)
    26b8:	0002      	movs	r2, r0
    26ba:	0092      	lsls	r2, r2, #2
    26bc:	1812      	adds	r2, r2, r0
    26be:	0193      	lsls	r3, r2, #6
    26c0:	001a      	movs	r2, r3
    26c2:	000b      	movs	r3, r1
    26c4:	009b      	lsls	r3, r3, #2
    26c6:	185b      	adds	r3, r3, r1
    26c8:	01db      	lsls	r3, r3, #7
    26ca:	18d3      	adds	r3, r2, r3
    26cc:	18e3      	adds	r3, r4, r3
    26ce:	1c32      	adds	r2, r6, #0
    26d0:	555a      	strb	r2, [r3, r5]
	cpu_irq_restore(flags);
    26d2:	693b      	ldr	r3, [r7, #16]
    26d4:	0018      	movs	r0, r3
    26d6:	4b11      	ldr	r3, [pc, #68]	; (271c <udi_cdc_multi_putc+0x11c>)
    26d8:	4798      	blx	r3

	if (b_databit_9) {
    26da:	2317      	movs	r3, #23
    26dc:	18fb      	adds	r3, r7, r3
    26de:	781b      	ldrb	r3, [r3, #0]
    26e0:	2b00      	cmp	r3, #0
    26e2:	d007      	beq.n	26f4 <udi_cdc_multi_putc+0xf4>
		// Send MSB
		b_databit_9 = false;
    26e4:	2317      	movs	r3, #23
    26e6:	18fb      	adds	r3, r7, r3
    26e8:	2200      	movs	r2, #0
    26ea:	701a      	strb	r2, [r3, #0]
		value = value >> 8;
    26ec:	683b      	ldr	r3, [r7, #0]
    26ee:	121b      	asrs	r3, r3, #8
    26f0:	603b      	str	r3, [r7, #0]
		goto udi_cdc_putc_process_one_byte;
    26f2:	e79e      	b.n	2632 <udi_cdc_multi_putc+0x32>
	}
	return true;
    26f4:	2301      	movs	r3, #1
}
    26f6:	0018      	movs	r0, r3
    26f8:	46bd      	mov	sp, r7
    26fa:	b007      	add	sp, #28
    26fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    26fe:	46c0      	nop			; (mov r8, r8)
    2700:	20000204 	.word	0x20000204
    2704:	000025d5 	.word	0x000025d5
    2708:	2000021c 	.word	0x2000021c
    270c:	0000193d 	.word	0x0000193d
    2710:	20000734 	.word	0x20000734
    2714:	20000730 	.word	0x20000730
    2718:	200004b0 	.word	0x200004b0
    271c:	00001985 	.word	0x00001985

00002720 <udi_cdc_putc>:

int udi_cdc_putc(int value)
{
    2720:	b580      	push	{r7, lr}
    2722:	b082      	sub	sp, #8
    2724:	af00      	add	r7, sp, #0
    2726:	6078      	str	r0, [r7, #4]
	return udi_cdc_multi_putc(0, value);
    2728:	687b      	ldr	r3, [r7, #4]
    272a:	0019      	movs	r1, r3
    272c:	2000      	movs	r0, #0
    272e:	4b03      	ldr	r3, [pc, #12]	; (273c <udi_cdc_putc+0x1c>)
    2730:	4798      	blx	r3
    2732:	0003      	movs	r3, r0
}
    2734:	0018      	movs	r0, r3
    2736:	46bd      	mov	sp, r7
    2738:	b002      	add	sp, #8
    273a:	bd80      	pop	{r7, pc}
    273c:	00002601 	.word	0x00002601

00002740 <udc_get_eof_conf>:
 * \brief Returns a value to check the end of USB Configuration descriptor
 *
 * \return address after the last byte of USB Configuration descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
    2740:	b580      	push	{r7, lr}
    2742:	af00      	add	r7, sp, #0
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
			udc_ptr_conf->desc +
    2744:	4b07      	ldr	r3, [pc, #28]	; (2764 <udc_get_eof_conf+0x24>)
    2746:	681b      	ldr	r3, [r3, #0]
    2748:	681a      	ldr	r2, [r3, #0]
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
    274a:	4b06      	ldr	r3, [pc, #24]	; (2764 <udc_get_eof_conf+0x24>)
    274c:	681b      	ldr	r3, [r3, #0]
    274e:	681b      	ldr	r3, [r3, #0]
    2750:	7899      	ldrb	r1, [r3, #2]
    2752:	78db      	ldrb	r3, [r3, #3]
    2754:	021b      	lsls	r3, r3, #8
    2756:	430b      	orrs	r3, r1
    2758:	b29b      	uxth	r3, r3
 *
 * \return address after the last byte of USB Configuration descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
    275a:	18d3      	adds	r3, r2, r3
			udc_ptr_conf->desc +
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
}
    275c:	0018      	movs	r0, r3
    275e:	46bd      	mov	sp, r7
    2760:	bd80      	pop	{r7, pc}
    2762:	46c0      	nop			; (mov r8, r8)
    2764:	20000750 	.word	0x20000750

00002768 <udc_next_desc_in_iface>:
 * \return address of specific descriptor found
 * \return NULL if it is the end of global interface descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t
		UDC_DESC_STORAGE * desc, uint8_t desc_id)
{
    2768:	b580      	push	{r7, lr}
    276a:	b084      	sub	sp, #16
    276c:	af00      	add	r7, sp, #0
    276e:	6078      	str	r0, [r7, #4]
    2770:	000a      	movs	r2, r1
    2772:	1cfb      	adds	r3, r7, #3
    2774:	701a      	strb	r2, [r3, #0]
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;

	ptr_eof_desc = udc_get_eof_conf();
    2776:	4b14      	ldr	r3, [pc, #80]	; (27c8 <udc_next_desc_in_iface+0x60>)
    2778:	4798      	blx	r3
    277a:	0003      	movs	r3, r0
    277c:	60fb      	str	r3, [r7, #12]
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
			desc->bLength);
    277e:	687b      	ldr	r3, [r7, #4]
    2780:	781b      	ldrb	r3, [r3, #0]
{
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;

	ptr_eof_desc = udc_get_eof_conf();
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
    2782:	001a      	movs	r2, r3
    2784:	687b      	ldr	r3, [r7, #4]
    2786:	189b      	adds	r3, r3, r2
    2788:	607b      	str	r3, [r7, #4]
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
    278a:	e011      	b.n	27b0 <udc_next_desc_in_iface+0x48>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
    278c:	687b      	ldr	r3, [r7, #4]
    278e:	785b      	ldrb	r3, [r3, #1]
    2790:	2b04      	cmp	r3, #4
    2792:	d012      	beq.n	27ba <udc_next_desc_in_iface+0x52>
			break; // End of global interface descriptor
		}
		if (desc_id == desc->bDescriptorType) {
    2794:	687b      	ldr	r3, [r7, #4]
    2796:	785b      	ldrb	r3, [r3, #1]
    2798:	1cfa      	adds	r2, r7, #3
    279a:	7812      	ldrb	r2, [r2, #0]
    279c:	429a      	cmp	r2, r3
    279e:	d101      	bne.n	27a4 <udc_next_desc_in_iface+0x3c>
			return desc; // Specific descriptor found
    27a0:	687b      	ldr	r3, [r7, #4]
    27a2:	e00c      	b.n	27be <udc_next_desc_in_iface+0x56>
		}
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
				desc->bLength);
    27a4:	687b      	ldr	r3, [r7, #4]
    27a6:	781b      	ldrb	r3, [r3, #0]
		}
		if (desc_id == desc->bDescriptorType) {
			return desc; // Specific descriptor found
		}
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
    27a8:	001a      	movs	r2, r3
    27aa:	687b      	ldr	r3, [r7, #4]
    27ac:	189b      	adds	r3, r3, r2
    27ae:	607b      	str	r3, [r7, #4]
	ptr_eof_desc = udc_get_eof_conf();
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
    27b0:	68fa      	ldr	r2, [r7, #12]
    27b2:	687b      	ldr	r3, [r7, #4]
    27b4:	429a      	cmp	r2, r3
    27b6:	d8e9      	bhi.n	278c <udc_next_desc_in_iface+0x24>
    27b8:	e000      	b.n	27bc <udc_next_desc_in_iface+0x54>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
			break; // End of global interface descriptor
    27ba:	46c0      	nop			; (mov r8, r8)
		}
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
				desc->bLength);
	}
	return NULL; // No specific descriptor found
    27bc:	2300      	movs	r3, #0
}
    27be:	0018      	movs	r0, r3
    27c0:	46bd      	mov	sp, r7
    27c2:	b004      	add	sp, #16
    27c4:	bd80      	pop	{r7, pc}
    27c6:	46c0      	nop			; (mov r8, r8)
    27c8:	00002741 	.word	0x00002741

000027cc <udc_update_iface_desc>:
 * \param setting_num   Setting number of interface to find
 *
 * \return 1 if found or 0 if not found
 */
static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
{
    27cc:	b580      	push	{r7, lr}
    27ce:	b084      	sub	sp, #16
    27d0:	af00      	add	r7, sp, #0
    27d2:	0002      	movs	r2, r0
    27d4:	1dfb      	adds	r3, r7, #7
    27d6:	701a      	strb	r2, [r3, #0]
    27d8:	1dbb      	adds	r3, r7, #6
    27da:	1c0a      	adds	r2, r1, #0
    27dc:	701a      	strb	r2, [r3, #0]
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;

	if (0 == udc_num_configuration) {
    27de:	4b20      	ldr	r3, [pc, #128]	; (2860 <udc_update_iface_desc+0x94>)
    27e0:	781b      	ldrb	r3, [r3, #0]
    27e2:	2b00      	cmp	r3, #0
    27e4:	d101      	bne.n	27ea <udc_update_iface_desc+0x1e>
		return false;
    27e6:	2300      	movs	r3, #0
    27e8:	e036      	b.n	2858 <udc_update_iface_desc+0x8c>
	}

	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
    27ea:	4b1e      	ldr	r3, [pc, #120]	; (2864 <udc_update_iface_desc+0x98>)
    27ec:	681b      	ldr	r3, [r3, #0]
    27ee:	681b      	ldr	r3, [r3, #0]
    27f0:	791b      	ldrb	r3, [r3, #4]
    27f2:	1dfa      	adds	r2, r7, #7
    27f4:	7812      	ldrb	r2, [r2, #0]
    27f6:	429a      	cmp	r2, r3
    27f8:	d301      	bcc.n	27fe <udc_update_iface_desc+0x32>
		return false;
    27fa:	2300      	movs	r3, #0
    27fc:	e02c      	b.n	2858 <udc_update_iface_desc+0x8c>
	}

	// Start at the beginning of configuration descriptor
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;
    27fe:	4b19      	ldr	r3, [pc, #100]	; (2864 <udc_update_iface_desc+0x98>)
    2800:	681b      	ldr	r3, [r3, #0]
    2802:	681a      	ldr	r2, [r3, #0]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
		return false;
	}

	// Start at the beginning of configuration descriptor
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
    2804:	4b18      	ldr	r3, [pc, #96]	; (2868 <udc_update_iface_desc+0x9c>)
    2806:	601a      	str	r2, [r3, #0]
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
    2808:	4b18      	ldr	r3, [pc, #96]	; (286c <udc_update_iface_desc+0xa0>)
    280a:	4798      	blx	r3
    280c:	0003      	movs	r3, r0
    280e:	60fb      	str	r3, [r7, #12]
	while (ptr_end_desc >
    2810:	e01c      	b.n	284c <udc_update_iface_desc+0x80>
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
    2812:	4b15      	ldr	r3, [pc, #84]	; (2868 <udc_update_iface_desc+0x9c>)
    2814:	681b      	ldr	r3, [r3, #0]
    2816:	785b      	ldrb	r3, [r3, #1]
    2818:	2b04      	cmp	r3, #4
    281a:	d10f      	bne.n	283c <udc_update_iface_desc+0x70>
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
    281c:	4b12      	ldr	r3, [pc, #72]	; (2868 <udc_update_iface_desc+0x9c>)
    281e:	681b      	ldr	r3, [r3, #0]
    2820:	789b      	ldrb	r3, [r3, #2]
    2822:	1dfa      	adds	r2, r7, #7
    2824:	7812      	ldrb	r2, [r2, #0]
    2826:	429a      	cmp	r2, r3
    2828:	d108      	bne.n	283c <udc_update_iface_desc+0x70>
					(setting_num ==
					udc_ptr_iface->bAlternateSetting)) {
    282a:	4b0f      	ldr	r3, [pc, #60]	; (2868 <udc_update_iface_desc+0x9c>)
    282c:	681b      	ldr	r3, [r3, #0]
    282e:	78db      	ldrb	r3, [r3, #3]
	while (ptr_end_desc >
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
    2830:	1dba      	adds	r2, r7, #6
    2832:	7812      	ldrb	r2, [r2, #0]
    2834:	429a      	cmp	r2, r3
    2836:	d101      	bne.n	283c <udc_update_iface_desc+0x70>
					(setting_num ==
					udc_ptr_iface->bAlternateSetting)) {
				return true; // Interface found
    2838:	2301      	movs	r3, #1
    283a:	e00d      	b.n	2858 <udc_update_iface_desc+0x8c>
			}
		}
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
    283c:	4b0a      	ldr	r3, [pc, #40]	; (2868 <udc_update_iface_desc+0x9c>)
    283e:	681a      	ldr	r2, [r3, #0]
				(uint8_t *) udc_ptr_iface +
				udc_ptr_iface->bLength);
    2840:	4b09      	ldr	r3, [pc, #36]	; (2868 <udc_update_iface_desc+0x9c>)
    2842:	681b      	ldr	r3, [r3, #0]
    2844:	781b      	ldrb	r3, [r3, #0]
					udc_ptr_iface->bAlternateSetting)) {
				return true; // Interface found
			}
		}
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
    2846:	18d2      	adds	r2, r2, r3
    2848:	4b07      	ldr	r3, [pc, #28]	; (2868 <udc_update_iface_desc+0x9c>)
    284a:	601a      	str	r2, [r3, #0]
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
    284c:	4b06      	ldr	r3, [pc, #24]	; (2868 <udc_update_iface_desc+0x9c>)
    284e:	681b      	ldr	r3, [r3, #0]
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
    2850:	68fa      	ldr	r2, [r7, #12]
    2852:	429a      	cmp	r2, r3
    2854:	d8dd      	bhi.n	2812 <udc_update_iface_desc+0x46>
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
				(uint8_t *) udc_ptr_iface +
				udc_ptr_iface->bLength);
	}
	return false; // Interface not found
    2856:	2300      	movs	r3, #0
}
    2858:	0018      	movs	r0, r3
    285a:	46bd      	mov	sp, r7
    285c:	b004      	add	sp, #16
    285e:	bd80      	pop	{r7, pc}
    2860:	2000074c 	.word	0x2000074c
    2864:	20000750 	.word	0x20000750
    2868:	20000754 	.word	0x20000754
    286c:	00002741 	.word	0x00002741

00002870 <udc_iface_disable>:
 * \param iface_num     Interface number to disable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_disable(uint8_t iface_num)
{
    2870:	b580      	push	{r7, lr}
    2872:	b084      	sub	sp, #16
    2874:	af00      	add	r7, sp, #0
    2876:	0002      	movs	r2, r0
    2878:	1dfb      	adds	r3, r7, #7
    287a:	701a      	strb	r2, [r3, #0]
	udi_api_t UDC_DESC_STORAGE *udi_api;

	// Select first alternate setting of the interface
	// to update udc_ptr_iface before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
    287c:	1dfb      	adds	r3, r7, #7
    287e:	781b      	ldrb	r3, [r3, #0]
    2880:	2100      	movs	r1, #0
    2882:	0018      	movs	r0, r3
    2884:	4b21      	ldr	r3, [pc, #132]	; (290c <udc_iface_disable+0x9c>)
    2886:	4798      	blx	r3
    2888:	0003      	movs	r3, r0
    288a:	001a      	movs	r2, r3
    288c:	2301      	movs	r3, #1
    288e:	4053      	eors	r3, r2
    2890:	b2db      	uxtb	r3, r3
    2892:	2b00      	cmp	r3, #0
    2894:	d001      	beq.n	289a <udc_iface_disable+0x2a>
		return false;
    2896:	2300      	movs	r3, #0
    2898:	e034      	b.n	2904 <udc_iface_disable+0x94>
	}

	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
    289a:	4b1d      	ldr	r3, [pc, #116]	; (2910 <udc_iface_disable+0xa0>)
    289c:	681b      	ldr	r3, [r3, #0]
    289e:	685a      	ldr	r2, [r3, #4]
    28a0:	1dfb      	adds	r3, r7, #7
    28a2:	781b      	ldrb	r3, [r3, #0]
    28a4:	009b      	lsls	r3, r3, #2
    28a6:	18d3      	adds	r3, r2, r3
    28a8:	681b      	ldr	r3, [r3, #0]
    28aa:	60bb      	str	r3, [r7, #8]

#if (0!=USB_DEVICE_MAX_EP)
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
    28ac:	68bb      	ldr	r3, [r7, #8]
    28ae:	68db      	ldr	r3, [r3, #12]
    28b0:	4798      	blx	r3
    28b2:	0003      	movs	r3, r0
    28b4:	001a      	movs	r2, r3
    28b6:	1dfb      	adds	r3, r7, #7
    28b8:	781b      	ldrb	r3, [r3, #0]
    28ba:	0011      	movs	r1, r2
    28bc:	0018      	movs	r0, r3
    28be:	4b13      	ldr	r3, [pc, #76]	; (290c <udc_iface_disable+0x9c>)
    28c0:	4798      	blx	r3
    28c2:	0003      	movs	r3, r0
    28c4:	001a      	movs	r2, r3
    28c6:	2301      	movs	r3, #1
    28c8:	4053      	eors	r3, r2
    28ca:	b2db      	uxtb	r3, r3
    28cc:	2b00      	cmp	r3, #0
    28ce:	d001      	beq.n	28d4 <udc_iface_disable+0x64>
		return false;
    28d0:	2300      	movs	r3, #0
    28d2:	e017      	b.n	2904 <udc_iface_disable+0x94>
	}

	// Start at the beginning of interface descriptor
	{
		usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
    28d4:	4b0f      	ldr	r3, [pc, #60]	; (2914 <udc_iface_disable+0xa4>)
    28d6:	681b      	ldr	r3, [r3, #0]
    28d8:	60fb      	str	r3, [r7, #12]
		while (1) {
			// Search Endpoint descriptor included in global interface descriptor
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
    28da:	68fb      	ldr	r3, [r7, #12]
    28dc:	2105      	movs	r1, #5
    28de:	0018      	movs	r0, r3
    28e0:	4b0d      	ldr	r3, [pc, #52]	; (2918 <udc_iface_disable+0xa8>)
    28e2:	4798      	blx	r3
    28e4:	0003      	movs	r3, r0
    28e6:	60fb      	str	r3, [r7, #12]
					udc_next_desc_in_iface((UDC_DESC_STORAGE
					usb_conf_desc_t *)
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc) {
    28e8:	68fb      	ldr	r3, [r7, #12]
    28ea:	2b00      	cmp	r3, #0
    28ec:	d005      	beq.n	28fa <udc_iface_disable+0x8a>
				break;
			}
			// Free the endpoint used by the interface
			udd_ep_free(ep_desc->bEndpointAddress);
    28ee:	68fb      	ldr	r3, [r7, #12]
    28f0:	789b      	ldrb	r3, [r3, #2]
    28f2:	0018      	movs	r0, r3
    28f4:	4b09      	ldr	r3, [pc, #36]	; (291c <udc_iface_disable+0xac>)
    28f6:	4798      	blx	r3
		}
    28f8:	e7ef      	b.n	28da <udc_iface_disable+0x6a>
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
					udc_next_desc_in_iface((UDC_DESC_STORAGE
					usb_conf_desc_t *)
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc) {
				break;
    28fa:	46c0      	nop			; (mov r8, r8)
		}
	}
#endif

	// Disable interface
	udi_api->disable();
    28fc:	68bb      	ldr	r3, [r7, #8]
    28fe:	685b      	ldr	r3, [r3, #4]
    2900:	4798      	blx	r3
	return true;
    2902:	2301      	movs	r3, #1
}
    2904:	0018      	movs	r0, r3
    2906:	46bd      	mov	sp, r7
    2908:	b004      	add	sp, #16
    290a:	bd80      	pop	{r7, pc}
    290c:	000027cd 	.word	0x000027cd
    2910:	20000750 	.word	0x20000750
    2914:	20000754 	.word	0x20000754
    2918:	00002769 	.word	0x00002769
    291c:	00004ab1 	.word	0x00004ab1

00002920 <udc_iface_enable>:
 * \param setting_num   Setting number to enable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_enable(uint8_t iface_num, uint8_t setting_num)
{
    2920:	b580      	push	{r7, lr}
    2922:	b084      	sub	sp, #16
    2924:	af00      	add	r7, sp, #0
    2926:	0002      	movs	r2, r0
    2928:	1dfb      	adds	r3, r7, #7
    292a:	701a      	strb	r2, [r3, #0]
    292c:	1dbb      	adds	r3, r7, #6
    292e:	1c0a      	adds	r2, r1, #0
    2930:	701a      	strb	r2, [r3, #0]
	// Select the interface descriptor
	if (!udc_update_iface_desc(iface_num, setting_num)) {
    2932:	1dbb      	adds	r3, r7, #6
    2934:	781a      	ldrb	r2, [r3, #0]
    2936:	1dfb      	adds	r3, r7, #7
    2938:	781b      	ldrb	r3, [r3, #0]
    293a:	0011      	movs	r1, r2
    293c:	0018      	movs	r0, r3
    293e:	4b1f      	ldr	r3, [pc, #124]	; (29bc <udc_iface_enable+0x9c>)
    2940:	4798      	blx	r3
    2942:	0003      	movs	r3, r0
    2944:	001a      	movs	r2, r3
    2946:	2301      	movs	r3, #1
    2948:	4053      	eors	r3, r2
    294a:	b2db      	uxtb	r3, r3
    294c:	2b00      	cmp	r3, #0
    294e:	d001      	beq.n	2954 <udc_iface_enable+0x34>
		return false;
    2950:	2300      	movs	r3, #0
    2952:	e02e      	b.n	29b2 <udc_iface_enable+0x92>

#if (0!=USB_DEVICE_MAX_EP)
	usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
    2954:	4b1a      	ldr	r3, [pc, #104]	; (29c0 <udc_iface_enable+0xa0>)
    2956:	681b      	ldr	r3, [r3, #0]
    2958:	60fb      	str	r3, [r7, #12]
	while (1) {
		// Search Endpoint descriptor included in the global interface descriptor
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
    295a:	68fb      	ldr	r3, [r7, #12]
    295c:	2105      	movs	r1, #5
    295e:	0018      	movs	r0, r3
    2960:	4b18      	ldr	r3, [pc, #96]	; (29c4 <udc_iface_enable+0xa4>)
    2962:	4798      	blx	r3
    2964:	0003      	movs	r3, r0
    2966:	60fb      	str	r3, [r7, #12]
				udc_next_desc_in_iface((UDC_DESC_STORAGE
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
    2968:	68fb      	ldr	r3, [r7, #12]
    296a:	2b00      	cmp	r3, #0
    296c:	d015      	beq.n	299a <udc_iface_enable+0x7a>
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
    296e:	68fb      	ldr	r3, [r7, #12]
    2970:	7898      	ldrb	r0, [r3, #2]
    2972:	68fb      	ldr	r3, [r7, #12]
    2974:	78d9      	ldrb	r1, [r3, #3]
    2976:	68fb      	ldr	r3, [r7, #12]
    2978:	791a      	ldrb	r2, [r3, #4]
    297a:	795b      	ldrb	r3, [r3, #5]
    297c:	021b      	lsls	r3, r3, #8
    297e:	4313      	orrs	r3, r2
    2980:	b29b      	uxth	r3, r3
    2982:	001a      	movs	r2, r3
    2984:	4b10      	ldr	r3, [pc, #64]	; (29c8 <udc_iface_enable+0xa8>)
    2986:	4798      	blx	r3
    2988:	0003      	movs	r3, r0
    298a:	001a      	movs	r2, r3
    298c:	2301      	movs	r3, #1
    298e:	4053      	eors	r3, r2
    2990:	b2db      	uxtb	r3, r3
    2992:	2b00      	cmp	r3, #0
    2994:	d0e1      	beq.n	295a <udc_iface_enable+0x3a>
				ep_desc->bmAttributes,
				le16_to_cpu
				(ep_desc->wMaxPacketSize))) {
			return false;
    2996:	2300      	movs	r3, #0
    2998:	e00b      	b.n	29b2 <udc_iface_enable+0x92>
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
				udc_next_desc_in_iface((UDC_DESC_STORAGE
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
			break;
    299a:	46c0      	nop			; (mov r8, r8)
			return false;
		}
	}
#endif
	// Enable the interface
	return udc_ptr_conf->udi_apis[iface_num]->enable();
    299c:	4b0b      	ldr	r3, [pc, #44]	; (29cc <udc_iface_enable+0xac>)
    299e:	681b      	ldr	r3, [r3, #0]
    29a0:	685a      	ldr	r2, [r3, #4]
    29a2:	1dfb      	adds	r3, r7, #7
    29a4:	781b      	ldrb	r3, [r3, #0]
    29a6:	009b      	lsls	r3, r3, #2
    29a8:	18d3      	adds	r3, r2, r3
    29aa:	681b      	ldr	r3, [r3, #0]
    29ac:	681b      	ldr	r3, [r3, #0]
    29ae:	4798      	blx	r3
    29b0:	0003      	movs	r3, r0
}
    29b2:	0018      	movs	r0, r3
    29b4:	46bd      	mov	sp, r7
    29b6:	b004      	add	sp, #16
    29b8:	bd80      	pop	{r7, pc}
    29ba:	46c0      	nop			; (mov r8, r8)
    29bc:	000027cd 	.word	0x000027cd
    29c0:	20000754 	.word	0x20000754
    29c4:	00002769 	.word	0x00002769
    29c8:	00004b3d 	.word	0x00004b3d
    29cc:	20000750 	.word	0x20000750

000029d0 <udc_start>:

/*! \brief Start the USB Device stack
 */
void udc_start(void)
{
    29d0:	b580      	push	{r7, lr}
    29d2:	af00      	add	r7, sp, #0
	udd_enable();
    29d4:	4b02      	ldr	r3, [pc, #8]	; (29e0 <udc_start+0x10>)
    29d6:	4798      	blx	r3
}
    29d8:	46c0      	nop			; (mov r8, r8)
    29da:	46bd      	mov	sp, r7
    29dc:	bd80      	pop	{r7, pc}
    29de:	46c0      	nop			; (mov r8, r8)
    29e0:	00005911 	.word	0x00005911

000029e4 <udc_reset>:
/**
 * \brief Reset the current configuration of the USB device,
 * This routines can be called by UDD when a RESET on the USB line occurs.
 */
void udc_reset(void)
{
    29e4:	b580      	push	{r7, lr}
    29e6:	b082      	sub	sp, #8
    29e8:	af00      	add	r7, sp, #0
	uint8_t iface_num;

	if (udc_num_configuration) {
    29ea:	4b12      	ldr	r3, [pc, #72]	; (2a34 <udc_reset+0x50>)
    29ec:	781b      	ldrb	r3, [r3, #0]
    29ee:	2b00      	cmp	r3, #0
    29f0:	d015      	beq.n	2a1e <udc_reset+0x3a>
		for (iface_num = 0;
    29f2:	1dfb      	adds	r3, r7, #7
    29f4:	2200      	movs	r2, #0
    29f6:	701a      	strb	r2, [r3, #0]
    29f8:	e009      	b.n	2a0e <udc_reset+0x2a>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			udc_iface_disable(iface_num);
    29fa:	1dfb      	adds	r3, r7, #7
    29fc:	781b      	ldrb	r3, [r3, #0]
    29fe:	0018      	movs	r0, r3
    2a00:	4b0d      	ldr	r3, [pc, #52]	; (2a38 <udc_reset+0x54>)
    2a02:	4798      	blx	r3
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
    2a04:	1dfb      	adds	r3, r7, #7
    2a06:	781a      	ldrb	r2, [r3, #0]
    2a08:	1dfb      	adds	r3, r7, #7
    2a0a:	3201      	adds	r2, #1
    2a0c:	701a      	strb	r2, [r3, #0]
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
    2a0e:	4b0b      	ldr	r3, [pc, #44]	; (2a3c <udc_reset+0x58>)
    2a10:	681b      	ldr	r3, [r3, #0]
    2a12:	681b      	ldr	r3, [r3, #0]
    2a14:	791b      	ldrb	r3, [r3, #4]
void udc_reset(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
    2a16:	1dfa      	adds	r2, r7, #7
    2a18:	7812      	ldrb	r2, [r2, #0]
    2a1a:	429a      	cmp	r2, r3
    2a1c:	d3ed      	bcc.n	29fa <udc_reset+0x16>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			udc_iface_disable(iface_num);
		}
	}
	udc_num_configuration = 0;
    2a1e:	4b05      	ldr	r3, [pc, #20]	; (2a34 <udc_reset+0x50>)
    2a20:	2200      	movs	r2, #0
    2a22:	701a      	strb	r2, [r3, #0]
	if (CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP) & udc_device_status) {
		// Remote wakeup is enabled then disable it
		UDC_REMOTEWAKEUP_DISABLE();
	}
#endif
	udc_device_status =
    2a24:	4b06      	ldr	r3, [pc, #24]	; (2a40 <udc_reset+0x5c>)
    2a26:	2201      	movs	r2, #1
    2a28:	801a      	strh	r2, [r3, #0]
#if (USB_DEVICE_ATTR & USB_CONFIG_ATTR_SELF_POWERED)
			CPU_TO_LE16(USB_DEV_STATUS_SELF_POWERED);
#else
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}
    2a2a:	46c0      	nop			; (mov r8, r8)
    2a2c:	46bd      	mov	sp, r7
    2a2e:	b002      	add	sp, #8
    2a30:	bd80      	pop	{r7, pc}
    2a32:	46c0      	nop			; (mov r8, r8)
    2a34:	2000074c 	.word	0x2000074c
    2a38:	00002871 	.word	0x00002871
    2a3c:	20000750 	.word	0x20000750
    2a40:	20000744 	.word	0x20000744

00002a44 <udc_sof_notify>:

void udc_sof_notify(void)
{
    2a44:	b580      	push	{r7, lr}
    2a46:	b082      	sub	sp, #8
    2a48:	af00      	add	r7, sp, #0
	uint8_t iface_num;

	if (udc_num_configuration) {
    2a4a:	4b17      	ldr	r3, [pc, #92]	; (2aa8 <udc_sof_notify+0x64>)
    2a4c:	781b      	ldrb	r3, [r3, #0]
    2a4e:	2b00      	cmp	r3, #0
    2a50:	d025      	beq.n	2a9e <udc_sof_notify+0x5a>
		for (iface_num = 0;
    2a52:	1dfb      	adds	r3, r7, #7
    2a54:	2200      	movs	r2, #0
    2a56:	701a      	strb	r2, [r3, #0]
    2a58:	e019      	b.n	2a8e <udc_sof_notify+0x4a>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
    2a5a:	4b14      	ldr	r3, [pc, #80]	; (2aac <udc_sof_notify+0x68>)
    2a5c:	681b      	ldr	r3, [r3, #0]
    2a5e:	685a      	ldr	r2, [r3, #4]
    2a60:	1dfb      	adds	r3, r7, #7
    2a62:	781b      	ldrb	r3, [r3, #0]
    2a64:	009b      	lsls	r3, r3, #2
    2a66:	18d3      	adds	r3, r2, r3
    2a68:	681b      	ldr	r3, [r3, #0]
    2a6a:	691b      	ldr	r3, [r3, #16]
    2a6c:	2b00      	cmp	r3, #0
    2a6e:	d009      	beq.n	2a84 <udc_sof_notify+0x40>
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
    2a70:	4b0e      	ldr	r3, [pc, #56]	; (2aac <udc_sof_notify+0x68>)
    2a72:	681b      	ldr	r3, [r3, #0]
    2a74:	685a      	ldr	r2, [r3, #4]
    2a76:	1dfb      	adds	r3, r7, #7
    2a78:	781b      	ldrb	r3, [r3, #0]
    2a7a:	009b      	lsls	r3, r3, #2
    2a7c:	18d3      	adds	r3, r2, r3
    2a7e:	681b      	ldr	r3, [r3, #0]
    2a80:	691b      	ldr	r3, [r3, #16]
    2a82:	4798      	blx	r3
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
    2a84:	1dfb      	adds	r3, r7, #7
    2a86:	781a      	ldrb	r2, [r3, #0]
    2a88:	1dfb      	adds	r3, r7, #7
    2a8a:	3201      	adds	r2, #1
    2a8c:	701a      	strb	r2, [r3, #0]
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
    2a8e:	4b07      	ldr	r3, [pc, #28]	; (2aac <udc_sof_notify+0x68>)
    2a90:	681b      	ldr	r3, [r3, #0]
    2a92:	681b      	ldr	r3, [r3, #0]
    2a94:	791b      	ldrb	r3, [r3, #4]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
    2a96:	1dfa      	adds	r2, r7, #7
    2a98:	7812      	ldrb	r2, [r2, #0]
    2a9a:	429a      	cmp	r2, r3
    2a9c:	d3dd      	bcc.n	2a5a <udc_sof_notify+0x16>
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
			}
		}
	}
}
    2a9e:	46c0      	nop			; (mov r8, r8)
    2aa0:	46bd      	mov	sp, r7
    2aa2:	b002      	add	sp, #8
    2aa4:	bd80      	pop	{r7, pc}
    2aa6:	46c0      	nop			; (mov r8, r8)
    2aa8:	2000074c 	.word	0x2000074c
    2aac:	20000750 	.word	0x20000750

00002ab0 <udc_req_std_dev_get_status>:
 * \brief Standard device request to get device status
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_status(void)
{
    2ab0:	b580      	push	{r7, lr}
    2ab2:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status)) {
    2ab4:	4b07      	ldr	r3, [pc, #28]	; (2ad4 <udc_req_std_dev_get_status+0x24>)
    2ab6:	88db      	ldrh	r3, [r3, #6]
    2ab8:	2b02      	cmp	r3, #2
    2aba:	d001      	beq.n	2ac0 <udc_req_std_dev_get_status+0x10>
		return false;
    2abc:	2300      	movs	r3, #0
    2abe:	e005      	b.n	2acc <udc_req_std_dev_get_status+0x1c>
	}

	udd_set_setup_payload( (uint8_t *) & udc_device_status,
    2ac0:	4b05      	ldr	r3, [pc, #20]	; (2ad8 <udc_req_std_dev_get_status+0x28>)
    2ac2:	2102      	movs	r1, #2
    2ac4:	0018      	movs	r0, r3
    2ac6:	4b05      	ldr	r3, [pc, #20]	; (2adc <udc_req_std_dev_get_status+0x2c>)
    2ac8:	4798      	blx	r3
			sizeof(udc_device_status));
	return true;
    2aca:	2301      	movs	r3, #1
}
    2acc:	0018      	movs	r0, r3
    2ace:	46bd      	mov	sp, r7
    2ad0:	bd80      	pop	{r7, pc}
    2ad2:	46c0      	nop			; (mov r8, r8)
    2ad4:	2000147c 	.word	0x2000147c
    2ad8:	20000744 	.word	0x20000744
    2adc:	00005145 	.word	0x00005145

00002ae0 <udc_req_std_ep_get_status>:
 * \brief Standard endpoint request to get endpoint status
 *
 * \return true if success
 */
static bool udc_req_std_ep_get_status(void)
{
    2ae0:	b580      	push	{r7, lr}
    2ae2:	af00      	add	r7, sp, #0
	static le16_t udc_ep_status;

	if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status)) {
    2ae4:	4b0c      	ldr	r3, [pc, #48]	; (2b18 <udc_req_std_ep_get_status+0x38>)
    2ae6:	88db      	ldrh	r3, [r3, #6]
    2ae8:	2b02      	cmp	r3, #2
    2aea:	d001      	beq.n	2af0 <udc_req_std_ep_get_status+0x10>
		return false;
    2aec:	2300      	movs	r3, #0
    2aee:	e00f      	b.n	2b10 <udc_req_std_ep_get_status+0x30>
	}

	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
    2af0:	4b09      	ldr	r3, [pc, #36]	; (2b18 <udc_req_std_ep_get_status+0x38>)
    2af2:	889b      	ldrh	r3, [r3, #4]
    2af4:	b2db      	uxtb	r3, r3
    2af6:	0018      	movs	r0, r3
    2af8:	4b08      	ldr	r3, [pc, #32]	; (2b1c <udc_req_std_ep_get_status+0x3c>)
    2afa:	4798      	blx	r3
    2afc:	0003      	movs	r3, r0
    2afe:	b29a      	uxth	r2, r3
    2b00:	4b07      	ldr	r3, [pc, #28]	; (2b20 <udc_req_std_ep_get_status+0x40>)
    2b02:	801a      	strh	r2, [r3, #0]
			wIndex & 0xFF) ? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;

	udd_set_setup_payload( (uint8_t *) & udc_ep_status,
    2b04:	4b06      	ldr	r3, [pc, #24]	; (2b20 <udc_req_std_ep_get_status+0x40>)
    2b06:	2102      	movs	r1, #2
    2b08:	0018      	movs	r0, r3
    2b0a:	4b06      	ldr	r3, [pc, #24]	; (2b24 <udc_req_std_ep_get_status+0x44>)
    2b0c:	4798      	blx	r3
			sizeof(udc_ep_status));
	return true;
    2b0e:	2301      	movs	r3, #1
}
    2b10:	0018      	movs	r0, r3
    2b12:	46bd      	mov	sp, r7
    2b14:	bd80      	pop	{r7, pc}
    2b16:	46c0      	nop			; (mov r8, r8)
    2b18:	2000147c 	.word	0x2000147c
    2b1c:	00004ce5 	.word	0x00004ce5
    2b20:	20000758 	.word	0x20000758
    2b24:	00005145 	.word	0x00005145

00002b28 <udc_req_std_dev_clear_feature>:
 * \brief Standard device request to change device status
 *
 * \return true if success
 */
static bool udc_req_std_dev_clear_feature(void)
{
    2b28:	b580      	push	{r7, lr}
    2b2a:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength) {
    2b2c:	4b0b      	ldr	r3, [pc, #44]	; (2b5c <udc_req_std_dev_clear_feature+0x34>)
    2b2e:	88db      	ldrh	r3, [r3, #6]
    2b30:	2b00      	cmp	r3, #0
    2b32:	d001      	beq.n	2b38 <udc_req_std_dev_clear_feature+0x10>
		return false;
    2b34:	2300      	movs	r3, #0
    2b36:	e00d      	b.n	2b54 <udc_req_std_dev_clear_feature+0x2c>
	}

	if (udd_g_ctrlreq.req.wValue == USB_DEV_FEATURE_REMOTE_WAKEUP) {
    2b38:	4b08      	ldr	r3, [pc, #32]	; (2b5c <udc_req_std_dev_clear_feature+0x34>)
    2b3a:	885b      	ldrh	r3, [r3, #2]
    2b3c:	2b01      	cmp	r3, #1
    2b3e:	d108      	bne.n	2b52 <udc_req_std_dev_clear_feature+0x2a>
		udc_device_status &= CPU_TO_LE16(~(uint32_t)USB_DEV_STATUS_REMOTEWAKEUP);
    2b40:	4b07      	ldr	r3, [pc, #28]	; (2b60 <udc_req_std_dev_clear_feature+0x38>)
    2b42:	881b      	ldrh	r3, [r3, #0]
    2b44:	2202      	movs	r2, #2
    2b46:	4393      	bics	r3, r2
    2b48:	b29a      	uxth	r2, r3
    2b4a:	4b05      	ldr	r3, [pc, #20]	; (2b60 <udc_req_std_dev_clear_feature+0x38>)
    2b4c:	801a      	strh	r2, [r3, #0]
#if (USB_CONFIG_ATTR_REMOTE_WAKEUP \
	== (USB_DEVICE_ATTR & USB_CONFIG_ATTR_REMOTE_WAKEUP))
		UDC_REMOTEWAKEUP_DISABLE();
#endif
		return true;
    2b4e:	2301      	movs	r3, #1
    2b50:	e000      	b.n	2b54 <udc_req_std_dev_clear_feature+0x2c>
	}
	return false;
    2b52:	2300      	movs	r3, #0
}
    2b54:	0018      	movs	r0, r3
    2b56:	46bd      	mov	sp, r7
    2b58:	bd80      	pop	{r7, pc}
    2b5a:	46c0      	nop			; (mov r8, r8)
    2b5c:	2000147c 	.word	0x2000147c
    2b60:	20000744 	.word	0x20000744

00002b64 <udc_req_std_ep_clear_feature>:
 * \brief Standard endpoint request to clear endpoint feature
 *
 * \return true if success
 */
static bool udc_req_std_ep_clear_feature(void)
{
    2b64:	b580      	push	{r7, lr}
    2b66:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength) {
    2b68:	4b0a      	ldr	r3, [pc, #40]	; (2b94 <udc_req_std_ep_clear_feature+0x30>)
    2b6a:	88db      	ldrh	r3, [r3, #6]
    2b6c:	2b00      	cmp	r3, #0
    2b6e:	d001      	beq.n	2b74 <udc_req_std_ep_clear_feature+0x10>
		return false;
    2b70:	2300      	movs	r3, #0
    2b72:	e00c      	b.n	2b8e <udc_req_std_ep_clear_feature+0x2a>
	}

	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
    2b74:	4b07      	ldr	r3, [pc, #28]	; (2b94 <udc_req_std_ep_clear_feature+0x30>)
    2b76:	885b      	ldrh	r3, [r3, #2]
    2b78:	2b00      	cmp	r3, #0
    2b7a:	d107      	bne.n	2b8c <udc_req_std_ep_clear_feature+0x28>
		return udd_ep_clear_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
    2b7c:	4b05      	ldr	r3, [pc, #20]	; (2b94 <udc_req_std_ep_clear_feature+0x30>)
    2b7e:	889b      	ldrh	r3, [r3, #4]
    2b80:	b2db      	uxtb	r3, r3
    2b82:	0018      	movs	r0, r3
    2b84:	4b04      	ldr	r3, [pc, #16]	; (2b98 <udc_req_std_ep_clear_feature+0x34>)
    2b86:	4798      	blx	r3
    2b88:	0003      	movs	r3, r0
    2b8a:	e000      	b.n	2b8e <udc_req_std_ep_clear_feature+0x2a>
	}
	return false;
    2b8c:	2300      	movs	r3, #0
}
    2b8e:	0018      	movs	r0, r3
    2b90:	46bd      	mov	sp, r7
    2b92:	bd80      	pop	{r7, pc}
    2b94:	2000147c 	.word	0x2000147c
    2b98:	00004d69 	.word	0x00004d69

00002b9c <udc_req_std_dev_set_feature>:
 * \brief Standard device request to set a feature
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_feature(void)
{
    2b9c:	b580      	push	{r7, lr}
    2b9e:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength) {
    2ba0:	4b08      	ldr	r3, [pc, #32]	; (2bc4 <udc_req_std_dev_set_feature+0x28>)
    2ba2:	88db      	ldrh	r3, [r3, #6]
    2ba4:	2b00      	cmp	r3, #0
    2ba6:	d001      	beq.n	2bac <udc_req_std_dev_set_feature+0x10>
		return false;
    2ba8:	2300      	movs	r3, #0
    2baa:	e007      	b.n	2bbc <udc_req_std_dev_set_feature+0x20>
	}

	switch (udd_g_ctrlreq.req.wValue) {
    2bac:	4b05      	ldr	r3, [pc, #20]	; (2bc4 <udc_req_std_dev_set_feature+0x28>)
    2bae:	885b      	ldrh	r3, [r3, #2]
    2bb0:	2b01      	cmp	r3, #1
    2bb2:	d002      	beq.n	2bba <udc_req_std_dev_set_feature+0x1e>
			break;
		}
		break;
#endif
	default:
		break;
    2bb4:	46c0      	nop			; (mov r8, r8)
	}
	return false;
    2bb6:	2300      	movs	r3, #0
    2bb8:	e000      	b.n	2bbc <udc_req_std_dev_set_feature+0x20>
	== (USB_DEVICE_ATTR & USB_CONFIG_ATTR_REMOTE_WAKEUP))
		udc_device_status |= CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP);
		UDC_REMOTEWAKEUP_ENABLE();
		return true;
#else
		return false;
    2bba:	2300      	movs	r3, #0
#endif
	default:
		break;
	}
	return false;
}
    2bbc:	0018      	movs	r0, r3
    2bbe:	46bd      	mov	sp, r7
    2bc0:	bd80      	pop	{r7, pc}
    2bc2:	46c0      	nop			; (mov r8, r8)
    2bc4:	2000147c 	.word	0x2000147c

00002bc8 <udc_req_std_ep_set_feature>:
 *
 * \return true if success
 */
#if (0!=USB_DEVICE_MAX_EP)
static bool udc_req_std_ep_set_feature(void)
{
    2bc8:	b580      	push	{r7, lr}
    2bca:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength) {
    2bcc:	4b0d      	ldr	r3, [pc, #52]	; (2c04 <udc_req_std_ep_set_feature+0x3c>)
    2bce:	88db      	ldrh	r3, [r3, #6]
    2bd0:	2b00      	cmp	r3, #0
    2bd2:	d001      	beq.n	2bd8 <udc_req_std_ep_set_feature+0x10>
		return false;
    2bd4:	2300      	movs	r3, #0
    2bd6:	e012      	b.n	2bfe <udc_req_std_ep_set_feature+0x36>
	}
	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
    2bd8:	4b0a      	ldr	r3, [pc, #40]	; (2c04 <udc_req_std_ep_set_feature+0x3c>)
    2bda:	885b      	ldrh	r3, [r3, #2]
    2bdc:	2b00      	cmp	r3, #0
    2bde:	d10d      	bne.n	2bfc <udc_req_std_ep_set_feature+0x34>
		udd_ep_abort(udd_g_ctrlreq.req.wIndex & 0xFF);
    2be0:	4b08      	ldr	r3, [pc, #32]	; (2c04 <udc_req_std_ep_set_feature+0x3c>)
    2be2:	889b      	ldrh	r3, [r3, #4]
    2be4:	b2db      	uxtb	r3, r3
    2be6:	0018      	movs	r0, r3
    2be8:	4b07      	ldr	r3, [pc, #28]	; (2c08 <udc_req_std_ep_set_feature+0x40>)
    2bea:	4798      	blx	r3
		return udd_ep_set_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
    2bec:	4b05      	ldr	r3, [pc, #20]	; (2c04 <udc_req_std_ep_set_feature+0x3c>)
    2bee:	889b      	ldrh	r3, [r3, #4]
    2bf0:	b2db      	uxtb	r3, r3
    2bf2:	0018      	movs	r0, r3
    2bf4:	4b05      	ldr	r3, [pc, #20]	; (2c0c <udc_req_std_ep_set_feature+0x44>)
    2bf6:	4798      	blx	r3
    2bf8:	0003      	movs	r3, r0
    2bfa:	e000      	b.n	2bfe <udc_req_std_ep_set_feature+0x36>
	}
	return false;
    2bfc:	2300      	movs	r3, #0
}
    2bfe:	0018      	movs	r0, r3
    2c00:	46bd      	mov	sp, r7
    2c02:	bd80      	pop	{r7, pc}
    2c04:	2000147c 	.word	0x2000147c
    2c08:	000049fd 	.word	0x000049fd
    2c0c:	00004d11 	.word	0x00004d11

00002c10 <udc_valid_address>:
/**
 * \brief Change the address of device
 * Callback called at the end of request set address
 */
static void udc_valid_address(void)
{
    2c10:	b580      	push	{r7, lr}
    2c12:	af00      	add	r7, sp, #0
	udd_set_address(udd_g_ctrlreq.req.wValue & 0x7F);
    2c14:	4b05      	ldr	r3, [pc, #20]	; (2c2c <udc_valid_address+0x1c>)
    2c16:	885b      	ldrh	r3, [r3, #2]
    2c18:	b2db      	uxtb	r3, r3
    2c1a:	227f      	movs	r2, #127	; 0x7f
    2c1c:	4013      	ands	r3, r2
    2c1e:	b2db      	uxtb	r3, r3
    2c20:	0018      	movs	r0, r3
    2c22:	4b03      	ldr	r3, [pc, #12]	; (2c30 <udc_valid_address+0x20>)
    2c24:	4798      	blx	r3
}
    2c26:	46c0      	nop			; (mov r8, r8)
    2c28:	46bd      	mov	sp, r7
    2c2a:	bd80      	pop	{r7, pc}
    2c2c:	2000147c 	.word	0x2000147c
    2c30:	000050fd 	.word	0x000050fd

00002c34 <udc_req_std_dev_set_address>:
 * \brief Standard device request to set device address
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_address(void)
{
    2c34:	b580      	push	{r7, lr}
    2c36:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength) {
    2c38:	4b06      	ldr	r3, [pc, #24]	; (2c54 <udc_req_std_dev_set_address+0x20>)
    2c3a:	88db      	ldrh	r3, [r3, #6]
    2c3c:	2b00      	cmp	r3, #0
    2c3e:	d001      	beq.n	2c44 <udc_req_std_dev_set_address+0x10>
		return false;
    2c40:	2300      	movs	r3, #0
    2c42:	e003      	b.n	2c4c <udc_req_std_dev_set_address+0x18>
	}

	// The address must be changed at the end of setup request after the handshake
	// then we use a callback to change address
	udd_g_ctrlreq.callback = udc_valid_address;
    2c44:	4b03      	ldr	r3, [pc, #12]	; (2c54 <udc_req_std_dev_set_address+0x20>)
    2c46:	4a04      	ldr	r2, [pc, #16]	; (2c58 <udc_req_std_dev_set_address+0x24>)
    2c48:	611a      	str	r2, [r3, #16]
	return true;
    2c4a:	2301      	movs	r3, #1
}
    2c4c:	0018      	movs	r0, r3
    2c4e:	46bd      	mov	sp, r7
    2c50:	bd80      	pop	{r7, pc}
    2c52:	46c0      	nop			; (mov r8, r8)
    2c54:	2000147c 	.word	0x2000147c
    2c58:	00002c11 	.word	0x00002c11

00002c5c <udc_req_std_dev_get_str_desc>:
 * \brief Standard device request to get device string descriptor
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_str_desc(void)
{
    2c5c:	b580      	push	{r7, lr}
    2c5e:	b084      	sub	sp, #16
    2c60:	af00      	add	r7, sp, #0
	uint8_t i;
	const uint8_t *str;
	uint8_t str_length = 0;
    2c62:	1dfb      	adds	r3, r7, #7
    2c64:	2200      	movs	r2, #0
    2c66:	701a      	strb	r2, [r3, #0]

	// Link payload pointer to the string corresponding at request
	switch (udd_g_ctrlreq.req.wValue & 0xff) {
    2c68:	4b2d      	ldr	r3, [pc, #180]	; (2d20 <udc_req_std_dev_get_str_desc+0xc4>)
    2c6a:	885b      	ldrh	r3, [r3, #2]
    2c6c:	001a      	movs	r2, r3
    2c6e:	23ff      	movs	r3, #255	; 0xff
    2c70:	4013      	ands	r3, r2
    2c72:	2b01      	cmp	r3, #1
    2c74:	d009      	beq.n	2c8a <udc_req_std_dev_get_str_desc+0x2e>
    2c76:	2b02      	cmp	r3, #2
    2c78:	d00d      	beq.n	2c96 <udc_req_std_dev_get_str_desc+0x3a>
    2c7a:	2b00      	cmp	r3, #0
    2c7c:	d111      	bne.n	2ca2 <udc_req_std_dev_get_str_desc+0x46>
	case 0:
		udd_set_setup_payload((uint8_t *) &udc_string_desc_languageid,
    2c7e:	4b29      	ldr	r3, [pc, #164]	; (2d24 <udc_req_std_dev_get_str_desc+0xc8>)
    2c80:	2104      	movs	r1, #4
    2c82:	0018      	movs	r0, r3
    2c84:	4b28      	ldr	r3, [pc, #160]	; (2d28 <udc_req_std_dev_get_str_desc+0xcc>)
    2c86:	4798      	blx	r3
				sizeof(udc_string_desc_languageid));
		break;
    2c88:	e00d      	b.n	2ca6 <udc_req_std_dev_get_str_desc+0x4a>

#ifdef USB_DEVICE_MANUFACTURE_NAME
	case 1:
		str_length = USB_DEVICE_MANUFACTURE_NAME_SIZE;
    2c8a:	1dfb      	adds	r3, r7, #7
    2c8c:	2209      	movs	r2, #9
    2c8e:	701a      	strb	r2, [r3, #0]
		str = udc_string_manufacturer_name;
    2c90:	4b26      	ldr	r3, [pc, #152]	; (2d2c <udc_req_std_dev_get_str_desc+0xd0>)
    2c92:	60bb      	str	r3, [r7, #8]
		break;
    2c94:	e007      	b.n	2ca6 <udc_req_std_dev_get_str_desc+0x4a>
#endif
#ifdef USB_DEVICE_PRODUCT_NAME
	case 2:
		str_length = USB_DEVICE_PRODUCT_NAME_SIZE;
    2c96:	1dfb      	adds	r3, r7, #7
    2c98:	2203      	movs	r2, #3
    2c9a:	701a      	strb	r2, [r3, #0]
		str = udc_string_product_name;
    2c9c:	4b24      	ldr	r3, [pc, #144]	; (2d30 <udc_req_std_dev_get_str_desc+0xd4>)
    2c9e:	60bb      	str	r3, [r7, #8]
		break;
    2ca0:	e001      	b.n	2ca6 <udc_req_std_dev_get_str_desc+0x4a>
#ifdef UDC_GET_EXTRA_STRING
		if (UDC_GET_EXTRA_STRING()) {
			break;
		}
#endif
		return false;
    2ca2:	2300      	movs	r3, #0
    2ca4:	e037      	b.n	2d16 <udc_req_std_dev_get_str_desc+0xba>
	}

	if (str_length) {
    2ca6:	1dfb      	adds	r3, r7, #7
    2ca8:	781b      	ldrb	r3, [r3, #0]
    2caa:	2b00      	cmp	r3, #0
    2cac:	d032      	beq.n	2d14 <udc_req_std_dev_get_str_desc+0xb8>
		for(i = 0; i < str_length; i++) {
    2cae:	230f      	movs	r3, #15
    2cb0:	18fb      	adds	r3, r7, r3
    2cb2:	2200      	movs	r2, #0
    2cb4:	701a      	strb	r2, [r3, #0]
    2cb6:	e016      	b.n	2ce6 <udc_req_std_dev_get_str_desc+0x8a>
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
    2cb8:	230f      	movs	r3, #15
    2cba:	18fb      	adds	r3, r7, r3
    2cbc:	781b      	ldrb	r3, [r3, #0]
    2cbe:	220f      	movs	r2, #15
    2cc0:	18ba      	adds	r2, r7, r2
    2cc2:	7812      	ldrb	r2, [r2, #0]
    2cc4:	68b9      	ldr	r1, [r7, #8]
    2cc6:	188a      	adds	r2, r1, r2
    2cc8:	7812      	ldrb	r2, [r2, #0]
    2cca:	b291      	uxth	r1, r2
    2ccc:	4a19      	ldr	r2, [pc, #100]	; (2d34 <udc_req_std_dev_get_str_desc+0xd8>)
    2cce:	005b      	lsls	r3, r3, #1
    2cd0:	18d3      	adds	r3, r2, r3
    2cd2:	3302      	adds	r3, #2
    2cd4:	1c0a      	adds	r2, r1, #0
    2cd6:	801a      	strh	r2, [r3, #0]
#endif
		return false;
	}

	if (str_length) {
		for(i = 0; i < str_length; i++) {
    2cd8:	230f      	movs	r3, #15
    2cda:	18fb      	adds	r3, r7, r3
    2cdc:	781a      	ldrb	r2, [r3, #0]
    2cde:	230f      	movs	r3, #15
    2ce0:	18fb      	adds	r3, r7, r3
    2ce2:	3201      	adds	r2, #1
    2ce4:	701a      	strb	r2, [r3, #0]
    2ce6:	230f      	movs	r3, #15
    2ce8:	18fa      	adds	r2, r7, r3
    2cea:	1dfb      	adds	r3, r7, #7
    2cec:	7812      	ldrb	r2, [r2, #0]
    2cee:	781b      	ldrb	r3, [r3, #0]
    2cf0:	429a      	cmp	r2, r3
    2cf2:	d3e1      	bcc.n	2cb8 <udc_req_std_dev_get_str_desc+0x5c>
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
		}

		udc_string_desc.header.bLength = 2 + (str_length) * 2;
    2cf4:	1dfb      	adds	r3, r7, #7
    2cf6:	781b      	ldrb	r3, [r3, #0]
    2cf8:	3301      	adds	r3, #1
    2cfa:	b2db      	uxtb	r3, r3
    2cfc:	18db      	adds	r3, r3, r3
    2cfe:	b2da      	uxtb	r2, r3
    2d00:	4b0c      	ldr	r3, [pc, #48]	; (2d34 <udc_req_std_dev_get_str_desc+0xd8>)
    2d02:	701a      	strb	r2, [r3, #0]
		udd_set_setup_payload(
			(uint8_t *) &udc_string_desc,
			udc_string_desc.header.bLength);
    2d04:	4b0b      	ldr	r3, [pc, #44]	; (2d34 <udc_req_std_dev_get_str_desc+0xd8>)
    2d06:	781b      	ldrb	r3, [r3, #0]
		for(i = 0; i < str_length; i++) {
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
		}

		udc_string_desc.header.bLength = 2 + (str_length) * 2;
		udd_set_setup_payload(
    2d08:	b29a      	uxth	r2, r3
    2d0a:	4b0a      	ldr	r3, [pc, #40]	; (2d34 <udc_req_std_dev_get_str_desc+0xd8>)
    2d0c:	0011      	movs	r1, r2
    2d0e:	0018      	movs	r0, r3
    2d10:	4b05      	ldr	r3, [pc, #20]	; (2d28 <udc_req_std_dev_get_str_desc+0xcc>)
    2d12:	4798      	blx	r3
			(uint8_t *) &udc_string_desc,
			udc_string_desc.header.bLength);
	}

	return true;
    2d14:	2301      	movs	r3, #1
}
    2d16:	0018      	movs	r0, r3
    2d18:	46bd      	mov	sp, r7
    2d1a:	b004      	add	sp, #16
    2d1c:	bd80      	pop	{r7, pc}
    2d1e:	46c0      	nop			; (mov r8, r8)
    2d20:	2000147c 	.word	0x2000147c
    2d24:	2000004c 	.word	0x2000004c
    2d28:	00005145 	.word	0x00005145
    2d2c:	20000050 	.word	0x20000050
    2d30:	2000005c 	.word	0x2000005c
    2d34:	20000060 	.word	0x20000060

00002d38 <udc_req_std_dev_get_descriptor>:
 * \brief Standard device request to get descriptors about USB device
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_descriptor(void)
{
    2d38:	b580      	push	{r7, lr}
    2d3a:	b082      	sub	sp, #8
    2d3c:	af00      	add	r7, sp, #0
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
    2d3e:	4b39      	ldr	r3, [pc, #228]	; (2e24 <udc_req_std_dev_get_descriptor+0xec>)
    2d40:	885a      	ldrh	r2, [r3, #2]
    2d42:	1dfb      	adds	r3, r7, #7
    2d44:	701a      	strb	r2, [r3, #0]

	// Check descriptor ID
	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
    2d46:	4b37      	ldr	r3, [pc, #220]	; (2e24 <udc_req_std_dev_get_descriptor+0xec>)
    2d48:	885b      	ldrh	r3, [r3, #2]
    2d4a:	0a1b      	lsrs	r3, r3, #8
    2d4c:	b29b      	uxth	r3, r3
    2d4e:	b2db      	uxtb	r3, r3
    2d50:	2b02      	cmp	r3, #2
    2d52:	d013      	beq.n	2d7c <udc_req_std_dev_get_descriptor+0x44>
    2d54:	dc02      	bgt.n	2d5c <udc_req_std_dev_get_descriptor+0x24>
    2d56:	2b01      	cmp	r3, #1
    2d58:	d005      	beq.n	2d66 <udc_req_std_dev_get_descriptor+0x2e>
    2d5a:	e051      	b.n	2e00 <udc_req_std_dev_get_descriptor+0xc8>
    2d5c:	2b03      	cmp	r3, #3
    2d5e:	d044      	beq.n	2dea <udc_req_std_dev_get_descriptor+0xb2>
    2d60:	2b0f      	cmp	r3, #15
    2d62:	d02f      	beq.n	2dc4 <udc_req_std_dev_get_descriptor+0x8c>
    2d64:	e04c      	b.n	2e00 <udc_req_std_dev_get_descriptor+0xc8>
				udc_config.confdev_hs->bLength);
		} else
#endif
		{
			udd_set_setup_payload(
				(uint8_t *) udc_config.confdev_lsfs,
    2d66:	4b30      	ldr	r3, [pc, #192]	; (2e28 <udc_req_std_dev_get_descriptor+0xf0>)
    2d68:	681a      	ldr	r2, [r3, #0]
				udc_config.confdev_lsfs->bLength);
    2d6a:	4b2f      	ldr	r3, [pc, #188]	; (2e28 <udc_req_std_dev_get_descriptor+0xf0>)
    2d6c:	681b      	ldr	r3, [r3, #0]
    2d6e:	781b      	ldrb	r3, [r3, #0]
				(uint8_t *) udc_config.confdev_hs,
				udc_config.confdev_hs->bLength);
		} else
#endif
		{
			udd_set_setup_payload(
    2d70:	b29b      	uxth	r3, r3
    2d72:	0019      	movs	r1, r3
    2d74:	0010      	movs	r0, r2
    2d76:	4b2d      	ldr	r3, [pc, #180]	; (2e2c <udc_req_std_dev_get_descriptor+0xf4>)
    2d78:	4798      	blx	r3
				(uint8_t *) udc_config.confdev_lsfs,
				udc_config.confdev_lsfs->bLength);
		}
		break;
    2d7a:	e044      	b.n	2e06 <udc_req_std_dev_get_descriptor+0xce>
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
		} else
#endif
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
    2d7c:	4b2a      	ldr	r3, [pc, #168]	; (2e28 <udc_req_std_dev_get_descriptor+0xf0>)
    2d7e:	681b      	ldr	r3, [r3, #0]
    2d80:	7c5b      	ldrb	r3, [r3, #17]
    2d82:	1dfa      	adds	r2, r7, #7
    2d84:	7812      	ldrb	r2, [r2, #0]
    2d86:	429a      	cmp	r2, r3
    2d88:	d301      	bcc.n	2d8e <udc_req_std_dev_get_descriptor+0x56>
					bNumConfigurations) {
				return false;
    2d8a:	2300      	movs	r3, #0
    2d8c:	e046      	b.n	2e1c <udc_req_std_dev_get_descriptor+0xe4>
			}
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
    2d8e:	4b26      	ldr	r3, [pc, #152]	; (2e28 <udc_req_std_dev_get_descriptor+0xf0>)
    2d90:	685a      	ldr	r2, [r3, #4]
    2d92:	1dfb      	adds	r3, r7, #7
    2d94:	781b      	ldrb	r3, [r3, #0]
    2d96:	00db      	lsls	r3, r3, #3
    2d98:	18d3      	adds	r3, r2, r3
    2d9a:	6818      	ldr	r0, [r3, #0]
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
    2d9c:	4b22      	ldr	r3, [pc, #136]	; (2e28 <udc_req_std_dev_get_descriptor+0xf0>)
    2d9e:	685a      	ldr	r2, [r3, #4]
    2da0:	1dfb      	adds	r3, r7, #7
    2da2:	781b      	ldrb	r3, [r3, #0]
    2da4:	00db      	lsls	r3, r3, #3
    2da6:	18d3      	adds	r3, r2, r3
    2da8:	681b      	ldr	r3, [r3, #0]
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
    2daa:	789a      	ldrb	r2, [r3, #2]
    2dac:	78db      	ldrb	r3, [r3, #3]
    2dae:	021b      	lsls	r3, r3, #8
    2db0:	4313      	orrs	r3, r2
    2db2:	b29b      	uxth	r3, r3
    2db4:	0019      	movs	r1, r3
    2db6:	4b1d      	ldr	r3, [pc, #116]	; (2e2c <udc_req_std_dev_get_descriptor+0xf4>)
    2db8:	4798      	blx	r3
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
		}
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
    2dba:	4b1a      	ldr	r3, [pc, #104]	; (2e24 <udc_req_std_dev_get_descriptor+0xec>)
    2dbc:	689b      	ldr	r3, [r3, #8]
    2dbe:	2202      	movs	r2, #2
    2dc0:	705a      	strb	r2, [r3, #1]
				USB_DT_CONFIGURATION;
		break;
    2dc2:	e020      	b.n	2e06 <udc_req_std_dev_get_descriptor+0xce>
		break;
#endif

	case USB_DT_BOS:
		// Device BOS descriptor requested
		if (udc_config.conf_bos == NULL) {
    2dc4:	4b18      	ldr	r3, [pc, #96]	; (2e28 <udc_req_std_dev_get_descriptor+0xf0>)
    2dc6:	689b      	ldr	r3, [r3, #8]
    2dc8:	2b00      	cmp	r3, #0
    2dca:	d101      	bne.n	2dd0 <udc_req_std_dev_get_descriptor+0x98>
			return false;
    2dcc:	2300      	movs	r3, #0
    2dce:	e025      	b.n	2e1c <udc_req_std_dev_get_descriptor+0xe4>
		}
		udd_set_setup_payload( (uint8_t *) udc_config.conf_bos,
    2dd0:	4b15      	ldr	r3, [pc, #84]	; (2e28 <udc_req_std_dev_get_descriptor+0xf0>)
    2dd2:	6898      	ldr	r0, [r3, #8]
				udc_config.conf_bos->wTotalLength);
    2dd4:	4b14      	ldr	r3, [pc, #80]	; (2e28 <udc_req_std_dev_get_descriptor+0xf0>)
    2dd6:	689b      	ldr	r3, [r3, #8]
	case USB_DT_BOS:
		// Device BOS descriptor requested
		if (udc_config.conf_bos == NULL) {
			return false;
		}
		udd_set_setup_payload( (uint8_t *) udc_config.conf_bos,
    2dd8:	789a      	ldrb	r2, [r3, #2]
    2dda:	78db      	ldrb	r3, [r3, #3]
    2ddc:	021b      	lsls	r3, r3, #8
    2dde:	4313      	orrs	r3, r2
    2de0:	b29b      	uxth	r3, r3
    2de2:	0019      	movs	r1, r3
    2de4:	4b11      	ldr	r3, [pc, #68]	; (2e2c <udc_req_std_dev_get_descriptor+0xf4>)
    2de6:	4798      	blx	r3
				udc_config.conf_bos->wTotalLength);
		break;
    2de8:	e00d      	b.n	2e06 <udc_req_std_dev_get_descriptor+0xce>

	case USB_DT_STRING:
		// String descriptor requested
		if (!udc_req_std_dev_get_str_desc()) {
    2dea:	4b11      	ldr	r3, [pc, #68]	; (2e30 <udc_req_std_dev_get_descriptor+0xf8>)
    2dec:	4798      	blx	r3
    2dee:	0003      	movs	r3, r0
    2df0:	001a      	movs	r2, r3
    2df2:	2301      	movs	r3, #1
    2df4:	4053      	eors	r3, r2
    2df6:	b2db      	uxtb	r3, r3
    2df8:	2b00      	cmp	r3, #0
    2dfa:	d003      	beq.n	2e04 <udc_req_std_dev_get_descriptor+0xcc>
			return false;
    2dfc:	2300      	movs	r3, #0
    2dfe:	e00d      	b.n	2e1c <udc_req_std_dev_get_descriptor+0xe4>
		}
		break;

	default:
		// Unknown descriptor requested
		return false;
    2e00:	2300      	movs	r3, #0
    2e02:	e00b      	b.n	2e1c <udc_req_std_dev_get_descriptor+0xe4>
	case USB_DT_STRING:
		// String descriptor requested
		if (!udc_req_std_dev_get_str_desc()) {
			return false;
		}
		break;
    2e04:	46c0      	nop			; (mov r8, r8)
	default:
		// Unknown descriptor requested
		return false;
	}
	// if the descriptor is larger than length requested, then reduce it
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size) {
    2e06:	4b07      	ldr	r3, [pc, #28]	; (2e24 <udc_req_std_dev_get_descriptor+0xec>)
    2e08:	88da      	ldrh	r2, [r3, #6]
    2e0a:	4b06      	ldr	r3, [pc, #24]	; (2e24 <udc_req_std_dev_get_descriptor+0xec>)
    2e0c:	899b      	ldrh	r3, [r3, #12]
    2e0e:	429a      	cmp	r2, r3
    2e10:	d203      	bcs.n	2e1a <udc_req_std_dev_get_descriptor+0xe2>
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
    2e12:	4b04      	ldr	r3, [pc, #16]	; (2e24 <udc_req_std_dev_get_descriptor+0xec>)
    2e14:	88da      	ldrh	r2, [r3, #6]
    2e16:	4b03      	ldr	r3, [pc, #12]	; (2e24 <udc_req_std_dev_get_descriptor+0xec>)
    2e18:	819a      	strh	r2, [r3, #12]
	}
	return true;
    2e1a:	2301      	movs	r3, #1
}
    2e1c:	0018      	movs	r0, r3
    2e1e:	46bd      	mov	sp, r7
    2e20:	b002      	add	sp, #8
    2e22:	bd80      	pop	{r7, pc}
    2e24:	2000147c 	.word	0x2000147c
    2e28:	20000170 	.word	0x20000170
    2e2c:	00005145 	.word	0x00005145
    2e30:	00002c5d 	.word	0x00002c5d

00002e34 <udc_req_std_dev_get_configuration>:
 * \brief Standard device request to get configuration number
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_configuration(void)
{
    2e34:	b580      	push	{r7, lr}
    2e36:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength != 1) {
    2e38:	4b07      	ldr	r3, [pc, #28]	; (2e58 <udc_req_std_dev_get_configuration+0x24>)
    2e3a:	88db      	ldrh	r3, [r3, #6]
    2e3c:	2b01      	cmp	r3, #1
    2e3e:	d001      	beq.n	2e44 <udc_req_std_dev_get_configuration+0x10>
		return false;
    2e40:	2300      	movs	r3, #0
    2e42:	e005      	b.n	2e50 <udc_req_std_dev_get_configuration+0x1c>
	}

	udd_set_setup_payload(&udc_num_configuration,1);
    2e44:	4b05      	ldr	r3, [pc, #20]	; (2e5c <udc_req_std_dev_get_configuration+0x28>)
    2e46:	2101      	movs	r1, #1
    2e48:	0018      	movs	r0, r3
    2e4a:	4b05      	ldr	r3, [pc, #20]	; (2e60 <udc_req_std_dev_get_configuration+0x2c>)
    2e4c:	4798      	blx	r3
	return true;
    2e4e:	2301      	movs	r3, #1
}
    2e50:	0018      	movs	r0, r3
    2e52:	46bd      	mov	sp, r7
    2e54:	bd80      	pop	{r7, pc}
    2e56:	46c0      	nop			; (mov r8, r8)
    2e58:	2000147c 	.word	0x2000147c
    2e5c:	2000074c 	.word	0x2000074c
    2e60:	00005145 	.word	0x00005145

00002e64 <udc_req_std_dev_set_configuration>:
 * \brief Standard device request to enable a configuration
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_configuration(void)
{
    2e64:	b580      	push	{r7, lr}
    2e66:	b082      	sub	sp, #8
    2e68:	af00      	add	r7, sp, #0
	uint8_t iface_num;

	// Check request length
	if (udd_g_ctrlreq.req.wLength) {
    2e6a:	4b2a      	ldr	r3, [pc, #168]	; (2f14 <udc_req_std_dev_set_configuration+0xb0>)
    2e6c:	88db      	ldrh	r3, [r3, #6]
    2e6e:	2b00      	cmp	r3, #0
    2e70:	d001      	beq.n	2e76 <udc_req_std_dev_set_configuration+0x12>
		return false;
    2e72:	2300      	movs	r3, #0
    2e74:	e04a      	b.n	2f0c <udc_req_std_dev_set_configuration+0xa8>
	}
	// Authorize configuration only if the address is valid
	if (!udd_getaddress()) {
    2e76:	4b28      	ldr	r3, [pc, #160]	; (2f18 <udc_req_std_dev_set_configuration+0xb4>)
    2e78:	4798      	blx	r3
    2e7a:	1e03      	subs	r3, r0, #0
    2e7c:	d101      	bne.n	2e82 <udc_req_std_dev_set_configuration+0x1e>
		return false;
    2e7e:	2300      	movs	r3, #0
    2e80:	e044      	b.n	2f0c <udc_req_std_dev_set_configuration+0xa8>
		}
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
    2e82:	4b24      	ldr	r3, [pc, #144]	; (2f14 <udc_req_std_dev_set_configuration+0xb0>)
    2e84:	885b      	ldrh	r3, [r3, #2]
    2e86:	001a      	movs	r2, r3
    2e88:	23ff      	movs	r3, #255	; 0xff
    2e8a:	401a      	ands	r2, r3
				udc_config.confdev_lsfs->bNumConfigurations) {
    2e8c:	4b23      	ldr	r3, [pc, #140]	; (2f1c <udc_req_std_dev_set_configuration+0xb8>)
    2e8e:	681b      	ldr	r3, [r3, #0]
    2e90:	7c5b      	ldrb	r3, [r3, #17]
		}
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
    2e92:	429a      	cmp	r2, r3
    2e94:	dd01      	ble.n	2e9a <udc_req_std_dev_set_configuration+0x36>
				udc_config.confdev_lsfs->bNumConfigurations) {
			return false;
    2e96:	2300      	movs	r3, #0
    2e98:	e038      	b.n	2f0c <udc_req_std_dev_set_configuration+0xa8>
		}
	}

	// Reset current configuration
	udc_reset();
    2e9a:	4b21      	ldr	r3, [pc, #132]	; (2f20 <udc_req_std_dev_set_configuration+0xbc>)
    2e9c:	4798      	blx	r3

	// Enable new configuration
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
    2e9e:	4b1d      	ldr	r3, [pc, #116]	; (2f14 <udc_req_std_dev_set_configuration+0xb0>)
    2ea0:	885b      	ldrh	r3, [r3, #2]
    2ea2:	b2da      	uxtb	r2, r3
    2ea4:	4b1f      	ldr	r3, [pc, #124]	; (2f24 <udc_req_std_dev_set_configuration+0xc0>)
    2ea6:	701a      	strb	r2, [r3, #0]
	if (udc_num_configuration == 0) {
    2ea8:	4b1e      	ldr	r3, [pc, #120]	; (2f24 <udc_req_std_dev_set_configuration+0xc0>)
    2eaa:	781b      	ldrb	r3, [r3, #0]
    2eac:	2b00      	cmp	r3, #0
    2eae:	d101      	bne.n	2eb4 <udc_req_std_dev_set_configuration+0x50>
		return true; // Default empty configuration requested
    2eb0:	2301      	movs	r3, #1
    2eb2:	e02b      	b.n	2f0c <udc_req_std_dev_set_configuration+0xa8>
		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
	} else
#endif
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
    2eb4:	4b19      	ldr	r3, [pc, #100]	; (2f1c <udc_req_std_dev_set_configuration+0xb8>)
    2eb6:	685a      	ldr	r2, [r3, #4]
    2eb8:	4b1a      	ldr	r3, [pc, #104]	; (2f24 <udc_req_std_dev_set_configuration+0xc0>)
    2eba:	781b      	ldrb	r3, [r3, #0]
    2ebc:	491a      	ldr	r1, [pc, #104]	; (2f28 <udc_req_std_dev_set_configuration+0xc4>)
    2ebe:	468c      	mov	ip, r1
    2ec0:	4463      	add	r3, ip
    2ec2:	00db      	lsls	r3, r3, #3
    2ec4:	18d2      	adds	r2, r2, r3
    2ec6:	4b19      	ldr	r3, [pc, #100]	; (2f2c <udc_req_std_dev_set_configuration+0xc8>)
    2ec8:	601a      	str	r2, [r3, #0]
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
    2eca:	1dfb      	adds	r3, r7, #7
    2ecc:	2200      	movs	r2, #0
    2ece:	701a      	strb	r2, [r3, #0]
    2ed0:	e013      	b.n	2efa <udc_req_std_dev_set_configuration+0x96>
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
    2ed2:	1dfb      	adds	r3, r7, #7
    2ed4:	781b      	ldrb	r3, [r3, #0]
    2ed6:	2100      	movs	r1, #0
    2ed8:	0018      	movs	r0, r3
    2eda:	4b15      	ldr	r3, [pc, #84]	; (2f30 <udc_req_std_dev_set_configuration+0xcc>)
    2edc:	4798      	blx	r3
    2ede:	0003      	movs	r3, r0
    2ee0:	001a      	movs	r2, r3
    2ee2:	2301      	movs	r3, #1
    2ee4:	4053      	eors	r3, r2
    2ee6:	b2db      	uxtb	r3, r3
    2ee8:	2b00      	cmp	r3, #0
    2eea:	d001      	beq.n	2ef0 <udc_req_std_dev_set_configuration+0x8c>
			return false;
    2eec:	2300      	movs	r3, #0
    2eee:	e00d      	b.n	2f0c <udc_req_std_dev_set_configuration+0xa8>
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
    2ef0:	1dfb      	adds	r3, r7, #7
    2ef2:	781a      	ldrb	r2, [r3, #0]
    2ef4:	1dfb      	adds	r3, r7, #7
    2ef6:	3201      	adds	r2, #1
    2ef8:	701a      	strb	r2, [r3, #0]
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
    2efa:	4b0c      	ldr	r3, [pc, #48]	; (2f2c <udc_req_std_dev_set_configuration+0xc8>)
    2efc:	681b      	ldr	r3, [r3, #0]
    2efe:	681b      	ldr	r3, [r3, #0]
    2f00:	791b      	ldrb	r3, [r3, #4]
    2f02:	1dfa      	adds	r2, r7, #7
    2f04:	7812      	ldrb	r2, [r2, #0]
    2f06:	429a      	cmp	r2, r3
    2f08:	d3e3      	bcc.n	2ed2 <udc_req_std_dev_set_configuration+0x6e>
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
			return false;
		}
	}
	return true;
    2f0a:	2301      	movs	r3, #1
}
    2f0c:	0018      	movs	r0, r3
    2f0e:	46bd      	mov	sp, r7
    2f10:	b002      	add	sp, #8
    2f12:	bd80      	pop	{r7, pc}
    2f14:	2000147c 	.word	0x2000147c
    2f18:	00005129 	.word	0x00005129
    2f1c:	20000170 	.word	0x20000170
    2f20:	000029e5 	.word	0x000029e5
    2f24:	2000074c 	.word	0x2000074c
    2f28:	1fffffff 	.word	0x1fffffff
    2f2c:	20000750 	.word	0x20000750
    2f30:	00002921 	.word	0x00002921

00002f34 <udc_req_std_iface_get_setting>:
 * to get the alternate setting number of an interface
 *
 * \return true if success
 */
static bool udc_req_std_iface_get_setting(void)
{
    2f34:	b580      	push	{r7, lr}
    2f36:	b082      	sub	sp, #8
    2f38:	af00      	add	r7, sp, #0
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (udd_g_ctrlreq.req.wLength != 1) {
    2f3a:	4b21      	ldr	r3, [pc, #132]	; (2fc0 <udc_req_std_iface_get_setting+0x8c>)
    2f3c:	88db      	ldrh	r3, [r3, #6]
    2f3e:	2b01      	cmp	r3, #1
    2f40:	d001      	beq.n	2f46 <udc_req_std_iface_get_setting+0x12>
		return false; // Error in request
    2f42:	2300      	movs	r3, #0
    2f44:	e038      	b.n	2fb8 <udc_req_std_iface_get_setting+0x84>
	}
	if (!udc_num_configuration) {
    2f46:	4b1f      	ldr	r3, [pc, #124]	; (2fc4 <udc_req_std_iface_get_setting+0x90>)
    2f48:	781b      	ldrb	r3, [r3, #0]
    2f4a:	2b00      	cmp	r3, #0
    2f4c:	d101      	bne.n	2f52 <udc_req_std_iface_get_setting+0x1e>
		return false; // The device is not is configured state yet
    2f4e:	2300      	movs	r3, #0
    2f50:	e032      	b.n	2fb8 <udc_req_std_iface_get_setting+0x84>
	}

	// Check the interface number included in the request
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
    2f52:	4b1b      	ldr	r3, [pc, #108]	; (2fc0 <udc_req_std_iface_get_setting+0x8c>)
    2f54:	889a      	ldrh	r2, [r3, #4]
    2f56:	1dfb      	adds	r3, r7, #7
    2f58:	701a      	strb	r2, [r3, #0]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
    2f5a:	4b1b      	ldr	r3, [pc, #108]	; (2fc8 <udc_req_std_iface_get_setting+0x94>)
    2f5c:	681b      	ldr	r3, [r3, #0]
    2f5e:	681b      	ldr	r3, [r3, #0]
    2f60:	791b      	ldrb	r3, [r3, #4]
    2f62:	1dfa      	adds	r2, r7, #7
    2f64:	7812      	ldrb	r2, [r2, #0]
    2f66:	429a      	cmp	r2, r3
    2f68:	d301      	bcc.n	2f6e <udc_req_std_iface_get_setting+0x3a>
		return false;
    2f6a:	2300      	movs	r3, #0
    2f6c:	e024      	b.n	2fb8 <udc_req_std_iface_get_setting+0x84>
	}

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
    2f6e:	1dfb      	adds	r3, r7, #7
    2f70:	781b      	ldrb	r3, [r3, #0]
    2f72:	2100      	movs	r1, #0
    2f74:	0018      	movs	r0, r3
    2f76:	4b15      	ldr	r3, [pc, #84]	; (2fcc <udc_req_std_iface_get_setting+0x98>)
    2f78:	4798      	blx	r3
    2f7a:	0003      	movs	r3, r0
    2f7c:	001a      	movs	r2, r3
    2f7e:	2301      	movs	r3, #1
    2f80:	4053      	eors	r3, r2
    2f82:	b2db      	uxtb	r3, r3
    2f84:	2b00      	cmp	r3, #0
    2f86:	d001      	beq.n	2f8c <udc_req_std_iface_get_setting+0x58>
		return false;
    2f88:	2300      	movs	r3, #0
    2f8a:	e015      	b.n	2fb8 <udc_req_std_iface_get_setting+0x84>
	}
	// Get alternate setting from UDI
	udi_api = udc_ptr_conf->udi_apis[iface_num];
    2f8c:	4b0e      	ldr	r3, [pc, #56]	; (2fc8 <udc_req_std_iface_get_setting+0x94>)
    2f8e:	681b      	ldr	r3, [r3, #0]
    2f90:	685a      	ldr	r2, [r3, #4]
    2f92:	1dfb      	adds	r3, r7, #7
    2f94:	781b      	ldrb	r3, [r3, #0]
    2f96:	009b      	lsls	r3, r3, #2
    2f98:	18d3      	adds	r3, r2, r3
    2f9a:	681b      	ldr	r3, [r3, #0]
    2f9c:	603b      	str	r3, [r7, #0]
	udc_iface_setting = udi_api->getsetting();
    2f9e:	683b      	ldr	r3, [r7, #0]
    2fa0:	68db      	ldr	r3, [r3, #12]
    2fa2:	4798      	blx	r3
    2fa4:	0003      	movs	r3, r0
    2fa6:	001a      	movs	r2, r3
    2fa8:	4b09      	ldr	r3, [pc, #36]	; (2fd0 <udc_req_std_iface_get_setting+0x9c>)
    2faa:	701a      	strb	r2, [r3, #0]

	// Link value to payload pointer of request
	udd_set_setup_payload(&udc_iface_setting,1);
    2fac:	4b08      	ldr	r3, [pc, #32]	; (2fd0 <udc_req_std_iface_get_setting+0x9c>)
    2fae:	2101      	movs	r1, #1
    2fb0:	0018      	movs	r0, r3
    2fb2:	4b08      	ldr	r3, [pc, #32]	; (2fd4 <udc_req_std_iface_get_setting+0xa0>)
    2fb4:	4798      	blx	r3
	return true;
    2fb6:	2301      	movs	r3, #1
}
    2fb8:	0018      	movs	r0, r3
    2fba:	46bd      	mov	sp, r7
    2fbc:	b002      	add	sp, #8
    2fbe:	bd80      	pop	{r7, pc}
    2fc0:	2000147c 	.word	0x2000147c
    2fc4:	2000074c 	.word	0x2000074c
    2fc8:	20000750 	.word	0x20000750
    2fcc:	000027cd 	.word	0x000027cd
    2fd0:	20000748 	.word	0x20000748
    2fd4:	00005145 	.word	0x00005145

00002fd8 <udc_req_std_iface_set_setting>:
 * to set an alternate setting of an interface
 *
 * \return true if success
 */
static bool udc_req_std_iface_set_setting(void)
{
    2fd8:	b580      	push	{r7, lr}
    2fda:	b082      	sub	sp, #8
    2fdc:	af00      	add	r7, sp, #0
	uint8_t iface_num, setting_num;

	if (udd_g_ctrlreq.req.wLength) {
    2fde:	4b17      	ldr	r3, [pc, #92]	; (303c <udc_req_std_iface_set_setting+0x64>)
    2fe0:	88db      	ldrh	r3, [r3, #6]
    2fe2:	2b00      	cmp	r3, #0
    2fe4:	d001      	beq.n	2fea <udc_req_std_iface_set_setting+0x12>
		return false; // Error in request
    2fe6:	2300      	movs	r3, #0
    2fe8:	e024      	b.n	3034 <udc_req_std_iface_set_setting+0x5c>
	}
	if (!udc_num_configuration) {
    2fea:	4b15      	ldr	r3, [pc, #84]	; (3040 <udc_req_std_iface_set_setting+0x68>)
    2fec:	781b      	ldrb	r3, [r3, #0]
    2fee:	2b00      	cmp	r3, #0
    2ff0:	d101      	bne.n	2ff6 <udc_req_std_iface_set_setting+0x1e>
		return false; // The device is not is configured state yet
    2ff2:	2300      	movs	r3, #0
    2ff4:	e01e      	b.n	3034 <udc_req_std_iface_set_setting+0x5c>
	}

	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
    2ff6:	4b11      	ldr	r3, [pc, #68]	; (303c <udc_req_std_iface_set_setting+0x64>)
    2ff8:	889a      	ldrh	r2, [r3, #4]
    2ffa:	1dfb      	adds	r3, r7, #7
    2ffc:	701a      	strb	r2, [r3, #0]
	setting_num = udd_g_ctrlreq.req.wValue & 0xFF;
    2ffe:	4b0f      	ldr	r3, [pc, #60]	; (303c <udc_req_std_iface_set_setting+0x64>)
    3000:	885a      	ldrh	r2, [r3, #2]
    3002:	1dbb      	adds	r3, r7, #6
    3004:	701a      	strb	r2, [r3, #0]

	// Disable current setting
	if (!udc_iface_disable(iface_num)) {
    3006:	1dfb      	adds	r3, r7, #7
    3008:	781b      	ldrb	r3, [r3, #0]
    300a:	0018      	movs	r0, r3
    300c:	4b0d      	ldr	r3, [pc, #52]	; (3044 <udc_req_std_iface_set_setting+0x6c>)
    300e:	4798      	blx	r3
    3010:	0003      	movs	r3, r0
    3012:	001a      	movs	r2, r3
    3014:	2301      	movs	r3, #1
    3016:	4053      	eors	r3, r2
    3018:	b2db      	uxtb	r3, r3
    301a:	2b00      	cmp	r3, #0
    301c:	d001      	beq.n	3022 <udc_req_std_iface_set_setting+0x4a>
		return false;
    301e:	2300      	movs	r3, #0
    3020:	e008      	b.n	3034 <udc_req_std_iface_set_setting+0x5c>
	}

	// Enable new setting
	return udc_iface_enable(iface_num, setting_num);
    3022:	1dbb      	adds	r3, r7, #6
    3024:	781a      	ldrb	r2, [r3, #0]
    3026:	1dfb      	adds	r3, r7, #7
    3028:	781b      	ldrb	r3, [r3, #0]
    302a:	0011      	movs	r1, r2
    302c:	0018      	movs	r0, r3
    302e:	4b06      	ldr	r3, [pc, #24]	; (3048 <udc_req_std_iface_set_setting+0x70>)
    3030:	4798      	blx	r3
    3032:	0003      	movs	r3, r0
}
    3034:	0018      	movs	r0, r3
    3036:	46bd      	mov	sp, r7
    3038:	b002      	add	sp, #8
    303a:	bd80      	pop	{r7, pc}
    303c:	2000147c 	.word	0x2000147c
    3040:	2000074c 	.word	0x2000074c
    3044:	00002871 	.word	0x00002871
    3048:	00002921 	.word	0x00002921

0000304c <udc_reqstd>:
 * \brief Main routine to manage the standard USB SETUP request
 *
 * \return true if the request is supported
 */
static bool udc_reqstd(void)
{
    304c:	b580      	push	{r7, lr}
    304e:	af00      	add	r7, sp, #0
	if (Udd_setup_is_in()) {
    3050:	4b47      	ldr	r3, [pc, #284]	; (3170 <udc_reqstd+0x124>)
    3052:	781b      	ldrb	r3, [r3, #0]
    3054:	b25b      	sxtb	r3, r3
    3056:	2b00      	cmp	r3, #0
    3058:	da40      	bge.n	30dc <udc_reqstd+0x90>
		// GET Standard Requests
		if (udd_g_ctrlreq.req.wLength == 0) {
    305a:	4b45      	ldr	r3, [pc, #276]	; (3170 <udc_reqstd+0x124>)
    305c:	88db      	ldrh	r3, [r3, #6]
    305e:	2b00      	cmp	r3, #0
    3060:	d101      	bne.n	3066 <udc_reqstd+0x1a>
			return false; // Error for USB host
    3062:	2300      	movs	r3, #0
    3064:	e081      	b.n	316a <udc_reqstd+0x11e>
		}

		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
    3066:	4b42      	ldr	r3, [pc, #264]	; (3170 <udc_reqstd+0x124>)
    3068:	781b      	ldrb	r3, [r3, #0]
    306a:	001a      	movs	r2, r3
    306c:	231f      	movs	r3, #31
    306e:	4013      	ands	r3, r2
    3070:	d114      	bne.n	309c <udc_reqstd+0x50>
			// Standard Get Device request
			switch (udd_g_ctrlreq.req.bRequest) {
    3072:	4b3f      	ldr	r3, [pc, #252]	; (3170 <udc_reqstd+0x124>)
    3074:	785b      	ldrb	r3, [r3, #1]
    3076:	2b06      	cmp	r3, #6
    3078:	d008      	beq.n	308c <udc_reqstd+0x40>
    307a:	2b08      	cmp	r3, #8
    307c:	d00a      	beq.n	3094 <udc_reqstd+0x48>
    307e:	2b00      	cmp	r3, #0
    3080:	d000      	beq.n	3084 <udc_reqstd+0x38>
			case USB_REQ_GET_DESCRIPTOR:
				return udc_req_std_dev_get_descriptor();
			case USB_REQ_GET_CONFIGURATION:
				return udc_req_std_dev_get_configuration();
			default:
				break;
    3082:	e00b      	b.n	309c <udc_reqstd+0x50>

		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
			// Standard Get Device request
			switch (udd_g_ctrlreq.req.bRequest) {
			case USB_REQ_GET_STATUS:
				return udc_req_std_dev_get_status();
    3084:	4b3b      	ldr	r3, [pc, #236]	; (3174 <udc_reqstd+0x128>)
    3086:	4798      	blx	r3
    3088:	0003      	movs	r3, r0
    308a:	e06e      	b.n	316a <udc_reqstd+0x11e>
			case USB_REQ_GET_DESCRIPTOR:
				return udc_req_std_dev_get_descriptor();
    308c:	4b3a      	ldr	r3, [pc, #232]	; (3178 <udc_reqstd+0x12c>)
    308e:	4798      	blx	r3
    3090:	0003      	movs	r3, r0
    3092:	e06a      	b.n	316a <udc_reqstd+0x11e>
			case USB_REQ_GET_CONFIGURATION:
				return udc_req_std_dev_get_configuration();
    3094:	4b39      	ldr	r3, [pc, #228]	; (317c <udc_reqstd+0x130>)
    3096:	4798      	blx	r3
    3098:	0003      	movs	r3, r0
    309a:	e066      	b.n	316a <udc_reqstd+0x11e>
			default:
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
    309c:	4b34      	ldr	r3, [pc, #208]	; (3170 <udc_reqstd+0x124>)
    309e:	781b      	ldrb	r3, [r3, #0]
    30a0:	001a      	movs	r2, r3
    30a2:	231f      	movs	r3, #31
    30a4:	4013      	ands	r3, r2
    30a6:	2b01      	cmp	r3, #1
    30a8:	d108      	bne.n	30bc <udc_reqstd+0x70>
			// Standard Get Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
    30aa:	4b31      	ldr	r3, [pc, #196]	; (3170 <udc_reqstd+0x124>)
    30ac:	785b      	ldrb	r3, [r3, #1]
    30ae:	2b0a      	cmp	r3, #10
    30b0:	d000      	beq.n	30b4 <udc_reqstd+0x68>
			case USB_REQ_GET_INTERFACE:
				return udc_req_std_iface_get_setting();
			default:
				break;
    30b2:	e003      	b.n	30bc <udc_reqstd+0x70>

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
			// Standard Get Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
			case USB_REQ_GET_INTERFACE:
				return udc_req_std_iface_get_setting();
    30b4:	4b32      	ldr	r3, [pc, #200]	; (3180 <udc_reqstd+0x134>)
    30b6:	4798      	blx	r3
    30b8:	0003      	movs	r3, r0
    30ba:	e056      	b.n	316a <udc_reqstd+0x11e>
			default:
				break;
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
    30bc:	4b2c      	ldr	r3, [pc, #176]	; (3170 <udc_reqstd+0x124>)
    30be:	781b      	ldrb	r3, [r3, #0]
    30c0:	001a      	movs	r2, r3
    30c2:	231f      	movs	r3, #31
    30c4:	4013      	ands	r3, r2
    30c6:	2b02      	cmp	r3, #2
    30c8:	d14e      	bne.n	3168 <udc_reqstd+0x11c>
			// Standard Get Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
    30ca:	4b29      	ldr	r3, [pc, #164]	; (3170 <udc_reqstd+0x124>)
    30cc:	785b      	ldrb	r3, [r3, #1]
    30ce:	2b00      	cmp	r3, #0
    30d0:	d000      	beq.n	30d4 <udc_reqstd+0x88>
			case USB_REQ_GET_STATUS:
				return udc_req_std_ep_get_status();
			default:
				break;
    30d2:	e049      	b.n	3168 <udc_reqstd+0x11c>
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
			// Standard Get Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
			case USB_REQ_GET_STATUS:
				return udc_req_std_ep_get_status();
    30d4:	4b2b      	ldr	r3, [pc, #172]	; (3184 <udc_reqstd+0x138>)
    30d6:	4798      	blx	r3
    30d8:	0003      	movs	r3, r0
    30da:	e046      	b.n	316a <udc_reqstd+0x11e>
			}
		}
#endif
	} else {
		// SET Standard Requests
		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
    30dc:	4b24      	ldr	r3, [pc, #144]	; (3170 <udc_reqstd+0x124>)
    30de:	781b      	ldrb	r3, [r3, #0]
    30e0:	001a      	movs	r2, r3
    30e2:	231f      	movs	r3, #31
    30e4:	4013      	ands	r3, r2
    30e6:	d119      	bne.n	311c <udc_reqstd+0xd0>
			// Standard Set Device request
			switch (udd_g_ctrlreq.req.bRequest) {
    30e8:	4b21      	ldr	r3, [pc, #132]	; (3170 <udc_reqstd+0x124>)
    30ea:	785b      	ldrb	r3, [r3, #1]
    30ec:	2b09      	cmp	r3, #9
    30ee:	d814      	bhi.n	311a <udc_reqstd+0xce>
    30f0:	009a      	lsls	r2, r3, #2
    30f2:	4b25      	ldr	r3, [pc, #148]	; (3188 <udc_reqstd+0x13c>)
    30f4:	18d3      	adds	r3, r2, r3
    30f6:	681b      	ldr	r3, [r3, #0]
    30f8:	469f      	mov	pc, r3
			case USB_REQ_SET_ADDRESS:
				return udc_req_std_dev_set_address();
    30fa:	4b24      	ldr	r3, [pc, #144]	; (318c <udc_reqstd+0x140>)
    30fc:	4798      	blx	r3
    30fe:	0003      	movs	r3, r0
    3100:	e033      	b.n	316a <udc_reqstd+0x11e>
			case USB_REQ_CLEAR_FEATURE:
				return udc_req_std_dev_clear_feature();
    3102:	4b23      	ldr	r3, [pc, #140]	; (3190 <udc_reqstd+0x144>)
    3104:	4798      	blx	r3
    3106:	0003      	movs	r3, r0
    3108:	e02f      	b.n	316a <udc_reqstd+0x11e>
			case USB_REQ_SET_FEATURE:
				return udc_req_std_dev_set_feature();
    310a:	4b22      	ldr	r3, [pc, #136]	; (3194 <udc_reqstd+0x148>)
    310c:	4798      	blx	r3
    310e:	0003      	movs	r3, r0
    3110:	e02b      	b.n	316a <udc_reqstd+0x11e>
			case USB_REQ_SET_CONFIGURATION:
				return udc_req_std_dev_set_configuration();
    3112:	4b21      	ldr	r3, [pc, #132]	; (3198 <udc_reqstd+0x14c>)
    3114:	4798      	blx	r3
    3116:	0003      	movs	r3, r0
    3118:	e027      	b.n	316a <udc_reqstd+0x11e>
			case USB_REQ_SET_DESCRIPTOR:
				/* Not supported (defined as optional by the USB 2.0 spec) */
				break;
			default:
				break;
    311a:	46c0      	nop			; (mov r8, r8)
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
    311c:	4b14      	ldr	r3, [pc, #80]	; (3170 <udc_reqstd+0x124>)
    311e:	781b      	ldrb	r3, [r3, #0]
    3120:	001a      	movs	r2, r3
    3122:	231f      	movs	r3, #31
    3124:	4013      	ands	r3, r2
    3126:	2b01      	cmp	r3, #1
    3128:	d108      	bne.n	313c <udc_reqstd+0xf0>
			// Standard Set Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
    312a:	4b11      	ldr	r3, [pc, #68]	; (3170 <udc_reqstd+0x124>)
    312c:	785b      	ldrb	r3, [r3, #1]
    312e:	2b0b      	cmp	r3, #11
    3130:	d000      	beq.n	3134 <udc_reqstd+0xe8>
			case USB_REQ_SET_INTERFACE:
				return udc_req_std_iface_set_setting();
			default:
				break;
    3132:	e003      	b.n	313c <udc_reqstd+0xf0>

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
			// Standard Set Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
			case USB_REQ_SET_INTERFACE:
				return udc_req_std_iface_set_setting();
    3134:	4b19      	ldr	r3, [pc, #100]	; (319c <udc_reqstd+0x150>)
    3136:	4798      	blx	r3
    3138:	0003      	movs	r3, r0
    313a:	e016      	b.n	316a <udc_reqstd+0x11e>
			default:
				break;
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
    313c:	4b0c      	ldr	r3, [pc, #48]	; (3170 <udc_reqstd+0x124>)
    313e:	781b      	ldrb	r3, [r3, #0]
    3140:	001a      	movs	r2, r3
    3142:	231f      	movs	r3, #31
    3144:	4013      	ands	r3, r2
    3146:	2b02      	cmp	r3, #2
    3148:	d10e      	bne.n	3168 <udc_reqstd+0x11c>
			// Standard Set Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
    314a:	4b09      	ldr	r3, [pc, #36]	; (3170 <udc_reqstd+0x124>)
    314c:	785b      	ldrb	r3, [r3, #1]
    314e:	2b01      	cmp	r3, #1
    3150:	d002      	beq.n	3158 <udc_reqstd+0x10c>
    3152:	2b03      	cmp	r3, #3
    3154:	d004      	beq.n	3160 <udc_reqstd+0x114>
			case USB_REQ_CLEAR_FEATURE:
				return udc_req_std_ep_clear_feature();
			case USB_REQ_SET_FEATURE:
				return udc_req_std_ep_set_feature();
			default:
				break;
    3156:	e007      	b.n	3168 <udc_reqstd+0x11c>
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
			// Standard Set Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
			case USB_REQ_CLEAR_FEATURE:
				return udc_req_std_ep_clear_feature();
    3158:	4b11      	ldr	r3, [pc, #68]	; (31a0 <udc_reqstd+0x154>)
    315a:	4798      	blx	r3
    315c:	0003      	movs	r3, r0
    315e:	e004      	b.n	316a <udc_reqstd+0x11e>
			case USB_REQ_SET_FEATURE:
				return udc_req_std_ep_set_feature();
    3160:	4b10      	ldr	r3, [pc, #64]	; (31a4 <udc_reqstd+0x158>)
    3162:	4798      	blx	r3
    3164:	0003      	movs	r3, r0
    3166:	e000      	b.n	316a <udc_reqstd+0x11e>
				break;
			}
		}
#endif
	}
	return false;
    3168:	2300      	movs	r3, #0
}
    316a:	0018      	movs	r0, r3
    316c:	46bd      	mov	sp, r7
    316e:	bd80      	pop	{r7, pc}
    3170:	2000147c 	.word	0x2000147c
    3174:	00002ab1 	.word	0x00002ab1
    3178:	00002d39 	.word	0x00002d39
    317c:	00002e35 	.word	0x00002e35
    3180:	00002f35 	.word	0x00002f35
    3184:	00002ae1 	.word	0x00002ae1
    3188:	000151b4 	.word	0x000151b4
    318c:	00002c35 	.word	0x00002c35
    3190:	00002b29 	.word	0x00002b29
    3194:	00002b9d 	.word	0x00002b9d
    3198:	00002e65 	.word	0x00002e65
    319c:	00002fd9 	.word	0x00002fd9
    31a0:	00002b65 	.word	0x00002b65
    31a4:	00002bc9 	.word	0x00002bc9

000031a8 <udc_req_iface>:
 * \brief Send the SETUP interface request to UDI
 *
 * \return true if the request is supported
 */
static bool udc_req_iface(void)
{
    31a8:	b580      	push	{r7, lr}
    31aa:	b082      	sub	sp, #8
    31ac:	af00      	add	r7, sp, #0
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
    31ae:	4b24      	ldr	r3, [pc, #144]	; (3240 <udc_req_iface+0x98>)
    31b0:	781b      	ldrb	r3, [r3, #0]
    31b2:	2b00      	cmp	r3, #0
    31b4:	d101      	bne.n	31ba <udc_req_iface+0x12>
		return false; // The device is not is configured state yet
    31b6:	2300      	movs	r3, #0
    31b8:	e03d      	b.n	3236 <udc_req_iface+0x8e>
	}
	// Check interface number
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
    31ba:	4b22      	ldr	r3, [pc, #136]	; (3244 <udc_req_iface+0x9c>)
    31bc:	889a      	ldrh	r2, [r3, #4]
    31be:	1dfb      	adds	r3, r7, #7
    31c0:	701a      	strb	r2, [r3, #0]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
    31c2:	4b21      	ldr	r3, [pc, #132]	; (3248 <udc_req_iface+0xa0>)
    31c4:	681b      	ldr	r3, [r3, #0]
    31c6:	681b      	ldr	r3, [r3, #0]
    31c8:	791b      	ldrb	r3, [r3, #4]
    31ca:	1dfa      	adds	r2, r7, #7
    31cc:	7812      	ldrb	r2, [r2, #0]
    31ce:	429a      	cmp	r2, r3
    31d0:	d301      	bcc.n	31d6 <udc_req_iface+0x2e>
		return false;
    31d2:	2300      	movs	r3, #0
    31d4:	e02f      	b.n	3236 <udc_req_iface+0x8e>
	}

	//* To update udc_ptr_iface with the selected interface in request
	// Select first alternate setting of interface to update udc_ptr_iface
	// before calling udi_api->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
    31d6:	1dfb      	adds	r3, r7, #7
    31d8:	781b      	ldrb	r3, [r3, #0]
    31da:	2100      	movs	r1, #0
    31dc:	0018      	movs	r0, r3
    31de:	4b1b      	ldr	r3, [pc, #108]	; (324c <udc_req_iface+0xa4>)
    31e0:	4798      	blx	r3
    31e2:	0003      	movs	r3, r0
    31e4:	001a      	movs	r2, r3
    31e6:	2301      	movs	r3, #1
    31e8:	4053      	eors	r3, r2
    31ea:	b2db      	uxtb	r3, r3
    31ec:	2b00      	cmp	r3, #0
    31ee:	d001      	beq.n	31f4 <udc_req_iface+0x4c>
		return false;
    31f0:	2300      	movs	r3, #0
    31f2:	e020      	b.n	3236 <udc_req_iface+0x8e>
	}
	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
    31f4:	4b14      	ldr	r3, [pc, #80]	; (3248 <udc_req_iface+0xa0>)
    31f6:	681b      	ldr	r3, [r3, #0]
    31f8:	685a      	ldr	r2, [r3, #4]
    31fa:	1dfb      	adds	r3, r7, #7
    31fc:	781b      	ldrb	r3, [r3, #0]
    31fe:	009b      	lsls	r3, r3, #2
    3200:	18d3      	adds	r3, r2, r3
    3202:	681b      	ldr	r3, [r3, #0]
    3204:	603b      	str	r3, [r7, #0]
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
    3206:	683b      	ldr	r3, [r7, #0]
    3208:	68db      	ldr	r3, [r3, #12]
    320a:	4798      	blx	r3
    320c:	0003      	movs	r3, r0
    320e:	001a      	movs	r2, r3
    3210:	1dfb      	adds	r3, r7, #7
    3212:	781b      	ldrb	r3, [r3, #0]
    3214:	0011      	movs	r1, r2
    3216:	0018      	movs	r0, r3
    3218:	4b0c      	ldr	r3, [pc, #48]	; (324c <udc_req_iface+0xa4>)
    321a:	4798      	blx	r3
    321c:	0003      	movs	r3, r0
    321e:	001a      	movs	r2, r3
    3220:	2301      	movs	r3, #1
    3222:	4053      	eors	r3, r2
    3224:	b2db      	uxtb	r3, r3
    3226:	2b00      	cmp	r3, #0
    3228:	d001      	beq.n	322e <udc_req_iface+0x86>
		return false;
    322a:	2300      	movs	r3, #0
    322c:	e003      	b.n	3236 <udc_req_iface+0x8e>
	}

	// Send the SETUP request to the UDI corresponding to the interface number
	return udi_api->setup();
    322e:	683b      	ldr	r3, [r7, #0]
    3230:	689b      	ldr	r3, [r3, #8]
    3232:	4798      	blx	r3
    3234:	0003      	movs	r3, r0
}
    3236:	0018      	movs	r0, r3
    3238:	46bd      	mov	sp, r7
    323a:	b002      	add	sp, #8
    323c:	bd80      	pop	{r7, pc}
    323e:	46c0      	nop			; (mov r8, r8)
    3240:	2000074c 	.word	0x2000074c
    3244:	2000147c 	.word	0x2000147c
    3248:	20000750 	.word	0x20000750
    324c:	000027cd 	.word	0x000027cd

00003250 <udc_req_ep>:
 * \brief Send the SETUP interface request to UDI
 *
 * \return true if the request is supported
 */
static bool udc_req_ep(void)
{
    3250:	b580      	push	{r7, lr}
    3252:	b082      	sub	sp, #8
    3254:	af00      	add	r7, sp, #0
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
    3256:	4b22      	ldr	r3, [pc, #136]	; (32e0 <udc_req_ep+0x90>)
    3258:	781b      	ldrb	r3, [r3, #0]
    325a:	2b00      	cmp	r3, #0
    325c:	d101      	bne.n	3262 <udc_req_ep+0x12>
		return false; // The device is not is configured state yet
    325e:	2300      	movs	r3, #0
    3260:	e039      	b.n	32d6 <udc_req_ep+0x86>
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
    3262:	4b20      	ldr	r3, [pc, #128]	; (32e4 <udc_req_ep+0x94>)
    3264:	889a      	ldrh	r2, [r3, #4]
    3266:	1dfb      	adds	r3, r7, #7
    3268:	701a      	strb	r2, [r3, #0]
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
    326a:	1dfb      	adds	r3, r7, #7
    326c:	2200      	movs	r2, #0
    326e:	701a      	strb	r2, [r3, #0]
    3270:	e028      	b.n	32c4 <udc_req_ep+0x74>
			iface_num++) {
		// Select the interface with the current alternate setting
		udi_api = udc_ptr_conf->udi_apis[iface_num];
    3272:	4b1d      	ldr	r3, [pc, #116]	; (32e8 <udc_req_ep+0x98>)
    3274:	681b      	ldr	r3, [r3, #0]
    3276:	685a      	ldr	r2, [r3, #4]
    3278:	1dfb      	adds	r3, r7, #7
    327a:	781b      	ldrb	r3, [r3, #0]
    327c:	009b      	lsls	r3, r3, #2
    327e:	18d3      	adds	r3, r2, r3
    3280:	681b      	ldr	r3, [r3, #0]
    3282:	603b      	str	r3, [r7, #0]
		if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
    3284:	683b      	ldr	r3, [r7, #0]
    3286:	68db      	ldr	r3, [r3, #12]
    3288:	4798      	blx	r3
    328a:	0003      	movs	r3, r0
    328c:	001a      	movs	r2, r3
    328e:	1dfb      	adds	r3, r7, #7
    3290:	781b      	ldrb	r3, [r3, #0]
    3292:	0011      	movs	r1, r2
    3294:	0018      	movs	r0, r3
    3296:	4b15      	ldr	r3, [pc, #84]	; (32ec <udc_req_ep+0x9c>)
    3298:	4798      	blx	r3
    329a:	0003      	movs	r3, r0
    329c:	001a      	movs	r2, r3
    329e:	2301      	movs	r3, #1
    32a0:	4053      	eors	r3, r2
    32a2:	b2db      	uxtb	r3, r3
    32a4:	2b00      	cmp	r3, #0
    32a6:	d001      	beq.n	32ac <udc_req_ep+0x5c>
			return false;
    32a8:	2300      	movs	r3, #0
    32aa:	e014      	b.n	32d6 <udc_req_ep+0x86>
		}

		// Send the SETUP request to the UDI
		if (udi_api->setup()) {
    32ac:	683b      	ldr	r3, [r7, #0]
    32ae:	689b      	ldr	r3, [r3, #8]
    32b0:	4798      	blx	r3
    32b2:	1e03      	subs	r3, r0, #0
    32b4:	d001      	beq.n	32ba <udc_req_ep+0x6a>
			return true;
    32b6:	2301      	movs	r3, #1
    32b8:	e00d      	b.n	32d6 <udc_req_ep+0x86>
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
    32ba:	1dfb      	adds	r3, r7, #7
    32bc:	781a      	ldrb	r2, [r3, #0]
    32be:	1dfb      	adds	r3, r7, #7
    32c0:	3201      	adds	r2, #1
    32c2:	701a      	strb	r2, [r3, #0]
	if (0 == udc_num_configuration) {
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
    32c4:	4b08      	ldr	r3, [pc, #32]	; (32e8 <udc_req_ep+0x98>)
    32c6:	681b      	ldr	r3, [r3, #0]
    32c8:	681b      	ldr	r3, [r3, #0]
    32ca:	791b      	ldrb	r3, [r3, #4]
    32cc:	1dfa      	adds	r2, r7, #7
    32ce:	7812      	ldrb	r2, [r2, #0]
    32d0:	429a      	cmp	r2, r3
    32d2:	d3ce      	bcc.n	3272 <udc_req_ep+0x22>
		// Send the SETUP request to the UDI
		if (udi_api->setup()) {
			return true;
		}
	}
	return false;
    32d4:	2300      	movs	r3, #0
}
    32d6:	0018      	movs	r0, r3
    32d8:	46bd      	mov	sp, r7
    32da:	b002      	add	sp, #8
    32dc:	bd80      	pop	{r7, pc}
    32de:	46c0      	nop			; (mov r8, r8)
    32e0:	2000074c 	.word	0x2000074c
    32e4:	2000147c 	.word	0x2000147c
    32e8:	20000750 	.word	0x20000750
    32ec:	000027cd 	.word	0x000027cd

000032f0 <udc_process_setup>:
 * sent to a specific application callback.
 *
 * \return true if the request is supported, else the request is stalled by UDD
 */
bool udc_process_setup(void)
{
    32f0:	b580      	push	{r7, lr}
    32f2:	af00      	add	r7, sp, #0
	// By default no data (receive/send) and no callbacks registered
	udd_g_ctrlreq.payload_size = 0;
    32f4:	4b1e      	ldr	r3, [pc, #120]	; (3370 <udc_process_setup+0x80>)
    32f6:	2200      	movs	r2, #0
    32f8:	819a      	strh	r2, [r3, #12]
	udd_g_ctrlreq.callback = NULL;
    32fa:	4b1d      	ldr	r3, [pc, #116]	; (3370 <udc_process_setup+0x80>)
    32fc:	2200      	movs	r2, #0
    32fe:	611a      	str	r2, [r3, #16]
	udd_g_ctrlreq.over_under_run = NULL;
    3300:	4b1b      	ldr	r3, [pc, #108]	; (3370 <udc_process_setup+0x80>)
    3302:	2200      	movs	r2, #0
    3304:	615a      	str	r2, [r3, #20]

	if (Udd_setup_is_in()) {
    3306:	4b1a      	ldr	r3, [pc, #104]	; (3370 <udc_process_setup+0x80>)
    3308:	781b      	ldrb	r3, [r3, #0]
    330a:	b25b      	sxtb	r3, r3
    330c:	2b00      	cmp	r3, #0
    330e:	da05      	bge.n	331c <udc_process_setup+0x2c>
		if (udd_g_ctrlreq.req.wLength == 0) {
    3310:	4b17      	ldr	r3, [pc, #92]	; (3370 <udc_process_setup+0x80>)
    3312:	88db      	ldrh	r3, [r3, #6]
    3314:	2b00      	cmp	r3, #0
    3316:	d101      	bne.n	331c <udc_process_setup+0x2c>
			return false; // Error from USB host
    3318:	2300      	movs	r3, #0
    331a:	e026      	b.n	336a <udc_process_setup+0x7a>
		}
	}

	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
    331c:	4b14      	ldr	r3, [pc, #80]	; (3370 <udc_process_setup+0x80>)
    331e:	781b      	ldrb	r3, [r3, #0]
    3320:	001a      	movs	r2, r3
    3322:	2360      	movs	r3, #96	; 0x60
    3324:	4013      	ands	r3, r2
    3326:	d105      	bne.n	3334 <udc_process_setup+0x44>
		if (udc_reqstd()) {
    3328:	4b12      	ldr	r3, [pc, #72]	; (3374 <udc_process_setup+0x84>)
    332a:	4798      	blx	r3
    332c:	1e03      	subs	r3, r0, #0
    332e:	d001      	beq.n	3334 <udc_process_setup+0x44>
			return true;
    3330:	2301      	movs	r3, #1
    3332:	e01a      	b.n	336a <udc_process_setup+0x7a>
		}
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
    3334:	4b0e      	ldr	r3, [pc, #56]	; (3370 <udc_process_setup+0x80>)
    3336:	781b      	ldrb	r3, [r3, #0]
    3338:	001a      	movs	r2, r3
    333a:	231f      	movs	r3, #31
    333c:	4013      	ands	r3, r2
    333e:	2b01      	cmp	r3, #1
    3340:	d105      	bne.n	334e <udc_process_setup+0x5e>
		if (udc_req_iface()) {
    3342:	4b0d      	ldr	r3, [pc, #52]	; (3378 <udc_process_setup+0x88>)
    3344:	4798      	blx	r3
    3346:	1e03      	subs	r3, r0, #0
    3348:	d001      	beq.n	334e <udc_process_setup+0x5e>
			return true;
    334a:	2301      	movs	r3, #1
    334c:	e00d      	b.n	336a <udc_process_setup+0x7a>
		}
	}

	// If endpoint request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_ENDPOINT) {
    334e:	4b08      	ldr	r3, [pc, #32]	; (3370 <udc_process_setup+0x80>)
    3350:	781b      	ldrb	r3, [r3, #0]
    3352:	001a      	movs	r2, r3
    3354:	231f      	movs	r3, #31
    3356:	4013      	ands	r3, r2
    3358:	2b02      	cmp	r3, #2
    335a:	d105      	bne.n	3368 <udc_process_setup+0x78>
		if (udc_req_ep()) {
    335c:	4b07      	ldr	r3, [pc, #28]	; (337c <udc_process_setup+0x8c>)
    335e:	4798      	blx	r3
    3360:	1e03      	subs	r3, r0, #0
    3362:	d001      	beq.n	3368 <udc_process_setup+0x78>
			return true;
    3364:	2301      	movs	r3, #1
    3366:	e000      	b.n	336a <udc_process_setup+0x7a>
	// Here SETUP request unknown by UDC and UDIs
#ifdef USB_DEVICE_SPECIFIC_REQUEST
	// Try to decode it in specific callback
	return USB_DEVICE_SPECIFIC_REQUEST(); // Ex: Vendor request,...
#else
	return false;
    3368:	2300      	movs	r3, #0
#endif
}
    336a:	0018      	movs	r0, r3
    336c:	46bd      	mov	sp, r7
    336e:	bd80      	pop	{r7, pc}
    3370:	2000147c 	.word	0x2000147c
    3374:	0000304d 	.word	0x0000304d
    3378:	000031a9 	.word	0x000031a9
    337c:	00003251 	.word	0x00003251

00003380 <stdio_usb_putchar>:
#include "stdio_usb.h"

static bool stdio_usb_interface_enable = false;

int stdio_usb_putchar (volatile void * unused, char data)
{
    3380:	b580      	push	{r7, lr}
    3382:	b082      	sub	sp, #8
    3384:	af00      	add	r7, sp, #0
    3386:	6078      	str	r0, [r7, #4]
    3388:	000a      	movs	r2, r1
    338a:	1cfb      	adds	r3, r7, #3
    338c:	701a      	strb	r2, [r3, #0]
	/* A negative return value should be used to indicate that data
	 * was not written, but this doesn't seem to work with GCC libc.
	 */
	if (!stdio_usb_interface_enable) {
    338e:	4b0c      	ldr	r3, [pc, #48]	; (33c0 <stdio_usb_putchar+0x40>)
    3390:	781b      	ldrb	r3, [r3, #0]
    3392:	2201      	movs	r2, #1
    3394:	4053      	eors	r3, r2
    3396:	b2db      	uxtb	r3, r3
    3398:	2b00      	cmp	r3, #0
    339a:	d001      	beq.n	33a0 <stdio_usb_putchar+0x20>
		return 0;  // -1
    339c:	2300      	movs	r3, #0
    339e:	e00b      	b.n	33b8 <stdio_usb_putchar+0x38>
	}

	return udi_cdc_putc(data) ? 0 : -1;
    33a0:	1cfb      	adds	r3, r7, #3
    33a2:	781b      	ldrb	r3, [r3, #0]
    33a4:	0018      	movs	r0, r3
    33a6:	4b07      	ldr	r3, [pc, #28]	; (33c4 <stdio_usb_putchar+0x44>)
    33a8:	4798      	blx	r3
    33aa:	1e03      	subs	r3, r0, #0
    33ac:	d001      	beq.n	33b2 <stdio_usb_putchar+0x32>
    33ae:	2300      	movs	r3, #0
    33b0:	e001      	b.n	33b6 <stdio_usb_putchar+0x36>
    33b2:	2301      	movs	r3, #1
    33b4:	425b      	negs	r3, r3
    33b6:	46c0      	nop			; (mov r8, r8)
}
    33b8:	0018      	movs	r0, r3
    33ba:	46bd      	mov	sp, r7
    33bc:	b002      	add	sp, #8
    33be:	bd80      	pop	{r7, pc}
    33c0:	2000075a 	.word	0x2000075a
    33c4:	00002721 	.word	0x00002721

000033c8 <stdio_usb_getchar>:

void stdio_usb_getchar (void volatile * unused, char *data)
{
    33c8:	b580      	push	{r7, lr}
    33ca:	b082      	sub	sp, #8
    33cc:	af00      	add	r7, sp, #0
    33ce:	6078      	str	r0, [r7, #4]
    33d0:	6039      	str	r1, [r7, #0]
	/* A negative return value should be used to indicate that data
	 * was not read, but this doesn't seem to work with GCC libc.
	 */
	if (!stdio_usb_interface_enable) {
    33d2:	4b0a      	ldr	r3, [pc, #40]	; (33fc <stdio_usb_getchar+0x34>)
    33d4:	781b      	ldrb	r3, [r3, #0]
    33d6:	2201      	movs	r2, #1
    33d8:	4053      	eors	r3, r2
    33da:	b2db      	uxtb	r3, r3
    33dc:	2b00      	cmp	r3, #0
    33de:	d003      	beq.n	33e8 <stdio_usb_getchar+0x20>
		*data = 0;  // -1
    33e0:	683b      	ldr	r3, [r7, #0]
    33e2:	2200      	movs	r2, #0
    33e4:	701a      	strb	r2, [r3, #0]
		return;
    33e6:	e005      	b.n	33f4 <stdio_usb_getchar+0x2c>
	}

	*data = (char)udi_cdc_getc();
    33e8:	4b05      	ldr	r3, [pc, #20]	; (3400 <stdio_usb_getchar+0x38>)
    33ea:	4798      	blx	r3
    33ec:	0003      	movs	r3, r0
    33ee:	b2da      	uxtb	r2, r3
    33f0:	683b      	ldr	r3, [r7, #0]
    33f2:	701a      	strb	r2, [r3, #0]
}
    33f4:	46bd      	mov	sp, r7
    33f6:	b002      	add	sp, #8
    33f8:	bd80      	pop	{r7, pc}
    33fa:	46c0      	nop			; (mov r8, r8)
    33fc:	2000075a 	.word	0x2000075a
    3400:	000024f5 	.word	0x000024f5

00003404 <stdio_usb_enable>:

bool stdio_usb_enable(void)
{
    3404:	b580      	push	{r7, lr}
    3406:	af00      	add	r7, sp, #0
	stdio_usb_interface_enable = true;
    3408:	4b03      	ldr	r3, [pc, #12]	; (3418 <stdio_usb_enable+0x14>)
    340a:	2201      	movs	r2, #1
    340c:	701a      	strb	r2, [r3, #0]
	return true;
    340e:	2301      	movs	r3, #1
}
    3410:	0018      	movs	r0, r3
    3412:	46bd      	mov	sp, r7
    3414:	bd80      	pop	{r7, pc}
    3416:	46c0      	nop			; (mov r8, r8)
    3418:	2000075a 	.word	0x2000075a

0000341c <stdio_usb_disable>:

void stdio_usb_disable(void)
{
    341c:	b580      	push	{r7, lr}
    341e:	af00      	add	r7, sp, #0
	stdio_usb_interface_enable = false;
    3420:	4b02      	ldr	r3, [pc, #8]	; (342c <stdio_usb_disable+0x10>)
    3422:	2200      	movs	r2, #0
    3424:	701a      	strb	r2, [r3, #0]
}
    3426:	46c0      	nop			; (mov r8, r8)
    3428:	46bd      	mov	sp, r7
    342a:	bd80      	pop	{r7, pc}
    342c:	2000075a 	.word	0x2000075a

00003430 <stdio_usb_init>:

void stdio_usb_init(void)
{
    3430:	b580      	push	{r7, lr}
    3432:	af00      	add	r7, sp, #0
	stdio_base = NULL;
    3434:	4b0d      	ldr	r3, [pc, #52]	; (346c <stdio_usb_init+0x3c>)
    3436:	2200      	movs	r2, #0
    3438:	601a      	str	r2, [r3, #0]
	ptr_put = stdio_usb_putchar;
    343a:	4b0d      	ldr	r3, [pc, #52]	; (3470 <stdio_usb_init+0x40>)
    343c:	4a0d      	ldr	r2, [pc, #52]	; (3474 <stdio_usb_init+0x44>)
    343e:	601a      	str	r2, [r3, #0]
	ptr_get = stdio_usb_getchar;
    3440:	4b0d      	ldr	r3, [pc, #52]	; (3478 <stdio_usb_init+0x48>)
    3442:	4a0e      	ldr	r2, [pc, #56]	; (347c <stdio_usb_init+0x4c>)
    3444:	601a      	str	r2, [r3, #0]
	/*
	 * Start and attach USB CDC device interface for devices with
	 * integrated USB interfaces.  Assume the VBUS is present if
	 * VBUS monitoring is not available.
	 */
	udc_start ();
    3446:	4b0e      	ldr	r3, [pc, #56]	; (3480 <stdio_usb_init+0x50>)
    3448:	4798      	blx	r3
	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
# endif
# if UC3 || SAM
	// For AVR32 and SAM GCC
	// Specify that stdout and stdin should not be buffered.
	setbuf(stdout, NULL);
    344a:	4b0e      	ldr	r3, [pc, #56]	; (3484 <stdio_usb_init+0x54>)
    344c:	681b      	ldr	r3, [r3, #0]
    344e:	689b      	ldr	r3, [r3, #8]
    3450:	2100      	movs	r1, #0
    3452:	0018      	movs	r0, r3
    3454:	4b0c      	ldr	r3, [pc, #48]	; (3488 <stdio_usb_init+0x58>)
    3456:	4798      	blx	r3
	setbuf(stdin, NULL);
    3458:	4b0a      	ldr	r3, [pc, #40]	; (3484 <stdio_usb_init+0x54>)
    345a:	681b      	ldr	r3, [r3, #0]
    345c:	685b      	ldr	r3, [r3, #4]
    345e:	2100      	movs	r1, #0
    3460:	0018      	movs	r0, r3
    3462:	4b09      	ldr	r3, [pc, #36]	; (3488 <stdio_usb_init+0x58>)
    3464:	4798      	blx	r3
	// and AVR GCC library:
	// - printf() emits one character at a time.
	// - getchar() requests only 1 byte to exit.
# endif
#endif
}
    3466:	46c0      	nop			; (mov r8, r8)
    3468:	46bd      	mov	sp, r7
    346a:	bd80      	pop	{r7, pc}
    346c:	200014dc 	.word	0x200014dc
    3470:	200014d8 	.word	0x200014d8
    3474:	00003381 	.word	0x00003381
    3478:	200014d4 	.word	0x200014d4
    347c:	000033c9 	.word	0x000033c9
    3480:	000029d1 	.word	0x000029d1
    3484:	200001e0 	.word	0x200001e0
    3488:	00012af9 	.word	0x00012af9

0000348c <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
    348c:	b580      	push	{r7, lr}
    348e:	b082      	sub	sp, #8
    3490:	af00      	add	r7, sp, #0
    3492:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    3494:	687b      	ldr	r3, [r7, #4]
    3496:	2200      	movs	r2, #0
    3498:	701a      	strb	r2, [r3, #0]
}
    349a:	46c0      	nop			; (mov r8, r8)
    349c:	46bd      	mov	sp, r7
    349e:	b002      	add	sp, #8
    34a0:	bd80      	pop	{r7, pc}
    34a2:	46c0      	nop			; (mov r8, r8)

000034a4 <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
    34a4:	b580      	push	{r7, lr}
    34a6:	b082      	sub	sp, #8
    34a8:	af00      	add	r7, sp, #0
    34aa:	0002      	movs	r2, r0
    34ac:	6039      	str	r1, [r7, #0]
    34ae:	1dfb      	adds	r3, r7, #7
    34b0:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    34b2:	1dfb      	adds	r3, r7, #7
    34b4:	781b      	ldrb	r3, [r3, #0]
    34b6:	2b01      	cmp	r3, #1
    34b8:	d00a      	beq.n	34d0 <system_apb_clock_set_mask+0x2c>
    34ba:	2b02      	cmp	r3, #2
    34bc:	d00f      	beq.n	34de <system_apb_clock_set_mask+0x3a>
    34be:	2b00      	cmp	r3, #0
    34c0:	d114      	bne.n	34ec <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    34c2:	4b0e      	ldr	r3, [pc, #56]	; (34fc <system_apb_clock_set_mask+0x58>)
    34c4:	4a0d      	ldr	r2, [pc, #52]	; (34fc <system_apb_clock_set_mask+0x58>)
    34c6:	6991      	ldr	r1, [r2, #24]
    34c8:	683a      	ldr	r2, [r7, #0]
    34ca:	430a      	orrs	r2, r1
    34cc:	619a      	str	r2, [r3, #24]
			break;
    34ce:	e00f      	b.n	34f0 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
    34d0:	4b0a      	ldr	r3, [pc, #40]	; (34fc <system_apb_clock_set_mask+0x58>)
    34d2:	4a0a      	ldr	r2, [pc, #40]	; (34fc <system_apb_clock_set_mask+0x58>)
    34d4:	69d1      	ldr	r1, [r2, #28]
    34d6:	683a      	ldr	r2, [r7, #0]
    34d8:	430a      	orrs	r2, r1
    34da:	61da      	str	r2, [r3, #28]
			break;
    34dc:	e008      	b.n	34f0 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    34de:	4b07      	ldr	r3, [pc, #28]	; (34fc <system_apb_clock_set_mask+0x58>)
    34e0:	4a06      	ldr	r2, [pc, #24]	; (34fc <system_apb_clock_set_mask+0x58>)
    34e2:	6a11      	ldr	r1, [r2, #32]
    34e4:	683a      	ldr	r2, [r7, #0]
    34e6:	430a      	orrs	r2, r1
    34e8:	621a      	str	r2, [r3, #32]
			break;
    34ea:	e001      	b.n	34f0 <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
    34ec:	2317      	movs	r3, #23
    34ee:	e000      	b.n	34f2 <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
    34f0:	2300      	movs	r3, #0
}
    34f2:	0018      	movs	r0, r3
    34f4:	46bd      	mov	sp, r7
    34f6:	b002      	add	sp, #8
    34f8:	bd80      	pop	{r7, pc}
    34fa:	46c0      	nop			; (mov r8, r8)
    34fc:	40000400 	.word	0x40000400

00003500 <system_interrupt_enable>:
 *
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
    3500:	b580      	push	{r7, lr}
    3502:	b082      	sub	sp, #8
    3504:	af00      	add	r7, sp, #0
    3506:	0002      	movs	r2, r0
    3508:	1dfb      	adds	r3, r7, #7
    350a:	701a      	strb	r2, [r3, #0]
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    350c:	4b06      	ldr	r3, [pc, #24]	; (3528 <system_interrupt_enable+0x28>)
    350e:	1dfa      	adds	r2, r7, #7
    3510:	7812      	ldrb	r2, [r2, #0]
    3512:	0011      	movs	r1, r2
    3514:	221f      	movs	r2, #31
    3516:	400a      	ands	r2, r1
    3518:	2101      	movs	r1, #1
    351a:	4091      	lsls	r1, r2
    351c:	000a      	movs	r2, r1
    351e:	601a      	str	r2, [r3, #0]
}
    3520:	46c0      	nop			; (mov r8, r8)
    3522:	46bd      	mov	sp, r7
    3524:	b002      	add	sp, #8
    3526:	bd80      	pop	{r7, pc}
    3528:	e000e100 	.word	0xe000e100

0000352c <extint_is_syncing>:
 *
 * \retval true  If the module synchronization is ongoing
 * \retval false If the module has completed synchronization
 */
static inline bool extint_is_syncing(void)
{
    352c:	b580      	push	{r7, lr}
    352e:	b082      	sub	sp, #8
    3530:	af00      	add	r7, sp, #0
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
    3532:	4b0f      	ldr	r3, [pc, #60]	; (3570 <extint_is_syncing+0x44>)
    3534:	603b      	str	r3, [r7, #0]

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    3536:	2300      	movs	r3, #0
    3538:	607b      	str	r3, [r7, #4]
    353a:	e011      	b.n	3560 <extint_is_syncing+0x34>
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
    353c:	687b      	ldr	r3, [r7, #4]
    353e:	009b      	lsls	r3, r3, #2
    3540:	2208      	movs	r2, #8
    3542:	4694      	mov	ip, r2
    3544:	44bc      	add	ip, r7
    3546:	4463      	add	r3, ip
    3548:	3b08      	subs	r3, #8
    354a:	681b      	ldr	r3, [r3, #0]
    354c:	785b      	ldrb	r3, [r3, #1]
    354e:	b2db      	uxtb	r3, r3
    3550:	b25b      	sxtb	r3, r3
    3552:	2b00      	cmp	r3, #0
    3554:	da01      	bge.n	355a <extint_is_syncing+0x2e>
			return true;
    3556:	2301      	movs	r3, #1
    3558:	e006      	b.n	3568 <extint_is_syncing+0x3c>
 */
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    355a:	687b      	ldr	r3, [r7, #4]
    355c:	3301      	adds	r3, #1
    355e:	607b      	str	r3, [r7, #4]
    3560:	687b      	ldr	r3, [r7, #4]
    3562:	2b00      	cmp	r3, #0
    3564:	d0ea      	beq.n	353c <extint_is_syncing+0x10>
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
			return true;
		}
	}
	return false;
    3566:	2300      	movs	r3, #0
}
    3568:	0018      	movs	r0, r3
    356a:	46bd      	mov	sp, r7
    356c:	b002      	add	sp, #8
    356e:	bd80      	pop	{r7, pc}
    3570:	40001800 	.word	0x40001800

00003574 <_system_extint_init>:
 * \note When SYSTEM module is used, this function will be invoked by
 * \ref system_init() automatically if the module is included.
 */
void _system_extint_init(void);
void _system_extint_init(void)
{
    3574:	b580      	push	{r7, lr}
    3576:	b084      	sub	sp, #16
    3578:	af00      	add	r7, sp, #0
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
    357a:	4b2d      	ldr	r3, [pc, #180]	; (3630 <_system_extint_init+0xbc>)
    357c:	607b      	str	r3, [r7, #4]

	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_EIC);
    357e:	2140      	movs	r1, #64	; 0x40
    3580:	2000      	movs	r0, #0
    3582:	4b2c      	ldr	r3, [pc, #176]	; (3634 <_system_extint_init+0xc0>)
    3584:	4798      	blx	r3

	/* Configure the generic clock for the module and enable it */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
    3586:	003b      	movs	r3, r7
    3588:	0018      	movs	r0, r3
    358a:	4b2b      	ldr	r3, [pc, #172]	; (3638 <_system_extint_init+0xc4>)
    358c:	4798      	blx	r3
	gclk_chan_conf.source_generator = EXTINT_CLOCK_SOURCE;
    358e:	003b      	movs	r3, r7
    3590:	2200      	movs	r2, #0
    3592:	701a      	strb	r2, [r3, #0]
	system_gclk_chan_set_config(EIC_GCLK_ID, &gclk_chan_conf);
    3594:	003b      	movs	r3, r7
    3596:	0019      	movs	r1, r3
    3598:	2005      	movs	r0, #5
    359a:	4b28      	ldr	r3, [pc, #160]	; (363c <_system_extint_init+0xc8>)
    359c:	4798      	blx	r3

	/* Enable the clock anyway, since when needed it will be requested
	 * by External Interrupt driver */
	system_gclk_chan_enable(EIC_GCLK_ID);
    359e:	2005      	movs	r0, #5
    35a0:	4b27      	ldr	r3, [pc, #156]	; (3640 <_system_extint_init+0xcc>)
    35a2:	4798      	blx	r3

	/* Reset all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    35a4:	2300      	movs	r3, #0
    35a6:	60fb      	str	r3, [r7, #12]
    35a8:	e018      	b.n	35dc <_system_extint_init+0x68>
		eics[i]->CTRL.reg |= EIC_CTRL_SWRST;
    35aa:	68fb      	ldr	r3, [r7, #12]
    35ac:	009b      	lsls	r3, r3, #2
    35ae:	2210      	movs	r2, #16
    35b0:	4694      	mov	ip, r2
    35b2:	44bc      	add	ip, r7
    35b4:	4463      	add	r3, ip
    35b6:	3b0c      	subs	r3, #12
    35b8:	681a      	ldr	r2, [r3, #0]
    35ba:	68fb      	ldr	r3, [r7, #12]
    35bc:	009b      	lsls	r3, r3, #2
    35be:	2110      	movs	r1, #16
    35c0:	468c      	mov	ip, r1
    35c2:	44bc      	add	ip, r7
    35c4:	4463      	add	r3, ip
    35c6:	3b0c      	subs	r3, #12
    35c8:	681b      	ldr	r3, [r3, #0]
    35ca:	781b      	ldrb	r3, [r3, #0]
    35cc:	b2db      	uxtb	r3, r3
    35ce:	2101      	movs	r1, #1
    35d0:	430b      	orrs	r3, r1
    35d2:	b2db      	uxtb	r3, r3
    35d4:	7013      	strb	r3, [r2, #0]
	/* Enable the clock anyway, since when needed it will be requested
	 * by External Interrupt driver */
	system_gclk_chan_enable(EIC_GCLK_ID);

	/* Reset all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    35d6:	68fb      	ldr	r3, [r7, #12]
    35d8:	3301      	adds	r3, #1
    35da:	60fb      	str	r3, [r7, #12]
    35dc:	68fb      	ldr	r3, [r7, #12]
    35de:	2b00      	cmp	r3, #0
    35e0:	d0e3      	beq.n	35aa <_system_extint_init+0x36>
		eics[i]->CTRL.reg |= EIC_CTRL_SWRST;
	}

	while (extint_is_syncing()) {
    35e2:	46c0      	nop			; (mov r8, r8)
    35e4:	4b17      	ldr	r3, [pc, #92]	; (3644 <_system_extint_init+0xd0>)
    35e6:	4798      	blx	r3
    35e8:	1e03      	subs	r3, r0, #0
    35ea:	d1fb      	bne.n	35e4 <_system_extint_init+0x70>
	}

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
    35ec:	230b      	movs	r3, #11
    35ee:	18fb      	adds	r3, r7, r3
    35f0:	2200      	movs	r2, #0
    35f2:	701a      	strb	r2, [r3, #0]
    35f4:	e00d      	b.n	3612 <_system_extint_init+0x9e>
		_extint_dev.callbacks[j] = NULL;
    35f6:	230b      	movs	r3, #11
    35f8:	18fb      	adds	r3, r7, r3
    35fa:	781a      	ldrb	r2, [r3, #0]
    35fc:	4b12      	ldr	r3, [pc, #72]	; (3648 <_system_extint_init+0xd4>)
    35fe:	0092      	lsls	r2, r2, #2
    3600:	2100      	movs	r1, #0
    3602:	50d1      	str	r1, [r2, r3]
	}

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
    3604:	230b      	movs	r3, #11
    3606:	18fb      	adds	r3, r7, r3
    3608:	781a      	ldrb	r2, [r3, #0]
    360a:	230b      	movs	r3, #11
    360c:	18fb      	adds	r3, r7, r3
    360e:	3201      	adds	r2, #1
    3610:	701a      	strb	r2, [r3, #0]
    3612:	230b      	movs	r3, #11
    3614:	18fb      	adds	r3, r7, r3
    3616:	781b      	ldrb	r3, [r3, #0]
    3618:	2b0f      	cmp	r3, #15
    361a:	d9ec      	bls.n	35f6 <_system_extint_init+0x82>
		_extint_dev.callbacks[j] = NULL;
	}
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_EIC);
    361c:	2004      	movs	r0, #4
    361e:	4b0b      	ldr	r3, [pc, #44]	; (364c <_system_extint_init+0xd8>)
    3620:	4798      	blx	r3
#endif

	/* Enables the driver for further use */
	_extint_enable();
    3622:	4b0b      	ldr	r3, [pc, #44]	; (3650 <_system_extint_init+0xdc>)
    3624:	4798      	blx	r3
}
    3626:	46c0      	nop			; (mov r8, r8)
    3628:	46bd      	mov	sp, r7
    362a:	b004      	add	sp, #16
    362c:	bd80      	pop	{r7, pc}
    362e:	46c0      	nop			; (mov r8, r8)
    3630:	40001800 	.word	0x40001800
    3634:	000034a5 	.word	0x000034a5
    3638:	0000348d 	.word	0x0000348d
    363c:	00011c05 	.word	0x00011c05
    3640:	00011c49 	.word	0x00011c49
    3644:	0000352d 	.word	0x0000352d
    3648:	20001214 	.word	0x20001214
    364c:	00003501 	.word	0x00003501
    3650:	00003655 	.word	0x00003655

00003654 <_extint_enable>:
 *
 * Enables EIC modules.
 * Registered callback list will not be affected if callback mode is used.
 */
void _extint_enable(void)
{
    3654:	b580      	push	{r7, lr}
    3656:	b082      	sub	sp, #8
    3658:	af00      	add	r7, sp, #0
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
    365a:	4b15      	ldr	r3, [pc, #84]	; (36b0 <_extint_enable+0x5c>)
    365c:	603b      	str	r3, [r7, #0]

	/* Enable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    365e:	2300      	movs	r3, #0
    3660:	607b      	str	r3, [r7, #4]
    3662:	e018      	b.n	3696 <_extint_enable+0x42>
		eics[i]->CTRL.reg |= EIC_CTRL_ENABLE;
    3664:	687b      	ldr	r3, [r7, #4]
    3666:	009b      	lsls	r3, r3, #2
    3668:	2208      	movs	r2, #8
    366a:	4694      	mov	ip, r2
    366c:	44bc      	add	ip, r7
    366e:	4463      	add	r3, ip
    3670:	3b08      	subs	r3, #8
    3672:	681a      	ldr	r2, [r3, #0]
    3674:	687b      	ldr	r3, [r7, #4]
    3676:	009b      	lsls	r3, r3, #2
    3678:	2108      	movs	r1, #8
    367a:	468c      	mov	ip, r1
    367c:	44bc      	add	ip, r7
    367e:	4463      	add	r3, ip
    3680:	3b08      	subs	r3, #8
    3682:	681b      	ldr	r3, [r3, #0]
    3684:	781b      	ldrb	r3, [r3, #0]
    3686:	b2db      	uxtb	r3, r3
    3688:	2102      	movs	r1, #2
    368a:	430b      	orrs	r3, r1
    368c:	b2db      	uxtb	r3, r3
    368e:	7013      	strb	r3, [r2, #0]
void _extint_enable(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	/* Enable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    3690:	687b      	ldr	r3, [r7, #4]
    3692:	3301      	adds	r3, #1
    3694:	607b      	str	r3, [r7, #4]
    3696:	687b      	ldr	r3, [r7, #4]
    3698:	2b00      	cmp	r3, #0
    369a:	d0e3      	beq.n	3664 <_extint_enable+0x10>
		eics[i]->CTRL.reg |= EIC_CTRL_ENABLE;
	}

	while (extint_is_syncing()) {
    369c:	46c0      	nop			; (mov r8, r8)
    369e:	4b05      	ldr	r3, [pc, #20]	; (36b4 <_extint_enable+0x60>)
    36a0:	4798      	blx	r3
    36a2:	1e03      	subs	r3, r0, #0
    36a4:	d1fb      	bne.n	369e <_extint_enable+0x4a>
		/* Wait for all hardware modules to complete synchronization */
	}
}
    36a6:	46c0      	nop			; (mov r8, r8)
    36a8:	46bd      	mov	sp, r7
    36aa:	b002      	add	sp, #8
    36ac:	bd80      	pop	{r7, pc}
    36ae:	46c0      	nop			; (mov r8, r8)
    36b0:	40001800 	.word	0x40001800
    36b4:	0000352d 	.word	0x0000352d

000036b8 <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
    36b8:	b580      	push	{r7, lr}
    36ba:	b082      	sub	sp, #8
    36bc:	af00      	add	r7, sp, #0
    36be:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    36c0:	687b      	ldr	r3, [r7, #4]
    36c2:	2200      	movs	r2, #0
    36c4:	701a      	strb	r2, [r3, #0]
}
    36c6:	46c0      	nop			; (mov r8, r8)
    36c8:	46bd      	mov	sp, r7
    36ca:	b002      	add	sp, #8
    36cc:	bd80      	pop	{r7, pc}
    36ce:	46c0      	nop			; (mov r8, r8)

000036d0 <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
    36d0:	b580      	push	{r7, lr}
    36d2:	b082      	sub	sp, #8
    36d4:	af00      	add	r7, sp, #0
    36d6:	0002      	movs	r2, r0
    36d8:	6039      	str	r1, [r7, #0]
    36da:	1dfb      	adds	r3, r7, #7
    36dc:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    36de:	1dfb      	adds	r3, r7, #7
    36e0:	781b      	ldrb	r3, [r3, #0]
    36e2:	2b01      	cmp	r3, #1
    36e4:	d00a      	beq.n	36fc <system_apb_clock_set_mask+0x2c>
    36e6:	2b02      	cmp	r3, #2
    36e8:	d00f      	beq.n	370a <system_apb_clock_set_mask+0x3a>
    36ea:	2b00      	cmp	r3, #0
    36ec:	d114      	bne.n	3718 <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    36ee:	4b0e      	ldr	r3, [pc, #56]	; (3728 <system_apb_clock_set_mask+0x58>)
    36f0:	4a0d      	ldr	r2, [pc, #52]	; (3728 <system_apb_clock_set_mask+0x58>)
    36f2:	6991      	ldr	r1, [r2, #24]
    36f4:	683a      	ldr	r2, [r7, #0]
    36f6:	430a      	orrs	r2, r1
    36f8:	619a      	str	r2, [r3, #24]
			break;
    36fa:	e00f      	b.n	371c <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
    36fc:	4b0a      	ldr	r3, [pc, #40]	; (3728 <system_apb_clock_set_mask+0x58>)
    36fe:	4a0a      	ldr	r2, [pc, #40]	; (3728 <system_apb_clock_set_mask+0x58>)
    3700:	69d1      	ldr	r1, [r2, #28]
    3702:	683a      	ldr	r2, [r7, #0]
    3704:	430a      	orrs	r2, r1
    3706:	61da      	str	r2, [r3, #28]
			break;
    3708:	e008      	b.n	371c <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    370a:	4b07      	ldr	r3, [pc, #28]	; (3728 <system_apb_clock_set_mask+0x58>)
    370c:	4a06      	ldr	r2, [pc, #24]	; (3728 <system_apb_clock_set_mask+0x58>)
    370e:	6a11      	ldr	r1, [r2, #32]
    3710:	683a      	ldr	r2, [r7, #0]
    3712:	430a      	orrs	r2, r1
    3714:	621a      	str	r2, [r3, #32]
			break;
    3716:	e001      	b.n	371c <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
    3718:	2317      	movs	r3, #23
    371a:	e000      	b.n	371e <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
    371c:	2300      	movs	r3, #0
}
    371e:	0018      	movs	r0, r3
    3720:	46bd      	mov	sp, r7
    3722:	b002      	add	sp, #8
    3724:	bd80      	pop	{r7, pc}
    3726:	46c0      	nop			; (mov r8, r8)
    3728:	40000400 	.word	0x40000400

0000372c <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
    372c:	b580      	push	{r7, lr}
    372e:	b082      	sub	sp, #8
    3730:	af00      	add	r7, sp, #0
    3732:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    3734:	687b      	ldr	r3, [r7, #4]
    3736:	2280      	movs	r2, #128	; 0x80
    3738:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    373a:	687b      	ldr	r3, [r7, #4]
    373c:	2200      	movs	r2, #0
    373e:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    3740:	687b      	ldr	r3, [r7, #4]
    3742:	2201      	movs	r2, #1
    3744:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    3746:	687b      	ldr	r3, [r7, #4]
    3748:	2200      	movs	r2, #0
    374a:	70da      	strb	r2, [r3, #3]
}
    374c:	46c0      	nop			; (mov r8, r8)
    374e:	46bd      	mov	sp, r7
    3750:	b002      	add	sp, #8
    3752:	bd80      	pop	{r7, pc}

00003754 <system_is_debugger_present>:
 * \retval true  Debugger is connected to the system
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
    3754:	b580      	push	{r7, lr}
    3756:	af00      	add	r7, sp, #0
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
    3758:	4b05      	ldr	r3, [pc, #20]	; (3770 <system_is_debugger_present+0x1c>)
    375a:	789b      	ldrb	r3, [r3, #2]
    375c:	b2db      	uxtb	r3, r3
    375e:	001a      	movs	r2, r3
    3760:	2302      	movs	r3, #2
    3762:	4013      	ands	r3, r2
    3764:	1e5a      	subs	r2, r3, #1
    3766:	4193      	sbcs	r3, r2
    3768:	b2db      	uxtb	r3, r3
}
    376a:	0018      	movs	r0, r3
    376c:	46bd      	mov	sp, r7
    376e:	bd80      	pop	{r7, pc}
    3770:	41002000 	.word	0x41002000

00003774 <i2c_master_is_syncing>:
 * \retval true   Module is busy synchronizing
 * \retval false  Module is not synchronizing
 */
static inline bool i2c_master_is_syncing (
		const struct i2c_master_module *const module)
{
    3774:	b580      	push	{r7, lr}
    3776:	b084      	sub	sp, #16
    3778:	af00      	add	r7, sp, #0
    377a:	6078      	str	r0, [r7, #4]
	/* Sanity check. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_hw = &(module->hw->I2CM);
    377c:	687b      	ldr	r3, [r7, #4]
    377e:	681b      	ldr	r3, [r3, #0]
    3780:	60fb      	str	r3, [r7, #12]

#if defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_1)
	return (i2c_hw->STATUS.reg & SERCOM_I2CM_STATUS_SYNCBUSY);
#elif defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_2)
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
    3782:	68fb      	ldr	r3, [r7, #12]
    3784:	69db      	ldr	r3, [r3, #28]
    3786:	2207      	movs	r2, #7
    3788:	4013      	ands	r3, r2
    378a:	1e5a      	subs	r2, r3, #1
    378c:	4193      	sbcs	r3, r2
    378e:	b2db      	uxtb	r3, r3
#else
#  error Unknown SERCOM SYNCBUSY scheme!
#endif
}
    3790:	0018      	movs	r0, r3
    3792:	46bd      	mov	sp, r7
    3794:	b004      	add	sp, #16
    3796:	bd80      	pop	{r7, pc}

00003798 <_i2c_master_wait_for_sync>:
 *
 * \param[in]  module  Pointer to software module structure
 */
static void _i2c_master_wait_for_sync(
		const struct i2c_master_module *const module)
{
    3798:	b580      	push	{r7, lr}
    379a:	b082      	sub	sp, #8
    379c:	af00      	add	r7, sp, #0
    379e:	6078      	str	r0, [r7, #4]
	/* Sanity check. */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
    37a0:	46c0      	nop			; (mov r8, r8)
    37a2:	687b      	ldr	r3, [r7, #4]
    37a4:	0018      	movs	r0, r3
    37a6:	4b04      	ldr	r3, [pc, #16]	; (37b8 <_i2c_master_wait_for_sync+0x20>)
    37a8:	4798      	blx	r3
    37aa:	1e03      	subs	r3, r0, #0
    37ac:	d1f9      	bne.n	37a2 <_i2c_master_wait_for_sync+0xa>
		/* Wait for I2C module to sync. */
	}
}
    37ae:	46c0      	nop			; (mov r8, r8)
    37b0:	46bd      	mov	sp, r7
    37b2:	b002      	add	sp, #8
    37b4:	bd80      	pop	{r7, pc}
    37b6:	46c0      	nop			; (mov r8, r8)
    37b8:	00003775 	.word	0x00003775

000037bc <i2c_master_disable>:
 *
 * \param[in]  module  Pointer to the software module struct
 */
static inline void i2c_master_disable(
		const struct i2c_master_module *const module)
{
    37bc:	b580      	push	{r7, lr}
    37be:	b084      	sub	sp, #16
    37c0:	af00      	add	r7, sp, #0
    37c2:	6078      	str	r0, [r7, #4]
	/* Sanity check of arguments. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    37c4:	687b      	ldr	r3, [r7, #4]
    37c6:	681b      	ldr	r3, [r3, #0]
    37c8:	60fb      	str	r3, [r7, #12]

	/* Wait for module to sync. */
	_i2c_master_wait_for_sync(module);
    37ca:	687b      	ldr	r3, [r7, #4]
    37cc:	0018      	movs	r0, r3
    37ce:	4b06      	ldr	r3, [pc, #24]	; (37e8 <i2c_master_disable+0x2c>)
    37d0:	4798      	blx	r3

	/* Disable module. */
	i2c_module->CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
    37d2:	68fb      	ldr	r3, [r7, #12]
    37d4:	681b      	ldr	r3, [r3, #0]
    37d6:	2202      	movs	r2, #2
    37d8:	4393      	bics	r3, r2
    37da:	001a      	movs	r2, r3
    37dc:	68fb      	ldr	r3, [r7, #12]
    37de:	601a      	str	r2, [r3, #0]

#if I2C_MASTER_CALLBACK_MODE == true
	/* Disable module interrupts */
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
#endif
}
    37e0:	46c0      	nop			; (mov r8, r8)
    37e2:	46bd      	mov	sp, r7
    37e4:	b004      	add	sp, #16
    37e6:	bd80      	pop	{r7, pc}
    37e8:	00003799 	.word	0x00003799

000037ec <_i2c_master_set_config>:
 *                                          with set GCLK frequency
 */
static enum status_code _i2c_master_set_config(
		struct i2c_master_module *const module,
		const struct i2c_master_config *const config)
{
    37ec:	b590      	push	{r4, r7, lr}
    37ee:	b093      	sub	sp, #76	; 0x4c
    37f0:	af00      	add	r7, sp, #0
    37f2:	6078      	str	r0, [r7, #4]
    37f4:	6039      	str	r1, [r7, #0]

	/* Temporary variables. */
	uint32_t tmp_ctrla;
	int32_t tmp_baud;
	int32_t tmp_baud_hs;
	enum status_code tmp_status_code = STATUS_OK;
    37f6:	233f      	movs	r3, #63	; 0x3f
    37f8:	18fb      	adds	r3, r7, r3
    37fa:	2200      	movs	r2, #0
    37fc:	701a      	strb	r2, [r3, #0]

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    37fe:	687b      	ldr	r3, [r7, #4]
    3800:	681b      	ldr	r3, [r3, #0]
    3802:	633b      	str	r3, [r7, #48]	; 0x30
	Sercom *const sercom_hw = module->hw;
    3804:	687b      	ldr	r3, [r7, #4]
    3806:	681b      	ldr	r3, [r3, #0]
    3808:	62fb      	str	r3, [r7, #44]	; 0x2c

	uint8_t sercom_index = _sercom_get_sercom_inst_index(sercom_hw);
    380a:	232b      	movs	r3, #43	; 0x2b
    380c:	18fc      	adds	r4, r7, r3
    380e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    3810:	0018      	movs	r0, r3
    3812:	4b8d      	ldr	r3, [pc, #564]	; (3a48 <_i2c_master_set_config+0x25c>)
    3814:	4798      	blx	r3
    3816:	0003      	movs	r3, r0
    3818:	7023      	strb	r3, [r4, #0]

	/* Pin configuration */
	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
    381a:	230c      	movs	r3, #12
    381c:	18fb      	adds	r3, r7, r3
    381e:	0018      	movs	r0, r3
    3820:	4b8a      	ldr	r3, [pc, #552]	; (3a4c <_i2c_master_set_config+0x260>)
    3822:	4798      	blx	r3

	uint32_t pad0 = config->pinmux_pad0;
    3824:	683b      	ldr	r3, [r7, #0]
    3826:	69db      	ldr	r3, [r3, #28]
    3828:	63bb      	str	r3, [r7, #56]	; 0x38
	uint32_t pad1 = config->pinmux_pad1;
    382a:	683b      	ldr	r3, [r7, #0]
    382c:	6a1b      	ldr	r3, [r3, #32]
    382e:	637b      	str	r3, [r7, #52]	; 0x34

	/* SERCOM PAD0 - SDA */
	if (pad0 == PINMUX_DEFAULT) {
    3830:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    3832:	2b00      	cmp	r3, #0
    3834:	d106      	bne.n	3844 <_i2c_master_set_config+0x58>
		pad0 = _sercom_get_default_pad(sercom_hw, 0);
    3836:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    3838:	2100      	movs	r1, #0
    383a:	0018      	movs	r0, r3
    383c:	4b84      	ldr	r3, [pc, #528]	; (3a50 <_i2c_master_set_config+0x264>)
    383e:	4798      	blx	r3
    3840:	0003      	movs	r3, r0
    3842:	63bb      	str	r3, [r7, #56]	; 0x38
	}
	pin_conf.mux_position = pad0 & 0xFFFF;
    3844:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    3846:	b2da      	uxtb	r2, r3
    3848:	230c      	movs	r3, #12
    384a:	18fb      	adds	r3, r7, r3
    384c:	701a      	strb	r2, [r3, #0]
	pin_conf.direction    = SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK;
    384e:	230c      	movs	r3, #12
    3850:	18fb      	adds	r3, r7, r3
    3852:	2202      	movs	r2, #2
    3854:	705a      	strb	r2, [r3, #1]
	system_pinmux_pin_set_config(pad0 >> 16, &pin_conf);
    3856:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    3858:	0c1b      	lsrs	r3, r3, #16
    385a:	b2db      	uxtb	r3, r3
    385c:	220c      	movs	r2, #12
    385e:	18ba      	adds	r2, r7, r2
    3860:	0011      	movs	r1, r2
    3862:	0018      	movs	r0, r3
    3864:	4b7b      	ldr	r3, [pc, #492]	; (3a54 <_i2c_master_set_config+0x268>)
    3866:	4798      	blx	r3

	/* SERCOM PAD1 - SCL */
	if (pad1 == PINMUX_DEFAULT) {
    3868:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    386a:	2b00      	cmp	r3, #0
    386c:	d106      	bne.n	387c <_i2c_master_set_config+0x90>
		pad1 = _sercom_get_default_pad(sercom_hw, 1);
    386e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    3870:	2101      	movs	r1, #1
    3872:	0018      	movs	r0, r3
    3874:	4b76      	ldr	r3, [pc, #472]	; (3a50 <_i2c_master_set_config+0x264>)
    3876:	4798      	blx	r3
    3878:	0003      	movs	r3, r0
    387a:	637b      	str	r3, [r7, #52]	; 0x34
	}
	pin_conf.mux_position = pad1 & 0xFFFF;
    387c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    387e:	b2da      	uxtb	r2, r3
    3880:	230c      	movs	r3, #12
    3882:	18fb      	adds	r3, r7, r3
    3884:	701a      	strb	r2, [r3, #0]
	pin_conf.direction    = SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK;
    3886:	230c      	movs	r3, #12
    3888:	18fb      	adds	r3, r7, r3
    388a:	2202      	movs	r2, #2
    388c:	705a      	strb	r2, [r3, #1]
	system_pinmux_pin_set_config(pad1 >> 16, &pin_conf);
    388e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    3890:	0c1b      	lsrs	r3, r3, #16
    3892:	b2db      	uxtb	r3, r3
    3894:	220c      	movs	r2, #12
    3896:	18ba      	adds	r2, r7, r2
    3898:	0011      	movs	r1, r2
    389a:	0018      	movs	r0, r3
    389c:	4b6d      	ldr	r3, [pc, #436]	; (3a54 <_i2c_master_set_config+0x268>)
    389e:	4798      	blx	r3

	/* Save timeout on unknown bus state in software module. */
	module->unknown_bus_state_timeout = config->unknown_bus_state_timeout;
    38a0:	683b      	ldr	r3, [r7, #0]
    38a2:	8a9a      	ldrh	r2, [r3, #20]
    38a4:	687b      	ldr	r3, [r7, #4]
    38a6:	80da      	strh	r2, [r3, #6]

	/* Save timeout on buffer write. */
	module->buffer_timeout = config->buffer_timeout;
    38a8:	683b      	ldr	r3, [r7, #0]
    38aa:	8ada      	ldrh	r2, [r3, #22]
    38ac:	687b      	ldr	r3, [r7, #4]
    38ae:	811a      	strh	r2, [r3, #8]

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    38b0:	683b      	ldr	r3, [r7, #0]
    38b2:	7e1b      	ldrb	r3, [r3, #24]
    38b4:	2b00      	cmp	r3, #0
    38b6:	d103      	bne.n	38c0 <_i2c_master_set_config+0xd4>
    38b8:	4b67      	ldr	r3, [pc, #412]	; (3a58 <_i2c_master_set_config+0x26c>)
    38ba:	4798      	blx	r3
    38bc:	1e03      	subs	r3, r0, #0
    38be:	d002      	beq.n	38c6 <_i2c_master_set_config+0xda>
		tmp_ctrla = SERCOM_I2CM_CTRLA_RUNSTDBY;
    38c0:	2380      	movs	r3, #128	; 0x80
    38c2:	647b      	str	r3, [r7, #68]	; 0x44
    38c4:	e001      	b.n	38ca <_i2c_master_set_config+0xde>
	} else {
		tmp_ctrla = 0;
    38c6:	2300      	movs	r3, #0
    38c8:	647b      	str	r3, [r7, #68]	; 0x44
	}

	/* Check and set start data hold timeout. */
	if (config->start_hold_time != I2C_MASTER_START_HOLD_TIME_DISABLED) {
    38ca:	683b      	ldr	r3, [r7, #0]
    38cc:	691b      	ldr	r3, [r3, #16]
    38ce:	2b00      	cmp	r3, #0
    38d0:	d004      	beq.n	38dc <_i2c_master_set_config+0xf0>
		tmp_ctrla |= config->start_hold_time;
    38d2:	683b      	ldr	r3, [r7, #0]
    38d4:	691b      	ldr	r3, [r3, #16]
    38d6:	6c7a      	ldr	r2, [r7, #68]	; 0x44
    38d8:	4313      	orrs	r3, r2
    38da:	647b      	str	r3, [r7, #68]	; 0x44
	}

	/* Check and set transfer speed */
	tmp_ctrla |= config->transfer_speed;
    38dc:	683b      	ldr	r3, [r7, #0]
    38de:	689b      	ldr	r3, [r3, #8]
    38e0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
    38e2:	4313      	orrs	r3, r2
    38e4:	647b      	str	r3, [r7, #68]	; 0x44

	/* Check and set SCL low timeout. */
	if (config->scl_low_timeout) {
    38e6:	683b      	ldr	r3, [r7, #0]
    38e8:	2224      	movs	r2, #36	; 0x24
    38ea:	5c9b      	ldrb	r3, [r3, r2]
    38ec:	2b00      	cmp	r3, #0
    38ee:	d004      	beq.n	38fa <_i2c_master_set_config+0x10e>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_LOWTOUTEN;
    38f0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    38f2:	2280      	movs	r2, #128	; 0x80
    38f4:	05d2      	lsls	r2, r2, #23
    38f6:	4313      	orrs	r3, r2
    38f8:	647b      	str	r3, [r7, #68]	; 0x44
	}

	/* Check and set inactive bus timeout. */
	if (config->inactive_timeout != I2C_MASTER_INACTIVE_TIMEOUT_DISABLED) {
    38fa:	683b      	ldr	r3, [r7, #0]
    38fc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    38fe:	2b00      	cmp	r3, #0
    3900:	d004      	beq.n	390c <_i2c_master_set_config+0x120>
		tmp_ctrla |= config->inactive_timeout;
    3902:	683b      	ldr	r3, [r7, #0]
    3904:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3906:	6c7a      	ldr	r2, [r7, #68]	; 0x44
    3908:	4313      	orrs	r3, r2
    390a:	647b      	str	r3, [r7, #68]	; 0x44
	}

	/* Check and set SCL clock stretch mode. */
	if (config->scl_stretch_only_after_ack_bit) {
    390c:	683b      	ldr	r3, [r7, #0]
    390e:	222c      	movs	r2, #44	; 0x2c
    3910:	5c9b      	ldrb	r3, [r3, r2]
    3912:	2b00      	cmp	r3, #0
    3914:	d004      	beq.n	3920 <_i2c_master_set_config+0x134>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_SCLSM;
    3916:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    3918:	2280      	movs	r2, #128	; 0x80
    391a:	0512      	lsls	r2, r2, #20
    391c:	4313      	orrs	r3, r2
    391e:	647b      	str	r3, [r7, #68]	; 0x44
	}

	/* Check and set slave SCL low extend timeout. */
	if (config->slave_scl_low_extend_timeout) {
    3920:	683b      	ldr	r3, [r7, #0]
    3922:	222d      	movs	r2, #45	; 0x2d
    3924:	5c9b      	ldrb	r3, [r3, r2]
    3926:	2b00      	cmp	r3, #0
    3928:	d004      	beq.n	3934 <_i2c_master_set_config+0x148>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_SEXTTOEN;
    392a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    392c:	2280      	movs	r2, #128	; 0x80
    392e:	0412      	lsls	r2, r2, #16
    3930:	4313      	orrs	r3, r2
    3932:	647b      	str	r3, [r7, #68]	; 0x44
	}

	/* Check and set master SCL low extend timeout. */
	if (config->master_scl_low_extend_timeout) {
    3934:	683b      	ldr	r3, [r7, #0]
    3936:	222e      	movs	r2, #46	; 0x2e
    3938:	5c9b      	ldrb	r3, [r3, r2]
    393a:	2b00      	cmp	r3, #0
    393c:	d004      	beq.n	3948 <_i2c_master_set_config+0x15c>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_MEXTTOEN;
    393e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    3940:	2280      	movs	r2, #128	; 0x80
    3942:	03d2      	lsls	r2, r2, #15
    3944:	4313      	orrs	r3, r2
    3946:	647b      	str	r3, [r7, #68]	; 0x44
	}

	/* Write config to register CTRLA. */
	i2c_module->CTRLA.reg |= tmp_ctrla;
    3948:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    394a:	681a      	ldr	r2, [r3, #0]
    394c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    394e:	431a      	orrs	r2, r3
    3950:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    3952:	601a      	str	r2, [r3, #0]

	/* Set configurations in CTRLB. */
	i2c_module->CTRLB.reg = SERCOM_I2CM_CTRLB_SMEN;
    3954:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    3956:	2280      	movs	r2, #128	; 0x80
    3958:	0052      	lsls	r2, r2, #1
    395a:	605a      	str	r2, [r3, #4]

	/* Find and set baudrate, considering sda/scl rise time */
	uint32_t fgclk       = system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index);
    395c:	232b      	movs	r3, #43	; 0x2b
    395e:	18fb      	adds	r3, r7, r3
    3960:	781b      	ldrb	r3, [r3, #0]
    3962:	3314      	adds	r3, #20
    3964:	b2db      	uxtb	r3, r3
    3966:	0018      	movs	r0, r3
    3968:	4b3c      	ldr	r3, [pc, #240]	; (3a5c <_i2c_master_set_config+0x270>)
    396a:	4798      	blx	r3
    396c:	0003      	movs	r3, r0
    396e:	627b      	str	r3, [r7, #36]	; 0x24
	uint32_t fscl        = 1000*config->baud_rate;
    3970:	683b      	ldr	r3, [r7, #0]
    3972:	681b      	ldr	r3, [r3, #0]
    3974:	22fa      	movs	r2, #250	; 0xfa
    3976:	0092      	lsls	r2, r2, #2
    3978:	4353      	muls	r3, r2
    397a:	623b      	str	r3, [r7, #32]
	uint32_t trise       = config->sda_scl_rise_time_ns;
    397c:	683b      	ldr	r3, [r7, #0]
    397e:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
    3980:	61fb      	str	r3, [r7, #28]
	int32_t  numerator   = fgclk - fscl*(10 + fgclk*trise/1000000000);
    3982:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3984:	69fa      	ldr	r2, [r7, #28]
    3986:	435a      	muls	r2, r3
    3988:	4b35      	ldr	r3, [pc, #212]	; (3a60 <_i2c_master_set_config+0x274>)
    398a:	4936      	ldr	r1, [pc, #216]	; (3a64 <_i2c_master_set_config+0x278>)
    398c:	0010      	movs	r0, r2
    398e:	4798      	blx	r3
    3990:	0003      	movs	r3, r0
    3992:	330a      	adds	r3, #10
    3994:	6a3a      	ldr	r2, [r7, #32]
    3996:	4353      	muls	r3, r2
    3998:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    399a:	1ad3      	subs	r3, r2, r3
    399c:	61bb      	str	r3, [r7, #24]
	int32_t  denominator = 2*fscl;
    399e:	6a3b      	ldr	r3, [r7, #32]
    39a0:	005b      	lsls	r3, r3, #1
    39a2:	617b      	str	r3, [r7, #20]
	/* For more accurate result, can use round div. */
	tmp_baud = (int32_t)(div_ceil(numerator, denominator));
    39a4:	69ba      	ldr	r2, [r7, #24]
    39a6:	697b      	ldr	r3, [r7, #20]
    39a8:	18d3      	adds	r3, r2, r3
    39aa:	1e5a      	subs	r2, r3, #1
    39ac:	4b2e      	ldr	r3, [pc, #184]	; (3a68 <_i2c_master_set_config+0x27c>)
    39ae:	6979      	ldr	r1, [r7, #20]
    39b0:	0010      	movs	r0, r2
    39b2:	4798      	blx	r3
    39b4:	0003      	movs	r3, r0
    39b6:	613b      	str	r3, [r7, #16]
	 
	/* Check that baudrate is supported at current speed. */
	if (tmp_baud > 255 || tmp_baud < 0) {
    39b8:	693b      	ldr	r3, [r7, #16]
    39ba:	2bff      	cmp	r3, #255	; 0xff
    39bc:	dc02      	bgt.n	39c4 <_i2c_master_set_config+0x1d8>
    39be:	693b      	ldr	r3, [r7, #16]
    39c0:	2b00      	cmp	r3, #0
    39c2:	da04      	bge.n	39ce <_i2c_master_set_config+0x1e2>
		/* Baud rate not supported. */
		tmp_status_code = STATUS_ERR_BAUDRATE_UNAVAILABLE;
    39c4:	233f      	movs	r3, #63	; 0x3f
    39c6:	18fb      	adds	r3, r7, r3
    39c8:	2240      	movs	r2, #64	; 0x40
    39ca:	701a      	strb	r2, [r3, #0]
    39cc:	e024      	b.n	3a18 <_i2c_master_set_config+0x22c>
	} else {
		/* Find baudrate for high speed */
		tmp_baud_hs = (int32_t)(div_ceil(
    39ce:	232b      	movs	r3, #43	; 0x2b
    39d0:	18fb      	adds	r3, r7, r3
    39d2:	781b      	ldrb	r3, [r3, #0]
    39d4:	3314      	adds	r3, #20
    39d6:	b2db      	uxtb	r3, r3
    39d8:	0018      	movs	r0, r3
    39da:	4b20      	ldr	r3, [pc, #128]	; (3a5c <_i2c_master_set_config+0x270>)
    39dc:	4798      	blx	r3
    39de:	0001      	movs	r1, r0
    39e0:	683b      	ldr	r3, [r7, #0]
    39e2:	685b      	ldr	r3, [r3, #4]
    39e4:	22fa      	movs	r2, #250	; 0xfa
    39e6:	00d2      	lsls	r2, r2, #3
    39e8:	4353      	muls	r3, r2
    39ea:	18cb      	adds	r3, r1, r3
    39ec:	1e58      	subs	r0, r3, #1
    39ee:	683b      	ldr	r3, [r7, #0]
    39f0:	685b      	ldr	r3, [r3, #4]
    39f2:	22fa      	movs	r2, #250	; 0xfa
    39f4:	00d2      	lsls	r2, r2, #3
    39f6:	435a      	muls	r2, r3
    39f8:	4b19      	ldr	r3, [pc, #100]	; (3a60 <_i2c_master_set_config+0x274>)
    39fa:	0011      	movs	r1, r2
    39fc:	4798      	blx	r3
    39fe:	0003      	movs	r3, r0
				system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index),
				(2000*(config->baud_rate_high_speed))) - 1);
    3a00:	3b01      	subs	r3, #1
	if (tmp_baud > 255 || tmp_baud < 0) {
		/* Baud rate not supported. */
		tmp_status_code = STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		/* Find baudrate for high speed */
		tmp_baud_hs = (int32_t)(div_ceil(
    3a02:	643b      	str	r3, [r7, #64]	; 0x40
				system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index),
				(2000*(config->baud_rate_high_speed))) - 1);

		/* Check that baudrate is supported at current speed. */
		if (tmp_baud_hs > 255 || tmp_baud_hs < 0) {
    3a04:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    3a06:	2bff      	cmp	r3, #255	; 0xff
    3a08:	dc02      	bgt.n	3a10 <_i2c_master_set_config+0x224>
    3a0a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    3a0c:	2b00      	cmp	r3, #0
    3a0e:	da03      	bge.n	3a18 <_i2c_master_set_config+0x22c>
			/* Baud rate not supported. */
			tmp_status_code = STATUS_ERR_BAUDRATE_UNAVAILABLE;
    3a10:	233f      	movs	r3, #63	; 0x3f
    3a12:	18fb      	adds	r3, r7, r3
    3a14:	2240      	movs	r2, #64	; 0x40
    3a16:	701a      	strb	r2, [r3, #0]
		}
	}
	if (tmp_status_code != STATUS_ERR_BAUDRATE_UNAVAILABLE) {
    3a18:	233f      	movs	r3, #63	; 0x3f
    3a1a:	18fb      	adds	r3, r7, r3
    3a1c:	781b      	ldrb	r3, [r3, #0]
    3a1e:	2b40      	cmp	r3, #64	; 0x40
    3a20:	d00b      	beq.n	3a3a <_i2c_master_set_config+0x24e>
		/* Baud rate acceptable. */
		i2c_module->BAUD.reg = SERCOM_I2CM_BAUD_BAUD(tmp_baud) |
    3a22:	693b      	ldr	r3, [r7, #16]
    3a24:	22ff      	movs	r2, #255	; 0xff
    3a26:	401a      	ands	r2, r3
			SERCOM_I2CM_BAUD_HSBAUD(tmp_baud_hs);
    3a28:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    3a2a:	041b      	lsls	r3, r3, #16
    3a2c:	0019      	movs	r1, r3
    3a2e:	23ff      	movs	r3, #255	; 0xff
    3a30:	041b      	lsls	r3, r3, #16
    3a32:	400b      	ands	r3, r1
			tmp_status_code = STATUS_ERR_BAUDRATE_UNAVAILABLE;
		}
	}
	if (tmp_status_code != STATUS_ERR_BAUDRATE_UNAVAILABLE) {
		/* Baud rate acceptable. */
		i2c_module->BAUD.reg = SERCOM_I2CM_BAUD_BAUD(tmp_baud) |
    3a34:	431a      	orrs	r2, r3
    3a36:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    3a38:	60da      	str	r2, [r3, #12]
			SERCOM_I2CM_BAUD_HSBAUD(tmp_baud_hs);
	}

	return tmp_status_code;
    3a3a:	233f      	movs	r3, #63	; 0x3f
    3a3c:	18fb      	adds	r3, r7, r3
    3a3e:	781b      	ldrb	r3, [r3, #0]
}
    3a40:	0018      	movs	r0, r3
    3a42:	46bd      	mov	sp, r7
    3a44:	b013      	add	sp, #76	; 0x4c
    3a46:	bd90      	pop	{r4, r7, pc}
    3a48:	00004315 	.word	0x00004315
    3a4c:	0000372d 	.word	0x0000372d
    3a50:	00004159 	.word	0x00004159
    3a54:	00011ef1 	.word	0x00011ef1
    3a58:	00003755 	.word	0x00003755
    3a5c:	00011d29 	.word	0x00011d29
    3a60:	000121bd 	.word	0x000121bd
    3a64:	3b9aca00 	.word	0x3b9aca00
    3a68:	000122d1 	.word	0x000122d1

00003a6c <i2c_master_init>:
 */
enum status_code i2c_master_init(
		struct i2c_master_module *const module,
		Sercom *const hw,
		const struct i2c_master_config *const config)
{
    3a6c:	b580      	push	{r7, lr}
    3a6e:	b08a      	sub	sp, #40	; 0x28
    3a70:	af00      	add	r7, sp, #0
    3a72:	60f8      	str	r0, [r7, #12]
    3a74:	60b9      	str	r1, [r7, #8]
    3a76:	607a      	str	r2, [r7, #4]
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize software module */
	module->hw = hw;
    3a78:	68fb      	ldr	r3, [r7, #12]
    3a7a:	68ba      	ldr	r2, [r7, #8]
    3a7c:	601a      	str	r2, [r3, #0]

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    3a7e:	68fb      	ldr	r3, [r7, #12]
    3a80:	681b      	ldr	r3, [r3, #0]
    3a82:	627b      	str	r3, [r7, #36]	; 0x24
	
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    3a84:	68fb      	ldr	r3, [r7, #12]
    3a86:	681b      	ldr	r3, [r3, #0]
    3a88:	0018      	movs	r0, r3
    3a8a:	4b25      	ldr	r3, [pc, #148]	; (3b20 <i2c_master_init+0xb4>)
    3a8c:	4798      	blx	r3
    3a8e:	0003      	movs	r3, r0
    3a90:	623b      	str	r3, [r7, #32]
#else
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
    3a92:	6a3b      	ldr	r3, [r7, #32]
    3a94:	3302      	adds	r3, #2
    3a96:	61fb      	str	r3, [r7, #28]
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    3a98:	6a3b      	ldr	r3, [r7, #32]
    3a9a:	3314      	adds	r3, #20
    3a9c:	61bb      	str	r3, [r7, #24]
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, 1 << pm_index);
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);	
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
    3a9e:	2201      	movs	r2, #1
    3aa0:	69fb      	ldr	r3, [r7, #28]
    3aa2:	409a      	lsls	r2, r3
    3aa4:	0013      	movs	r3, r2
    3aa6:	0019      	movs	r1, r3
    3aa8:	2002      	movs	r0, #2
    3aaa:	4b1e      	ldr	r3, [pc, #120]	; (3b24 <i2c_master_init+0xb8>)
    3aac:	4798      	blx	r3
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
    3aae:	2314      	movs	r3, #20
    3ab0:	18fb      	adds	r3, r7, r3
    3ab2:	0018      	movs	r0, r3
    3ab4:	4b1c      	ldr	r3, [pc, #112]	; (3b28 <i2c_master_init+0xbc>)
    3ab6:	4798      	blx	r3
	gclk_chan_conf.source_generator = config->generator_source;
    3ab8:	687b      	ldr	r3, [r7, #4]
    3aba:	7b1a      	ldrb	r2, [r3, #12]
    3abc:	2314      	movs	r3, #20
    3abe:	18fb      	adds	r3, r7, r3
    3ac0:	701a      	strb	r2, [r3, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    3ac2:	69bb      	ldr	r3, [r7, #24]
    3ac4:	b2db      	uxtb	r3, r3
    3ac6:	2214      	movs	r2, #20
    3ac8:	18ba      	adds	r2, r7, r2
    3aca:	0011      	movs	r1, r2
    3acc:	0018      	movs	r0, r3
    3ace:	4b17      	ldr	r3, [pc, #92]	; (3b2c <i2c_master_init+0xc0>)
    3ad0:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    3ad2:	69bb      	ldr	r3, [r7, #24]
    3ad4:	b2db      	uxtb	r3, r3
    3ad6:	0018      	movs	r0, r3
    3ad8:	4b15      	ldr	r3, [pc, #84]	; (3b30 <i2c_master_init+0xc4>)
    3ada:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    3adc:	687b      	ldr	r3, [r7, #4]
    3ade:	7b1b      	ldrb	r3, [r3, #12]
    3ae0:	2100      	movs	r1, #0
    3ae2:	0018      	movs	r0, r3
    3ae4:	4b13      	ldr	r3, [pc, #76]	; (3b34 <i2c_master_init+0xc8>)
    3ae6:	4798      	blx	r3

	/* Check if module is enabled. */
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_ENABLE) {
    3ae8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3aea:	681b      	ldr	r3, [r3, #0]
    3aec:	2202      	movs	r2, #2
    3aee:	4013      	ands	r3, r2
    3af0:	d001      	beq.n	3af6 <i2c_master_init+0x8a>
		return STATUS_ERR_DENIED;
    3af2:	231c      	movs	r3, #28
    3af4:	e010      	b.n	3b18 <i2c_master_init+0xac>
	}

	/* Check if reset is in progress. */
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_SWRST) {
    3af6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3af8:	681b      	ldr	r3, [r3, #0]
    3afa:	2201      	movs	r2, #1
    3afc:	4013      	ands	r3, r2
    3afe:	d001      	beq.n	3b04 <i2c_master_init+0x98>
		return STATUS_BUSY;
    3b00:	2305      	movs	r3, #5
    3b02:	e009      	b.n	3b18 <i2c_master_init+0xac>
	module->status = STATUS_OK;
	module->buffer = NULL;
#endif

	/* Set sercom module to operate in I2C master mode. */
	i2c_module->CTRLA.reg = SERCOM_I2CM_CTRLA_MODE(0x5);
    3b04:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3b06:	2214      	movs	r2, #20
    3b08:	601a      	str	r2, [r3, #0]

	/* Set config and return status. */
	return _i2c_master_set_config(module, config);
    3b0a:	687a      	ldr	r2, [r7, #4]
    3b0c:	68fb      	ldr	r3, [r7, #12]
    3b0e:	0011      	movs	r1, r2
    3b10:	0018      	movs	r0, r3
    3b12:	4b09      	ldr	r3, [pc, #36]	; (3b38 <i2c_master_init+0xcc>)
    3b14:	4798      	blx	r3
    3b16:	0003      	movs	r3, r0
}
    3b18:	0018      	movs	r0, r3
    3b1a:	46bd      	mov	sp, r7
    3b1c:	b00a      	add	sp, #40	; 0x28
    3b1e:	bd80      	pop	{r7, pc}
    3b20:	00004315 	.word	0x00004315
    3b24:	000036d1 	.word	0x000036d1
    3b28:	000036b9 	.word	0x000036b9
    3b2c:	00011c05 	.word	0x00011c05
    3b30:	00011c49 	.word	0x00011c49
    3b34:	000040cd 	.word	0x000040cd
    3b38:	000037ed 	.word	0x000037ed

00003b3c <i2c_master_reset>:
 * Reset the module to hardware defaults.
 *
 * \param[in,out] module Pointer to software module structure
 */
void i2c_master_reset(struct i2c_master_module *const module)
{
    3b3c:	b580      	push	{r7, lr}
    3b3e:	b084      	sub	sp, #16
    3b40:	af00      	add	r7, sp, #0
    3b42:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    3b44:	687b      	ldr	r3, [r7, #4]
    3b46:	681b      	ldr	r3, [r3, #0]
    3b48:	60fb      	str	r3, [r7, #12]

	/* Wait for sync */
	_i2c_master_wait_for_sync(module);
    3b4a:	687b      	ldr	r3, [r7, #4]
    3b4c:	0018      	movs	r0, r3
    3b4e:	4b08      	ldr	r3, [pc, #32]	; (3b70 <i2c_master_reset+0x34>)
    3b50:	4798      	blx	r3

	/* Disable module */
	i2c_master_disable(module);
    3b52:	687b      	ldr	r3, [r7, #4]
    3b54:	0018      	movs	r0, r3
    3b56:	4b07      	ldr	r3, [pc, #28]	; (3b74 <i2c_master_reset+0x38>)
    3b58:	4798      	blx	r3
	system_interrupt_clear_pending(_sercom_get_interrupt_vector(module->hw));
	system_interrupt_leave_critical_section();
#endif

	/* Wait for sync */
	_i2c_master_wait_for_sync(module);
    3b5a:	687b      	ldr	r3, [r7, #4]
    3b5c:	0018      	movs	r0, r3
    3b5e:	4b04      	ldr	r3, [pc, #16]	; (3b70 <i2c_master_reset+0x34>)
    3b60:	4798      	blx	r3

	/* Reset module */
	i2c_module->CTRLA.reg = SERCOM_I2CM_CTRLA_SWRST;
    3b62:	68fb      	ldr	r3, [r7, #12]
    3b64:	2201      	movs	r2, #1
    3b66:	601a      	str	r2, [r3, #0]
}
    3b68:	46c0      	nop			; (mov r8, r8)
    3b6a:	46bd      	mov	sp, r7
    3b6c:	b004      	add	sp, #16
    3b6e:	bd80      	pop	{r7, pc}
    3b70:	00003799 	.word	0x00003799
    3b74:	000037bd 	.word	0x000037bd

00003b78 <_i2c_master_address_response>:
 * \retval STATUS_ERR_BAD_ADDRESS       If slave is busy, or no slave
 *                                      acknowledged the address
 */
enum status_code _i2c_master_address_response(
		struct i2c_master_module *const module)
{
    3b78:	b580      	push	{r7, lr}
    3b7a:	b084      	sub	sp, #16
    3b7c:	af00      	add	r7, sp, #0
    3b7e:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    3b80:	687b      	ldr	r3, [r7, #4]
    3b82:	681b      	ldr	r3, [r3, #0]
    3b84:	60fb      	str	r3, [r7, #12]

	/* Check for error and ignore bus-error; workaround for BUSSTATE stuck in
	 * BUSY */
	if (i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB) {
    3b86:	68fb      	ldr	r3, [r7, #12]
    3b88:	7e1b      	ldrb	r3, [r3, #24]
    3b8a:	b2db      	uxtb	r3, r3
    3b8c:	001a      	movs	r2, r3
    3b8e:	2302      	movs	r3, #2
    3b90:	4013      	ands	r3, r2
    3b92:	d00b      	beq.n	3bac <_i2c_master_address_response+0x34>

		/* Clear write interrupt flag */
		i2c_module->INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    3b94:	68fb      	ldr	r3, [r7, #12]
    3b96:	2202      	movs	r2, #2
    3b98:	761a      	strb	r2, [r3, #24]

		/* Check arbitration. */
		if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_ARBLOST) {
    3b9a:	68fb      	ldr	r3, [r7, #12]
    3b9c:	8b5b      	ldrh	r3, [r3, #26]
    3b9e:	b29b      	uxth	r3, r3
    3ba0:	001a      	movs	r2, r3
    3ba2:	2302      	movs	r3, #2
    3ba4:	4013      	ands	r3, r2
    3ba6:	d011      	beq.n	3bcc <_i2c_master_address_response+0x54>
			/* Return packet collision. */
			return STATUS_ERR_PACKET_COLLISION;
    3ba8:	2341      	movs	r3, #65	; 0x41
    3baa:	e010      	b.n	3bce <_i2c_master_address_response+0x56>
		}
	/* Check that slave responded with ack. */
	} else if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK) {
    3bac:	68fb      	ldr	r3, [r7, #12]
    3bae:	8b5b      	ldrh	r3, [r3, #26]
    3bb0:	b29b      	uxth	r3, r3
    3bb2:	001a      	movs	r2, r3
    3bb4:	2304      	movs	r3, #4
    3bb6:	4013      	ands	r3, r2
    3bb8:	d008      	beq.n	3bcc <_i2c_master_address_response+0x54>
		/* Slave busy. Issue ack and stop command. */
		i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
    3bba:	68fb      	ldr	r3, [r7, #12]
    3bbc:	685b      	ldr	r3, [r3, #4]
    3bbe:	22c0      	movs	r2, #192	; 0xc0
    3bc0:	0292      	lsls	r2, r2, #10
    3bc2:	431a      	orrs	r2, r3
    3bc4:	68fb      	ldr	r3, [r7, #12]
    3bc6:	605a      	str	r2, [r3, #4]

		/* Return bad address value. */
		return STATUS_ERR_BAD_ADDRESS;
    3bc8:	2318      	movs	r3, #24
    3bca:	e000      	b.n	3bce <_i2c_master_address_response+0x56>
	}

	return STATUS_OK;
    3bcc:	2300      	movs	r3, #0
}
    3bce:	0018      	movs	r0, r3
    3bd0:	46bd      	mov	sp, r7
    3bd2:	b004      	add	sp, #16
    3bd4:	bd80      	pop	{r7, pc}
    3bd6:	46c0      	nop			; (mov r8, r8)

00003bd8 <_i2c_master_wait_for_bus>:
 * \retval STATUS_ERR_TIMEOUT  If no response was given within specified timeout
 *                             period
 */
enum status_code _i2c_master_wait_for_bus(
		struct i2c_master_module *const module)
{
    3bd8:	b580      	push	{r7, lr}
    3bda:	b084      	sub	sp, #16
    3bdc:	af00      	add	r7, sp, #0
    3bde:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    3be0:	687b      	ldr	r3, [r7, #4]
    3be2:	681b      	ldr	r3, [r3, #0]
    3be4:	60bb      	str	r3, [r7, #8]

	/* Wait for reply. */
	uint16_t timeout_counter = 0;
    3be6:	230e      	movs	r3, #14
    3be8:	18fb      	adds	r3, r7, r3
    3bea:	2200      	movs	r2, #0
    3bec:	801a      	strh	r2, [r3, #0]
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
    3bee:	e00f      	b.n	3c10 <_i2c_master_wait_for_bus+0x38>
			!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB)) {

		/* Check timeout condition. */
		if (++timeout_counter >= module->buffer_timeout) {
    3bf0:	230e      	movs	r3, #14
    3bf2:	18fb      	adds	r3, r7, r3
    3bf4:	220e      	movs	r2, #14
    3bf6:	18ba      	adds	r2, r7, r2
    3bf8:	8812      	ldrh	r2, [r2, #0]
    3bfa:	3201      	adds	r2, #1
    3bfc:	801a      	strh	r2, [r3, #0]
    3bfe:	687b      	ldr	r3, [r7, #4]
    3c00:	891b      	ldrh	r3, [r3, #8]
    3c02:	220e      	movs	r2, #14
    3c04:	18ba      	adds	r2, r7, r2
    3c06:	8812      	ldrh	r2, [r2, #0]
    3c08:	429a      	cmp	r2, r3
    3c0a:	d301      	bcc.n	3c10 <_i2c_master_wait_for_bus+0x38>
			return STATUS_ERR_TIMEOUT;
    3c0c:	2312      	movs	r3, #18
    3c0e:	e00e      	b.n	3c2e <_i2c_master_wait_for_bus+0x56>

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Wait for reply. */
	uint16_t timeout_counter = 0;
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
    3c10:	68bb      	ldr	r3, [r7, #8]
    3c12:	7e1b      	ldrb	r3, [r3, #24]
    3c14:	b2db      	uxtb	r3, r3
    3c16:	001a      	movs	r2, r3
    3c18:	2301      	movs	r3, #1
    3c1a:	4013      	ands	r3, r2
    3c1c:	d106      	bne.n	3c2c <_i2c_master_wait_for_bus+0x54>
			!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB)) {
    3c1e:	68bb      	ldr	r3, [r7, #8]
    3c20:	7e1b      	ldrb	r3, [r3, #24]
    3c22:	b2db      	uxtb	r3, r3
    3c24:	001a      	movs	r2, r3
    3c26:	2302      	movs	r3, #2
    3c28:	4013      	ands	r3, r2

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Wait for reply. */
	uint16_t timeout_counter = 0;
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
    3c2a:	d0e1      	beq.n	3bf0 <_i2c_master_wait_for_bus+0x18>
		/* Check timeout condition. */
		if (++timeout_counter >= module->buffer_timeout) {
			return STATUS_ERR_TIMEOUT;
		}
	}
	return STATUS_OK;
    3c2c:	2300      	movs	r3, #0
}
    3c2e:	0018      	movs	r0, r3
    3c30:	46bd      	mov	sp, r7
    3c32:	b004      	add	sp, #16
    3c34:	bd80      	pop	{r7, pc}
    3c36:	46c0      	nop			; (mov r8, r8)

00003c38 <_i2c_master_send_hs_master_code>:
 * \retval STATUS_OK           No error happen
 */
enum status_code _i2c_master_send_hs_master_code(
		struct i2c_master_module *const module,
		uint8_t hs_master_code)
{
    3c38:	b590      	push	{r4, r7, lr}
    3c3a:	b085      	sub	sp, #20
    3c3c:	af00      	add	r7, sp, #0
    3c3e:	6078      	str	r0, [r7, #4]
    3c40:	000a      	movs	r2, r1
    3c42:	1cfb      	adds	r3, r7, #3
    3c44:	701a      	strb	r2, [r3, #0]
	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    3c46:	687b      	ldr	r3, [r7, #4]
    3c48:	681b      	ldr	r3, [r3, #0]
    3c4a:	60fb      	str	r3, [r7, #12]
	/* Return value. */
	enum status_code tmp_status;

	/* Set NACK for high speed code */
	i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    3c4c:	68fb      	ldr	r3, [r7, #12]
    3c4e:	685b      	ldr	r3, [r3, #4]
    3c50:	2280      	movs	r2, #128	; 0x80
    3c52:	02d2      	lsls	r2, r2, #11
    3c54:	431a      	orrs	r2, r3
    3c56:	68fb      	ldr	r3, [r7, #12]
    3c58:	605a      	str	r2, [r3, #4]
	/* Send high speed code */
	i2c_module->ADDR.reg = hs_master_code;
    3c5a:	1cfb      	adds	r3, r7, #3
    3c5c:	781a      	ldrb	r2, [r3, #0]
    3c5e:	68fb      	ldr	r3, [r7, #12]
    3c60:	625a      	str	r2, [r3, #36]	; 0x24
	/* Wait for response on bus. */
	tmp_status = _i2c_master_wait_for_bus(module);
    3c62:	230b      	movs	r3, #11
    3c64:	18fc      	adds	r4, r7, r3
    3c66:	687b      	ldr	r3, [r7, #4]
    3c68:	0018      	movs	r0, r3
    3c6a:	4b07      	ldr	r3, [pc, #28]	; (3c88 <_i2c_master_send_hs_master_code+0x50>)
    3c6c:	4798      	blx	r3
    3c6e:	0003      	movs	r3, r0
    3c70:	7023      	strb	r3, [r4, #0]
	/* Clear write interrupt flag */
	i2c_module->INTFLAG.reg = SERCOM_I2CM_INTENCLR_MB;
    3c72:	68fb      	ldr	r3, [r7, #12]
    3c74:	2201      	movs	r2, #1
    3c76:	761a      	strb	r2, [r3, #24]

	return tmp_status;
    3c78:	230b      	movs	r3, #11
    3c7a:	18fb      	adds	r3, r7, r3
    3c7c:	781b      	ldrb	r3, [r3, #0]
}
    3c7e:	0018      	movs	r0, r3
    3c80:	46bd      	mov	sp, r7
    3c82:	b005      	add	sp, #20
    3c84:	bd90      	pop	{r4, r7, pc}
    3c86:	46c0      	nop			; (mov r8, r8)
    3c88:	00003bd9 	.word	0x00003bd9

00003c8c <_i2c_master_read_packet>:
 *
 */
static enum status_code _i2c_master_read_packet(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
    3c8c:	b590      	push	{r4, r7, lr}
    3c8e:	b087      	sub	sp, #28
    3c90:	af00      	add	r7, sp, #0
    3c92:	6078      	str	r0, [r7, #4]
    3c94:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);
	Assert(packet);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    3c96:	687b      	ldr	r3, [r7, #4]
    3c98:	681b      	ldr	r3, [r3, #0]
    3c9a:	60fb      	str	r3, [r7, #12]

	/* Return value. */
	enum status_code tmp_status;
	uint16_t tmp_data_length = packet->data_length;
    3c9c:	2314      	movs	r3, #20
    3c9e:	18fb      	adds	r3, r7, r3
    3ca0:	683a      	ldr	r2, [r7, #0]
    3ca2:	8852      	ldrh	r2, [r2, #2]
    3ca4:	801a      	strh	r2, [r3, #0]

	/* Written buffer counter. */
	uint16_t counter = 0;
    3ca6:	2312      	movs	r3, #18
    3ca8:	18fb      	adds	r3, r7, r3
    3caa:	2200      	movs	r2, #0
    3cac:	801a      	strh	r2, [r3, #0]

	bool sclsm_flag = i2c_module->CTRLA.bit.SCLSM;
    3cae:	68fb      	ldr	r3, [r7, #12]
    3cb0:	681b      	ldr	r3, [r3, #0]
    3cb2:	011b      	lsls	r3, r3, #4
    3cb4:	0fdb      	lsrs	r3, r3, #31
    3cb6:	b2db      	uxtb	r3, r3
    3cb8:	001a      	movs	r2, r3
    3cba:	230b      	movs	r3, #11
    3cbc:	18fb      	adds	r3, r7, r3
    3cbe:	1e51      	subs	r1, r2, #1
    3cc0:	418a      	sbcs	r2, r1
    3cc2:	701a      	strb	r2, [r3, #0]

	/* Switch to high speed mode */
	if (packet->high_speed) {
    3cc4:	683b      	ldr	r3, [r7, #0]
    3cc6:	7a5b      	ldrb	r3, [r3, #9]
    3cc8:	2b00      	cmp	r3, #0
    3cca:	d006      	beq.n	3cda <_i2c_master_read_packet+0x4e>
		_i2c_master_send_hs_master_code(module, packet->hs_master_code);
    3ccc:	683b      	ldr	r3, [r7, #0]
    3cce:	7a9a      	ldrb	r2, [r3, #10]
    3cd0:	687b      	ldr	r3, [r7, #4]
    3cd2:	0011      	movs	r1, r2
    3cd4:	0018      	movs	r0, r3
    3cd6:	4b7c      	ldr	r3, [pc, #496]	; (3ec8 <_i2c_master_read_packet+0x23c>)
    3cd8:	4798      	blx	r3
	}

	/* Set action to ACK. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    3cda:	68fb      	ldr	r3, [r7, #12]
    3cdc:	685b      	ldr	r3, [r3, #4]
    3cde:	4a7b      	ldr	r2, [pc, #492]	; (3ecc <_i2c_master_read_packet+0x240>)
    3ce0:	401a      	ands	r2, r3
    3ce2:	68fb      	ldr	r3, [r7, #12]
    3ce4:	605a      	str	r2, [r3, #4]

	/* Set address and direction bit. Will send start command on bus. */
	if (packet->ten_bit_address) {
    3ce6:	683b      	ldr	r3, [r7, #0]
    3ce8:	7a1b      	ldrb	r3, [r3, #8]
    3cea:	2b00      	cmp	r3, #0
    3cec:	d042      	beq.n	3d74 <_i2c_master_read_packet+0xe8>
		/*
		 * Write ADDR.ADDR[10:1] with the 10-bit address. ADDR.TENBITEN must
		 * be set and read/write bit (ADDR.ADDR[0]) equal to 0.
		 */
		i2c_module->ADDR.reg = (packet->address << 1) |
    3cee:	683b      	ldr	r3, [r7, #0]
    3cf0:	881b      	ldrh	r3, [r3, #0]
    3cf2:	005a      	lsls	r2, r3, #1
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
    3cf4:	683b      	ldr	r3, [r7, #0]
    3cf6:	7a5b      	ldrb	r3, [r3, #9]
    3cf8:	039b      	lsls	r3, r3, #14
	if (packet->ten_bit_address) {
		/*
		 * Write ADDR.ADDR[10:1] with the 10-bit address. ADDR.TENBITEN must
		 * be set and read/write bit (ADDR.ADDR[0]) equal to 0.
		 */
		i2c_module->ADDR.reg = (packet->address << 1) |
    3cfa:	4313      	orrs	r3, r2
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
    3cfc:	001a      	movs	r2, r3
    3cfe:	2380      	movs	r3, #128	; 0x80
    3d00:	021b      	lsls	r3, r3, #8
    3d02:	431a      	orrs	r2, r3
	if (packet->ten_bit_address) {
		/*
		 * Write ADDR.ADDR[10:1] with the 10-bit address. ADDR.TENBITEN must
		 * be set and read/write bit (ADDR.ADDR[0]) equal to 0.
		 */
		i2c_module->ADDR.reg = (packet->address << 1) |
    3d04:	68fb      	ldr	r3, [r7, #12]
    3d06:	625a      	str	r2, [r3, #36]	; 0x24
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
			SERCOM_I2CM_ADDR_TENBITEN;

		/* Wait for response on bus. */
		tmp_status = _i2c_master_wait_for_bus(module);
    3d08:	2317      	movs	r3, #23
    3d0a:	18fc      	adds	r4, r7, r3
    3d0c:	687b      	ldr	r3, [r7, #4]
    3d0e:	0018      	movs	r0, r3
    3d10:	4b6f      	ldr	r3, [pc, #444]	; (3ed0 <_i2c_master_read_packet+0x244>)
    3d12:	4798      	blx	r3
    3d14:	0003      	movs	r3, r0
    3d16:	7023      	strb	r3, [r4, #0]

		/* Set action to ack. */
		i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    3d18:	68fb      	ldr	r3, [r7, #12]
    3d1a:	685b      	ldr	r3, [r3, #4]
    3d1c:	4a6b      	ldr	r2, [pc, #428]	; (3ecc <_i2c_master_read_packet+0x240>)
    3d1e:	401a      	ands	r2, r3
    3d20:	68fb      	ldr	r3, [r7, #12]
    3d22:	605a      	str	r2, [r3, #4]

		/* Check for address response error unless previous error is
		 * detected. */
		if (tmp_status == STATUS_OK) {
    3d24:	2317      	movs	r3, #23
    3d26:	18fb      	adds	r3, r7, r3
    3d28:	781b      	ldrb	r3, [r3, #0]
    3d2a:	2b00      	cmp	r3, #0
    3d2c:	d107      	bne.n	3d3e <_i2c_master_read_packet+0xb2>
			tmp_status = _i2c_master_address_response(module);
    3d2e:	2317      	movs	r3, #23
    3d30:	18fc      	adds	r4, r7, r3
    3d32:	687b      	ldr	r3, [r7, #4]
    3d34:	0018      	movs	r0, r3
    3d36:	4b67      	ldr	r3, [pc, #412]	; (3ed4 <_i2c_master_read_packet+0x248>)
    3d38:	4798      	blx	r3
    3d3a:	0003      	movs	r3, r0
    3d3c:	7023      	strb	r3, [r4, #0]
		}

		if (tmp_status == STATUS_OK) {
    3d3e:	2317      	movs	r3, #23
    3d40:	18fb      	adds	r3, r7, r3
    3d42:	781b      	ldrb	r3, [r3, #0]
    3d44:	2b00      	cmp	r3, #0
    3d46:	d111      	bne.n	3d6c <_i2c_master_read_packet+0xe0>
			/*
			 * Write ADDR[7:0] register to "11110 address[9:8] 1"
			 * ADDR.TENBITEN must be cleared
			 */
			i2c_module->ADDR.reg = (((packet->address >> 8) | 0x78) << 1) |
    3d48:	683b      	ldr	r3, [r7, #0]
    3d4a:	881b      	ldrh	r3, [r3, #0]
    3d4c:	0a1b      	lsrs	r3, r3, #8
    3d4e:	b29b      	uxth	r3, r3
    3d50:	2278      	movs	r2, #120	; 0x78
    3d52:	4313      	orrs	r3, r2
    3d54:	b29b      	uxth	r3, r3
    3d56:	005a      	lsls	r2, r3, #1
				(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
    3d58:	683b      	ldr	r3, [r7, #0]
    3d5a:	7a5b      	ldrb	r3, [r3, #9]
    3d5c:	039b      	lsls	r3, r3, #14
		if (tmp_status == STATUS_OK) {
			/*
			 * Write ADDR[7:0] register to "11110 address[9:8] 1"
			 * ADDR.TENBITEN must be cleared
			 */
			i2c_module->ADDR.reg = (((packet->address >> 8) | 0x78) << 1) |
    3d5e:	4313      	orrs	r3, r2
				(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
    3d60:	2201      	movs	r2, #1
    3d62:	4313      	orrs	r3, r2
		if (tmp_status == STATUS_OK) {
			/*
			 * Write ADDR[7:0] register to "11110 address[9:8] 1"
			 * ADDR.TENBITEN must be cleared
			 */
			i2c_module->ADDR.reg = (((packet->address >> 8) | 0x78) << 1) |
    3d64:	001a      	movs	r2, r3
    3d66:	68fb      	ldr	r3, [r7, #12]
    3d68:	625a      	str	r2, [r3, #36]	; 0x24
    3d6a:	e00f      	b.n	3d8c <_i2c_master_read_packet+0x100>
				(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
				I2C_TRANSFER_READ;
		} else {
			return tmp_status;
    3d6c:	2317      	movs	r3, #23
    3d6e:	18fb      	adds	r3, r7, r3
    3d70:	781b      	ldrb	r3, [r3, #0]
    3d72:	e0a5      	b.n	3ec0 <_i2c_master_read_packet+0x234>
		}
	} else {
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_READ |
    3d74:	683b      	ldr	r3, [r7, #0]
    3d76:	881b      	ldrh	r3, [r3, #0]
    3d78:	005b      	lsls	r3, r3, #1
    3d7a:	2201      	movs	r2, #1
    3d7c:	431a      	orrs	r2, r3
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos);
    3d7e:	683b      	ldr	r3, [r7, #0]
    3d80:	7a5b      	ldrb	r3, [r3, #9]
    3d82:	039b      	lsls	r3, r3, #14
				I2C_TRANSFER_READ;
		} else {
			return tmp_status;
		}
	} else {
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_READ |
    3d84:	4313      	orrs	r3, r2
    3d86:	001a      	movs	r2, r3
    3d88:	68fb      	ldr	r3, [r7, #12]
    3d8a:	625a      	str	r2, [r3, #36]	; 0x24
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos);
	}

	/* Wait for response on bus. */
	tmp_status = _i2c_master_wait_for_bus(module);
    3d8c:	2317      	movs	r3, #23
    3d8e:	18fc      	adds	r4, r7, r3
    3d90:	687b      	ldr	r3, [r7, #4]
    3d92:	0018      	movs	r0, r3
    3d94:	4b4e      	ldr	r3, [pc, #312]	; (3ed0 <_i2c_master_read_packet+0x244>)
    3d96:	4798      	blx	r3
    3d98:	0003      	movs	r3, r0
    3d9a:	7023      	strb	r3, [r4, #0]

	/* Set action to ack. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    3d9c:	68fb      	ldr	r3, [r7, #12]
    3d9e:	685b      	ldr	r3, [r3, #4]
    3da0:	4a4a      	ldr	r2, [pc, #296]	; (3ecc <_i2c_master_read_packet+0x240>)
    3da2:	401a      	ands	r2, r3
    3da4:	68fb      	ldr	r3, [r7, #12]
    3da6:	605a      	str	r2, [r3, #4]

	/* Check for address response error unless previous error is
	 * detected. */
	if (tmp_status == STATUS_OK) {
    3da8:	2317      	movs	r3, #23
    3daa:	18fb      	adds	r3, r7, r3
    3dac:	781b      	ldrb	r3, [r3, #0]
    3dae:	2b00      	cmp	r3, #0
    3db0:	d107      	bne.n	3dc2 <_i2c_master_read_packet+0x136>
		tmp_status = _i2c_master_address_response(module);
    3db2:	2317      	movs	r3, #23
    3db4:	18fc      	adds	r4, r7, r3
    3db6:	687b      	ldr	r3, [r7, #4]
    3db8:	0018      	movs	r0, r3
    3dba:	4b46      	ldr	r3, [pc, #280]	; (3ed4 <_i2c_master_read_packet+0x248>)
    3dbc:	4798      	blx	r3
    3dbe:	0003      	movs	r3, r0
    3dc0:	7023      	strb	r3, [r4, #0]
	}

	/* Check that no error has occurred. */
	if (tmp_status == STATUS_OK) {
    3dc2:	2317      	movs	r3, #23
    3dc4:	18fb      	adds	r3, r7, r3
    3dc6:	781b      	ldrb	r3, [r3, #0]
    3dc8:	2b00      	cmp	r3, #0
    3dca:	d000      	beq.n	3dce <_i2c_master_read_packet+0x142>
    3dcc:	e075      	b.n	3eba <_i2c_master_read_packet+0x22e>
		/* Read data buffer. */
		while (tmp_data_length--) {
    3dce:	e04b      	b.n	3e68 <_i2c_master_read_packet+0x1dc>
			/* Check that bus ownership is not lost. */
			if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
    3dd0:	68fb      	ldr	r3, [r7, #12]
    3dd2:	8b5b      	ldrh	r3, [r3, #26]
    3dd4:	b29b      	uxth	r3, r3
    3dd6:	001a      	movs	r2, r3
    3dd8:	2320      	movs	r3, #32
    3dda:	4013      	ands	r3, r2
    3ddc:	d101      	bne.n	3de2 <_i2c_master_read_packet+0x156>
				return STATUS_ERR_PACKET_COLLISION;
    3dde:	2341      	movs	r3, #65	; 0x41
    3de0:	e06e      	b.n	3ec0 <_i2c_master_read_packet+0x234>
			}

			if (module->send_nack && (((!sclsm_flag) && (tmp_data_length == 0)) ||
    3de2:	687b      	ldr	r3, [r7, #4]
    3de4:	7adb      	ldrb	r3, [r3, #11]
    3de6:	2b00      	cmp	r3, #0
    3de8:	d01e      	beq.n	3e28 <_i2c_master_read_packet+0x19c>
    3dea:	230b      	movs	r3, #11
    3dec:	18fb      	adds	r3, r7, r3
    3dee:	781b      	ldrb	r3, [r3, #0]
    3df0:	2201      	movs	r2, #1
    3df2:	4053      	eors	r3, r2
    3df4:	b2db      	uxtb	r3, r3
    3df6:	2b00      	cmp	r3, #0
    3df8:	d004      	beq.n	3e04 <_i2c_master_read_packet+0x178>
    3dfa:	2314      	movs	r3, #20
    3dfc:	18fb      	adds	r3, r7, r3
    3dfe:	881b      	ldrh	r3, [r3, #0]
    3e00:	2b00      	cmp	r3, #0
    3e02:	d009      	beq.n	3e18 <_i2c_master_read_packet+0x18c>
    3e04:	230b      	movs	r3, #11
    3e06:	18fb      	adds	r3, r7, r3
    3e08:	781b      	ldrb	r3, [r3, #0]
    3e0a:	2b00      	cmp	r3, #0
    3e0c:	d00c      	beq.n	3e28 <_i2c_master_read_packet+0x19c>
					((sclsm_flag) && (tmp_data_length == 1)))) {
    3e0e:	2314      	movs	r3, #20
    3e10:	18fb      	adds	r3, r7, r3
    3e12:	881b      	ldrh	r3, [r3, #0]
    3e14:	2b01      	cmp	r3, #1
    3e16:	d107      	bne.n	3e28 <_i2c_master_read_packet+0x19c>
				/* Set action to NACK */
				i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    3e18:	68fb      	ldr	r3, [r7, #12]
    3e1a:	685b      	ldr	r3, [r3, #4]
    3e1c:	2280      	movs	r2, #128	; 0x80
    3e1e:	02d2      	lsls	r2, r2, #11
    3e20:	431a      	orrs	r2, r3
    3e22:	68fb      	ldr	r3, [r7, #12]
    3e24:	605a      	str	r2, [r3, #4]
    3e26:	e01a      	b.n	3e5e <_i2c_master_read_packet+0x1d2>
			} else {
				/* Save data to buffer. */
				_i2c_master_wait_for_sync(module);
    3e28:	687b      	ldr	r3, [r7, #4]
    3e2a:	0018      	movs	r0, r3
    3e2c:	4b2a      	ldr	r3, [pc, #168]	; (3ed8 <_i2c_master_read_packet+0x24c>)
    3e2e:	4798      	blx	r3
				packet->data[counter++] = i2c_module->DATA.reg;
    3e30:	683b      	ldr	r3, [r7, #0]
    3e32:	685a      	ldr	r2, [r3, #4]
    3e34:	2312      	movs	r3, #18
    3e36:	18fb      	adds	r3, r7, r3
    3e38:	881b      	ldrh	r3, [r3, #0]
    3e3a:	2112      	movs	r1, #18
    3e3c:	1879      	adds	r1, r7, r1
    3e3e:	1c58      	adds	r0, r3, #1
    3e40:	8008      	strh	r0, [r1, #0]
    3e42:	18d3      	adds	r3, r2, r3
    3e44:	68fa      	ldr	r2, [r7, #12]
    3e46:	2128      	movs	r1, #40	; 0x28
    3e48:	5c52      	ldrb	r2, [r2, r1]
    3e4a:	b2d2      	uxtb	r2, r2
    3e4c:	701a      	strb	r2, [r3, #0]
				/* Wait for response. */
				tmp_status = _i2c_master_wait_for_bus(module);
    3e4e:	2317      	movs	r3, #23
    3e50:	18fc      	adds	r4, r7, r3
    3e52:	687b      	ldr	r3, [r7, #4]
    3e54:	0018      	movs	r0, r3
    3e56:	4b1e      	ldr	r3, [pc, #120]	; (3ed0 <_i2c_master_read_packet+0x244>)
    3e58:	4798      	blx	r3
    3e5a:	0003      	movs	r3, r0
    3e5c:	7023      	strb	r3, [r4, #0]
			}

			/* Check for error. */
			if (tmp_status != STATUS_OK) {
    3e5e:	2317      	movs	r3, #23
    3e60:	18fb      	adds	r3, r7, r3
    3e62:	781b      	ldrb	r3, [r3, #0]
    3e64:	2b00      	cmp	r3, #0
    3e66:	d109      	bne.n	3e7c <_i2c_master_read_packet+0x1f0>
	}

	/* Check that no error has occurred. */
	if (tmp_status == STATUS_OK) {
		/* Read data buffer. */
		while (tmp_data_length--) {
    3e68:	2314      	movs	r3, #20
    3e6a:	18fb      	adds	r3, r7, r3
    3e6c:	881b      	ldrh	r3, [r3, #0]
    3e6e:	2214      	movs	r2, #20
    3e70:	18ba      	adds	r2, r7, r2
    3e72:	1e59      	subs	r1, r3, #1
    3e74:	8011      	strh	r1, [r2, #0]
    3e76:	2b00      	cmp	r3, #0
    3e78:	d1aa      	bne.n	3dd0 <_i2c_master_read_packet+0x144>
    3e7a:	e000      	b.n	3e7e <_i2c_master_read_packet+0x1f2>
				tmp_status = _i2c_master_wait_for_bus(module);
			}

			/* Check for error. */
			if (tmp_status != STATUS_OK) {
				break;
    3e7c:	46c0      	nop			; (mov r8, r8)
			}
		}

		if (module->send_stop) {
    3e7e:	687b      	ldr	r3, [r7, #4]
    3e80:	7a9b      	ldrb	r3, [r3, #10]
    3e82:	2b00      	cmp	r3, #0
    3e84:	d00a      	beq.n	3e9c <_i2c_master_read_packet+0x210>
			/* Send stop command unless arbitration is lost. */
			_i2c_master_wait_for_sync(module);
    3e86:	687b      	ldr	r3, [r7, #4]
    3e88:	0018      	movs	r0, r3
    3e8a:	4b13      	ldr	r3, [pc, #76]	; (3ed8 <_i2c_master_read_packet+0x24c>)
    3e8c:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
    3e8e:	68fb      	ldr	r3, [r7, #12]
    3e90:	685b      	ldr	r3, [r3, #4]
    3e92:	22c0      	movs	r2, #192	; 0xc0
    3e94:	0292      	lsls	r2, r2, #10
    3e96:	431a      	orrs	r2, r3
    3e98:	68fb      	ldr	r3, [r7, #12]
    3e9a:	605a      	str	r2, [r3, #4]
		}

		/* Save last data to buffer. */
		_i2c_master_wait_for_sync(module);
    3e9c:	687b      	ldr	r3, [r7, #4]
    3e9e:	0018      	movs	r0, r3
    3ea0:	4b0d      	ldr	r3, [pc, #52]	; (3ed8 <_i2c_master_read_packet+0x24c>)
    3ea2:	4798      	blx	r3
		packet->data[counter] = i2c_module->DATA.reg;
    3ea4:	683b      	ldr	r3, [r7, #0]
    3ea6:	685a      	ldr	r2, [r3, #4]
    3ea8:	2312      	movs	r3, #18
    3eaa:	18fb      	adds	r3, r7, r3
    3eac:	881b      	ldrh	r3, [r3, #0]
    3eae:	18d3      	adds	r3, r2, r3
    3eb0:	68fa      	ldr	r2, [r7, #12]
    3eb2:	2128      	movs	r1, #40	; 0x28
    3eb4:	5c52      	ldrb	r2, [r2, r1]
    3eb6:	b2d2      	uxtb	r2, r2
    3eb8:	701a      	strb	r2, [r3, #0]
	}

	return tmp_status;
    3eba:	2317      	movs	r3, #23
    3ebc:	18fb      	adds	r3, r7, r3
    3ebe:	781b      	ldrb	r3, [r3, #0]
}
    3ec0:	0018      	movs	r0, r3
    3ec2:	46bd      	mov	sp, r7
    3ec4:	b007      	add	sp, #28
    3ec6:	bd90      	pop	{r4, r7, pc}
    3ec8:	00003c39 	.word	0x00003c39
    3ecc:	fffbffff 	.word	0xfffbffff
    3ed0:	00003bd9 	.word	0x00003bd9
    3ed4:	00003b79 	.word	0x00003b79
    3ed8:	00003799 	.word	0x00003799

00003edc <i2c_master_read_packet_wait>:
 *                                      acknowledged the address
 */
enum status_code i2c_master_read_packet_wait(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
    3edc:	b580      	push	{r7, lr}
    3ede:	b082      	sub	sp, #8
    3ee0:	af00      	add	r7, sp, #0
    3ee2:	6078      	str	r0, [r7, #4]
    3ee4:	6039      	str	r1, [r7, #0]
	if (module->buffer_remaining > 0) {
		return STATUS_BUSY;
	}
#endif

	module->send_stop = true;
    3ee6:	687b      	ldr	r3, [r7, #4]
    3ee8:	2201      	movs	r2, #1
    3eea:	729a      	strb	r2, [r3, #10]
	module->send_nack = true;
    3eec:	687b      	ldr	r3, [r7, #4]
    3eee:	2201      	movs	r2, #1
    3ef0:	72da      	strb	r2, [r3, #11]
	
	return _i2c_master_read_packet(module, packet);
    3ef2:	683a      	ldr	r2, [r7, #0]
    3ef4:	687b      	ldr	r3, [r7, #4]
    3ef6:	0011      	movs	r1, r2
    3ef8:	0018      	movs	r0, r3
    3efa:	4b03      	ldr	r3, [pc, #12]	; (3f08 <i2c_master_read_packet_wait+0x2c>)
    3efc:	4798      	blx	r3
    3efe:	0003      	movs	r3, r0
}
    3f00:	0018      	movs	r0, r3
    3f02:	46bd      	mov	sp, r7
    3f04:	b002      	add	sp, #8
    3f06:	bd80      	pop	{r7, pc}
    3f08:	00003c8d 	.word	0x00003c8d

00003f0c <_i2c_master_write_packet>:
 *                                      acknowledged the address
 */
static enum status_code _i2c_master_write_packet(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
    3f0c:	b590      	push	{r4, r7, lr}
    3f0e:	b087      	sub	sp, #28
    3f10:	af00      	add	r7, sp, #0
    3f12:	6078      	str	r0, [r7, #4]
    3f14:	6039      	str	r1, [r7, #0]
	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    3f16:	687b      	ldr	r3, [r7, #4]
    3f18:	681b      	ldr	r3, [r3, #0]
    3f1a:	60fb      	str	r3, [r7, #12]

	/* Return value. */
	enum status_code tmp_status;
	uint16_t tmp_data_length = packet->data_length;
    3f1c:	2314      	movs	r3, #20
    3f1e:	18fb      	adds	r3, r7, r3
    3f20:	683a      	ldr	r2, [r7, #0]
    3f22:	8852      	ldrh	r2, [r2, #2]
    3f24:	801a      	strh	r2, [r3, #0]

	_i2c_master_wait_for_sync(module);
    3f26:	687b      	ldr	r3, [r7, #4]
    3f28:	0018      	movs	r0, r3
    3f2a:	4b51      	ldr	r3, [pc, #324]	; (4070 <_i2c_master_write_packet+0x164>)
    3f2c:	4798      	blx	r3

	/* Switch to high speed mode */
	if (packet->high_speed) {
    3f2e:	683b      	ldr	r3, [r7, #0]
    3f30:	7a5b      	ldrb	r3, [r3, #9]
    3f32:	2b00      	cmp	r3, #0
    3f34:	d006      	beq.n	3f44 <_i2c_master_write_packet+0x38>
		_i2c_master_send_hs_master_code(module, packet->hs_master_code);
    3f36:	683b      	ldr	r3, [r7, #0]
    3f38:	7a9a      	ldrb	r2, [r3, #10]
    3f3a:	687b      	ldr	r3, [r7, #4]
    3f3c:	0011      	movs	r1, r2
    3f3e:	0018      	movs	r0, r3
    3f40:	4b4c      	ldr	r3, [pc, #304]	; (4074 <_i2c_master_write_packet+0x168>)
    3f42:	4798      	blx	r3
	}

	/* Set action to ACK. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    3f44:	68fb      	ldr	r3, [r7, #12]
    3f46:	685b      	ldr	r3, [r3, #4]
    3f48:	4a4b      	ldr	r2, [pc, #300]	; (4078 <_i2c_master_write_packet+0x16c>)
    3f4a:	401a      	ands	r2, r3
    3f4c:	68fb      	ldr	r3, [r7, #12]
    3f4e:	605a      	str	r2, [r3, #4]

	/* Set address and direction bit. Will send start command on bus. */
	if (packet->ten_bit_address) {
    3f50:	683b      	ldr	r3, [r7, #0]
    3f52:	7a1b      	ldrb	r3, [r3, #8]
    3f54:	2b00      	cmp	r3, #0
    3f56:	d00d      	beq.n	3f74 <_i2c_master_write_packet+0x68>
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE |
    3f58:	683b      	ldr	r3, [r7, #0]
    3f5a:	881b      	ldrh	r3, [r3, #0]
    3f5c:	005a      	lsls	r2, r3, #1
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
    3f5e:	683b      	ldr	r3, [r7, #0]
    3f60:	7a5b      	ldrb	r3, [r3, #9]
    3f62:	039b      	lsls	r3, r3, #14
	/* Set action to ACK. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;

	/* Set address and direction bit. Will send start command on bus. */
	if (packet->ten_bit_address) {
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE |
    3f64:	4313      	orrs	r3, r2
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
    3f66:	001a      	movs	r2, r3
    3f68:	2380      	movs	r3, #128	; 0x80
    3f6a:	021b      	lsls	r3, r3, #8
    3f6c:	431a      	orrs	r2, r3
	/* Set action to ACK. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;

	/* Set address and direction bit. Will send start command on bus. */
	if (packet->ten_bit_address) {
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE |
    3f6e:	68fb      	ldr	r3, [r7, #12]
    3f70:	625a      	str	r2, [r3, #36]	; 0x24
    3f72:	e009      	b.n	3f88 <_i2c_master_write_packet+0x7c>
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
			SERCOM_I2CM_ADDR_TENBITEN;
	} else {
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE |
    3f74:	683b      	ldr	r3, [r7, #0]
    3f76:	881b      	ldrh	r3, [r3, #0]
    3f78:	005a      	lsls	r2, r3, #1
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos);
    3f7a:	683b      	ldr	r3, [r7, #0]
    3f7c:	7a5b      	ldrb	r3, [r3, #9]
    3f7e:	039b      	lsls	r3, r3, #14
	if (packet->ten_bit_address) {
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE |
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
			SERCOM_I2CM_ADDR_TENBITEN;
	} else {
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE |
    3f80:	4313      	orrs	r3, r2
    3f82:	001a      	movs	r2, r3
    3f84:	68fb      	ldr	r3, [r7, #12]
    3f86:	625a      	str	r2, [r3, #36]	; 0x24
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos);
	}
	/* Wait for response on bus. */
	tmp_status = _i2c_master_wait_for_bus(module);
    3f88:	2317      	movs	r3, #23
    3f8a:	18fc      	adds	r4, r7, r3
    3f8c:	687b      	ldr	r3, [r7, #4]
    3f8e:	0018      	movs	r0, r3
    3f90:	4b3a      	ldr	r3, [pc, #232]	; (407c <_i2c_master_write_packet+0x170>)
    3f92:	4798      	blx	r3
    3f94:	0003      	movs	r3, r0
    3f96:	7023      	strb	r3, [r4, #0]

	/* Check for address response error unless previous error is
	 * detected. */
	if (tmp_status == STATUS_OK) {
    3f98:	2317      	movs	r3, #23
    3f9a:	18fb      	adds	r3, r7, r3
    3f9c:	781b      	ldrb	r3, [r3, #0]
    3f9e:	2b00      	cmp	r3, #0
    3fa0:	d107      	bne.n	3fb2 <_i2c_master_write_packet+0xa6>
		tmp_status = _i2c_master_address_response(module);
    3fa2:	2317      	movs	r3, #23
    3fa4:	18fc      	adds	r4, r7, r3
    3fa6:	687b      	ldr	r3, [r7, #4]
    3fa8:	0018      	movs	r0, r3
    3faa:	4b35      	ldr	r3, [pc, #212]	; (4080 <_i2c_master_write_packet+0x174>)
    3fac:	4798      	blx	r3
    3fae:	0003      	movs	r3, r0
    3fb0:	7023      	strb	r3, [r4, #0]
	}

	/* Check that no error has occurred. */
	if (tmp_status == STATUS_OK) {
    3fb2:	2317      	movs	r3, #23
    3fb4:	18fb      	adds	r3, r7, r3
    3fb6:	781b      	ldrb	r3, [r3, #0]
    3fb8:	2b00      	cmp	r3, #0
    3fba:	d152      	bne.n	4062 <_i2c_master_write_packet+0x156>
		/* Buffer counter. */
		uint16_t buffer_counter = 0;
    3fbc:	2312      	movs	r3, #18
    3fbe:	18fb      	adds	r3, r7, r3
    3fc0:	2200      	movs	r2, #0
    3fc2:	801a      	strh	r2, [r3, #0]

		/* Write data buffer. */
		while (tmp_data_length--) {
    3fc4:	e033      	b.n	402e <_i2c_master_write_packet+0x122>
			/* Check that bus ownership is not lost. */
			if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
    3fc6:	68fb      	ldr	r3, [r7, #12]
    3fc8:	8b5b      	ldrh	r3, [r3, #26]
    3fca:	b29b      	uxth	r3, r3
    3fcc:	001a      	movs	r2, r3
    3fce:	2320      	movs	r3, #32
    3fd0:	4013      	ands	r3, r2
    3fd2:	d101      	bne.n	3fd8 <_i2c_master_write_packet+0xcc>
				return STATUS_ERR_PACKET_COLLISION;
    3fd4:	2341      	movs	r3, #65	; 0x41
    3fd6:	e047      	b.n	4068 <_i2c_master_write_packet+0x15c>
			}

			/* Write byte to slave. */
			_i2c_master_wait_for_sync(module);
    3fd8:	687b      	ldr	r3, [r7, #4]
    3fda:	0018      	movs	r0, r3
    3fdc:	4b24      	ldr	r3, [pc, #144]	; (4070 <_i2c_master_write_packet+0x164>)
    3fde:	4798      	blx	r3
			i2c_module->DATA.reg = packet->data[buffer_counter++];
    3fe0:	683b      	ldr	r3, [r7, #0]
    3fe2:	685a      	ldr	r2, [r3, #4]
    3fe4:	2312      	movs	r3, #18
    3fe6:	18fb      	adds	r3, r7, r3
    3fe8:	881b      	ldrh	r3, [r3, #0]
    3fea:	2112      	movs	r1, #18
    3fec:	1879      	adds	r1, r7, r1
    3fee:	1c58      	adds	r0, r3, #1
    3ff0:	8008      	strh	r0, [r1, #0]
    3ff2:	18d3      	adds	r3, r2, r3
    3ff4:	7819      	ldrb	r1, [r3, #0]
    3ff6:	68fb      	ldr	r3, [r7, #12]
    3ff8:	2228      	movs	r2, #40	; 0x28
    3ffa:	5499      	strb	r1, [r3, r2]

			/* Wait for response. */
			tmp_status = _i2c_master_wait_for_bus(module);
    3ffc:	2317      	movs	r3, #23
    3ffe:	18fc      	adds	r4, r7, r3
    4000:	687b      	ldr	r3, [r7, #4]
    4002:	0018      	movs	r0, r3
    4004:	4b1d      	ldr	r3, [pc, #116]	; (407c <_i2c_master_write_packet+0x170>)
    4006:	4798      	blx	r3
    4008:	0003      	movs	r3, r0
    400a:	7023      	strb	r3, [r4, #0]

			/* Check for error. */
			if (tmp_status != STATUS_OK) {
    400c:	2317      	movs	r3, #23
    400e:	18fb      	adds	r3, r7, r3
    4010:	781b      	ldrb	r3, [r3, #0]
    4012:	2b00      	cmp	r3, #0
    4014:	d115      	bne.n	4042 <_i2c_master_write_packet+0x136>
				break;
			}

			/* Check for NACK from slave. */
			if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK) {
    4016:	68fb      	ldr	r3, [r7, #12]
    4018:	8b5b      	ldrh	r3, [r3, #26]
    401a:	b29b      	uxth	r3, r3
    401c:	001a      	movs	r2, r3
    401e:	2304      	movs	r3, #4
    4020:	4013      	ands	r3, r2
    4022:	d004      	beq.n	402e <_i2c_master_write_packet+0x122>
				/* Return bad data value. */
				tmp_status = STATUS_ERR_OVERFLOW;
    4024:	2317      	movs	r3, #23
    4026:	18fb      	adds	r3, r7, r3
    4028:	221e      	movs	r2, #30
    402a:	701a      	strb	r2, [r3, #0]
				break;
    402c:	e00a      	b.n	4044 <_i2c_master_write_packet+0x138>
	if (tmp_status == STATUS_OK) {
		/* Buffer counter. */
		uint16_t buffer_counter = 0;

		/* Write data buffer. */
		while (tmp_data_length--) {
    402e:	2314      	movs	r3, #20
    4030:	18fb      	adds	r3, r7, r3
    4032:	881b      	ldrh	r3, [r3, #0]
    4034:	2214      	movs	r2, #20
    4036:	18ba      	adds	r2, r7, r2
    4038:	1e59      	subs	r1, r3, #1
    403a:	8011      	strh	r1, [r2, #0]
    403c:	2b00      	cmp	r3, #0
    403e:	d1c2      	bne.n	3fc6 <_i2c_master_write_packet+0xba>
    4040:	e000      	b.n	4044 <_i2c_master_write_packet+0x138>
			/* Wait for response. */
			tmp_status = _i2c_master_wait_for_bus(module);

			/* Check for error. */
			if (tmp_status != STATUS_OK) {
				break;
    4042:	46c0      	nop			; (mov r8, r8)
				tmp_status = STATUS_ERR_OVERFLOW;
				break;
			}
		}

		if (module->send_stop) {
    4044:	687b      	ldr	r3, [r7, #4]
    4046:	7a9b      	ldrb	r3, [r3, #10]
    4048:	2b00      	cmp	r3, #0
    404a:	d00a      	beq.n	4062 <_i2c_master_write_packet+0x156>
			/* Stop command */
			_i2c_master_wait_for_sync(module);
    404c:	687b      	ldr	r3, [r7, #4]
    404e:	0018      	movs	r0, r3
    4050:	4b07      	ldr	r3, [pc, #28]	; (4070 <_i2c_master_write_packet+0x164>)
    4052:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
    4054:	68fb      	ldr	r3, [r7, #12]
    4056:	685b      	ldr	r3, [r3, #4]
    4058:	22c0      	movs	r2, #192	; 0xc0
    405a:	0292      	lsls	r2, r2, #10
    405c:	431a      	orrs	r2, r3
    405e:	68fb      	ldr	r3, [r7, #12]
    4060:	605a      	str	r2, [r3, #4]
		}
	}

	return tmp_status;
    4062:	2317      	movs	r3, #23
    4064:	18fb      	adds	r3, r7, r3
    4066:	781b      	ldrb	r3, [r3, #0]
}
    4068:	0018      	movs	r0, r3
    406a:	46bd      	mov	sp, r7
    406c:	b007      	add	sp, #28
    406e:	bd90      	pop	{r4, r7, pc}
    4070:	00003799 	.word	0x00003799
    4074:	00003c39 	.word	0x00003c39
    4078:	fffbffff 	.word	0xfffbffff
    407c:	00003bd9 	.word	0x00003bd9
    4080:	00003b79 	.word	0x00003b79

00004084 <i2c_master_write_packet_wait>:
 *                                      last data sent
 */
enum status_code i2c_master_write_packet_wait(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
    4084:	b580      	push	{r7, lr}
    4086:	b082      	sub	sp, #8
    4088:	af00      	add	r7, sp, #0
    408a:	6078      	str	r0, [r7, #4]
    408c:	6039      	str	r1, [r7, #0]
	if (module->buffer_remaining > 0) {
		return STATUS_BUSY;
	}
#endif

	module->send_stop = true;
    408e:	687b      	ldr	r3, [r7, #4]
    4090:	2201      	movs	r2, #1
    4092:	729a      	strb	r2, [r3, #10]
	module->send_nack = true;
    4094:	687b      	ldr	r3, [r7, #4]
    4096:	2201      	movs	r2, #1
    4098:	72da      	strb	r2, [r3, #11]

	return _i2c_master_write_packet(module, packet);
    409a:	683a      	ldr	r2, [r7, #0]
    409c:	687b      	ldr	r3, [r7, #4]
    409e:	0011      	movs	r1, r2
    40a0:	0018      	movs	r0, r3
    40a2:	4b03      	ldr	r3, [pc, #12]	; (40b0 <i2c_master_write_packet_wait+0x2c>)
    40a4:	4798      	blx	r3
    40a6:	0003      	movs	r3, r0
}
    40a8:	0018      	movs	r0, r3
    40aa:	46bd      	mov	sp, r7
    40ac:	b002      	add	sp, #8
    40ae:	bd80      	pop	{r7, pc}
    40b0:	00003f0d 	.word	0x00003f0d

000040b4 <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
    40b4:	b580      	push	{r7, lr}
    40b6:	b082      	sub	sp, #8
    40b8:	af00      	add	r7, sp, #0
    40ba:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    40bc:	687b      	ldr	r3, [r7, #4]
    40be:	2200      	movs	r2, #0
    40c0:	701a      	strb	r2, [r3, #0]
}
    40c2:	46c0      	nop			; (mov r8, r8)
    40c4:	46bd      	mov	sp, r7
    40c6:	b002      	add	sp, #8
    40c8:	bd80      	pop	{r7, pc}
    40ca:	46c0      	nop			; (mov r8, r8)

000040cc <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
    40cc:	b580      	push	{r7, lr}
    40ce:	b084      	sub	sp, #16
    40d0:	af00      	add	r7, sp, #0
    40d2:	0002      	movs	r2, r0
    40d4:	1dfb      	adds	r3, r7, #7
    40d6:	701a      	strb	r2, [r3, #0]
    40d8:	1dbb      	adds	r3, r7, #6
    40da:	1c0a      	adds	r2, r1, #0
    40dc:	701a      	strb	r2, [r3, #0]
	/* Check if valid option. */
	if (!_sercom_config.generator_is_set || force_change) {
    40de:	4b1a      	ldr	r3, [pc, #104]	; (4148 <sercom_set_gclk_generator+0x7c>)
    40e0:	781b      	ldrb	r3, [r3, #0]
    40e2:	2201      	movs	r2, #1
    40e4:	4053      	eors	r3, r2
    40e6:	b2db      	uxtb	r3, r3
    40e8:	2b00      	cmp	r3, #0
    40ea:	d103      	bne.n	40f4 <sercom_set_gclk_generator+0x28>
    40ec:	1dbb      	adds	r3, r7, #6
    40ee:	781b      	ldrb	r3, [r3, #0]
    40f0:	2b00      	cmp	r3, #0
    40f2:	d01b      	beq.n	412c <sercom_set_gclk_generator+0x60>
		/* Create and fill a GCLK configuration structure for the new config. */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
    40f4:	230c      	movs	r3, #12
    40f6:	18fb      	adds	r3, r7, r3
    40f8:	0018      	movs	r0, r3
    40fa:	4b14      	ldr	r3, [pc, #80]	; (414c <sercom_set_gclk_generator+0x80>)
    40fc:	4798      	blx	r3
		gclk_chan_conf.source_generator = generator_source;
    40fe:	230c      	movs	r3, #12
    4100:	18fb      	adds	r3, r7, r3
    4102:	1dfa      	adds	r2, r7, #7
    4104:	7812      	ldrb	r2, [r2, #0]
    4106:	701a      	strb	r2, [r3, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
    4108:	230c      	movs	r3, #12
    410a:	18fb      	adds	r3, r7, r3
    410c:	0019      	movs	r1, r3
    410e:	2013      	movs	r0, #19
    4110:	4b0f      	ldr	r3, [pc, #60]	; (4150 <sercom_set_gclk_generator+0x84>)
    4112:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
    4114:	2013      	movs	r0, #19
    4116:	4b0f      	ldr	r3, [pc, #60]	; (4154 <sercom_set_gclk_generator+0x88>)
    4118:	4798      	blx	r3

		/* Save config. */
		_sercom_config.generator_source = generator_source;
    411a:	4b0b      	ldr	r3, [pc, #44]	; (4148 <sercom_set_gclk_generator+0x7c>)
    411c:	1dfa      	adds	r2, r7, #7
    411e:	7812      	ldrb	r2, [r2, #0]
    4120:	705a      	strb	r2, [r3, #1]
		_sercom_config.generator_is_set = true;
    4122:	4b09      	ldr	r3, [pc, #36]	; (4148 <sercom_set_gclk_generator+0x7c>)
    4124:	2201      	movs	r2, #1
    4126:	701a      	strb	r2, [r3, #0]

		return STATUS_OK;
    4128:	2300      	movs	r3, #0
    412a:	e008      	b.n	413e <sercom_set_gclk_generator+0x72>
	} else if (generator_source == _sercom_config.generator_source) {
    412c:	4b06      	ldr	r3, [pc, #24]	; (4148 <sercom_set_gclk_generator+0x7c>)
    412e:	785b      	ldrb	r3, [r3, #1]
    4130:	1dfa      	adds	r2, r7, #7
    4132:	7812      	ldrb	r2, [r2, #0]
    4134:	429a      	cmp	r2, r3
    4136:	d101      	bne.n	413c <sercom_set_gclk_generator+0x70>
		/* Return status OK if same config. */
		return STATUS_OK;
    4138:	2300      	movs	r3, #0
    413a:	e000      	b.n	413e <sercom_set_gclk_generator+0x72>
	}

	/* Return invalid config to already initialized GCLK. */
	return STATUS_ERR_ALREADY_INITIALIZED;
    413c:	231d      	movs	r3, #29
}
    413e:	0018      	movs	r0, r3
    4140:	46bd      	mov	sp, r7
    4142:	b004      	add	sp, #16
    4144:	bd80      	pop	{r7, pc}
    4146:	46c0      	nop			; (mov r8, r8)
    4148:	2000075c 	.word	0x2000075c
    414c:	000040b5 	.word	0x000040b5
    4150:	00011c05 	.word	0x00011c05
    4154:	00011c49 	.word	0x00011c49

00004158 <_sercom_get_default_pad>:
 *
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
    4158:	b580      	push	{r7, lr}
    415a:	b082      	sub	sp, #8
    415c:	af00      	add	r7, sp, #0
    415e:	6078      	str	r0, [r7, #4]
    4160:	000a      	movs	r2, r1
    4162:	1cfb      	adds	r3, r7, #3
    4164:	701a      	strb	r2, [r3, #0]
	switch ((uintptr_t)sercom_module) {
    4166:	687b      	ldr	r3, [r7, #4]
    4168:	4a4d      	ldr	r2, [pc, #308]	; (42a0 <_sercom_get_default_pad+0x148>)
    416a:	4293      	cmp	r3, r2
    416c:	d03f      	beq.n	41ee <_sercom_get_default_pad+0x96>
    416e:	4a4c      	ldr	r2, [pc, #304]	; (42a0 <_sercom_get_default_pad+0x148>)
    4170:	4293      	cmp	r3, r2
    4172:	d806      	bhi.n	4182 <_sercom_get_default_pad+0x2a>
    4174:	4a4b      	ldr	r2, [pc, #300]	; (42a4 <_sercom_get_default_pad+0x14c>)
    4176:	4293      	cmp	r3, r2
    4178:	d00f      	beq.n	419a <_sercom_get_default_pad+0x42>
    417a:	4a4b      	ldr	r2, [pc, #300]	; (42a8 <_sercom_get_default_pad+0x150>)
    417c:	4293      	cmp	r3, r2
    417e:	d021      	beq.n	41c4 <_sercom_get_default_pad+0x6c>
    4180:	e089      	b.n	4296 <_sercom_get_default_pad+0x13e>
    4182:	4a4a      	ldr	r2, [pc, #296]	; (42ac <_sercom_get_default_pad+0x154>)
    4184:	4293      	cmp	r3, r2
    4186:	d100      	bne.n	418a <_sercom_get_default_pad+0x32>
    4188:	e05b      	b.n	4242 <_sercom_get_default_pad+0xea>
    418a:	4a49      	ldr	r2, [pc, #292]	; (42b0 <_sercom_get_default_pad+0x158>)
    418c:	4293      	cmp	r3, r2
    418e:	d100      	bne.n	4192 <_sercom_get_default_pad+0x3a>
    4190:	e06c      	b.n	426c <_sercom_get_default_pad+0x114>
    4192:	4a48      	ldr	r2, [pc, #288]	; (42b4 <_sercom_get_default_pad+0x15c>)
    4194:	4293      	cmp	r3, r2
    4196:	d03f      	beq.n	4218 <_sercom_get_default_pad+0xc0>
    4198:	e07d      	b.n	4296 <_sercom_get_default_pad+0x13e>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    419a:	1cfb      	adds	r3, r7, #3
    419c:	781b      	ldrb	r3, [r3, #0]
    419e:	2b01      	cmp	r3, #1
    41a0:	d00a      	beq.n	41b8 <_sercom_get_default_pad+0x60>
    41a2:	dc02      	bgt.n	41aa <_sercom_get_default_pad+0x52>
    41a4:	2b00      	cmp	r3, #0
    41a6:	d005      	beq.n	41b4 <_sercom_get_default_pad+0x5c>
    41a8:	e075      	b.n	4296 <_sercom_get_default_pad+0x13e>
    41aa:	2b02      	cmp	r3, #2
    41ac:	d006      	beq.n	41bc <_sercom_get_default_pad+0x64>
    41ae:	2b03      	cmp	r3, #3
    41b0:	d006      	beq.n	41c0 <_sercom_get_default_pad+0x68>
    41b2:	e070      	b.n	4296 <_sercom_get_default_pad+0x13e>
    41b4:	4b40      	ldr	r3, [pc, #256]	; (42b8 <_sercom_get_default_pad+0x160>)
    41b6:	e06f      	b.n	4298 <_sercom_get_default_pad+0x140>
    41b8:	4b40      	ldr	r3, [pc, #256]	; (42bc <_sercom_get_default_pad+0x164>)
    41ba:	e06d      	b.n	4298 <_sercom_get_default_pad+0x140>
    41bc:	4b40      	ldr	r3, [pc, #256]	; (42c0 <_sercom_get_default_pad+0x168>)
    41be:	e06b      	b.n	4298 <_sercom_get_default_pad+0x140>
    41c0:	4b40      	ldr	r3, [pc, #256]	; (42c4 <_sercom_get_default_pad+0x16c>)
    41c2:	e069      	b.n	4298 <_sercom_get_default_pad+0x140>
    41c4:	1cfb      	adds	r3, r7, #3
    41c6:	781b      	ldrb	r3, [r3, #0]
    41c8:	2b01      	cmp	r3, #1
    41ca:	d00a      	beq.n	41e2 <_sercom_get_default_pad+0x8a>
    41cc:	dc02      	bgt.n	41d4 <_sercom_get_default_pad+0x7c>
    41ce:	2b00      	cmp	r3, #0
    41d0:	d005      	beq.n	41de <_sercom_get_default_pad+0x86>
    41d2:	e060      	b.n	4296 <_sercom_get_default_pad+0x13e>
    41d4:	2b02      	cmp	r3, #2
    41d6:	d006      	beq.n	41e6 <_sercom_get_default_pad+0x8e>
    41d8:	2b03      	cmp	r3, #3
    41da:	d006      	beq.n	41ea <_sercom_get_default_pad+0x92>
    41dc:	e05b      	b.n	4296 <_sercom_get_default_pad+0x13e>
    41de:	2303      	movs	r3, #3
    41e0:	e05a      	b.n	4298 <_sercom_get_default_pad+0x140>
    41e2:	4b39      	ldr	r3, [pc, #228]	; (42c8 <_sercom_get_default_pad+0x170>)
    41e4:	e058      	b.n	4298 <_sercom_get_default_pad+0x140>
    41e6:	4b39      	ldr	r3, [pc, #228]	; (42cc <_sercom_get_default_pad+0x174>)
    41e8:	e056      	b.n	4298 <_sercom_get_default_pad+0x140>
    41ea:	4b39      	ldr	r3, [pc, #228]	; (42d0 <_sercom_get_default_pad+0x178>)
    41ec:	e054      	b.n	4298 <_sercom_get_default_pad+0x140>
    41ee:	1cfb      	adds	r3, r7, #3
    41f0:	781b      	ldrb	r3, [r3, #0]
    41f2:	2b01      	cmp	r3, #1
    41f4:	d00a      	beq.n	420c <_sercom_get_default_pad+0xb4>
    41f6:	dc02      	bgt.n	41fe <_sercom_get_default_pad+0xa6>
    41f8:	2b00      	cmp	r3, #0
    41fa:	d005      	beq.n	4208 <_sercom_get_default_pad+0xb0>
    41fc:	e04b      	b.n	4296 <_sercom_get_default_pad+0x13e>
    41fe:	2b02      	cmp	r3, #2
    4200:	d006      	beq.n	4210 <_sercom_get_default_pad+0xb8>
    4202:	2b03      	cmp	r3, #3
    4204:	d006      	beq.n	4214 <_sercom_get_default_pad+0xbc>
    4206:	e046      	b.n	4296 <_sercom_get_default_pad+0x13e>
    4208:	4b32      	ldr	r3, [pc, #200]	; (42d4 <_sercom_get_default_pad+0x17c>)
    420a:	e045      	b.n	4298 <_sercom_get_default_pad+0x140>
    420c:	4b32      	ldr	r3, [pc, #200]	; (42d8 <_sercom_get_default_pad+0x180>)
    420e:	e043      	b.n	4298 <_sercom_get_default_pad+0x140>
    4210:	4b32      	ldr	r3, [pc, #200]	; (42dc <_sercom_get_default_pad+0x184>)
    4212:	e041      	b.n	4298 <_sercom_get_default_pad+0x140>
    4214:	4b32      	ldr	r3, [pc, #200]	; (42e0 <_sercom_get_default_pad+0x188>)
    4216:	e03f      	b.n	4298 <_sercom_get_default_pad+0x140>
    4218:	1cfb      	adds	r3, r7, #3
    421a:	781b      	ldrb	r3, [r3, #0]
    421c:	2b01      	cmp	r3, #1
    421e:	d00a      	beq.n	4236 <_sercom_get_default_pad+0xde>
    4220:	dc02      	bgt.n	4228 <_sercom_get_default_pad+0xd0>
    4222:	2b00      	cmp	r3, #0
    4224:	d005      	beq.n	4232 <_sercom_get_default_pad+0xda>
    4226:	e036      	b.n	4296 <_sercom_get_default_pad+0x13e>
    4228:	2b02      	cmp	r3, #2
    422a:	d006      	beq.n	423a <_sercom_get_default_pad+0xe2>
    422c:	2b03      	cmp	r3, #3
    422e:	d006      	beq.n	423e <_sercom_get_default_pad+0xe6>
    4230:	e031      	b.n	4296 <_sercom_get_default_pad+0x13e>
    4232:	4b2c      	ldr	r3, [pc, #176]	; (42e4 <_sercom_get_default_pad+0x18c>)
    4234:	e030      	b.n	4298 <_sercom_get_default_pad+0x140>
    4236:	4b2c      	ldr	r3, [pc, #176]	; (42e8 <_sercom_get_default_pad+0x190>)
    4238:	e02e      	b.n	4298 <_sercom_get_default_pad+0x140>
    423a:	4b2c      	ldr	r3, [pc, #176]	; (42ec <_sercom_get_default_pad+0x194>)
    423c:	e02c      	b.n	4298 <_sercom_get_default_pad+0x140>
    423e:	4b2c      	ldr	r3, [pc, #176]	; (42f0 <_sercom_get_default_pad+0x198>)
    4240:	e02a      	b.n	4298 <_sercom_get_default_pad+0x140>
    4242:	1cfb      	adds	r3, r7, #3
    4244:	781b      	ldrb	r3, [r3, #0]
    4246:	2b01      	cmp	r3, #1
    4248:	d00a      	beq.n	4260 <_sercom_get_default_pad+0x108>
    424a:	dc02      	bgt.n	4252 <_sercom_get_default_pad+0xfa>
    424c:	2b00      	cmp	r3, #0
    424e:	d005      	beq.n	425c <_sercom_get_default_pad+0x104>
    4250:	e021      	b.n	4296 <_sercom_get_default_pad+0x13e>
    4252:	2b02      	cmp	r3, #2
    4254:	d006      	beq.n	4264 <_sercom_get_default_pad+0x10c>
    4256:	2b03      	cmp	r3, #3
    4258:	d006      	beq.n	4268 <_sercom_get_default_pad+0x110>
    425a:	e01c      	b.n	4296 <_sercom_get_default_pad+0x13e>
    425c:	4b25      	ldr	r3, [pc, #148]	; (42f4 <_sercom_get_default_pad+0x19c>)
    425e:	e01b      	b.n	4298 <_sercom_get_default_pad+0x140>
    4260:	4b25      	ldr	r3, [pc, #148]	; (42f8 <_sercom_get_default_pad+0x1a0>)
    4262:	e019      	b.n	4298 <_sercom_get_default_pad+0x140>
    4264:	4b25      	ldr	r3, [pc, #148]	; (42fc <_sercom_get_default_pad+0x1a4>)
    4266:	e017      	b.n	4298 <_sercom_get_default_pad+0x140>
    4268:	4b25      	ldr	r3, [pc, #148]	; (4300 <_sercom_get_default_pad+0x1a8>)
    426a:	e015      	b.n	4298 <_sercom_get_default_pad+0x140>
    426c:	1cfb      	adds	r3, r7, #3
    426e:	781b      	ldrb	r3, [r3, #0]
    4270:	2b01      	cmp	r3, #1
    4272:	d00a      	beq.n	428a <_sercom_get_default_pad+0x132>
    4274:	dc02      	bgt.n	427c <_sercom_get_default_pad+0x124>
    4276:	2b00      	cmp	r3, #0
    4278:	d005      	beq.n	4286 <_sercom_get_default_pad+0x12e>
    427a:	e00c      	b.n	4296 <_sercom_get_default_pad+0x13e>
    427c:	2b02      	cmp	r3, #2
    427e:	d006      	beq.n	428e <_sercom_get_default_pad+0x136>
    4280:	2b03      	cmp	r3, #3
    4282:	d006      	beq.n	4292 <_sercom_get_default_pad+0x13a>
    4284:	e007      	b.n	4296 <_sercom_get_default_pad+0x13e>
    4286:	4b1f      	ldr	r3, [pc, #124]	; (4304 <_sercom_get_default_pad+0x1ac>)
    4288:	e006      	b.n	4298 <_sercom_get_default_pad+0x140>
    428a:	4b1f      	ldr	r3, [pc, #124]	; (4308 <_sercom_get_default_pad+0x1b0>)
    428c:	e004      	b.n	4298 <_sercom_get_default_pad+0x140>
    428e:	4b1f      	ldr	r3, [pc, #124]	; (430c <_sercom_get_default_pad+0x1b4>)
    4290:	e002      	b.n	4298 <_sercom_get_default_pad+0x140>
    4292:	4b1f      	ldr	r3, [pc, #124]	; (4310 <_sercom_get_default_pad+0x1b8>)
    4294:	e000      	b.n	4298 <_sercom_get_default_pad+0x140>
	}

	Assert(false);
	return 0;
    4296:	2300      	movs	r3, #0
}
    4298:	0018      	movs	r0, r3
    429a:	46bd      	mov	sp, r7
    429c:	b002      	add	sp, #8
    429e:	bd80      	pop	{r7, pc}
    42a0:	42001000 	.word	0x42001000
    42a4:	42000800 	.word	0x42000800
    42a8:	42000c00 	.word	0x42000c00
    42ac:	42001800 	.word	0x42001800
    42b0:	42001c00 	.word	0x42001c00
    42b4:	42001400 	.word	0x42001400
    42b8:	00040003 	.word	0x00040003
    42bc:	00050003 	.word	0x00050003
    42c0:	00060003 	.word	0x00060003
    42c4:	00070003 	.word	0x00070003
    42c8:	00010003 	.word	0x00010003
    42cc:	001e0003 	.word	0x001e0003
    42d0:	001f0003 	.word	0x001f0003
    42d4:	00080003 	.word	0x00080003
    42d8:	00090003 	.word	0x00090003
    42dc:	000a0003 	.word	0x000a0003
    42e0:	000b0003 	.word	0x000b0003
    42e4:	00100003 	.word	0x00100003
    42e8:	00110003 	.word	0x00110003
    42ec:	00120003 	.word	0x00120003
    42f0:	00130003 	.word	0x00130003
    42f4:	000c0003 	.word	0x000c0003
    42f8:	000d0003 	.word	0x000d0003
    42fc:	000e0003 	.word	0x000e0003
    4300:	000f0003 	.word	0x000f0003
    4304:	00160003 	.word	0x00160003
    4308:	00170003 	.word	0x00170003
    430c:	00180003 	.word	0x00180003
    4310:	00190003 	.word	0x00190003

00004314 <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
    4314:	b590      	push	{r4, r7, lr}
    4316:	b08b      	sub	sp, #44	; 0x2c
    4318:	af00      	add	r7, sp, #0
    431a:	6078      	str	r0, [r7, #4]
	/* Save all available SERCOM instances for compare. */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
    431c:	230c      	movs	r3, #12
    431e:	18fb      	adds	r3, r7, r3
    4320:	4a0f      	ldr	r2, [pc, #60]	; (4360 <_sercom_get_sercom_inst_index+0x4c>)
    4322:	ca13      	ldmia	r2!, {r0, r1, r4}
    4324:	c313      	stmia	r3!, {r0, r1, r4}
    4326:	ca13      	ldmia	r2!, {r0, r1, r4}
    4328:	c313      	stmia	r3!, {r0, r1, r4}

	/* Find index for sercom instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    432a:	2300      	movs	r3, #0
    432c:	627b      	str	r3, [r7, #36]	; 0x24
    432e:	e00e      	b.n	434e <_sercom_get_sercom_inst_index+0x3a>
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
    4330:	230c      	movs	r3, #12
    4332:	18fb      	adds	r3, r7, r3
    4334:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    4336:	0092      	lsls	r2, r2, #2
    4338:	58d3      	ldr	r3, [r2, r3]
    433a:	1e1a      	subs	r2, r3, #0
    433c:	687b      	ldr	r3, [r7, #4]
    433e:	429a      	cmp	r2, r3
    4340:	d102      	bne.n	4348 <_sercom_get_sercom_inst_index+0x34>
			return i;
    4342:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    4344:	b2db      	uxtb	r3, r3
    4346:	e006      	b.n	4356 <_sercom_get_sercom_inst_index+0x42>
{
	/* Save all available SERCOM instances for compare. */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    4348:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    434a:	3301      	adds	r3, #1
    434c:	627b      	str	r3, [r7, #36]	; 0x24
    434e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    4350:	2b05      	cmp	r3, #5
    4352:	d9ed      	bls.n	4330 <_sercom_get_sercom_inst_index+0x1c>
		}
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
    4354:	2300      	movs	r3, #0
}
    4356:	0018      	movs	r0, r3
    4358:	46bd      	mov	sp, r7
    435a:	b00b      	add	sp, #44	; 0x2c
    435c:	bd90      	pop	{r4, r7, pc}
    435e:	46c0      	nop			; (mov r8, r8)
    4360:	000151dc 	.word	0x000151dc

00004364 <cpu_irq_save>:

static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
    4364:	b580      	push	{r7, lr}
    4366:	b082      	sub	sp, #8
    4368:	af00      	add	r7, sp, #0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    436a:	f3ef 8310 	mrs	r3, PRIMASK
    436e:	603b      	str	r3, [r7, #0]
  return(result);
    4370:	683b      	ldr	r3, [r7, #0]
	irqflags_t flags = cpu_irq_is_enabled();
    4372:	425a      	negs	r2, r3
    4374:	4153      	adcs	r3, r2
    4376:	b2db      	uxtb	r3, r3
    4378:	607b      	str	r3, [r7, #4]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    437a:	b672      	cpsid	i
    437c:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
    4380:	4b03      	ldr	r3, [pc, #12]	; (4390 <cpu_irq_save+0x2c>)
    4382:	2200      	movs	r2, #0
    4384:	701a      	strb	r2, [r3, #0]
	return flags;
    4386:	687b      	ldr	r3, [r7, #4]
}
    4388:	0018      	movs	r0, r3
    438a:	46bd      	mov	sp, r7
    438c:	b002      	add	sp, #8
    438e:	bd80      	pop	{r7, pc}
    4390:	2000017c 	.word	0x2000017c

00004394 <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
    4394:	b580      	push	{r7, lr}
    4396:	b082      	sub	sp, #8
    4398:	af00      	add	r7, sp, #0
    439a:	6078      	str	r0, [r7, #4]
	return (flags);
    439c:	687b      	ldr	r3, [r7, #4]
    439e:	1e5a      	subs	r2, r3, #1
    43a0:	4193      	sbcs	r3, r2
    43a2:	b2db      	uxtb	r3, r3
}
    43a4:	0018      	movs	r0, r3
    43a6:	46bd      	mov	sp, r7
    43a8:	b002      	add	sp, #8
    43aa:	bd80      	pop	{r7, pc}

000043ac <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
    43ac:	b580      	push	{r7, lr}
    43ae:	b082      	sub	sp, #8
    43b0:	af00      	add	r7, sp, #0
    43b2:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
    43b4:	687b      	ldr	r3, [r7, #4]
    43b6:	0018      	movs	r0, r3
    43b8:	4b06      	ldr	r3, [pc, #24]	; (43d4 <cpu_irq_restore+0x28>)
    43ba:	4798      	blx	r3
    43bc:	1e03      	subs	r3, r0, #0
    43be:	d005      	beq.n	43cc <cpu_irq_restore+0x20>
		cpu_irq_enable();
    43c0:	4b05      	ldr	r3, [pc, #20]	; (43d8 <cpu_irq_restore+0x2c>)
    43c2:	2201      	movs	r2, #1
    43c4:	701a      	strb	r2, [r3, #0]
    43c6:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    43ca:	b662      	cpsie	i
}
    43cc:	46c0      	nop			; (mov r8, r8)
    43ce:	46bd      	mov	sp, r7
    43d0:	b002      	add	sp, #8
    43d2:	bd80      	pop	{r7, pc}
    43d4:	00004395 	.word	0x00004395
    43d8:	2000017c 	.word	0x2000017c

000043dc <usb_device_attach>:
 * \brief Attach USB device to the bus
 *
 * \param module_inst Pointer to USB device module instance
 */
static inline void usb_device_attach(struct usb_module *module_inst)
{
    43dc:	b580      	push	{r7, lr}
    43de:	b082      	sub	sp, #8
    43e0:	af00      	add	r7, sp, #0
    43e2:	6078      	str	r0, [r7, #4]
	module_inst->hw->DEVICE.CTRLB.reg &= ~USB_DEVICE_CTRLB_DETACH;
    43e4:	687b      	ldr	r3, [r7, #4]
    43e6:	681a      	ldr	r2, [r3, #0]
    43e8:	687b      	ldr	r3, [r7, #4]
    43ea:	681b      	ldr	r3, [r3, #0]
    43ec:	891b      	ldrh	r3, [r3, #8]
    43ee:	b29b      	uxth	r3, r3
    43f0:	2101      	movs	r1, #1
    43f2:	438b      	bics	r3, r1
    43f4:	b29b      	uxth	r3, r3
    43f6:	8113      	strh	r3, [r2, #8]
}
    43f8:	46c0      	nop			; (mov r8, r8)
    43fa:	46bd      	mov	sp, r7
    43fc:	b002      	add	sp, #8
    43fe:	bd80      	pop	{r7, pc}

00004400 <usb_device_get_address>:
 *
 * \param module_inst Pointer to USB device module instance
 * \return USB device address value.
 */
static inline uint8_t usb_device_get_address(struct usb_module *module_inst)
{
    4400:	b580      	push	{r7, lr}
    4402:	b082      	sub	sp, #8
    4404:	af00      	add	r7, sp, #0
    4406:	6078      	str	r0, [r7, #4]
	return ((uint8_t)(module_inst->hw->DEVICE.DADD.bit.DADD));
    4408:	687b      	ldr	r3, [r7, #4]
    440a:	681b      	ldr	r3, [r3, #0]
    440c:	7a9b      	ldrb	r3, [r3, #10]
    440e:	065b      	lsls	r3, r3, #25
    4410:	0e5b      	lsrs	r3, r3, #25
    4412:	b2db      	uxtb	r3, r3
}
    4414:	0018      	movs	r0, r3
    4416:	46bd      	mov	sp, r7
    4418:	b002      	add	sp, #8
    441a:	bd80      	pop	{r7, pc}

0000441c <usb_device_set_address>:
 *
 * \param module_inst Pointer to USB device module instance
 * \param address     USB device address value
 */
static inline void usb_device_set_address(struct usb_module *module_inst, uint8_t address)
{
    441c:	b580      	push	{r7, lr}
    441e:	b082      	sub	sp, #8
    4420:	af00      	add	r7, sp, #0
    4422:	6078      	str	r0, [r7, #4]
    4424:	000a      	movs	r2, r1
    4426:	1cfb      	adds	r3, r7, #3
    4428:	701a      	strb	r2, [r3, #0]
	module_inst->hw->DEVICE.DADD.reg = USB_DEVICE_DADD_ADDEN | address;
    442a:	687b      	ldr	r3, [r7, #4]
    442c:	681b      	ldr	r3, [r3, #0]
    442e:	1cfa      	adds	r2, r7, #3
    4430:	7812      	ldrb	r2, [r2, #0]
    4432:	2180      	movs	r1, #128	; 0x80
    4434:	4249      	negs	r1, r1
    4436:	430a      	orrs	r2, r1
    4438:	b2d2      	uxtb	r2, r2
    443a:	729a      	strb	r2, [r3, #10]
}
    443c:	46c0      	nop			; (mov r8, r8)
    443e:	46bd      	mov	sp, r7
    4440:	b002      	add	sp, #8
    4442:	bd80      	pop	{r7, pc}

00004444 <usb_device_get_frame_number>:
 *
 * \param module_inst Pointer to USB device module instance
 * \return USB device frame number value.
 */
static inline uint16_t usb_device_get_frame_number(struct usb_module *module_inst)
{
    4444:	b580      	push	{r7, lr}
    4446:	b082      	sub	sp, #8
    4448:	af00      	add	r7, sp, #0
    444a:	6078      	str	r0, [r7, #4]
	return ((uint16_t)(module_inst->hw->DEVICE.FNUM.bit.FNUM));
    444c:	687b      	ldr	r3, [r7, #4]
    444e:	681b      	ldr	r3, [r3, #0]
    4450:	8a1b      	ldrh	r3, [r3, #16]
    4452:	049b      	lsls	r3, r3, #18
    4454:	0d5b      	lsrs	r3, r3, #21
    4456:	b29b      	uxth	r3, r3
}
    4458:	0018      	movs	r0, r3
    445a:	46bd      	mov	sp, r7
    445c:	b002      	add	sp, #8
    445e:	bd80      	pop	{r7, pc}

00004460 <usb_device_get_micro_frame_number>:
 *
 * \param module_inst Pointer to USB device module instance
 * \return USB device micro-frame number value.
 */
static inline uint16_t usb_device_get_micro_frame_number(struct usb_module *module_inst)
{
    4460:	b580      	push	{r7, lr}
    4462:	b082      	sub	sp, #8
    4464:	af00      	add	r7, sp, #0
    4466:	6078      	str	r0, [r7, #4]
	return ((uint16_t)(module_inst->hw->DEVICE.FNUM.reg));
    4468:	687b      	ldr	r3, [r7, #4]
    446a:	681b      	ldr	r3, [r3, #0]
    446c:	8a1b      	ldrh	r3, [r3, #16]
    446e:	b29b      	uxth	r3, r3
}
    4470:	0018      	movs	r0, r3
    4472:	46bd      	mov	sp, r7
    4474:	b002      	add	sp, #8
    4476:	bd80      	pop	{r7, pc}

00004478 <usb_device_set_lpm_mode>:
 * \param module_inst Pointer to USB device module instance
 * \param lpm_mode    LPM mode
 */
static inline void usb_device_set_lpm_mode(struct usb_module *module_inst,
		enum usb_device_lpm_mode lpm_mode)
{
    4478:	b580      	push	{r7, lr}
    447a:	b082      	sub	sp, #8
    447c:	af00      	add	r7, sp, #0
    447e:	6078      	str	r0, [r7, #4]
    4480:	000a      	movs	r2, r1
    4482:	1cfb      	adds	r3, r7, #3
    4484:	701a      	strb	r2, [r3, #0]
	module_inst->hw->DEVICE.CTRLB.bit.LPMHDSK = lpm_mode;
    4486:	687b      	ldr	r3, [r7, #4]
    4488:	681a      	ldr	r2, [r3, #0]
    448a:	1cfb      	adds	r3, r7, #3
    448c:	781b      	ldrb	r3, [r3, #0]
    448e:	2103      	movs	r1, #3
    4490:	400b      	ands	r3, r1
    4492:	b2d9      	uxtb	r1, r3
    4494:	8913      	ldrh	r3, [r2, #8]
    4496:	1c08      	adds	r0, r1, #0
    4498:	2103      	movs	r1, #3
    449a:	4001      	ands	r1, r0
    449c:	0288      	lsls	r0, r1, #10
    449e:	4905      	ldr	r1, [pc, #20]	; (44b4 <usb_device_set_lpm_mode+0x3c>)
    44a0:	400b      	ands	r3, r1
    44a2:	1c19      	adds	r1, r3, #0
    44a4:	1c03      	adds	r3, r0, #0
    44a6:	430b      	orrs	r3, r1
    44a8:	8113      	strh	r3, [r2, #8]
}
    44aa:	46c0      	nop			; (mov r8, r8)
    44ac:	46bd      	mov	sp, r7
    44ae:	b002      	add	sp, #8
    44b0:	bd80      	pop	{r7, pc}
    44b2:	46c0      	nop			; (mov r8, r8)
    44b4:	fffff3ff 	.word	0xfffff3ff

000044b8 <sleepmgr_lock_mode>:
 * not put the device to sleep in the deeper sleep modes.
 *
 * \param mode Sleep mode to lock.
 */
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
    44b8:	b580      	push	{r7, lr}
    44ba:	b084      	sub	sp, #16
    44bc:	af00      	add	r7, sp, #0
    44be:	0002      	movs	r2, r0
    44c0:	1dfb      	adds	r3, r7, #7
    44c2:	701a      	strb	r2, [r3, #0]
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
    44c4:	1dfb      	adds	r3, r7, #7
    44c6:	781b      	ldrb	r3, [r3, #0]
    44c8:	4a0c      	ldr	r2, [pc, #48]	; (44fc <sleepmgr_lock_mode+0x44>)
    44ca:	5cd3      	ldrb	r3, [r2, r3]
    44cc:	2bff      	cmp	r3, #255	; 0xff
    44ce:	d100      	bne.n	44d2 <sleepmgr_lock_mode+0x1a>
		while (true) {
			// Warning: maximum value of sleepmgr_locks buffer is no more than 255.
			// Check APP or change the data type to uint16_t.
		}
    44d0:	e7fe      	b.n	44d0 <sleepmgr_lock_mode+0x18>
	}

	// Enter a critical section
	flags = cpu_irq_save();
    44d2:	4b0b      	ldr	r3, [pc, #44]	; (4500 <sleepmgr_lock_mode+0x48>)
    44d4:	4798      	blx	r3
    44d6:	0003      	movs	r3, r0
    44d8:	60fb      	str	r3, [r7, #12]

	++sleepmgr_locks[mode];
    44da:	1dfb      	adds	r3, r7, #7
    44dc:	781b      	ldrb	r3, [r3, #0]
    44de:	4a07      	ldr	r2, [pc, #28]	; (44fc <sleepmgr_lock_mode+0x44>)
    44e0:	5cd2      	ldrb	r2, [r2, r3]
    44e2:	3201      	adds	r2, #1
    44e4:	b2d1      	uxtb	r1, r2
    44e6:	4a05      	ldr	r2, [pc, #20]	; (44fc <sleepmgr_lock_mode+0x44>)
    44e8:	54d1      	strb	r1, [r2, r3]

	// Leave the critical section
	cpu_irq_restore(flags);
    44ea:	68fb      	ldr	r3, [r7, #12]
    44ec:	0018      	movs	r0, r3
    44ee:	4b05      	ldr	r3, [pc, #20]	; (4504 <sleepmgr_lock_mode+0x4c>)
    44f0:	4798      	blx	r3
#else
	UNUSED(mode);
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
    44f2:	46c0      	nop			; (mov r8, r8)
    44f4:	46bd      	mov	sp, r7
    44f6:	b004      	add	sp, #16
    44f8:	bd80      	pop	{r7, pc}
    44fa:	46c0      	nop			; (mov r8, r8)
    44fc:	2000120c 	.word	0x2000120c
    4500:	00004365 	.word	0x00004365
    4504:	000043ad 	.word	0x000043ad

00004508 <sleepmgr_unlock_mode>:
 * manager can put the device to sleep in the deeper sleep modes.
 *
 * \param mode Sleep mode to unlock.
 */
static inline void sleepmgr_unlock_mode(enum sleepmgr_mode mode)
{
    4508:	b580      	push	{r7, lr}
    450a:	b084      	sub	sp, #16
    450c:	af00      	add	r7, sp, #0
    450e:	0002      	movs	r2, r0
    4510:	1dfb      	adds	r3, r7, #7
    4512:	701a      	strb	r2, [r3, #0]
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] == 0) {
    4514:	1dfb      	adds	r3, r7, #7
    4516:	781b      	ldrb	r3, [r3, #0]
    4518:	4a0c      	ldr	r2, [pc, #48]	; (454c <sleepmgr_unlock_mode+0x44>)
    451a:	5cd3      	ldrb	r3, [r2, r3]
    451c:	2b00      	cmp	r3, #0
    451e:	d100      	bne.n	4522 <sleepmgr_unlock_mode+0x1a>
		while (true) {
			// Warning: minimum value of sleepmgr_locks buffer is no less than 0.
			// Check APP.
		}
    4520:	e7fe      	b.n	4520 <sleepmgr_unlock_mode+0x18>
	}

	// Enter a critical section
	flags = cpu_irq_save();
    4522:	4b0b      	ldr	r3, [pc, #44]	; (4550 <sleepmgr_unlock_mode+0x48>)
    4524:	4798      	blx	r3
    4526:	0003      	movs	r3, r0
    4528:	60fb      	str	r3, [r7, #12]

	--sleepmgr_locks[mode];
    452a:	1dfb      	adds	r3, r7, #7
    452c:	781b      	ldrb	r3, [r3, #0]
    452e:	4a07      	ldr	r2, [pc, #28]	; (454c <sleepmgr_unlock_mode+0x44>)
    4530:	5cd2      	ldrb	r2, [r2, r3]
    4532:	3a01      	subs	r2, #1
    4534:	b2d1      	uxtb	r1, r2
    4536:	4a05      	ldr	r2, [pc, #20]	; (454c <sleepmgr_unlock_mode+0x44>)
    4538:	54d1      	strb	r1, [r2, r3]

	// Leave the critical section
	cpu_irq_restore(flags);
    453a:	68fb      	ldr	r3, [r7, #12]
    453c:	0018      	movs	r0, r3
    453e:	4b05      	ldr	r3, [pc, #20]	; (4554 <sleepmgr_unlock_mode+0x4c>)
    4540:	4798      	blx	r3
#else
	UNUSED(mode);
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
    4542:	46c0      	nop			; (mov r8, r8)
    4544:	46bd      	mov	sp, r7
    4546:	b004      	add	sp, #16
    4548:	bd80      	pop	{r7, pc}
    454a:	46c0      	nop			; (mov r8, r8)
    454c:	2000120c 	.word	0x2000120c
    4550:	00004365 	.word	0x00004365
    4554:	000043ad 	.word	0x000043ad

00004558 <udd_wait_clock_ready>:
#endif
#ifndef UDD_CLOCK_SOURCE
#  define UDD_CLOCK_SOURCE   SYSTEM_CLOCK_SOURCE_DFLL
#endif
static inline void udd_wait_clock_ready(void)
{
    4558:	b580      	push	{r7, lr}
    455a:	af00      	add	r7, sp, #0
#else
#define DFLL_READY_FLAG (SYSCTRL_PCLKSR_DFLLRDY | \
		SYSCTRL_PCLKSR_DFLLLCKF | SYSCTRL_PCLKSR_DFLLLCKC)

		/* In USB recovery mode the status is not checked */
		if (!(SYSCTRL->DFLLCTRL.reg & SYSCTRL_DFLLCTRL_USBCRM)) {
    455c:	4b0b      	ldr	r3, [pc, #44]	; (458c <udd_wait_clock_ready+0x34>)
    455e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    4560:	b29b      	uxth	r3, r3
    4562:	001a      	movs	r2, r3
    4564:	2320      	movs	r3, #32
    4566:	4013      	ands	r3, r2
    4568:	d107      	bne.n	457a <udd_wait_clock_ready+0x22>
			while((SYSCTRL->PCLKSR.reg & DFLL_READY_FLAG) != DFLL_READY_FLAG);
    456a:	46c0      	nop			; (mov r8, r8)
    456c:	4b07      	ldr	r3, [pc, #28]	; (458c <udd_wait_clock_ready+0x34>)
    456e:	68db      	ldr	r3, [r3, #12]
    4570:	22d0      	movs	r2, #208	; 0xd0
    4572:	4013      	ands	r3, r2
    4574:	2bd0      	cmp	r3, #208	; 0xd0
    4576:	d1f9      	bne.n	456c <udd_wait_clock_ready+0x14>
		} else {
			while((SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) != SYSCTRL_PCLKSR_DFLLRDY);
		}
	}
#endif
}
    4578:	e005      	b.n	4586 <udd_wait_clock_ready+0x2e>

		/* In USB recovery mode the status is not checked */
		if (!(SYSCTRL->DFLLCTRL.reg & SYSCTRL_DFLLCTRL_USBCRM)) {
			while((SYSCTRL->PCLKSR.reg & DFLL_READY_FLAG) != DFLL_READY_FLAG);
		} else {
			while((SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) != SYSCTRL_PCLKSR_DFLLRDY);
    457a:	46c0      	nop			; (mov r8, r8)
    457c:	4b03      	ldr	r3, [pc, #12]	; (458c <udd_wait_clock_ready+0x34>)
    457e:	68db      	ldr	r3, [r3, #12]
    4580:	2210      	movs	r2, #16
    4582:	4013      	ands	r3, r2
    4584:	d0fa      	beq.n	457c <udd_wait_clock_ready+0x24>
		}
	}
#endif
}
    4586:	46c0      	nop			; (mov r8, r8)
    4588:	46bd      	mov	sp, r7
    458a:	bd80      	pop	{r7, pc}
    458c:	40000800 	.word	0x40000800

00004590 <udd_sleep_mode>:
/** \brief Manages the sleep mode following the USB state
 *
 * \param new_state  New USB state
 */
static void udd_sleep_mode(enum udd_usb_state_enum new_state)
{
    4590:	b580      	push	{r7, lr}
    4592:	b084      	sub	sp, #16
    4594:	af00      	add	r7, sp, #0
    4596:	0002      	movs	r2, r0
    4598:	1dfb      	adds	r3, r7, #7
    459a:	701a      	strb	r2, [r3, #0]
	enum sleepmgr_mode sleep_mode[] = {
    459c:	230c      	movs	r3, #12
    459e:	18fa      	adds	r2, r7, r3
    45a0:	4b17      	ldr	r3, [pc, #92]	; (4600 <udd_sleep_mode+0x70>)
    45a2:	0010      	movs	r0, r2
    45a4:	0019      	movs	r1, r3
    45a6:	2304      	movs	r3, #4
    45a8:	001a      	movs	r2, r3
    45aa:	4b16      	ldr	r3, [pc, #88]	; (4604 <udd_sleep_mode+0x74>)
    45ac:	4798      	blx	r3
	#endif	
	};

	static enum udd_usb_state_enum udd_state = UDD_STATE_OFF;

	if (udd_state == new_state) {
    45ae:	4b16      	ldr	r3, [pc, #88]	; (4608 <udd_sleep_mode+0x78>)
    45b0:	781b      	ldrb	r3, [r3, #0]
    45b2:	1dfa      	adds	r2, r7, #7
    45b4:	7812      	ldrb	r2, [r2, #0]
    45b6:	429a      	cmp	r2, r3
    45b8:	d01d      	beq.n	45f6 <udd_sleep_mode+0x66>
		return; // No change
	}
	if (new_state != UDD_STATE_OFF) {
    45ba:	1dfb      	adds	r3, r7, #7
    45bc:	781b      	ldrb	r3, [r3, #0]
    45be:	2b00      	cmp	r3, #0
    45c0:	d007      	beq.n	45d2 <udd_sleep_mode+0x42>
		/* Lock new limit */
		sleepmgr_lock_mode(sleep_mode[new_state]);
    45c2:	1dfb      	adds	r3, r7, #7
    45c4:	781b      	ldrb	r3, [r3, #0]
    45c6:	220c      	movs	r2, #12
    45c8:	18ba      	adds	r2, r7, r2
    45ca:	5cd3      	ldrb	r3, [r2, r3]
    45cc:	0018      	movs	r0, r3
    45ce:	4b0f      	ldr	r3, [pc, #60]	; (460c <udd_sleep_mode+0x7c>)
    45d0:	4798      	blx	r3
	}
	if (udd_state != UDD_STATE_OFF) {
    45d2:	4b0d      	ldr	r3, [pc, #52]	; (4608 <udd_sleep_mode+0x78>)
    45d4:	781b      	ldrb	r3, [r3, #0]
    45d6:	2b00      	cmp	r3, #0
    45d8:	d008      	beq.n	45ec <udd_sleep_mode+0x5c>
		/* Unlock old limit */
		sleepmgr_unlock_mode(sleep_mode[udd_state]);
    45da:	4b0b      	ldr	r3, [pc, #44]	; (4608 <udd_sleep_mode+0x78>)
    45dc:	781b      	ldrb	r3, [r3, #0]
    45de:	001a      	movs	r2, r3
    45e0:	230c      	movs	r3, #12
    45e2:	18fb      	adds	r3, r7, r3
    45e4:	5c9b      	ldrb	r3, [r3, r2]
    45e6:	0018      	movs	r0, r3
    45e8:	4b09      	ldr	r3, [pc, #36]	; (4610 <udd_sleep_mode+0x80>)
    45ea:	4798      	blx	r3
	}
	udd_state = new_state;
    45ec:	4b06      	ldr	r3, [pc, #24]	; (4608 <udd_sleep_mode+0x78>)
    45ee:	1dfa      	adds	r2, r7, #7
    45f0:	7812      	ldrb	r2, [r2, #0]
    45f2:	701a      	strb	r2, [r3, #0]
    45f4:	e000      	b.n	45f8 <udd_sleep_mode+0x68>
	};

	static enum udd_usb_state_enum udd_state = UDD_STATE_OFF;

	if (udd_state == new_state) {
		return; // No change
    45f6:	46c0      	nop			; (mov r8, r8)
	if (udd_state != UDD_STATE_OFF) {
		/* Unlock old limit */
		sleepmgr_unlock_mode(sleep_mode[udd_state]);
	}
	udd_state = new_state;
}
    45f8:	46bd      	mov	sp, r7
    45fa:	b004      	add	sp, #16
    45fc:	bd80      	pop	{r7, pc}
    45fe:	46c0      	nop			; (mov r8, r8)
    4600:	000151f4 	.word	0x000151f4
    4604:	000127e7 	.word	0x000127e7
    4608:	200007dc 	.word	0x200007dc
    460c:	000044b9 	.word	0x000044b9
    4610:	00004509 	.word	0x00004509

00004614 <udd_ep_get_job>:
 * \brief     Get the detailed job by endpoint number
 * \param[in] ep  Endpoint Address
 * \retval    pointer to an udd_ep_job_t structure instance
 */
static udd_ep_job_t* udd_ep_get_job(udd_ep_id_t ep)
{
    4614:	b580      	push	{r7, lr}
    4616:	b082      	sub	sp, #8
    4618:	af00      	add	r7, sp, #0
    461a:	0002      	movs	r2, r0
    461c:	1dfb      	adds	r3, r7, #7
    461e:	701a      	strb	r2, [r3, #0]
	return &udd_ep_job[(2 * (ep & USB_EP_ADDR_MASK) + ((ep & USB_EP_DIR_IN) ? 1 : 0)) - 2];
    4620:	1dfb      	adds	r3, r7, #7
    4622:	781b      	ldrb	r3, [r3, #0]
    4624:	220f      	movs	r2, #15
    4626:	4013      	ands	r3, r2
    4628:	005b      	lsls	r3, r3, #1
    462a:	1dfa      	adds	r2, r7, #7
    462c:	7812      	ldrb	r2, [r2, #0]
    462e:	b252      	sxtb	r2, r2
    4630:	b2d2      	uxtb	r2, r2
    4632:	09d2      	lsrs	r2, r2, #7
    4634:	b2d2      	uxtb	r2, r2
    4636:	189b      	adds	r3, r3, r2
    4638:	1e9a      	subs	r2, r3, #2
    463a:	0013      	movs	r3, r2
    463c:	009b      	lsls	r3, r3, #2
    463e:	189b      	adds	r3, r3, r2
    4640:	009b      	lsls	r3, r3, #2
    4642:	4a03      	ldr	r2, [pc, #12]	; (4650 <udd_ep_get_job+0x3c>)
    4644:	189b      	adds	r3, r3, r2
}
    4646:	0018      	movs	r0, r3
    4648:	46bd      	mov	sp, r7
    464a:	b002      	add	sp, #8
    464c:	bd80      	pop	{r7, pc}
    464e:	46c0      	nop			; (mov r8, r8)
    4650:	20000764 	.word	0x20000764

00004654 <udd_ep_trans_in_next>:
/**
 * \brief     Endpoint IN process, continue to send packets or zero length packet
 * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 */
static void udd_ep_trans_in_next(void* pointer)
{
    4654:	b590      	push	{r4, r7, lr}
    4656:	b089      	sub	sp, #36	; 0x24
    4658:	af00      	add	r7, sp, #0
    465a:	6078      	str	r0, [r7, #4]
	struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parameter*)pointer;
    465c:	687b      	ldr	r3, [r7, #4]
    465e:	61bb      	str	r3, [r7, #24]
	udd_ep_id_t ep = ep_callback_para->endpoint_address;
    4660:	2317      	movs	r3, #23
    4662:	18fb      	adds	r3, r7, r3
    4664:	69ba      	ldr	r2, [r7, #24]
    4666:	7992      	ldrb	r2, [r2, #6]
    4668:	701a      	strb	r2, [r3, #0]
	uint16_t ep_size, nb_trans;
	uint16_t next_trans;
	udd_ep_id_t ep_num;
	udd_ep_job_t *ptr_job;

	ptr_job = udd_ep_get_job(ep);
    466a:	2317      	movs	r3, #23
    466c:	18fb      	adds	r3, r7, r3
    466e:	781b      	ldrb	r3, [r3, #0]
    4670:	0018      	movs	r0, r3
    4672:	4b54      	ldr	r3, [pc, #336]	; (47c4 <udd_ep_trans_in_next+0x170>)
    4674:	4798      	blx	r3
    4676:	0003      	movs	r3, r0
    4678:	613b      	str	r3, [r7, #16]
	ep_num = ep & USB_EP_ADDR_MASK;
    467a:	230f      	movs	r3, #15
    467c:	18fb      	adds	r3, r7, r3
    467e:	2217      	movs	r2, #23
    4680:	18ba      	adds	r2, r7, r2
    4682:	7812      	ldrb	r2, [r2, #0]
    4684:	210f      	movs	r1, #15
    4686:	400a      	ands	r2, r1
    4688:	701a      	strb	r2, [r3, #0]

	ep_size = ptr_job->ep_size;
    468a:	230c      	movs	r3, #12
    468c:	18fb      	adds	r3, r7, r3
    468e:	693a      	ldr	r2, [r7, #16]
    4690:	8a12      	ldrh	r2, [r2, #16]
    4692:	801a      	strh	r2, [r3, #0]
	/* Update number of data transferred */
	nb_trans = ep_callback_para->sent_bytes;
    4694:	230a      	movs	r3, #10
    4696:	18fb      	adds	r3, r7, r3
    4698:	69ba      	ldr	r2, [r7, #24]
    469a:	8852      	ldrh	r2, [r2, #2]
    469c:	801a      	strh	r2, [r3, #0]
	ptr_job->nb_trans += nb_trans;
    469e:	693b      	ldr	r3, [r7, #16]
    46a0:	68da      	ldr	r2, [r3, #12]
    46a2:	230a      	movs	r3, #10
    46a4:	18fb      	adds	r3, r7, r3
    46a6:	881b      	ldrh	r3, [r3, #0]
    46a8:	18d2      	adds	r2, r2, r3
    46aa:	693b      	ldr	r3, [r7, #16]
    46ac:	60da      	str	r2, [r3, #12]

	/* Need to send other data */
	if (ptr_job->nb_trans != ptr_job->buf_size) {
    46ae:	693b      	ldr	r3, [r7, #16]
    46b0:	68da      	ldr	r2, [r3, #12]
    46b2:	693b      	ldr	r3, [r7, #16]
    46b4:	689b      	ldr	r3, [r3, #8]
    46b6:	429a      	cmp	r2, r3
    46b8:	d054      	beq.n	4764 <udd_ep_trans_in_next+0x110>
		next_trans = ptr_job->buf_size - ptr_job->nb_trans;
    46ba:	693b      	ldr	r3, [r7, #16]
    46bc:	689b      	ldr	r3, [r3, #8]
    46be:	b299      	uxth	r1, r3
    46c0:	693b      	ldr	r3, [r7, #16]
    46c2:	68db      	ldr	r3, [r3, #12]
    46c4:	b29a      	uxth	r2, r3
    46c6:	231e      	movs	r3, #30
    46c8:	18fb      	adds	r3, r7, r3
    46ca:	1a8a      	subs	r2, r1, r2
    46cc:	801a      	strh	r2, [r3, #0]
		if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
    46ce:	231e      	movs	r3, #30
    46d0:	18fb      	adds	r3, r7, r3
    46d2:	881b      	ldrh	r3, [r3, #0]
    46d4:	4a3c      	ldr	r2, [pc, #240]	; (47c8 <udd_ep_trans_in_next+0x174>)
    46d6:	4293      	cmp	r3, r2
    46d8:	d90d      	bls.n	46f6 <udd_ep_trans_in_next+0xa2>
		/* The USB hardware support a maximum
		 * transfer size of UDD_ENDPOINT_MAX_TRANS Bytes */
			next_trans = UDD_ENDPOINT_MAX_TRANS -(UDD_ENDPOINT_MAX_TRANS % ep_size);
    46da:	230c      	movs	r3, #12
    46dc:	18fb      	adds	r3, r7, r3
    46de:	881a      	ldrh	r2, [r3, #0]
    46e0:	4839      	ldr	r0, [pc, #228]	; (47c8 <udd_ep_trans_in_next+0x174>)
    46e2:	4b3a      	ldr	r3, [pc, #232]	; (47cc <udd_ep_trans_in_next+0x178>)
    46e4:	0011      	movs	r1, r2
    46e6:	4798      	blx	r3
    46e8:	000b      	movs	r3, r1
    46ea:	b29a      	uxth	r2, r3
    46ec:	231e      	movs	r3, #30
    46ee:	18fb      	adds	r3, r7, r3
    46f0:	4935      	ldr	r1, [pc, #212]	; (47c8 <udd_ep_trans_in_next+0x174>)
    46f2:	1a8a      	subs	r2, r1, r2
    46f4:	801a      	strh	r2, [r3, #0]
		}
		/* Need ZLP, if requested and last packet is not a short packet */
		ptr_job->b_shortpacket = ptr_job->b_shortpacket && (0 == (next_trans % ep_size));
    46f6:	693b      	ldr	r3, [r7, #16]
    46f8:	7c9b      	ldrb	r3, [r3, #18]
    46fa:	2202      	movs	r2, #2
    46fc:	4013      	ands	r3, r2
    46fe:	b2db      	uxtb	r3, r3
    4700:	2b00      	cmp	r3, #0
    4702:	d00e      	beq.n	4722 <udd_ep_trans_in_next+0xce>
    4704:	231e      	movs	r3, #30
    4706:	18fa      	adds	r2, r7, r3
    4708:	230c      	movs	r3, #12
    470a:	18fb      	adds	r3, r7, r3
    470c:	8812      	ldrh	r2, [r2, #0]
    470e:	8819      	ldrh	r1, [r3, #0]
    4710:	4b2f      	ldr	r3, [pc, #188]	; (47d0 <udd_ep_trans_in_next+0x17c>)
    4712:	0010      	movs	r0, r2
    4714:	4798      	blx	r3
    4716:	000b      	movs	r3, r1
    4718:	b29b      	uxth	r3, r3
    471a:	2b00      	cmp	r3, #0
    471c:	d101      	bne.n	4722 <udd_ep_trans_in_next+0xce>
    471e:	2301      	movs	r3, #1
    4720:	e000      	b.n	4724 <udd_ep_trans_in_next+0xd0>
    4722:	2300      	movs	r3, #0
    4724:	b2db      	uxtb	r3, r3
    4726:	1c1a      	adds	r2, r3, #0
    4728:	2301      	movs	r3, #1
    472a:	4013      	ands	r3, r2
    472c:	b2da      	uxtb	r2, r3
    472e:	693b      	ldr	r3, [r7, #16]
    4730:	2101      	movs	r1, #1
    4732:	400a      	ands	r2, r1
    4734:	1890      	adds	r0, r2, r2
    4736:	7c9a      	ldrb	r2, [r3, #18]
    4738:	2102      	movs	r1, #2
    473a:	438a      	bics	r2, r1
    473c:	1c11      	adds	r1, r2, #0
    473e:	1c02      	adds	r2, r0, #0
    4740:	430a      	orrs	r2, r1
    4742:	749a      	strb	r2, [r3, #18]
		usb_device_endpoint_write_buffer_job(&usb_device,ep_num,&ptr_job->buf[ptr_job->nb_trans],next_trans);
    4744:	693b      	ldr	r3, [r7, #16]
    4746:	685a      	ldr	r2, [r3, #4]
    4748:	693b      	ldr	r3, [r7, #16]
    474a:	68db      	ldr	r3, [r3, #12]
    474c:	18d2      	adds	r2, r2, r3
    474e:	231e      	movs	r3, #30
    4750:	18fb      	adds	r3, r7, r3
    4752:	881c      	ldrh	r4, [r3, #0]
    4754:	230f      	movs	r3, #15
    4756:	18fb      	adds	r3, r7, r3
    4758:	7819      	ldrb	r1, [r3, #0]
    475a:	481e      	ldr	r0, [pc, #120]	; (47d4 <udd_ep_trans_in_next+0x180>)
    475c:	0023      	movs	r3, r4
    475e:	4c1e      	ldr	r4, [pc, #120]	; (47d8 <udd_ep_trans_in_next+0x184>)
    4760:	47a0      	blx	r4
		return;
    4762:	e02b      	b.n	47bc <udd_ep_trans_in_next+0x168>
	}

	/* Need to send a ZLP after all data transfer */
	if (ptr_job->b_shortpacket) {
    4764:	693b      	ldr	r3, [r7, #16]
    4766:	7c9b      	ldrb	r3, [r3, #18]
    4768:	2202      	movs	r2, #2
    476a:	4013      	ands	r3, r2
    476c:	b2db      	uxtb	r3, r3
    476e:	2b00      	cmp	r3, #0
    4770:	d011      	beq.n	4796 <udd_ep_trans_in_next+0x142>
		ptr_job->b_shortpacket = false;
    4772:	693b      	ldr	r3, [r7, #16]
    4774:	7c9a      	ldrb	r2, [r3, #18]
    4776:	2102      	movs	r1, #2
    4778:	438a      	bics	r2, r1
    477a:	749a      	strb	r2, [r3, #18]
		/* Start new transfer */
		usb_device_endpoint_write_buffer_job(&usb_device,ep_num,&ptr_job->buf[ptr_job->nb_trans],0);
    477c:	693b      	ldr	r3, [r7, #16]
    477e:	685a      	ldr	r2, [r3, #4]
    4780:	693b      	ldr	r3, [r7, #16]
    4782:	68db      	ldr	r3, [r3, #12]
    4784:	18d2      	adds	r2, r2, r3
    4786:	230f      	movs	r3, #15
    4788:	18fb      	adds	r3, r7, r3
    478a:	7819      	ldrb	r1, [r3, #0]
    478c:	4811      	ldr	r0, [pc, #68]	; (47d4 <udd_ep_trans_in_next+0x180>)
    478e:	2300      	movs	r3, #0
    4790:	4c11      	ldr	r4, [pc, #68]	; (47d8 <udd_ep_trans_in_next+0x184>)
    4792:	47a0      	blx	r4
		return;
    4794:	e012      	b.n	47bc <udd_ep_trans_in_next+0x168>
	}

	/* Job complete then call callback */
	ptr_job->busy = false;
    4796:	693b      	ldr	r3, [r7, #16]
    4798:	7c9a      	ldrb	r2, [r3, #18]
    479a:	2101      	movs	r1, #1
    479c:	438a      	bics	r2, r1
    479e:	749a      	strb	r2, [r3, #18]
	if (NULL != ptr_job->call_trans) {
    47a0:	693b      	ldr	r3, [r7, #16]
    47a2:	681b      	ldr	r3, [r3, #0]
    47a4:	2b00      	cmp	r3, #0
    47a6:	d009      	beq.n	47bc <udd_ep_trans_in_next+0x168>
		ptr_job->call_trans(UDD_EP_TRANSFER_OK, ptr_job->nb_trans, ep);
    47a8:	693b      	ldr	r3, [r7, #16]
    47aa:	681c      	ldr	r4, [r3, #0]
    47ac:	693b      	ldr	r3, [r7, #16]
    47ae:	68d9      	ldr	r1, [r3, #12]
    47b0:	2317      	movs	r3, #23
    47b2:	18fb      	adds	r3, r7, r3
    47b4:	781b      	ldrb	r3, [r3, #0]
    47b6:	001a      	movs	r2, r3
    47b8:	2000      	movs	r0, #0
    47ba:	47a0      	blx	r4
	}
}
    47bc:	46bd      	mov	sp, r7
    47be:	b009      	add	sp, #36	; 0x24
    47c0:	bd90      	pop	{r4, r7, pc}
    47c2:	46c0      	nop			; (mov r8, r8)
    47c4:	00004615 	.word	0x00004615
    47c8:	00001fff 	.word	0x00001fff
    47cc:	0001249d 	.word	0x0001249d
    47d0:	000122c9 	.word	0x000122c9
    47d4:	20001314 	.word	0x20001314
    47d8:	00010375 	.word	0x00010375

000047dc <udd_ep_trans_out_next>:
/**
 * \brief     Endpoint OUT process, continue to receive packets or zero length packet
 * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 */
static void udd_ep_trans_out_next(void* pointer)
{
    47dc:	b5b0      	push	{r4, r5, r7, lr}
    47de:	b088      	sub	sp, #32
    47e0:	af00      	add	r7, sp, #0
    47e2:	6078      	str	r0, [r7, #4]
	struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parameter*)pointer;
    47e4:	687b      	ldr	r3, [r7, #4]
    47e6:	61bb      	str	r3, [r7, #24]
	udd_ep_id_t ep = ep_callback_para->endpoint_address;
    47e8:	2317      	movs	r3, #23
    47ea:	18fb      	adds	r3, r7, r3
    47ec:	69ba      	ldr	r2, [r7, #24]
    47ee:	7992      	ldrb	r2, [r2, #6]
    47f0:	701a      	strb	r2, [r3, #0]
	uint16_t ep_size, nb_trans;
	uint16_t next_trans;
	udd_ep_id_t ep_num;
	udd_ep_job_t *ptr_job;

	ptr_job = udd_ep_get_job(ep);
    47f2:	2317      	movs	r3, #23
    47f4:	18fb      	adds	r3, r7, r3
    47f6:	781b      	ldrb	r3, [r3, #0]
    47f8:	0018      	movs	r0, r3
    47fa:	4b66      	ldr	r3, [pc, #408]	; (4994 <udd_ep_trans_out_next+0x1b8>)
    47fc:	4798      	blx	r3
    47fe:	0003      	movs	r3, r0
    4800:	613b      	str	r3, [r7, #16]
	ep_num = ep & USB_EP_ADDR_MASK;
    4802:	230f      	movs	r3, #15
    4804:	18fb      	adds	r3, r7, r3
    4806:	2217      	movs	r2, #23
    4808:	18ba      	adds	r2, r7, r2
    480a:	7812      	ldrb	r2, [r2, #0]
    480c:	210f      	movs	r1, #15
    480e:	400a      	ands	r2, r1
    4810:	701a      	strb	r2, [r3, #0]

	ep_size = ptr_job->ep_size;
    4812:	230c      	movs	r3, #12
    4814:	18fb      	adds	r3, r7, r3
    4816:	693a      	ldr	r2, [r7, #16]
    4818:	8a12      	ldrh	r2, [r2, #16]
    481a:	801a      	strh	r2, [r3, #0]
	/* Update number of data transferred */
	nb_trans = ep_callback_para->received_bytes;
    481c:	230a      	movs	r3, #10
    481e:	18fb      	adds	r3, r7, r3
    4820:	69ba      	ldr	r2, [r7, #24]
    4822:	8812      	ldrh	r2, [r2, #0]
    4824:	801a      	strh	r2, [r3, #0]

	/* Can be necessary to copy data receive from cache buffer to user buffer */
	if (ptr_job->b_use_out_cache_buffer) {
    4826:	693b      	ldr	r3, [r7, #16]
    4828:	7c9b      	ldrb	r3, [r3, #18]
    482a:	2204      	movs	r2, #4
    482c:	4013      	ands	r3, r2
    482e:	b2db      	uxtb	r3, r3
    4830:	2b00      	cmp	r3, #0
    4832:	d019      	beq.n	4868 <udd_ep_trans_out_next+0x8c>
		memcpy(&ptr_job->buf[ptr_job->nb_trans], udd_ep_out_cache_buffer[ep_num - 1], ptr_job->buf_size % ep_size);
    4834:	693b      	ldr	r3, [r7, #16]
    4836:	685a      	ldr	r2, [r3, #4]
    4838:	693b      	ldr	r3, [r7, #16]
    483a:	68db      	ldr	r3, [r3, #12]
    483c:	18d4      	adds	r4, r2, r3
    483e:	230f      	movs	r3, #15
    4840:	18fb      	adds	r3, r7, r3
    4842:	781b      	ldrb	r3, [r3, #0]
    4844:	3b01      	subs	r3, #1
    4846:	019a      	lsls	r2, r3, #6
    4848:	4b53      	ldr	r3, [pc, #332]	; (4998 <udd_ep_trans_out_next+0x1bc>)
    484a:	18d5      	adds	r5, r2, r3
    484c:	693b      	ldr	r3, [r7, #16]
    484e:	689a      	ldr	r2, [r3, #8]
    4850:	230c      	movs	r3, #12
    4852:	18fb      	adds	r3, r7, r3
    4854:	8819      	ldrh	r1, [r3, #0]
    4856:	4b51      	ldr	r3, [pc, #324]	; (499c <udd_ep_trans_out_next+0x1c0>)
    4858:	0010      	movs	r0, r2
    485a:	4798      	blx	r3
    485c:	000b      	movs	r3, r1
    485e:	001a      	movs	r2, r3
    4860:	0029      	movs	r1, r5
    4862:	0020      	movs	r0, r4
    4864:	4b4e      	ldr	r3, [pc, #312]	; (49a0 <udd_ep_trans_out_next+0x1c4>)
    4866:	4798      	blx	r3
	}

	/* Update number of data transferred */
	ptr_job->nb_trans += nb_trans;
    4868:	693b      	ldr	r3, [r7, #16]
    486a:	68da      	ldr	r2, [r3, #12]
    486c:	230a      	movs	r3, #10
    486e:	18fb      	adds	r3, r7, r3
    4870:	881b      	ldrh	r3, [r3, #0]
    4872:	18d2      	adds	r2, r2, r3
    4874:	693b      	ldr	r3, [r7, #16]
    4876:	60da      	str	r2, [r3, #12]
	if (ptr_job->nb_trans > ptr_job->buf_size) {
    4878:	693b      	ldr	r3, [r7, #16]
    487a:	68da      	ldr	r2, [r3, #12]
    487c:	693b      	ldr	r3, [r7, #16]
    487e:	689b      	ldr	r3, [r3, #8]
    4880:	429a      	cmp	r2, r3
    4882:	d903      	bls.n	488c <udd_ep_trans_out_next+0xb0>
		ptr_job->nb_trans = ptr_job->buf_size;
    4884:	693b      	ldr	r3, [r7, #16]
    4886:	689a      	ldr	r2, [r3, #8]
    4888:	693b      	ldr	r3, [r7, #16]
    488a:	60da      	str	r2, [r3, #12]
	}

	/* If all previous data requested are received and user buffer not full
	 * then need to receive other data */
	if ((nb_trans == ep_callback_para->out_buffer_size) && (ptr_job->nb_trans != ptr_job->buf_size)) {
    488c:	69bb      	ldr	r3, [r7, #24]
    488e:	889b      	ldrh	r3, [r3, #4]
    4890:	220a      	movs	r2, #10
    4892:	18ba      	adds	r2, r7, r2
    4894:	8812      	ldrh	r2, [r2, #0]
    4896:	429a      	cmp	r2, r3
    4898:	d165      	bne.n	4966 <udd_ep_trans_out_next+0x18a>
    489a:	693b      	ldr	r3, [r7, #16]
    489c:	68da      	ldr	r2, [r3, #12]
    489e:	693b      	ldr	r3, [r7, #16]
    48a0:	689b      	ldr	r3, [r3, #8]
    48a2:	429a      	cmp	r2, r3
    48a4:	d05f      	beq.n	4966 <udd_ep_trans_out_next+0x18a>
		next_trans = ptr_job->buf_size - ptr_job->nb_trans;
    48a6:	693b      	ldr	r3, [r7, #16]
    48a8:	689b      	ldr	r3, [r3, #8]
    48aa:	b299      	uxth	r1, r3
    48ac:	693b      	ldr	r3, [r7, #16]
    48ae:	68db      	ldr	r3, [r3, #12]
    48b0:	b29a      	uxth	r2, r3
    48b2:	231e      	movs	r3, #30
    48b4:	18fb      	adds	r3, r7, r3
    48b6:	1a8a      	subs	r2, r1, r2
    48b8:	801a      	strh	r2, [r3, #0]
		if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
    48ba:	231e      	movs	r3, #30
    48bc:	18fb      	adds	r3, r7, r3
    48be:	881b      	ldrh	r3, [r3, #0]
    48c0:	4a38      	ldr	r2, [pc, #224]	; (49a4 <udd_ep_trans_out_next+0x1c8>)
    48c2:	4293      	cmp	r3, r2
    48c4:	d90e      	bls.n	48e4 <udd_ep_trans_out_next+0x108>
		/* The USB hardware support a maximum transfer size
		 * of UDD_ENDPOINT_MAX_TRANS Bytes */
		next_trans = UDD_ENDPOINT_MAX_TRANS - (UDD_ENDPOINT_MAX_TRANS % ep_size);
    48c6:	230c      	movs	r3, #12
    48c8:	18fb      	adds	r3, r7, r3
    48ca:	881a      	ldrh	r2, [r3, #0]
    48cc:	4835      	ldr	r0, [pc, #212]	; (49a4 <udd_ep_trans_out_next+0x1c8>)
    48ce:	4b36      	ldr	r3, [pc, #216]	; (49a8 <udd_ep_trans_out_next+0x1cc>)
    48d0:	0011      	movs	r1, r2
    48d2:	4798      	blx	r3
    48d4:	000b      	movs	r3, r1
    48d6:	b29a      	uxth	r2, r3
    48d8:	231e      	movs	r3, #30
    48da:	18fb      	adds	r3, r7, r3
    48dc:	4931      	ldr	r1, [pc, #196]	; (49a4 <udd_ep_trans_out_next+0x1c8>)
    48de:	1a8a      	subs	r2, r1, r2
    48e0:	801a      	strh	r2, [r3, #0]
    48e2:	e011      	b.n	4908 <udd_ep_trans_out_next+0x12c>
		} else {
			next_trans -= next_trans % ep_size;
    48e4:	231e      	movs	r3, #30
    48e6:	18fa      	adds	r2, r7, r3
    48e8:	230c      	movs	r3, #12
    48ea:	18fb      	adds	r3, r7, r3
    48ec:	8812      	ldrh	r2, [r2, #0]
    48ee:	8819      	ldrh	r1, [r3, #0]
    48f0:	4b2a      	ldr	r3, [pc, #168]	; (499c <udd_ep_trans_out_next+0x1c0>)
    48f2:	0010      	movs	r0, r2
    48f4:	4798      	blx	r3
    48f6:	000b      	movs	r3, r1
    48f8:	b29a      	uxth	r2, r3
    48fa:	231e      	movs	r3, #30
    48fc:	18fb      	adds	r3, r7, r3
    48fe:	211e      	movs	r1, #30
    4900:	1879      	adds	r1, r7, r1
    4902:	8809      	ldrh	r1, [r1, #0]
    4904:	1a8a      	subs	r2, r1, r2
    4906:	801a      	strh	r2, [r3, #0]
		}

		if (next_trans < ep_size) {
    4908:	231e      	movs	r3, #30
    490a:	18fa      	adds	r2, r7, r3
    490c:	230c      	movs	r3, #12
    490e:	18fb      	adds	r3, r7, r3
    4910:	8812      	ldrh	r2, [r2, #0]
    4912:	881b      	ldrh	r3, [r3, #0]
    4914:	429a      	cmp	r2, r3
    4916:	d216      	bcs.n	4946 <udd_ep_trans_out_next+0x16a>
			/* Use the cache buffer for Bulk or Interrupt size endpoint */
			ptr_job->b_use_out_cache_buffer = true;
    4918:	693b      	ldr	r3, [r7, #16]
    491a:	7c9a      	ldrb	r2, [r3, #18]
    491c:	2104      	movs	r1, #4
    491e:	430a      	orrs	r2, r1
    4920:	749a      	strb	r2, [r3, #18]
			usb_device_endpoint_read_buffer_job(&usb_device,ep_num,udd_ep_out_cache_buffer[ep_num - 1],ep_size);
    4922:	230f      	movs	r3, #15
    4924:	18fb      	adds	r3, r7, r3
    4926:	781b      	ldrb	r3, [r3, #0]
    4928:	3b01      	subs	r3, #1
    492a:	019a      	lsls	r2, r3, #6
    492c:	4b1a      	ldr	r3, [pc, #104]	; (4998 <udd_ep_trans_out_next+0x1bc>)
    492e:	18d2      	adds	r2, r2, r3
    4930:	230c      	movs	r3, #12
    4932:	18fb      	adds	r3, r7, r3
    4934:	881c      	ldrh	r4, [r3, #0]
    4936:	230f      	movs	r3, #15
    4938:	18fb      	adds	r3, r7, r3
    493a:	7819      	ldrb	r1, [r3, #0]
    493c:	481b      	ldr	r0, [pc, #108]	; (49ac <udd_ep_trans_out_next+0x1d0>)
    493e:	0023      	movs	r3, r4
    4940:	4c1b      	ldr	r4, [pc, #108]	; (49b0 <udd_ep_trans_out_next+0x1d4>)
    4942:	47a0      	blx	r4
		} else {
			usb_device_endpoint_read_buffer_job(&usb_device,ep_num,&ptr_job->buf[ptr_job->nb_trans],next_trans);
		}
		return;
    4944:	e022      	b.n	498c <udd_ep_trans_out_next+0x1b0>
		if (next_trans < ep_size) {
			/* Use the cache buffer for Bulk or Interrupt size endpoint */
			ptr_job->b_use_out_cache_buffer = true;
			usb_device_endpoint_read_buffer_job(&usb_device,ep_num,udd_ep_out_cache_buffer[ep_num - 1],ep_size);
		} else {
			usb_device_endpoint_read_buffer_job(&usb_device,ep_num,&ptr_job->buf[ptr_job->nb_trans],next_trans);
    4946:	693b      	ldr	r3, [r7, #16]
    4948:	685a      	ldr	r2, [r3, #4]
    494a:	693b      	ldr	r3, [r7, #16]
    494c:	68db      	ldr	r3, [r3, #12]
    494e:	18d2      	adds	r2, r2, r3
    4950:	231e      	movs	r3, #30
    4952:	18fb      	adds	r3, r7, r3
    4954:	881c      	ldrh	r4, [r3, #0]
    4956:	230f      	movs	r3, #15
    4958:	18fb      	adds	r3, r7, r3
    495a:	7819      	ldrb	r1, [r3, #0]
    495c:	4813      	ldr	r0, [pc, #76]	; (49ac <udd_ep_trans_out_next+0x1d0>)
    495e:	0023      	movs	r3, r4
    4960:	4c13      	ldr	r4, [pc, #76]	; (49b0 <udd_ep_trans_out_next+0x1d4>)
    4962:	47a0      	blx	r4
		}
		return;
    4964:	e012      	b.n	498c <udd_ep_trans_out_next+0x1b0>
	}

	/* Job complete then call callback */
	ptr_job->busy = false;
    4966:	693b      	ldr	r3, [r7, #16]
    4968:	7c9a      	ldrb	r2, [r3, #18]
    496a:	2101      	movs	r1, #1
    496c:	438a      	bics	r2, r1
    496e:	749a      	strb	r2, [r3, #18]
	if (NULL != ptr_job->call_trans) {
    4970:	693b      	ldr	r3, [r7, #16]
    4972:	681b      	ldr	r3, [r3, #0]
    4974:	2b00      	cmp	r3, #0
    4976:	d009      	beq.n	498c <udd_ep_trans_out_next+0x1b0>
		ptr_job->call_trans(UDD_EP_TRANSFER_OK, ptr_job->nb_trans, ep);
    4978:	693b      	ldr	r3, [r7, #16]
    497a:	681c      	ldr	r4, [r3, #0]
    497c:	693b      	ldr	r3, [r7, #16]
    497e:	68d9      	ldr	r1, [r3, #12]
    4980:	2317      	movs	r3, #23
    4982:	18fb      	adds	r3, r7, r3
    4984:	781b      	ldrb	r3, [r3, #0]
    4986:	001a      	movs	r2, r3
    4988:	2000      	movs	r0, #0
    498a:	47a0      	blx	r4
	}
}
    498c:	46bd      	mov	sp, r7
    498e:	b008      	add	sp, #32
    4990:	bdb0      	pop	{r4, r5, r7, pc}
    4992:	46c0      	nop			; (mov r8, r8)
    4994:	00004615 	.word	0x00004615
    4998:	20001254 	.word	0x20001254
    499c:	000122c9 	.word	0x000122c9
    49a0:	000127e7 	.word	0x000127e7
    49a4:	00001fff 	.word	0x00001fff
    49a8:	0001249d 	.word	0x0001249d
    49ac:	20001314 	.word	0x20001314
    49b0:	00010429 	.word	0x00010429

000049b4 <udd_ep_transfer_process>:
 * \brief     Endpoint Transfer Complete callback function, to do the next transfer depends on the direction(IN or OUT)
 * \param[in] module_inst Pointer to USB module instance
 * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 */
static void udd_ep_transfer_process(struct usb_module *module_inst, void* pointer)
{
    49b4:	b580      	push	{r7, lr}
    49b6:	b084      	sub	sp, #16
    49b8:	af00      	add	r7, sp, #0
    49ba:	6078      	str	r0, [r7, #4]
    49bc:	6039      	str	r1, [r7, #0]
	struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parameter*)pointer;
    49be:	683b      	ldr	r3, [r7, #0]
    49c0:	60fb      	str	r3, [r7, #12]
	udd_ep_id_t ep = ep_callback_para->endpoint_address;
    49c2:	230b      	movs	r3, #11
    49c4:	18fb      	adds	r3, r7, r3
    49c6:	68fa      	ldr	r2, [r7, #12]
    49c8:	7992      	ldrb	r2, [r2, #6]
    49ca:	701a      	strb	r2, [r3, #0]

	if (ep & USB_EP_DIR_IN) {
    49cc:	230b      	movs	r3, #11
    49ce:	18fb      	adds	r3, r7, r3
    49d0:	781b      	ldrb	r3, [r3, #0]
    49d2:	b25b      	sxtb	r3, r3
    49d4:	2b00      	cmp	r3, #0
    49d6:	da04      	bge.n	49e2 <udd_ep_transfer_process+0x2e>
		udd_ep_trans_in_next(pointer);
    49d8:	683b      	ldr	r3, [r7, #0]
    49da:	0018      	movs	r0, r3
    49dc:	4b05      	ldr	r3, [pc, #20]	; (49f4 <udd_ep_transfer_process+0x40>)
    49de:	4798      	blx	r3
	} else {
		udd_ep_trans_out_next(pointer);
	}
}
    49e0:	e003      	b.n	49ea <udd_ep_transfer_process+0x36>
	udd_ep_id_t ep = ep_callback_para->endpoint_address;

	if (ep & USB_EP_DIR_IN) {
		udd_ep_trans_in_next(pointer);
	} else {
		udd_ep_trans_out_next(pointer);
    49e2:	683b      	ldr	r3, [r7, #0]
    49e4:	0018      	movs	r0, r3
    49e6:	4b04      	ldr	r3, [pc, #16]	; (49f8 <udd_ep_transfer_process+0x44>)
    49e8:	4798      	blx	r3
	}
}
    49ea:	46c0      	nop			; (mov r8, r8)
    49ec:	46bd      	mov	sp, r7
    49ee:	b004      	add	sp, #16
    49f0:	bd80      	pop	{r7, pc}
    49f2:	46c0      	nop			; (mov r8, r8)
    49f4:	00004655 	.word	0x00004655
    49f8:	000047dd 	.word	0x000047dd

000049fc <udd_ep_abort>:

void udd_ep_abort(udd_ep_id_t ep)
{
    49fc:	b590      	push	{r4, r7, lr}
    49fe:	b085      	sub	sp, #20
    4a00:	af00      	add	r7, sp, #0
    4a02:	0002      	movs	r2, r0
    4a04:	1dfb      	adds	r3, r7, #7
    4a06:	701a      	strb	r2, [r3, #0]
	udd_ep_job_t *ptr_job;

	usb_device_endpoint_abort_job(&usb_device, ep);
    4a08:	1dfb      	adds	r3, r7, #7
    4a0a:	781a      	ldrb	r2, [r3, #0]
    4a0c:	4b14      	ldr	r3, [pc, #80]	; (4a60 <udd_ep_abort+0x64>)
    4a0e:	0011      	movs	r1, r2
    4a10:	0018      	movs	r0, r3
    4a12:	4b14      	ldr	r3, [pc, #80]	; (4a64 <udd_ep_abort+0x68>)
    4a14:	4798      	blx	r3

	/* Job complete then call callback */
	ptr_job = udd_ep_get_job(ep);
    4a16:	1dfb      	adds	r3, r7, #7
    4a18:	781b      	ldrb	r3, [r3, #0]
    4a1a:	0018      	movs	r0, r3
    4a1c:	4b12      	ldr	r3, [pc, #72]	; (4a68 <udd_ep_abort+0x6c>)
    4a1e:	4798      	blx	r3
    4a20:	0003      	movs	r3, r0
    4a22:	60fb      	str	r3, [r7, #12]
	if (!ptr_job->busy) {
    4a24:	68fb      	ldr	r3, [r7, #12]
    4a26:	7c9b      	ldrb	r3, [r3, #18]
    4a28:	2201      	movs	r2, #1
    4a2a:	4013      	ands	r3, r2
    4a2c:	b2db      	uxtb	r3, r3
    4a2e:	2b00      	cmp	r3, #0
    4a30:	d012      	beq.n	4a58 <udd_ep_abort+0x5c>
		return;
	}
	ptr_job->busy = false;
    4a32:	68fb      	ldr	r3, [r7, #12]
    4a34:	7c9a      	ldrb	r2, [r3, #18]
    4a36:	2101      	movs	r1, #1
    4a38:	438a      	bics	r2, r1
    4a3a:	749a      	strb	r2, [r3, #18]
	if (NULL != ptr_job->call_trans) {
    4a3c:	68fb      	ldr	r3, [r7, #12]
    4a3e:	681b      	ldr	r3, [r3, #0]
    4a40:	2b00      	cmp	r3, #0
    4a42:	d00a      	beq.n	4a5a <udd_ep_abort+0x5e>
		/* It can be a Transfer or stall callback */
		ptr_job->call_trans(UDD_EP_TRANSFER_ABORT, ptr_job->nb_trans, ep);
    4a44:	68fb      	ldr	r3, [r7, #12]
    4a46:	681c      	ldr	r4, [r3, #0]
    4a48:	68fb      	ldr	r3, [r7, #12]
    4a4a:	68d9      	ldr	r1, [r3, #12]
    4a4c:	1dfb      	adds	r3, r7, #7
    4a4e:	781b      	ldrb	r3, [r3, #0]
    4a50:	001a      	movs	r2, r3
    4a52:	2001      	movs	r0, #1
    4a54:	47a0      	blx	r4
    4a56:	e000      	b.n	4a5a <udd_ep_abort+0x5e>
	usb_device_endpoint_abort_job(&usb_device, ep);

	/* Job complete then call callback */
	ptr_job = udd_ep_get_job(ep);
	if (!ptr_job->busy) {
		return;
    4a58:	46c0      	nop			; (mov r8, r8)
	ptr_job->busy = false;
	if (NULL != ptr_job->call_trans) {
		/* It can be a Transfer or stall callback */
		ptr_job->call_trans(UDD_EP_TRANSFER_ABORT, ptr_job->nb_trans, ep);
	}
}
    4a5a:	46bd      	mov	sp, r7
    4a5c:	b005      	add	sp, #20
    4a5e:	bd90      	pop	{r4, r7, pc}
    4a60:	20001314 	.word	0x20001314
    4a64:	000100f1 	.word	0x000100f1
    4a68:	00004615 	.word	0x00004615

00004a6c <udd_is_high_speed>:

bool udd_is_high_speed(void)
{
    4a6c:	b580      	push	{r7, lr}
    4a6e:	af00      	add	r7, sp, #0
#if SAMD21 || SAMR21 || SAMD11 || SAML21 || SAMDA1
	return false;
    4a70:	2300      	movs	r3, #0
#endif
}
    4a72:	0018      	movs	r0, r3
    4a74:	46bd      	mov	sp, r7
    4a76:	bd80      	pop	{r7, pc}

00004a78 <udd_get_frame_number>:

uint16_t udd_get_frame_number(void)
{
    4a78:	b580      	push	{r7, lr}
    4a7a:	af00      	add	r7, sp, #0
	return usb_device_get_frame_number(&usb_device);
    4a7c:	4b03      	ldr	r3, [pc, #12]	; (4a8c <udd_get_frame_number+0x14>)
    4a7e:	0018      	movs	r0, r3
    4a80:	4b03      	ldr	r3, [pc, #12]	; (4a90 <udd_get_frame_number+0x18>)
    4a82:	4798      	blx	r3
    4a84:	0003      	movs	r3, r0
}
    4a86:	0018      	movs	r0, r3
    4a88:	46bd      	mov	sp, r7
    4a8a:	bd80      	pop	{r7, pc}
    4a8c:	20001314 	.word	0x20001314
    4a90:	00004445 	.word	0x00004445

00004a94 <udd_get_micro_frame_number>:

uint16_t udd_get_micro_frame_number(void)
{
    4a94:	b580      	push	{r7, lr}
    4a96:	af00      	add	r7, sp, #0
	return usb_device_get_micro_frame_number(&usb_device);
    4a98:	4b03      	ldr	r3, [pc, #12]	; (4aa8 <udd_get_micro_frame_number+0x14>)
    4a9a:	0018      	movs	r0, r3
    4a9c:	4b03      	ldr	r3, [pc, #12]	; (4aac <udd_get_micro_frame_number+0x18>)
    4a9e:	4798      	blx	r3
    4aa0:	0003      	movs	r3, r0
}
    4aa2:	0018      	movs	r0, r3
    4aa4:	46bd      	mov	sp, r7
    4aa6:	bd80      	pop	{r7, pc}
    4aa8:	20001314 	.word	0x20001314
    4aac:	00004461 	.word	0x00004461

00004ab0 <udd_ep_free>:

void udd_ep_free(udd_ep_id_t ep)
{
    4ab0:	b580      	push	{r7, lr}
    4ab2:	b084      	sub	sp, #16
    4ab4:	af00      	add	r7, sp, #0
    4ab6:	0002      	movs	r2, r0
    4ab8:	1dfb      	adds	r3, r7, #7
    4aba:	701a      	strb	r2, [r3, #0]
	struct usb_device_endpoint_config config_ep;
	usb_device_endpoint_get_config_defaults(&config_ep);
    4abc:	2308      	movs	r3, #8
    4abe:	18fb      	adds	r3, r7, r3
    4ac0:	0018      	movs	r0, r3
    4ac2:	4b18      	ldr	r3, [pc, #96]	; (4b24 <udd_ep_free+0x74>)
    4ac4:	4798      	blx	r3

	uint8_t ep_num = ep & USB_EP_ADDR_MASK;
    4ac6:	230f      	movs	r3, #15
    4ac8:	18fb      	adds	r3, r7, r3
    4aca:	1dfa      	adds	r2, r7, #7
    4acc:	7812      	ldrb	r2, [r2, #0]
    4ace:	210f      	movs	r1, #15
    4ad0:	400a      	ands	r2, r1
    4ad2:	701a      	strb	r2, [r3, #0]
	udd_ep_abort(ep);
    4ad4:	1dfb      	adds	r3, r7, #7
    4ad6:	781b      	ldrb	r3, [r3, #0]
    4ad8:	0018      	movs	r0, r3
    4ada:	4b13      	ldr	r3, [pc, #76]	; (4b28 <udd_ep_free+0x78>)
    4adc:	4798      	blx	r3

	config_ep.ep_address = ep;
    4ade:	2308      	movs	r3, #8
    4ae0:	18fb      	adds	r3, r7, r3
    4ae2:	1dfa      	adds	r2, r7, #7
    4ae4:	7812      	ldrb	r2, [r2, #0]
    4ae6:	701a      	strb	r2, [r3, #0]
	config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_DISABLE;
    4ae8:	2308      	movs	r3, #8
    4aea:	18fb      	adds	r3, r7, r3
    4aec:	2200      	movs	r2, #0
    4aee:	70da      	strb	r2, [r3, #3]
	usb_device_endpoint_set_config(&usb_device, &config_ep);
    4af0:	2308      	movs	r3, #8
    4af2:	18fa      	adds	r2, r7, r3
    4af4:	4b0d      	ldr	r3, [pc, #52]	; (4b2c <udd_ep_free+0x7c>)
    4af6:	0011      	movs	r1, r2
    4af8:	0018      	movs	r0, r3
    4afa:	4b0d      	ldr	r3, [pc, #52]	; (4b30 <udd_ep_free+0x80>)
    4afc:	4798      	blx	r3
	usb_device_endpoint_unregister_callback(&usb_device,ep_num,USB_DEVICE_ENDPOINT_CALLBACK_TRCPT);
    4afe:	230f      	movs	r3, #15
    4b00:	18fb      	adds	r3, r7, r3
    4b02:	7819      	ldrb	r1, [r3, #0]
    4b04:	4b09      	ldr	r3, [pc, #36]	; (4b2c <udd_ep_free+0x7c>)
    4b06:	2200      	movs	r2, #0
    4b08:	0018      	movs	r0, r3
    4b0a:	4b0a      	ldr	r3, [pc, #40]	; (4b34 <udd_ep_free+0x84>)
    4b0c:	4798      	blx	r3
	usb_device_endpoint_disable_callback(&usb_device,ep,USB_DEVICE_ENDPOINT_CALLBACK_TRCPT);
    4b0e:	1dfb      	adds	r3, r7, #7
    4b10:	7819      	ldrb	r1, [r3, #0]
    4b12:	4b06      	ldr	r3, [pc, #24]	; (4b2c <udd_ep_free+0x7c>)
    4b14:	2200      	movs	r2, #0
    4b16:	0018      	movs	r0, r3
    4b18:	4b07      	ldr	r3, [pc, #28]	; (4b38 <udd_ep_free+0x88>)
    4b1a:	4798      	blx	r3
}
    4b1c:	46c0      	nop			; (mov r8, r8)
    4b1e:	46bd      	mov	sp, r7
    4b20:	b004      	add	sp, #16
    4b22:	bd80      	pop	{r7, pc}
    4b24:	0000fbd1 	.word	0x0000fbd1
    4b28:	000049fd 	.word	0x000049fd
    4b2c:	20001314 	.word	0x20001314
    4b30:	0000fbf9 	.word	0x0000fbf9
    4b34:	0000f819 	.word	0x0000f819
    4b38:	0000fa2d 	.word	0x0000fa2d

00004b3c <udd_ep_alloc>:

bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes, uint16_t MaxEndpointSize)
{
    4b3c:	b590      	push	{r4, r7, lr}
    4b3e:	b087      	sub	sp, #28
    4b40:	af00      	add	r7, sp, #0
    4b42:	0004      	movs	r4, r0
    4b44:	0008      	movs	r0, r1
    4b46:	0011      	movs	r1, r2
    4b48:	1dfb      	adds	r3, r7, #7
    4b4a:	1c22      	adds	r2, r4, #0
    4b4c:	701a      	strb	r2, [r3, #0]
    4b4e:	1dbb      	adds	r3, r7, #6
    4b50:	1c02      	adds	r2, r0, #0
    4b52:	701a      	strb	r2, [r3, #0]
    4b54:	1d3b      	adds	r3, r7, #4
    4b56:	1c0a      	adds	r2, r1, #0
    4b58:	801a      	strh	r2, [r3, #0]
	struct usb_device_endpoint_config config_ep;
	usb_device_endpoint_get_config_defaults(&config_ep);
    4b5a:	230c      	movs	r3, #12
    4b5c:	18fb      	adds	r3, r7, r3
    4b5e:	0018      	movs	r0, r3
    4b60:	4b58      	ldr	r3, [pc, #352]	; (4cc4 <udd_ep_alloc+0x188>)
    4b62:	4798      	blx	r3

	config_ep.ep_address = ep;
    4b64:	230c      	movs	r3, #12
    4b66:	18fb      	adds	r3, r7, r3
    4b68:	1dfa      	adds	r2, r7, #7
    4b6a:	7812      	ldrb	r2, [r2, #0]
    4b6c:	701a      	strb	r2, [r3, #0]

	if(MaxEndpointSize <= 8) {
    4b6e:	1d3b      	adds	r3, r7, #4
    4b70:	881b      	ldrh	r3, [r3, #0]
    4b72:	2b08      	cmp	r3, #8
    4b74:	d804      	bhi.n	4b80 <udd_ep_alloc+0x44>
		config_ep.ep_size = USB_ENDPOINT_8_BYTE;
    4b76:	230c      	movs	r3, #12
    4b78:	18fb      	adds	r3, r7, r3
    4b7a:	2200      	movs	r2, #0
    4b7c:	705a      	strb	r2, [r3, #1]
    4b7e:	e045      	b.n	4c0c <udd_ep_alloc+0xd0>
	} else if(MaxEndpointSize <= 16) {
    4b80:	1d3b      	adds	r3, r7, #4
    4b82:	881b      	ldrh	r3, [r3, #0]
    4b84:	2b10      	cmp	r3, #16
    4b86:	d804      	bhi.n	4b92 <udd_ep_alloc+0x56>
		config_ep.ep_size = USB_ENDPOINT_16_BYTE;
    4b88:	230c      	movs	r3, #12
    4b8a:	18fb      	adds	r3, r7, r3
    4b8c:	2201      	movs	r2, #1
    4b8e:	705a      	strb	r2, [r3, #1]
    4b90:	e03c      	b.n	4c0c <udd_ep_alloc+0xd0>
	} else if(MaxEndpointSize <= 32) {
    4b92:	1d3b      	adds	r3, r7, #4
    4b94:	881b      	ldrh	r3, [r3, #0]
    4b96:	2b20      	cmp	r3, #32
    4b98:	d804      	bhi.n	4ba4 <udd_ep_alloc+0x68>
		config_ep.ep_size = USB_ENDPOINT_32_BYTE;
    4b9a:	230c      	movs	r3, #12
    4b9c:	18fb      	adds	r3, r7, r3
    4b9e:	2202      	movs	r2, #2
    4ba0:	705a      	strb	r2, [r3, #1]
    4ba2:	e033      	b.n	4c0c <udd_ep_alloc+0xd0>
	} else if(MaxEndpointSize <= 64) {
    4ba4:	1d3b      	adds	r3, r7, #4
    4ba6:	881b      	ldrh	r3, [r3, #0]
    4ba8:	2b40      	cmp	r3, #64	; 0x40
    4baa:	d804      	bhi.n	4bb6 <udd_ep_alloc+0x7a>
		config_ep.ep_size = USB_ENDPOINT_64_BYTE;
    4bac:	230c      	movs	r3, #12
    4bae:	18fb      	adds	r3, r7, r3
    4bb0:	2203      	movs	r2, #3
    4bb2:	705a      	strb	r2, [r3, #1]
    4bb4:	e02a      	b.n	4c0c <udd_ep_alloc+0xd0>
	} else if(MaxEndpointSize <= 128) {
    4bb6:	1d3b      	adds	r3, r7, #4
    4bb8:	881b      	ldrh	r3, [r3, #0]
    4bba:	2b80      	cmp	r3, #128	; 0x80
    4bbc:	d804      	bhi.n	4bc8 <udd_ep_alloc+0x8c>
		config_ep.ep_size = USB_ENDPOINT_128_BYTE;
    4bbe:	230c      	movs	r3, #12
    4bc0:	18fb      	adds	r3, r7, r3
    4bc2:	2204      	movs	r2, #4
    4bc4:	705a      	strb	r2, [r3, #1]
    4bc6:	e021      	b.n	4c0c <udd_ep_alloc+0xd0>
	} else if(MaxEndpointSize <= 256) {
    4bc8:	1d3b      	adds	r3, r7, #4
    4bca:	881a      	ldrh	r2, [r3, #0]
    4bcc:	2380      	movs	r3, #128	; 0x80
    4bce:	005b      	lsls	r3, r3, #1
    4bd0:	429a      	cmp	r2, r3
    4bd2:	d804      	bhi.n	4bde <udd_ep_alloc+0xa2>
		config_ep.ep_size = USB_ENDPOINT_256_BYTE;
    4bd4:	230c      	movs	r3, #12
    4bd6:	18fb      	adds	r3, r7, r3
    4bd8:	2205      	movs	r2, #5
    4bda:	705a      	strb	r2, [r3, #1]
    4bdc:	e016      	b.n	4c0c <udd_ep_alloc+0xd0>
	} else if(MaxEndpointSize <= 512) {
    4bde:	1d3b      	adds	r3, r7, #4
    4be0:	881a      	ldrh	r2, [r3, #0]
    4be2:	2380      	movs	r3, #128	; 0x80
    4be4:	009b      	lsls	r3, r3, #2
    4be6:	429a      	cmp	r2, r3
    4be8:	d804      	bhi.n	4bf4 <udd_ep_alloc+0xb8>
		config_ep.ep_size = USB_ENDPOINT_512_BYTE;
    4bea:	230c      	movs	r3, #12
    4bec:	18fb      	adds	r3, r7, r3
    4bee:	2206      	movs	r2, #6
    4bf0:	705a      	strb	r2, [r3, #1]
    4bf2:	e00b      	b.n	4c0c <udd_ep_alloc+0xd0>
	} else if(MaxEndpointSize <= 1023) {
    4bf4:	1d3b      	adds	r3, r7, #4
    4bf6:	881b      	ldrh	r3, [r3, #0]
    4bf8:	4a33      	ldr	r2, [pc, #204]	; (4cc8 <udd_ep_alloc+0x18c>)
    4bfa:	4293      	cmp	r3, r2
    4bfc:	d804      	bhi.n	4c08 <udd_ep_alloc+0xcc>
		config_ep.ep_size = USB_ENDPOINT_1023_BYTE;
    4bfe:	230c      	movs	r3, #12
    4c00:	18fb      	adds	r3, r7, r3
    4c02:	2207      	movs	r2, #7
    4c04:	705a      	strb	r2, [r3, #1]
    4c06:	e001      	b.n	4c0c <udd_ep_alloc+0xd0>
	} else {
		return false;
    4c08:	2300      	movs	r3, #0
    4c0a:	e057      	b.n	4cbc <udd_ep_alloc+0x180>
	}
	udd_ep_job_t *ptr_job = udd_ep_get_job(ep);
    4c0c:	1dfb      	adds	r3, r7, #7
    4c0e:	781b      	ldrb	r3, [r3, #0]
    4c10:	0018      	movs	r0, r3
    4c12:	4b2e      	ldr	r3, [pc, #184]	; (4ccc <udd_ep_alloc+0x190>)
    4c14:	4798      	blx	r3
    4c16:	0003      	movs	r3, r0
    4c18:	617b      	str	r3, [r7, #20]
	ptr_job->ep_size = MaxEndpointSize;
    4c1a:	697b      	ldr	r3, [r7, #20]
    4c1c:	1d3a      	adds	r2, r7, #4
    4c1e:	8812      	ldrh	r2, [r2, #0]
    4c20:	821a      	strh	r2, [r3, #16]

	bmAttributes = bmAttributes & USB_EP_TYPE_MASK;
    4c22:	1dbb      	adds	r3, r7, #6
    4c24:	1dba      	adds	r2, r7, #6
    4c26:	7812      	ldrb	r2, [r2, #0]
    4c28:	2103      	movs	r1, #3
    4c2a:	400a      	ands	r2, r1
    4c2c:	701a      	strb	r2, [r3, #0]

	/* Check endpoint type */
	if(USB_EP_TYPE_ISOCHRONOUS == bmAttributes) {
    4c2e:	1dbb      	adds	r3, r7, #6
    4c30:	781b      	ldrb	r3, [r3, #0]
    4c32:	2b01      	cmp	r3, #1
    4c34:	d104      	bne.n	4c40 <udd_ep_alloc+0x104>
		config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_ISOCHRONOUS;
    4c36:	230c      	movs	r3, #12
    4c38:	18fb      	adds	r3, r7, r3
    4c3a:	2202      	movs	r2, #2
    4c3c:	70da      	strb	r2, [r3, #3]
    4c3e:	e013      	b.n	4c68 <udd_ep_alloc+0x12c>
	} else if (USB_EP_TYPE_BULK == bmAttributes) {
    4c40:	1dbb      	adds	r3, r7, #6
    4c42:	781b      	ldrb	r3, [r3, #0]
    4c44:	2b02      	cmp	r3, #2
    4c46:	d104      	bne.n	4c52 <udd_ep_alloc+0x116>
		config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_BULK;
    4c48:	230c      	movs	r3, #12
    4c4a:	18fb      	adds	r3, r7, r3
    4c4c:	2203      	movs	r2, #3
    4c4e:	70da      	strb	r2, [r3, #3]
    4c50:	e00a      	b.n	4c68 <udd_ep_alloc+0x12c>
	} else if (USB_EP_TYPE_INTERRUPT == bmAttributes) {
    4c52:	1dbb      	adds	r3, r7, #6
    4c54:	781b      	ldrb	r3, [r3, #0]
    4c56:	2b03      	cmp	r3, #3
    4c58:	d104      	bne.n	4c64 <udd_ep_alloc+0x128>
		config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_INTERRUPT;
    4c5a:	230c      	movs	r3, #12
    4c5c:	18fb      	adds	r3, r7, r3
    4c5e:	2204      	movs	r2, #4
    4c60:	70da      	strb	r2, [r3, #3]
    4c62:	e001      	b.n	4c68 <udd_ep_alloc+0x12c>
	} else {
		return false;
    4c64:	2300      	movs	r3, #0
    4c66:	e029      	b.n	4cbc <udd_ep_alloc+0x180>
	}

	uint8_t ep_num = ep & USB_EP_ADDR_MASK;
    4c68:	2313      	movs	r3, #19
    4c6a:	18fb      	adds	r3, r7, r3
    4c6c:	1dfa      	adds	r2, r7, #7
    4c6e:	7812      	ldrb	r2, [r2, #0]
    4c70:	210f      	movs	r1, #15
    4c72:	400a      	ands	r2, r1
    4c74:	701a      	strb	r2, [r3, #0]

	if (STATUS_OK != usb_device_endpoint_set_config(&usb_device, &config_ep)) {
    4c76:	230c      	movs	r3, #12
    4c78:	18fa      	adds	r2, r7, r3
    4c7a:	4b15      	ldr	r3, [pc, #84]	; (4cd0 <udd_ep_alloc+0x194>)
    4c7c:	0011      	movs	r1, r2
    4c7e:	0018      	movs	r0, r3
    4c80:	4b14      	ldr	r3, [pc, #80]	; (4cd4 <udd_ep_alloc+0x198>)
    4c82:	4798      	blx	r3
    4c84:	1e03      	subs	r3, r0, #0
    4c86:	d001      	beq.n	4c8c <udd_ep_alloc+0x150>
		return false;
    4c88:	2300      	movs	r3, #0
    4c8a:	e017      	b.n	4cbc <udd_ep_alloc+0x180>
	}
	usb_device_endpoint_register_callback(&usb_device,ep_num,USB_DEVICE_ENDPOINT_CALLBACK_TRCPT,udd_ep_transfer_process);
    4c8c:	4a12      	ldr	r2, [pc, #72]	; (4cd8 <udd_ep_alloc+0x19c>)
    4c8e:	2313      	movs	r3, #19
    4c90:	18fb      	adds	r3, r7, r3
    4c92:	7819      	ldrb	r1, [r3, #0]
    4c94:	480e      	ldr	r0, [pc, #56]	; (4cd0 <udd_ep_alloc+0x194>)
    4c96:	0013      	movs	r3, r2
    4c98:	2200      	movs	r2, #0
    4c9a:	4c10      	ldr	r4, [pc, #64]	; (4cdc <udd_ep_alloc+0x1a0>)
    4c9c:	47a0      	blx	r4
	usb_device_endpoint_enable_callback(&usb_device,ep,USB_DEVICE_ENDPOINT_CALLBACK_TRCPT);
    4c9e:	1dfb      	adds	r3, r7, #7
    4ca0:	7819      	ldrb	r1, [r3, #0]
    4ca2:	4b0b      	ldr	r3, [pc, #44]	; (4cd0 <udd_ep_alloc+0x194>)
    4ca4:	2200      	movs	r2, #0
    4ca6:	0018      	movs	r0, r3
    4ca8:	4b0d      	ldr	r3, [pc, #52]	; (4ce0 <udd_ep_alloc+0x1a4>)
    4caa:	4798      	blx	r3
	usb_device_endpoint_enable_callback(&usb_device,ep,USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL);
    4cac:	1dfb      	adds	r3, r7, #7
    4cae:	7819      	ldrb	r1, [r3, #0]
    4cb0:	4b07      	ldr	r3, [pc, #28]	; (4cd0 <udd_ep_alloc+0x194>)
    4cb2:	2201      	movs	r2, #1
    4cb4:	0018      	movs	r0, r3
    4cb6:	4b0a      	ldr	r3, [pc, #40]	; (4ce0 <udd_ep_alloc+0x1a4>)
    4cb8:	4798      	blx	r3

	return true;
    4cba:	2301      	movs	r3, #1
}
    4cbc:	0018      	movs	r0, r3
    4cbe:	46bd      	mov	sp, r7
    4cc0:	b007      	add	sp, #28
    4cc2:	bd90      	pop	{r4, r7, pc}
    4cc4:	0000fbd1 	.word	0x0000fbd1
    4cc8:	000003ff 	.word	0x000003ff
    4ccc:	00004615 	.word	0x00004615
    4cd0:	20001314 	.word	0x20001314
    4cd4:	0000fbf9 	.word	0x0000fbf9
    4cd8:	000049b5 	.word	0x000049b5
    4cdc:	0000f799 	.word	0x0000f799
    4ce0:	0000f891 	.word	0x0000f891

00004ce4 <udd_ep_is_halted>:

bool udd_ep_is_halted(udd_ep_id_t ep)
{
    4ce4:	b580      	push	{r7, lr}
    4ce6:	b082      	sub	sp, #8
    4ce8:	af00      	add	r7, sp, #0
    4cea:	0002      	movs	r2, r0
    4cec:	1dfb      	adds	r3, r7, #7
    4cee:	701a      	strb	r2, [r3, #0]
	return usb_device_endpoint_is_halted(&usb_device, ep);
    4cf0:	1dfb      	adds	r3, r7, #7
    4cf2:	781a      	ldrb	r2, [r3, #0]
    4cf4:	4b04      	ldr	r3, [pc, #16]	; (4d08 <udd_ep_is_halted+0x24>)
    4cf6:	0011      	movs	r1, r2
    4cf8:	0018      	movs	r0, r3
    4cfa:	4b04      	ldr	r3, [pc, #16]	; (4d0c <udd_ep_is_halted+0x28>)
    4cfc:	4798      	blx	r3
    4cfe:	0003      	movs	r3, r0
}
    4d00:	0018      	movs	r0, r3
    4d02:	46bd      	mov	sp, r7
    4d04:	b002      	add	sp, #8
    4d06:	bd80      	pop	{r7, pc}
    4d08:	20001314 	.word	0x20001314
    4d0c:	00010179 	.word	0x00010179

00004d10 <udd_ep_set_halt>:

bool udd_ep_set_halt(udd_ep_id_t ep)
{
    4d10:	b580      	push	{r7, lr}
    4d12:	b084      	sub	sp, #16
    4d14:	af00      	add	r7, sp, #0
    4d16:	0002      	movs	r2, r0
    4d18:	1dfb      	adds	r3, r7, #7
    4d1a:	701a      	strb	r2, [r3, #0]
	uint8_t ep_num = ep & USB_EP_ADDR_MASK;
    4d1c:	230f      	movs	r3, #15
    4d1e:	18fb      	adds	r3, r7, r3
    4d20:	1dfa      	adds	r2, r7, #7
    4d22:	7812      	ldrb	r2, [r2, #0]
    4d24:	210f      	movs	r1, #15
    4d26:	400a      	ands	r2, r1
    4d28:	701a      	strb	r2, [r3, #0]

	if (USB_DEVICE_MAX_EP < ep_num) {
    4d2a:	230f      	movs	r3, #15
    4d2c:	18fb      	adds	r3, r7, r3
    4d2e:	781b      	ldrb	r3, [r3, #0]
    4d30:	2b03      	cmp	r3, #3
    4d32:	d901      	bls.n	4d38 <udd_ep_set_halt+0x28>
		return false;
    4d34:	2300      	movs	r3, #0
    4d36:	e00c      	b.n	4d52 <udd_ep_set_halt+0x42>
	}

	usb_device_endpoint_set_halt(&usb_device, ep);
    4d38:	1dfb      	adds	r3, r7, #7
    4d3a:	781a      	ldrb	r2, [r3, #0]
    4d3c:	4b07      	ldr	r3, [pc, #28]	; (4d5c <udd_ep_set_halt+0x4c>)
    4d3e:	0011      	movs	r1, r2
    4d40:	0018      	movs	r0, r3
    4d42:	4b07      	ldr	r3, [pc, #28]	; (4d60 <udd_ep_set_halt+0x50>)
    4d44:	4798      	blx	r3

	udd_ep_abort(ep);
    4d46:	1dfb      	adds	r3, r7, #7
    4d48:	781b      	ldrb	r3, [r3, #0]
    4d4a:	0018      	movs	r0, r3
    4d4c:	4b05      	ldr	r3, [pc, #20]	; (4d64 <udd_ep_set_halt+0x54>)
    4d4e:	4798      	blx	r3
	return true;
    4d50:	2301      	movs	r3, #1
}
    4d52:	0018      	movs	r0, r3
    4d54:	46bd      	mov	sp, r7
    4d56:	b004      	add	sp, #16
    4d58:	bd80      	pop	{r7, pc}
    4d5a:	46c0      	nop			; (mov r8, r8)
    4d5c:	20001314 	.word	0x20001314
    4d60:	000101ed 	.word	0x000101ed
    4d64:	000049fd 	.word	0x000049fd

00004d68 <udd_ep_clear_halt>:

bool udd_ep_clear_halt(udd_ep_id_t ep)
{
    4d68:	b580      	push	{r7, lr}
    4d6a:	b084      	sub	sp, #16
    4d6c:	af00      	add	r7, sp, #0
    4d6e:	0002      	movs	r2, r0
    4d70:	1dfb      	adds	r3, r7, #7
    4d72:	701a      	strb	r2, [r3, #0]
	udd_ep_job_t *ptr_job;
	uint8_t ep_num = ep & USB_EP_ADDR_MASK;
    4d74:	230f      	movs	r3, #15
    4d76:	18fb      	adds	r3, r7, r3
    4d78:	1dfa      	adds	r2, r7, #7
    4d7a:	7812      	ldrb	r2, [r2, #0]
    4d7c:	210f      	movs	r1, #15
    4d7e:	400a      	ands	r2, r1
    4d80:	701a      	strb	r2, [r3, #0]

	if (USB_DEVICE_MAX_EP < ep_num) {
    4d82:	230f      	movs	r3, #15
    4d84:	18fb      	adds	r3, r7, r3
    4d86:	781b      	ldrb	r3, [r3, #0]
    4d88:	2b03      	cmp	r3, #3
    4d8a:	d901      	bls.n	4d90 <udd_ep_clear_halt+0x28>
		return false;
    4d8c:	2300      	movs	r3, #0
    4d8e:	e01d      	b.n	4dcc <udd_ep_clear_halt+0x64>
	}
	ptr_job = udd_ep_get_job(ep);
    4d90:	1dfb      	adds	r3, r7, #7
    4d92:	781b      	ldrb	r3, [r3, #0]
    4d94:	0018      	movs	r0, r3
    4d96:	4b0f      	ldr	r3, [pc, #60]	; (4dd4 <udd_ep_clear_halt+0x6c>)
    4d98:	4798      	blx	r3
    4d9a:	0003      	movs	r3, r0
    4d9c:	60bb      	str	r3, [r7, #8]

	usb_device_endpoint_clear_halt(&usb_device, ep);
    4d9e:	1dfb      	adds	r3, r7, #7
    4da0:	781a      	ldrb	r2, [r3, #0]
    4da2:	4b0d      	ldr	r3, [pc, #52]	; (4dd8 <udd_ep_clear_halt+0x70>)
    4da4:	0011      	movs	r1, r2
    4da6:	0018      	movs	r0, r3
    4da8:	4b0c      	ldr	r3, [pc, #48]	; (4ddc <udd_ep_clear_halt+0x74>)
    4daa:	4798      	blx	r3

	/* If a job is register on clear halt action then execute callback */
	if (ptr_job->busy == true) {
    4dac:	68bb      	ldr	r3, [r7, #8]
    4dae:	7c9b      	ldrb	r3, [r3, #18]
    4db0:	2201      	movs	r2, #1
    4db2:	4013      	ands	r3, r2
    4db4:	b2db      	uxtb	r3, r3
    4db6:	2b00      	cmp	r3, #0
    4db8:	d007      	beq.n	4dca <udd_ep_clear_halt+0x62>
		ptr_job->busy = false;
    4dba:	68bb      	ldr	r3, [r7, #8]
    4dbc:	7c9a      	ldrb	r2, [r3, #18]
    4dbe:	2101      	movs	r1, #1
    4dc0:	438a      	bics	r2, r1
    4dc2:	749a      	strb	r2, [r3, #18]
		ptr_job->call_nohalt();
    4dc4:	68bb      	ldr	r3, [r7, #8]
    4dc6:	681b      	ldr	r3, [r3, #0]
    4dc8:	4798      	blx	r3
	}

	return true;
    4dca:	2301      	movs	r3, #1
}
    4dcc:	0018      	movs	r0, r3
    4dce:	46bd      	mov	sp, r7
    4dd0:	b004      	add	sp, #16
    4dd2:	bd80      	pop	{r7, pc}
    4dd4:	00004615 	.word	0x00004615
    4dd8:	20001314 	.word	0x20001314
    4ddc:	00010249 	.word	0x00010249

00004de0 <udd_ctrl_stall_data>:

/**
 * \brief Control Endpoint stall sending data
 */
static void udd_ctrl_stall_data(void)
{
    4de0:	b580      	push	{r7, lr}
    4de2:	af00      	add	r7, sp, #0
	udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
    4de4:	4b07      	ldr	r3, [pc, #28]	; (4e04 <udd_ctrl_stall_data+0x24>)
    4de6:	2205      	movs	r2, #5
    4de8:	701a      	strb	r2, [r3, #0]

	usb_device_endpoint_set_halt(&usb_device, USB_EP_DIR_IN);
    4dea:	4b07      	ldr	r3, [pc, #28]	; (4e08 <udd_ctrl_stall_data+0x28>)
    4dec:	2180      	movs	r1, #128	; 0x80
    4dee:	0018      	movs	r0, r3
    4df0:	4b06      	ldr	r3, [pc, #24]	; (4e0c <udd_ctrl_stall_data+0x2c>)
    4df2:	4798      	blx	r3
	usb_device_endpoint_clear_halt(&usb_device, USB_EP_DIR_OUT);
    4df4:	4b04      	ldr	r3, [pc, #16]	; (4e08 <udd_ctrl_stall_data+0x28>)
    4df6:	2100      	movs	r1, #0
    4df8:	0018      	movs	r0, r3
    4dfa:	4b05      	ldr	r3, [pc, #20]	; (4e10 <udd_ctrl_stall_data+0x30>)
    4dfc:	4798      	blx	r3
}
    4dfe:	46c0      	nop			; (mov r8, r8)
    4e00:	46bd      	mov	sp, r7
    4e02:	bd80      	pop	{r7, pc}
    4e04:	2000075e 	.word	0x2000075e
    4e08:	20001314 	.word	0x20001314
    4e0c:	000101ed 	.word	0x000101ed
    4e10:	00010249 	.word	0x00010249

00004e14 <udd_ep_run>:

bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket, uint8_t * buf, iram_size_t buf_size, udd_callback_trans_t callback)
{
    4e14:	b590      	push	{r4, r7, lr}
    4e16:	b089      	sub	sp, #36	; 0x24
    4e18:	af00      	add	r7, sp, #0
    4e1a:	60ba      	str	r2, [r7, #8]
    4e1c:	607b      	str	r3, [r7, #4]
    4e1e:	230f      	movs	r3, #15
    4e20:	18fb      	adds	r3, r7, r3
    4e22:	1c02      	adds	r2, r0, #0
    4e24:	701a      	strb	r2, [r3, #0]
    4e26:	230e      	movs	r3, #14
    4e28:	18fb      	adds	r3, r7, r3
    4e2a:	1c0a      	adds	r2, r1, #0
    4e2c:	701a      	strb	r2, [r3, #0]
	udd_ep_id_t ep_num;
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	ep_num = ep & USB_EP_ADDR_MASK;
    4e2e:	231d      	movs	r3, #29
    4e30:	18fb      	adds	r3, r7, r3
    4e32:	220f      	movs	r2, #15
    4e34:	18ba      	adds	r2, r7, r2
    4e36:	7812      	ldrb	r2, [r2, #0]
    4e38:	210f      	movs	r1, #15
    4e3a:	400a      	ands	r2, r1
    4e3c:	701a      	strb	r2, [r3, #0]

	if ((USB_DEVICE_MAX_EP < ep_num) || (udd_ep_is_halted(ep))) {
    4e3e:	231d      	movs	r3, #29
    4e40:	18fb      	adds	r3, r7, r3
    4e42:	781b      	ldrb	r3, [r3, #0]
    4e44:	2b03      	cmp	r3, #3
    4e46:	d807      	bhi.n	4e58 <udd_ep_run+0x44>
    4e48:	230f      	movs	r3, #15
    4e4a:	18fb      	adds	r3, r7, r3
    4e4c:	781b      	ldrb	r3, [r3, #0]
    4e4e:	0018      	movs	r0, r3
    4e50:	4b9f      	ldr	r3, [pc, #636]	; (50d0 <udd_ep_run+0x2bc>)
    4e52:	4798      	blx	r3
    4e54:	1e03      	subs	r3, r0, #0
    4e56:	d001      	beq.n	4e5c <udd_ep_run+0x48>
		return false;
    4e58:	2300      	movs	r3, #0
    4e5a:	e134      	b.n	50c6 <udd_ep_run+0x2b2>
	}

	ptr_job = udd_ep_get_job(ep);
    4e5c:	230f      	movs	r3, #15
    4e5e:	18fb      	adds	r3, r7, r3
    4e60:	781b      	ldrb	r3, [r3, #0]
    4e62:	0018      	movs	r0, r3
    4e64:	4b9b      	ldr	r3, [pc, #620]	; (50d4 <udd_ep_run+0x2c0>)
    4e66:	4798      	blx	r3
    4e68:	0003      	movs	r3, r0
    4e6a:	61bb      	str	r3, [r7, #24]

	flags = cpu_irq_save();
    4e6c:	4b9a      	ldr	r3, [pc, #616]	; (50d8 <udd_ep_run+0x2c4>)
    4e6e:	4798      	blx	r3
    4e70:	0003      	movs	r3, r0
    4e72:	617b      	str	r3, [r7, #20]
	if (ptr_job->busy == true) {
    4e74:	69bb      	ldr	r3, [r7, #24]
    4e76:	7c9b      	ldrb	r3, [r3, #18]
    4e78:	2201      	movs	r2, #1
    4e7a:	4013      	ands	r3, r2
    4e7c:	b2db      	uxtb	r3, r3
    4e7e:	2b00      	cmp	r3, #0
    4e80:	d005      	beq.n	4e8e <udd_ep_run+0x7a>
		cpu_irq_restore(flags);
    4e82:	697b      	ldr	r3, [r7, #20]
    4e84:	0018      	movs	r0, r3
    4e86:	4b95      	ldr	r3, [pc, #596]	; (50dc <udd_ep_run+0x2c8>)
    4e88:	4798      	blx	r3
		return false; /* Job already on going */
    4e8a:	2300      	movs	r3, #0
    4e8c:	e11b      	b.n	50c6 <udd_ep_run+0x2b2>
	}
	ptr_job->busy = true;
    4e8e:	69bb      	ldr	r3, [r7, #24]
    4e90:	7c9a      	ldrb	r2, [r3, #18]
    4e92:	2101      	movs	r1, #1
    4e94:	430a      	orrs	r2, r1
    4e96:	749a      	strb	r2, [r3, #18]
	cpu_irq_restore(flags);
    4e98:	697b      	ldr	r3, [r7, #20]
    4e9a:	0018      	movs	r0, r3
    4e9c:	4b8f      	ldr	r3, [pc, #572]	; (50dc <udd_ep_run+0x2c8>)
    4e9e:	4798      	blx	r3

	/* No job running, set up a new one */
	ptr_job->buf = buf;
    4ea0:	69bb      	ldr	r3, [r7, #24]
    4ea2:	68ba      	ldr	r2, [r7, #8]
    4ea4:	605a      	str	r2, [r3, #4]
	ptr_job->buf_size = buf_size;
    4ea6:	69bb      	ldr	r3, [r7, #24]
    4ea8:	687a      	ldr	r2, [r7, #4]
    4eaa:	609a      	str	r2, [r3, #8]
	ptr_job->nb_trans = 0;
    4eac:	69bb      	ldr	r3, [r7, #24]
    4eae:	2200      	movs	r2, #0
    4eb0:	60da      	str	r2, [r3, #12]
	ptr_job->call_trans = callback;
    4eb2:	69bb      	ldr	r3, [r7, #24]
    4eb4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    4eb6:	601a      	str	r2, [r3, #0]
	ptr_job->b_shortpacket = b_shortpacket;
    4eb8:	69bb      	ldr	r3, [r7, #24]
    4eba:	220e      	movs	r2, #14
    4ebc:	18ba      	adds	r2, r7, r2
    4ebe:	7812      	ldrb	r2, [r2, #0]
    4ec0:	2101      	movs	r1, #1
    4ec2:	400a      	ands	r2, r1
    4ec4:	1890      	adds	r0, r2, r2
    4ec6:	7c9a      	ldrb	r2, [r3, #18]
    4ec8:	2102      	movs	r1, #2
    4eca:	438a      	bics	r2, r1
    4ecc:	1c11      	adds	r1, r2, #0
    4ece:	1c02      	adds	r2, r0, #0
    4ed0:	430a      	orrs	r2, r1
    4ed2:	749a      	strb	r2, [r3, #18]
	ptr_job->b_use_out_cache_buffer = false;
    4ed4:	69bb      	ldr	r3, [r7, #24]
    4ed6:	7c9a      	ldrb	r2, [r3, #18]
    4ed8:	2104      	movs	r1, #4
    4eda:	438a      	bics	r2, r1
    4edc:	749a      	strb	r2, [r3, #18]

	/* Initialize value to simulate a empty transfer */
	uint16_t next_trans;

	if (ep & USB_EP_DIR_IN) {
    4ede:	230f      	movs	r3, #15
    4ee0:	18fb      	adds	r3, r7, r3
    4ee2:	781b      	ldrb	r3, [r3, #0]
    4ee4:	b25b      	sxtb	r3, r3
    4ee6:	2b00      	cmp	r3, #0
    4ee8:	db00      	blt.n	4eec <udd_ep_run+0xd8>
    4eea:	e078      	b.n	4fde <udd_ep_run+0x1ca>
		if (0 != ptr_job->buf_size) {
    4eec:	69bb      	ldr	r3, [r7, #24]
    4eee:	689b      	ldr	r3, [r3, #8]
    4ef0:	2b00      	cmp	r3, #0
    4ef2:	d03f      	beq.n	4f74 <udd_ep_run+0x160>
			next_trans = ptr_job->buf_size;
    4ef4:	69bb      	ldr	r3, [r7, #24]
    4ef6:	689a      	ldr	r2, [r3, #8]
    4ef8:	231e      	movs	r3, #30
    4efa:	18fb      	adds	r3, r7, r3
    4efc:	801a      	strh	r2, [r3, #0]
			if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
    4efe:	231e      	movs	r3, #30
    4f00:	18fb      	adds	r3, r7, r3
    4f02:	881b      	ldrh	r3, [r3, #0]
    4f04:	4a76      	ldr	r2, [pc, #472]	; (50e0 <udd_ep_run+0x2cc>)
    4f06:	4293      	cmp	r3, r2
    4f08:	d90d      	bls.n	4f26 <udd_ep_run+0x112>
				next_trans = UDD_ENDPOINT_MAX_TRANS -
						(UDD_ENDPOINT_MAX_TRANS % ptr_job->ep_size);
    4f0a:	69bb      	ldr	r3, [r7, #24]
    4f0c:	8a1b      	ldrh	r3, [r3, #16]
    4f0e:	0019      	movs	r1, r3
    4f10:	4a73      	ldr	r2, [pc, #460]	; (50e0 <udd_ep_run+0x2cc>)
    4f12:	4b74      	ldr	r3, [pc, #464]	; (50e4 <udd_ep_run+0x2d0>)
    4f14:	0010      	movs	r0, r2
    4f16:	4798      	blx	r3
    4f18:	000b      	movs	r3, r1

	if (ep & USB_EP_DIR_IN) {
		if (0 != ptr_job->buf_size) {
			next_trans = ptr_job->buf_size;
			if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
				next_trans = UDD_ENDPOINT_MAX_TRANS -
    4f1a:	b29a      	uxth	r2, r3
    4f1c:	231e      	movs	r3, #30
    4f1e:	18fb      	adds	r3, r7, r3
    4f20:	496f      	ldr	r1, [pc, #444]	; (50e0 <udd_ep_run+0x2cc>)
    4f22:	1a8a      	subs	r2, r1, r2
    4f24:	801a      	strh	r2, [r3, #0]
						(UDD_ENDPOINT_MAX_TRANS % ptr_job->ep_size);
			}
			ptr_job->b_shortpacket = ptr_job->b_shortpacket &&
    4f26:	69bb      	ldr	r3, [r7, #24]
    4f28:	7c9b      	ldrb	r3, [r3, #18]
    4f2a:	2202      	movs	r2, #2
    4f2c:	4013      	ands	r3, r2
    4f2e:	b2db      	uxtb	r3, r3
    4f30:	2b00      	cmp	r3, #0
    4f32:	d00d      	beq.n	4f50 <udd_ep_run+0x13c>
					(0 == (next_trans % ptr_job->ep_size));
    4f34:	69bb      	ldr	r3, [r7, #24]
    4f36:	8a19      	ldrh	r1, [r3, #16]
    4f38:	231e      	movs	r3, #30
    4f3a:	18fb      	adds	r3, r7, r3
    4f3c:	881a      	ldrh	r2, [r3, #0]
    4f3e:	4b6a      	ldr	r3, [pc, #424]	; (50e8 <udd_ep_run+0x2d4>)
    4f40:	0010      	movs	r0, r2
    4f42:	4798      	blx	r3
    4f44:	000b      	movs	r3, r1
    4f46:	b29b      	uxth	r3, r3
			next_trans = ptr_job->buf_size;
			if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
				next_trans = UDD_ENDPOINT_MAX_TRANS -
						(UDD_ENDPOINT_MAX_TRANS % ptr_job->ep_size);
			}
			ptr_job->b_shortpacket = ptr_job->b_shortpacket &&
    4f48:	2b00      	cmp	r3, #0
    4f4a:	d101      	bne.n	4f50 <udd_ep_run+0x13c>
    4f4c:	2301      	movs	r3, #1
    4f4e:	e000      	b.n	4f52 <udd_ep_run+0x13e>
    4f50:	2300      	movs	r3, #0
    4f52:	b2db      	uxtb	r3, r3
    4f54:	1c1a      	adds	r2, r3, #0
    4f56:	2301      	movs	r3, #1
    4f58:	4013      	ands	r3, r2
    4f5a:	b2da      	uxtb	r2, r3
    4f5c:	69bb      	ldr	r3, [r7, #24]
    4f5e:	2101      	movs	r1, #1
    4f60:	400a      	ands	r2, r1
    4f62:	1890      	adds	r0, r2, r2
    4f64:	7c9a      	ldrb	r2, [r3, #18]
    4f66:	2102      	movs	r1, #2
    4f68:	438a      	bics	r2, r1
    4f6a:	1c11      	adds	r1, r2, #0
    4f6c:	1c02      	adds	r2, r0, #0
    4f6e:	430a      	orrs	r2, r1
    4f70:	749a      	strb	r2, [r3, #18]
    4f72:	e023      	b.n	4fbc <udd_ep_run+0x1a8>
					(0 == (next_trans % ptr_job->ep_size));
		} else if (true == ptr_job->b_shortpacket) {
    4f74:	69bb      	ldr	r3, [r7, #24]
    4f76:	7c9b      	ldrb	r3, [r3, #18]
    4f78:	2202      	movs	r2, #2
    4f7a:	4013      	ands	r3, r2
    4f7c:	b2db      	uxtb	r3, r3
    4f7e:	2b00      	cmp	r3, #0
    4f80:	d009      	beq.n	4f96 <udd_ep_run+0x182>
			ptr_job->b_shortpacket = false; /* avoid to send zero length packet again */
    4f82:	69bb      	ldr	r3, [r7, #24]
    4f84:	7c9a      	ldrb	r2, [r3, #18]
    4f86:	2102      	movs	r1, #2
    4f88:	438a      	bics	r2, r1
    4f8a:	749a      	strb	r2, [r3, #18]
			next_trans = 0;
    4f8c:	231e      	movs	r3, #30
    4f8e:	18fb      	adds	r3, r7, r3
    4f90:	2200      	movs	r2, #0
    4f92:	801a      	strh	r2, [r3, #0]
    4f94:	e012      	b.n	4fbc <udd_ep_run+0x1a8>
		} else {
			ptr_job->busy = false;
    4f96:	69bb      	ldr	r3, [r7, #24]
    4f98:	7c9a      	ldrb	r2, [r3, #18]
    4f9a:	2101      	movs	r1, #1
    4f9c:	438a      	bics	r2, r1
    4f9e:	749a      	strb	r2, [r3, #18]
			if (NULL != ptr_job->call_trans) {
    4fa0:	69bb      	ldr	r3, [r7, #24]
    4fa2:	681b      	ldr	r3, [r3, #0]
    4fa4:	2b00      	cmp	r3, #0
    4fa6:	d007      	beq.n	4fb8 <udd_ep_run+0x1a4>
				ptr_job->call_trans(UDD_EP_TRANSFER_OK, 0, ep);
    4fa8:	69bb      	ldr	r3, [r7, #24]
    4faa:	681b      	ldr	r3, [r3, #0]
    4fac:	220f      	movs	r2, #15
    4fae:	18ba      	adds	r2, r7, r2
    4fb0:	7812      	ldrb	r2, [r2, #0]
    4fb2:	2100      	movs	r1, #0
    4fb4:	2000      	movs	r0, #0
    4fb6:	4798      	blx	r3
			}
			return true;
    4fb8:	2301      	movs	r3, #1
    4fba:	e084      	b.n	50c6 <udd_ep_run+0x2b2>
		}
		return (STATUS_OK ==
				usb_device_endpoint_write_buffer_job(&usb_device,
    4fbc:	69bb      	ldr	r3, [r7, #24]
    4fbe:	685a      	ldr	r2, [r3, #4]
    4fc0:	231e      	movs	r3, #30
    4fc2:	18fb      	adds	r3, r7, r3
    4fc4:	881c      	ldrh	r4, [r3, #0]
    4fc6:	231d      	movs	r3, #29
    4fc8:	18fb      	adds	r3, r7, r3
    4fca:	7819      	ldrb	r1, [r3, #0]
    4fcc:	4847      	ldr	r0, [pc, #284]	; (50ec <udd_ep_run+0x2d8>)
    4fce:	0023      	movs	r3, r4
    4fd0:	4c47      	ldr	r4, [pc, #284]	; (50f0 <udd_ep_run+0x2dc>)
    4fd2:	47a0      	blx	r4
    4fd4:	0003      	movs	r3, r0
			if (NULL != ptr_job->call_trans) {
				ptr_job->call_trans(UDD_EP_TRANSFER_OK, 0, ep);
			}
			return true;
		}
		return (STATUS_OK ==
    4fd6:	425a      	negs	r2, r3
    4fd8:	4153      	adcs	r3, r2
    4fda:	b2db      	uxtb	r3, r3
    4fdc:	e073      	b.n	50c6 <udd_ep_run+0x2b2>
				usb_device_endpoint_write_buffer_job(&usb_device,
						ep_num,&ptr_job->buf[0],next_trans));
	} else {
		if (0 != ptr_job->buf_size) {
    4fde:	69bb      	ldr	r3, [r7, #24]
    4fe0:	689b      	ldr	r3, [r3, #8]
    4fe2:	2b00      	cmp	r3, #0
    4fe4:	d05d      	beq.n	50a2 <udd_ep_run+0x28e>
			next_trans = ptr_job->buf_size;
    4fe6:	69bb      	ldr	r3, [r7, #24]
    4fe8:	689a      	ldr	r2, [r3, #8]
    4fea:	231e      	movs	r3, #30
    4fec:	18fb      	adds	r3, r7, r3
    4fee:	801a      	strh	r2, [r3, #0]
			if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
    4ff0:	231e      	movs	r3, #30
    4ff2:	18fb      	adds	r3, r7, r3
    4ff4:	881b      	ldrh	r3, [r3, #0]
    4ff6:	4a3a      	ldr	r2, [pc, #232]	; (50e0 <udd_ep_run+0x2cc>)
    4ff8:	4293      	cmp	r3, r2
    4ffa:	d90e      	bls.n	501a <udd_ep_run+0x206>
				/* The USB hardware support a maximum transfer size
				 * of UDD_ENDPOINT_MAX_TRANS Bytes */
				next_trans = UDD_ENDPOINT_MAX_TRANS -
						(UDD_ENDPOINT_MAX_TRANS % ptr_job->ep_size);
    4ffc:	69bb      	ldr	r3, [r7, #24]
    4ffe:	8a1b      	ldrh	r3, [r3, #16]
    5000:	0019      	movs	r1, r3
    5002:	4a37      	ldr	r2, [pc, #220]	; (50e0 <udd_ep_run+0x2cc>)
    5004:	4b37      	ldr	r3, [pc, #220]	; (50e4 <udd_ep_run+0x2d0>)
    5006:	0010      	movs	r0, r2
    5008:	4798      	blx	r3
    500a:	000b      	movs	r3, r1
		if (0 != ptr_job->buf_size) {
			next_trans = ptr_job->buf_size;
			if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
				/* The USB hardware support a maximum transfer size
				 * of UDD_ENDPOINT_MAX_TRANS Bytes */
				next_trans = UDD_ENDPOINT_MAX_TRANS -
    500c:	b29a      	uxth	r2, r3
    500e:	231e      	movs	r3, #30
    5010:	18fb      	adds	r3, r7, r3
    5012:	4933      	ldr	r1, [pc, #204]	; (50e0 <udd_ep_run+0x2cc>)
    5014:	1a8a      	subs	r2, r1, r2
    5016:	801a      	strh	r2, [r3, #0]
    5018:	e010      	b.n	503c <udd_ep_run+0x228>
						(UDD_ENDPOINT_MAX_TRANS % ptr_job->ep_size);
			} else {
				next_trans -= next_trans % ptr_job->ep_size;
    501a:	69bb      	ldr	r3, [r7, #24]
    501c:	8a19      	ldrh	r1, [r3, #16]
    501e:	231e      	movs	r3, #30
    5020:	18fb      	adds	r3, r7, r3
    5022:	881a      	ldrh	r2, [r3, #0]
    5024:	4b30      	ldr	r3, [pc, #192]	; (50e8 <udd_ep_run+0x2d4>)
    5026:	0010      	movs	r0, r2
    5028:	4798      	blx	r3
    502a:	000b      	movs	r3, r1
    502c:	b29a      	uxth	r2, r3
    502e:	231e      	movs	r3, #30
    5030:	18fb      	adds	r3, r7, r3
    5032:	211e      	movs	r1, #30
    5034:	1879      	adds	r1, r7, r1
    5036:	8809      	ldrh	r1, [r1, #0]
    5038:	1a8a      	subs	r2, r1, r2
    503a:	801a      	strh	r2, [r3, #0]
			}
			if (next_trans < ptr_job->ep_size) {
    503c:	69bb      	ldr	r3, [r7, #24]
    503e:	8a1b      	ldrh	r3, [r3, #16]
    5040:	221e      	movs	r2, #30
    5042:	18ba      	adds	r2, r7, r2
    5044:	8812      	ldrh	r2, [r2, #0]
    5046:	429a      	cmp	r2, r3
    5048:	d21a      	bcs.n	5080 <udd_ep_run+0x26c>
				ptr_job->b_use_out_cache_buffer = true;
    504a:	69bb      	ldr	r3, [r7, #24]
    504c:	7c9a      	ldrb	r2, [r3, #18]
    504e:	2104      	movs	r1, #4
    5050:	430a      	orrs	r2, r1
    5052:	749a      	strb	r2, [r3, #18]
				return (STATUS_OK ==
						usb_device_endpoint_read_buffer_job(&usb_device, ep_num,
								udd_ep_out_cache_buffer[ep_num - 1],
    5054:	231d      	movs	r3, #29
    5056:	18fb      	adds	r3, r7, r3
    5058:	781b      	ldrb	r3, [r3, #0]
    505a:	3b01      	subs	r3, #1
    505c:	019a      	lsls	r2, r3, #6
    505e:	4b25      	ldr	r3, [pc, #148]	; (50f4 <udd_ep_run+0x2e0>)
    5060:	18d2      	adds	r2, r2, r3
								ptr_job->ep_size));
    5062:	69bb      	ldr	r3, [r7, #24]
    5064:	8a1b      	ldrh	r3, [r3, #16]
				next_trans -= next_trans % ptr_job->ep_size;
			}
			if (next_trans < ptr_job->ep_size) {
				ptr_job->b_use_out_cache_buffer = true;
				return (STATUS_OK ==
						usb_device_endpoint_read_buffer_job(&usb_device, ep_num,
    5066:	001c      	movs	r4, r3
    5068:	231d      	movs	r3, #29
    506a:	18fb      	adds	r3, r7, r3
    506c:	7819      	ldrb	r1, [r3, #0]
    506e:	481f      	ldr	r0, [pc, #124]	; (50ec <udd_ep_run+0x2d8>)
    5070:	0023      	movs	r3, r4
    5072:	4c21      	ldr	r4, [pc, #132]	; (50f8 <udd_ep_run+0x2e4>)
    5074:	47a0      	blx	r4
    5076:	0003      	movs	r3, r0
			} else {
				next_trans -= next_trans % ptr_job->ep_size;
			}
			if (next_trans < ptr_job->ep_size) {
				ptr_job->b_use_out_cache_buffer = true;
				return (STATUS_OK ==
    5078:	425a      	negs	r2, r3
    507a:	4153      	adcs	r3, r2
    507c:	b2db      	uxtb	r3, r3
    507e:	e022      	b.n	50c6 <udd_ep_run+0x2b2>
						usb_device_endpoint_read_buffer_job(&usb_device, ep_num,
								udd_ep_out_cache_buffer[ep_num - 1],
								ptr_job->ep_size));
			} else {
				return (STATUS_OK ==
						usb_device_endpoint_read_buffer_job(&usb_device, ep_num,
    5080:	69bb      	ldr	r3, [r7, #24]
    5082:	685a      	ldr	r2, [r3, #4]
    5084:	231e      	movs	r3, #30
    5086:	18fb      	adds	r3, r7, r3
    5088:	881c      	ldrh	r4, [r3, #0]
    508a:	231d      	movs	r3, #29
    508c:	18fb      	adds	r3, r7, r3
    508e:	7819      	ldrb	r1, [r3, #0]
    5090:	4816      	ldr	r0, [pc, #88]	; (50ec <udd_ep_run+0x2d8>)
    5092:	0023      	movs	r3, r4
    5094:	4c18      	ldr	r4, [pc, #96]	; (50f8 <udd_ep_run+0x2e4>)
    5096:	47a0      	blx	r4
    5098:	0003      	movs	r3, r0
				return (STATUS_OK ==
						usb_device_endpoint_read_buffer_job(&usb_device, ep_num,
								udd_ep_out_cache_buffer[ep_num - 1],
								ptr_job->ep_size));
			} else {
				return (STATUS_OK ==
    509a:	425a      	negs	r2, r3
    509c:	4153      	adcs	r3, r2
    509e:	b2db      	uxtb	r3, r3
    50a0:	e011      	b.n	50c6 <udd_ep_run+0x2b2>
						usb_device_endpoint_read_buffer_job(&usb_device, ep_num,
								&ptr_job->buf[0],next_trans));
			}
		} else {
			ptr_job->busy = false;
    50a2:	69bb      	ldr	r3, [r7, #24]
    50a4:	7c9a      	ldrb	r2, [r3, #18]
    50a6:	2101      	movs	r1, #1
    50a8:	438a      	bics	r2, r1
    50aa:	749a      	strb	r2, [r3, #18]
			if (NULL != ptr_job->call_trans) {
    50ac:	69bb      	ldr	r3, [r7, #24]
    50ae:	681b      	ldr	r3, [r3, #0]
    50b0:	2b00      	cmp	r3, #0
    50b2:	d007      	beq.n	50c4 <udd_ep_run+0x2b0>
				ptr_job->call_trans(UDD_EP_TRANSFER_OK, 0, ep);
    50b4:	69bb      	ldr	r3, [r7, #24]
    50b6:	681b      	ldr	r3, [r3, #0]
    50b8:	220f      	movs	r2, #15
    50ba:	18ba      	adds	r2, r7, r2
    50bc:	7812      	ldrb	r2, [r2, #0]
    50be:	2100      	movs	r1, #0
    50c0:	2000      	movs	r0, #0
    50c2:	4798      	blx	r3
			}
			return true;
    50c4:	2301      	movs	r3, #1
		}
	}
}
    50c6:	0018      	movs	r0, r3
    50c8:	46bd      	mov	sp, r7
    50ca:	b009      	add	sp, #36	; 0x24
    50cc:	bd90      	pop	{r4, r7, pc}
    50ce:	46c0      	nop			; (mov r8, r8)
    50d0:	00004ce5 	.word	0x00004ce5
    50d4:	00004615 	.word	0x00004615
    50d8:	00004365 	.word	0x00004365
    50dc:	000043ad 	.word	0x000043ad
    50e0:	00001fff 	.word	0x00001fff
    50e4:	0001249d 	.word	0x0001249d
    50e8:	000122c9 	.word	0x000122c9
    50ec:	20001314 	.word	0x20001314
    50f0:	00010375 	.word	0x00010375
    50f4:	20001254 	.word	0x20001254
    50f8:	00010429 	.word	0x00010429

000050fc <udd_set_address>:

void udd_set_address(uint8_t address)
{
    50fc:	b580      	push	{r7, lr}
    50fe:	b082      	sub	sp, #8
    5100:	af00      	add	r7, sp, #0
    5102:	0002      	movs	r2, r0
    5104:	1dfb      	adds	r3, r7, #7
    5106:	701a      	strb	r2, [r3, #0]
	usb_device_set_address(&usb_device,address);
    5108:	1dfb      	adds	r3, r7, #7
    510a:	781a      	ldrb	r2, [r3, #0]
    510c:	4b04      	ldr	r3, [pc, #16]	; (5120 <udd_set_address+0x24>)
    510e:	0011      	movs	r1, r2
    5110:	0018      	movs	r0, r3
    5112:	4b04      	ldr	r3, [pc, #16]	; (5124 <udd_set_address+0x28>)
    5114:	4798      	blx	r3
}
    5116:	46c0      	nop			; (mov r8, r8)
    5118:	46bd      	mov	sp, r7
    511a:	b002      	add	sp, #8
    511c:	bd80      	pop	{r7, pc}
    511e:	46c0      	nop			; (mov r8, r8)
    5120:	20001314 	.word	0x20001314
    5124:	0000441d 	.word	0x0000441d

00005128 <udd_getaddress>:

uint8_t udd_getaddress(void)
{
    5128:	b580      	push	{r7, lr}
    512a:	af00      	add	r7, sp, #0
	return usb_device_get_address(&usb_device);
    512c:	4b03      	ldr	r3, [pc, #12]	; (513c <udd_getaddress+0x14>)
    512e:	0018      	movs	r0, r3
    5130:	4b03      	ldr	r3, [pc, #12]	; (5140 <udd_getaddress+0x18>)
    5132:	4798      	blx	r3
    5134:	0003      	movs	r3, r0
}
    5136:	0018      	movs	r0, r3
    5138:	46bd      	mov	sp, r7
    513a:	bd80      	pop	{r7, pc}
    513c:	20001314 	.word	0x20001314
    5140:	00004401 	.word	0x00004401

00005144 <udd_set_setup_payload>:
		usb_device_send_remote_wake_up(&usb_device);
	}
}

void udd_set_setup_payload( uint8_t *payload, uint16_t payload_size )
{
    5144:	b580      	push	{r7, lr}
    5146:	b082      	sub	sp, #8
    5148:	af00      	add	r7, sp, #0
    514a:	6078      	str	r0, [r7, #4]
    514c:	000a      	movs	r2, r1
    514e:	1cbb      	adds	r3, r7, #2
    5150:	801a      	strh	r2, [r3, #0]
	udd_g_ctrlreq.payload = payload;
    5152:	4b05      	ldr	r3, [pc, #20]	; (5168 <udd_set_setup_payload+0x24>)
    5154:	687a      	ldr	r2, [r7, #4]
    5156:	609a      	str	r2, [r3, #8]
	udd_g_ctrlreq.payload_size = payload_size;
    5158:	4b03      	ldr	r3, [pc, #12]	; (5168 <udd_set_setup_payload+0x24>)
    515a:	1cba      	adds	r2, r7, #2
    515c:	8812      	ldrh	r2, [r2, #0]
    515e:	819a      	strh	r2, [r3, #12]
}
    5160:	46c0      	nop			; (mov r8, r8)
    5162:	46bd      	mov	sp, r7
    5164:	b002      	add	sp, #8
    5166:	bd80      	pop	{r7, pc}
    5168:	2000147c 	.word	0x2000147c

0000516c <udd_ctrl_fetch_ram>:

/**
 * \brief Control Endpoint translate the data in buffer into Device Request Struct
 */
static void udd_ctrl_fetch_ram(void)
{
    516c:	b580      	push	{r7, lr}
    516e:	af00      	add	r7, sp, #0
	udd_g_ctrlreq.req.bmRequestType = udd_ctrl_buffer[0];
    5170:	4b17      	ldr	r3, [pc, #92]	; (51d0 <udd_ctrl_fetch_ram+0x64>)
    5172:	781a      	ldrb	r2, [r3, #0]
    5174:	4b17      	ldr	r3, [pc, #92]	; (51d4 <udd_ctrl_fetch_ram+0x68>)
    5176:	701a      	strb	r2, [r3, #0]
	udd_g_ctrlreq.req.bRequest = udd_ctrl_buffer[1];
    5178:	4b15      	ldr	r3, [pc, #84]	; (51d0 <udd_ctrl_fetch_ram+0x64>)
    517a:	785a      	ldrb	r2, [r3, #1]
    517c:	4b15      	ldr	r3, [pc, #84]	; (51d4 <udd_ctrl_fetch_ram+0x68>)
    517e:	705a      	strb	r2, [r3, #1]
	udd_g_ctrlreq.req.wValue = ((uint16_t)(udd_ctrl_buffer[3]) << 8) + udd_ctrl_buffer[2];
    5180:	4b13      	ldr	r3, [pc, #76]	; (51d0 <udd_ctrl_fetch_ram+0x64>)
    5182:	78db      	ldrb	r3, [r3, #3]
    5184:	b29b      	uxth	r3, r3
    5186:	021b      	lsls	r3, r3, #8
    5188:	b29a      	uxth	r2, r3
    518a:	4b11      	ldr	r3, [pc, #68]	; (51d0 <udd_ctrl_fetch_ram+0x64>)
    518c:	789b      	ldrb	r3, [r3, #2]
    518e:	b29b      	uxth	r3, r3
    5190:	18d3      	adds	r3, r2, r3
    5192:	b29a      	uxth	r2, r3
    5194:	4b0f      	ldr	r3, [pc, #60]	; (51d4 <udd_ctrl_fetch_ram+0x68>)
    5196:	805a      	strh	r2, [r3, #2]
	udd_g_ctrlreq.req.wIndex = ((uint16_t)(udd_ctrl_buffer[5]) << 8) + udd_ctrl_buffer[4];
    5198:	4b0d      	ldr	r3, [pc, #52]	; (51d0 <udd_ctrl_fetch_ram+0x64>)
    519a:	795b      	ldrb	r3, [r3, #5]
    519c:	b29b      	uxth	r3, r3
    519e:	021b      	lsls	r3, r3, #8
    51a0:	b29a      	uxth	r2, r3
    51a2:	4b0b      	ldr	r3, [pc, #44]	; (51d0 <udd_ctrl_fetch_ram+0x64>)
    51a4:	791b      	ldrb	r3, [r3, #4]
    51a6:	b29b      	uxth	r3, r3
    51a8:	18d3      	adds	r3, r2, r3
    51aa:	b29a      	uxth	r2, r3
    51ac:	4b09      	ldr	r3, [pc, #36]	; (51d4 <udd_ctrl_fetch_ram+0x68>)
    51ae:	809a      	strh	r2, [r3, #4]
	udd_g_ctrlreq.req.wLength = ((uint16_t)(udd_ctrl_buffer[7]) << 8) + udd_ctrl_buffer[6];
    51b0:	4b07      	ldr	r3, [pc, #28]	; (51d0 <udd_ctrl_fetch_ram+0x64>)
    51b2:	79db      	ldrb	r3, [r3, #7]
    51b4:	b29b      	uxth	r3, r3
    51b6:	021b      	lsls	r3, r3, #8
    51b8:	b29a      	uxth	r2, r3
    51ba:	4b05      	ldr	r3, [pc, #20]	; (51d0 <udd_ctrl_fetch_ram+0x64>)
    51bc:	799b      	ldrb	r3, [r3, #6]
    51be:	b29b      	uxth	r3, r3
    51c0:	18d3      	adds	r3, r2, r3
    51c2:	b29a      	uxth	r2, r3
    51c4:	4b03      	ldr	r3, [pc, #12]	; (51d4 <udd_ctrl_fetch_ram+0x68>)
    51c6:	80da      	strh	r2, [r3, #6]
}
    51c8:	46c0      	nop			; (mov r8, r8)
    51ca:	46bd      	mov	sp, r7
    51cc:	bd80      	pop	{r7, pc}
    51ce:	46c0      	nop			; (mov r8, r8)
    51d0:	20001494 	.word	0x20001494
    51d4:	2000147c 	.word	0x2000147c

000051d8 <udd_ctrl_send_zlp_in>:

/**
 * \brief Control Endpoint send out zero length packet
 */
static void udd_ctrl_send_zlp_in(void)
{
    51d8:	b5b0      	push	{r4, r5, r7, lr}
    51da:	af00      	add	r7, sp, #0
	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
    51dc:	4b09      	ldr	r3, [pc, #36]	; (5204 <udd_ctrl_send_zlp_in+0x2c>)
    51de:	2203      	movs	r2, #3
    51e0:	701a      	strb	r2, [r3, #0]
	usb_device_endpoint_setup_buffer_job(&usb_device,udd_ctrl_buffer);
    51e2:	4a09      	ldr	r2, [pc, #36]	; (5208 <udd_ctrl_send_zlp_in+0x30>)
    51e4:	4b09      	ldr	r3, [pc, #36]	; (520c <udd_ctrl_send_zlp_in+0x34>)
    51e6:	0011      	movs	r1, r2
    51e8:	0018      	movs	r0, r3
    51ea:	4b09      	ldr	r3, [pc, #36]	; (5210 <udd_ctrl_send_zlp_in+0x38>)
    51ec:	4798      	blx	r3
	usb_device_endpoint_write_buffer_job(&usb_device,0,udd_g_ctrlreq.payload,0);
    51ee:	4b09      	ldr	r3, [pc, #36]	; (5214 <udd_ctrl_send_zlp_in+0x3c>)
    51f0:	689a      	ldr	r2, [r3, #8]
    51f2:	4806      	ldr	r0, [pc, #24]	; (520c <udd_ctrl_send_zlp_in+0x34>)
    51f4:	2300      	movs	r3, #0
    51f6:	2100      	movs	r1, #0
    51f8:	4c07      	ldr	r4, [pc, #28]	; (5218 <udd_ctrl_send_zlp_in+0x40>)
    51fa:	47a0      	blx	r4
}
    51fc:	46c0      	nop			; (mov r8, r8)
    51fe:	46bd      	mov	sp, r7
    5200:	bdb0      	pop	{r4, r5, r7, pc}
    5202:	46c0      	nop			; (mov r8, r8)
    5204:	2000075e 	.word	0x2000075e
    5208:	20001494 	.word	0x20001494
    520c:	20001314 	.word	0x20001314
    5210:	000104d9 	.word	0x000104d9
    5214:	2000147c 	.word	0x2000147c
    5218:	00010375 	.word	0x00010375

0000521c <udd_ctrl_in_sent>:

/**
 * \brief Process control endpoint IN transaction
 */
static void udd_ctrl_in_sent(void)
{
    521c:	b590      	push	{r4, r7, lr}
    521e:	b083      	sub	sp, #12
    5220:	af00      	add	r7, sp, #0
	static bool b_shortpacket = false;
	uint16_t nb_remain;

	nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
    5222:	4b30      	ldr	r3, [pc, #192]	; (52e4 <udd_ctrl_in_sent+0xc8>)
    5224:	8999      	ldrh	r1, [r3, #12]
    5226:	4b30      	ldr	r3, [pc, #192]	; (52e8 <udd_ctrl_in_sent+0xcc>)
    5228:	881a      	ldrh	r2, [r3, #0]
    522a:	1dbb      	adds	r3, r7, #6
    522c:	1a8a      	subs	r2, r1, r2
    522e:	801a      	strh	r2, [r3, #0]

	if (0 == nb_remain) {
    5230:	1dbb      	adds	r3, r7, #6
    5232:	881b      	ldrh	r3, [r3, #0]
    5234:	2b00      	cmp	r3, #0
    5236:	d130      	bne.n	529a <udd_ctrl_in_sent+0x7e>
		/* All content of current buffer payload are sent Update number of total data sending by previous payload buffer */
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
    5238:	4b2c      	ldr	r3, [pc, #176]	; (52ec <udd_ctrl_in_sent+0xd0>)
    523a:	881a      	ldrh	r2, [r3, #0]
    523c:	4b2a      	ldr	r3, [pc, #168]	; (52e8 <udd_ctrl_in_sent+0xcc>)
    523e:	881b      	ldrh	r3, [r3, #0]
    5240:	18d3      	adds	r3, r2, r3
    5242:	b29a      	uxth	r2, r3
    5244:	4b29      	ldr	r3, [pc, #164]	; (52ec <udd_ctrl_in_sent+0xd0>)
    5246:	801a      	strh	r2, [r3, #0]
		if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_nb_trans) || b_shortpacket) {
    5248:	4b26      	ldr	r3, [pc, #152]	; (52e4 <udd_ctrl_in_sent+0xc8>)
    524a:	88da      	ldrh	r2, [r3, #6]
    524c:	4b27      	ldr	r3, [pc, #156]	; (52ec <udd_ctrl_in_sent+0xd0>)
    524e:	881b      	ldrh	r3, [r3, #0]
    5250:	429a      	cmp	r2, r3
    5252:	d003      	beq.n	525c <udd_ctrl_in_sent+0x40>
    5254:	4b26      	ldr	r3, [pc, #152]	; (52f0 <udd_ctrl_in_sent+0xd4>)
    5256:	781b      	ldrb	r3, [r3, #0]
    5258:	2b00      	cmp	r3, #0
    525a:	d009      	beq.n	5270 <udd_ctrl_in_sent+0x54>
			/* All data requested are transferred or a short packet has been sent, then it is the end of data phase.
			 * Generate an OUT ZLP for handshake phase */
			udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
    525c:	4b25      	ldr	r3, [pc, #148]	; (52f4 <udd_ctrl_in_sent+0xd8>)
    525e:	2204      	movs	r2, #4
    5260:	701a      	strb	r2, [r3, #0]
			usb_device_endpoint_setup_buffer_job(&usb_device,udd_ctrl_buffer);
    5262:	4a25      	ldr	r2, [pc, #148]	; (52f8 <udd_ctrl_in_sent+0xdc>)
    5264:	4b25      	ldr	r3, [pc, #148]	; (52fc <udd_ctrl_in_sent+0xe0>)
    5266:	0011      	movs	r1, r2
    5268:	0018      	movs	r0, r3
    526a:	4b25      	ldr	r3, [pc, #148]	; (5300 <udd_ctrl_in_sent+0xe4>)
    526c:	4798      	blx	r3
			return;
    526e:	e035      	b.n	52dc <udd_ctrl_in_sent+0xc0>
		}
		/* Need of new buffer because the data phase is not complete */
		if ((!udd_g_ctrlreq.over_under_run) || (!udd_g_ctrlreq.over_under_run())) {
    5270:	4b1c      	ldr	r3, [pc, #112]	; (52e4 <udd_ctrl_in_sent+0xc8>)
    5272:	695b      	ldr	r3, [r3, #20]
    5274:	2b00      	cmp	r3, #0
    5276:	d010      	beq.n	529a <udd_ctrl_in_sent+0x7e>
    5278:	4b1a      	ldr	r3, [pc, #104]	; (52e4 <udd_ctrl_in_sent+0xc8>)
    527a:	695b      	ldr	r3, [r3, #20]
    527c:	4798      	blx	r3
    527e:	0003      	movs	r3, r0
    5280:	001a      	movs	r2, r3
    5282:	2301      	movs	r3, #1
    5284:	4053      	eors	r3, r2
    5286:	b2db      	uxtb	r3, r3
    5288:	2b00      	cmp	r3, #0
    528a:	d106      	bne.n	529a <udd_ctrl_in_sent+0x7e>
			/* Under run then send zlp on IN
			 * Here nb_remain=0, this allows to send a IN ZLP */
		} else {
			/* A new payload buffer is given */
			udd_ctrl_payload_nb_trans = 0;
    528c:	4b16      	ldr	r3, [pc, #88]	; (52e8 <udd_ctrl_in_sent+0xcc>)
    528e:	2200      	movs	r2, #0
    5290:	801a      	strh	r2, [r3, #0]
			nb_remain = udd_g_ctrlreq.payload_size;
    5292:	1dbb      	adds	r3, r7, #6
    5294:	4a13      	ldr	r2, [pc, #76]	; (52e4 <udd_ctrl_in_sent+0xc8>)
    5296:	8992      	ldrh	r2, [r2, #12]
    5298:	801a      	strh	r2, [r3, #0]
		}
	}

	/* Continue transfer and send next data */
	if (nb_remain >= USB_DEVICE_EP_CTRL_SIZE) {
    529a:	1dbb      	adds	r3, r7, #6
    529c:	881b      	ldrh	r3, [r3, #0]
    529e:	2b3f      	cmp	r3, #63	; 0x3f
    52a0:	d906      	bls.n	52b0 <udd_ctrl_in_sent+0x94>
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
    52a2:	1dbb      	adds	r3, r7, #6
    52a4:	2240      	movs	r2, #64	; 0x40
    52a6:	801a      	strh	r2, [r3, #0]
		b_shortpacket = false;
    52a8:	4b11      	ldr	r3, [pc, #68]	; (52f0 <udd_ctrl_in_sent+0xd4>)
    52aa:	2200      	movs	r2, #0
    52ac:	701a      	strb	r2, [r3, #0]
    52ae:	e002      	b.n	52b6 <udd_ctrl_in_sent+0x9a>
	} else {
		b_shortpacket = true;
    52b0:	4b0f      	ldr	r3, [pc, #60]	; (52f0 <udd_ctrl_in_sent+0xd4>)
    52b2:	2201      	movs	r2, #1
    52b4:	701a      	strb	r2, [r3, #0]
	}

	/* Link payload buffer directly on USB hardware */
	usb_device_endpoint_write_buffer_job(&usb_device,0,udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans,nb_remain);
    52b6:	4b0b      	ldr	r3, [pc, #44]	; (52e4 <udd_ctrl_in_sent+0xc8>)
    52b8:	689b      	ldr	r3, [r3, #8]
    52ba:	4a0b      	ldr	r2, [pc, #44]	; (52e8 <udd_ctrl_in_sent+0xcc>)
    52bc:	8812      	ldrh	r2, [r2, #0]
    52be:	189a      	adds	r2, r3, r2
    52c0:	1dbb      	adds	r3, r7, #6
    52c2:	881b      	ldrh	r3, [r3, #0]
    52c4:	480d      	ldr	r0, [pc, #52]	; (52fc <udd_ctrl_in_sent+0xe0>)
    52c6:	2100      	movs	r1, #0
    52c8:	4c0e      	ldr	r4, [pc, #56]	; (5304 <udd_ctrl_in_sent+0xe8>)
    52ca:	47a0      	blx	r4

	udd_ctrl_payload_nb_trans += nb_remain;
    52cc:	4b06      	ldr	r3, [pc, #24]	; (52e8 <udd_ctrl_in_sent+0xcc>)
    52ce:	881a      	ldrh	r2, [r3, #0]
    52d0:	1dbb      	adds	r3, r7, #6
    52d2:	881b      	ldrh	r3, [r3, #0]
    52d4:	18d3      	adds	r3, r2, r3
    52d6:	b29a      	uxth	r2, r3
    52d8:	4b03      	ldr	r3, [pc, #12]	; (52e8 <udd_ctrl_in_sent+0xcc>)
    52da:	801a      	strh	r2, [r3, #0]
}
    52dc:	46bd      	mov	sp, r7
    52de:	b003      	add	sp, #12
    52e0:	bd90      	pop	{r4, r7, pc}
    52e2:	46c0      	nop			; (mov r8, r8)
    52e4:	2000147c 	.word	0x2000147c
    52e8:	20000762 	.word	0x20000762
    52ec:	20000760 	.word	0x20000760
    52f0:	200007dd 	.word	0x200007dd
    52f4:	2000075e 	.word	0x2000075e
    52f8:	20001494 	.word	0x20001494
    52fc:	20001314 	.word	0x20001314
    5300:	000104d9 	.word	0x000104d9
    5304:	00010375 	.word	0x00010375

00005308 <udd_ctrl_out_received>:
/**
 * \brief Process control endpoint OUT transaction
 * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 */
static void udd_ctrl_out_received(void* pointer)
{
    5308:	b590      	push	{r4, r7, lr}
    530a:	b085      	sub	sp, #20
    530c:	af00      	add	r7, sp, #0
    530e:	6078      	str	r0, [r7, #4]
	struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parameter*)pointer;
    5310:	687b      	ldr	r3, [r7, #4]
    5312:	60bb      	str	r3, [r7, #8]

	uint16_t nb_data;
	nb_data = ep_callback_para->received_bytes; /* Read data received during OUT phase */
    5314:	230e      	movs	r3, #14
    5316:	18fb      	adds	r3, r7, r3
    5318:	68ba      	ldr	r2, [r7, #8]
    531a:	8812      	ldrh	r2, [r2, #0]
    531c:	801a      	strh	r2, [r3, #0]

	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_nb_trans + nb_data)) {
    531e:	4b45      	ldr	r3, [pc, #276]	; (5434 <udd_ctrl_out_received+0x12c>)
    5320:	899b      	ldrh	r3, [r3, #12]
    5322:	001a      	movs	r2, r3
    5324:	4b44      	ldr	r3, [pc, #272]	; (5438 <udd_ctrl_out_received+0x130>)
    5326:	881b      	ldrh	r3, [r3, #0]
    5328:	0019      	movs	r1, r3
    532a:	230e      	movs	r3, #14
    532c:	18fb      	adds	r3, r7, r3
    532e:	881b      	ldrh	r3, [r3, #0]
    5330:	18cb      	adds	r3, r1, r3
    5332:	429a      	cmp	r2, r3
    5334:	da07      	bge.n	5346 <udd_ctrl_out_received+0x3e>
		/* Payload buffer too small */
		nb_data = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
    5336:	4b3f      	ldr	r3, [pc, #252]	; (5434 <udd_ctrl_out_received+0x12c>)
    5338:	8999      	ldrh	r1, [r3, #12]
    533a:	4b3f      	ldr	r3, [pc, #252]	; (5438 <udd_ctrl_out_received+0x130>)
    533c:	881a      	ldrh	r2, [r3, #0]
    533e:	230e      	movs	r3, #14
    5340:	18fb      	adds	r3, r7, r3
    5342:	1a8a      	subs	r2, r1, r2
    5344:	801a      	strh	r2, [r3, #0]
	}

	memcpy((uint8_t *) (udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans), udd_ctrl_buffer, nb_data);
    5346:	4b3b      	ldr	r3, [pc, #236]	; (5434 <udd_ctrl_out_received+0x12c>)
    5348:	689b      	ldr	r3, [r3, #8]
    534a:	4a3b      	ldr	r2, [pc, #236]	; (5438 <udd_ctrl_out_received+0x130>)
    534c:	8812      	ldrh	r2, [r2, #0]
    534e:	1898      	adds	r0, r3, r2
    5350:	230e      	movs	r3, #14
    5352:	18fb      	adds	r3, r7, r3
    5354:	881a      	ldrh	r2, [r3, #0]
    5356:	4b39      	ldr	r3, [pc, #228]	; (543c <udd_ctrl_out_received+0x134>)
    5358:	0019      	movs	r1, r3
    535a:	4b39      	ldr	r3, [pc, #228]	; (5440 <udd_ctrl_out_received+0x138>)
    535c:	4798      	blx	r3
	udd_ctrl_payload_nb_trans += nb_data;
    535e:	4b36      	ldr	r3, [pc, #216]	; (5438 <udd_ctrl_out_received+0x130>)
    5360:	881a      	ldrh	r2, [r3, #0]
    5362:	230e      	movs	r3, #14
    5364:	18fb      	adds	r3, r7, r3
    5366:	881b      	ldrh	r3, [r3, #0]
    5368:	18d3      	adds	r3, r2, r3
    536a:	b29a      	uxth	r2, r3
    536c:	4b32      	ldr	r3, [pc, #200]	; (5438 <udd_ctrl_out_received+0x130>)
    536e:	801a      	strh	r2, [r3, #0]

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data) || \
    5370:	230e      	movs	r3, #14
    5372:	18fb      	adds	r3, r7, r3
    5374:	881b      	ldrh	r3, [r3, #0]
    5376:	2b40      	cmp	r3, #64	; 0x40
    5378:	d10a      	bne.n	5390 <udd_ctrl_out_received+0x88>
	(udd_g_ctrlreq.req.wLength <= (udd_ctrl_prev_payload_nb_trans + udd_ctrl_payload_nb_trans))) {
    537a:	4b2e      	ldr	r3, [pc, #184]	; (5434 <udd_ctrl_out_received+0x12c>)
    537c:	88db      	ldrh	r3, [r3, #6]
    537e:	001a      	movs	r2, r3
    5380:	4b30      	ldr	r3, [pc, #192]	; (5444 <udd_ctrl_out_received+0x13c>)
    5382:	881b      	ldrh	r3, [r3, #0]
    5384:	0019      	movs	r1, r3
    5386:	4b2c      	ldr	r3, [pc, #176]	; (5438 <udd_ctrl_out_received+0x130>)
    5388:	881b      	ldrh	r3, [r3, #0]
    538a:	18cb      	adds	r3, r1, r3
	}

	memcpy((uint8_t *) (udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans), udd_ctrl_buffer, nb_data);
	udd_ctrl_payload_nb_trans += nb_data;

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data) || \
    538c:	429a      	cmp	r2, r3
    538e:	dc1b      	bgt.n	53c8 <udd_ctrl_out_received+0xc0>
		/* End of reception because it is a short packet
		 * or all data are transferred */

		/* Before send ZLP, call intermediate callback
		 * in case of data receive generate a stall */
		udd_g_ctrlreq.payload_size = udd_ctrl_payload_nb_trans;
    5390:	4b29      	ldr	r3, [pc, #164]	; (5438 <udd_ctrl_out_received+0x130>)
    5392:	881a      	ldrh	r2, [r3, #0]
    5394:	4b27      	ldr	r3, [pc, #156]	; (5434 <udd_ctrl_out_received+0x12c>)
    5396:	819a      	strh	r2, [r3, #12]
		if (NULL != udd_g_ctrlreq.over_under_run) {
    5398:	4b26      	ldr	r3, [pc, #152]	; (5434 <udd_ctrl_out_received+0x12c>)
    539a:	695b      	ldr	r3, [r3, #20]
    539c:	2b00      	cmp	r3, #0
    539e:	d010      	beq.n	53c2 <udd_ctrl_out_received+0xba>
			if (!udd_g_ctrlreq.over_under_run()) {
    53a0:	4b24      	ldr	r3, [pc, #144]	; (5434 <udd_ctrl_out_received+0x12c>)
    53a2:	695b      	ldr	r3, [r3, #20]
    53a4:	4798      	blx	r3
    53a6:	0003      	movs	r3, r0
    53a8:	001a      	movs	r2, r3
    53aa:	2301      	movs	r3, #1
    53ac:	4053      	eors	r3, r2
    53ae:	b2db      	uxtb	r3, r3
    53b0:	2b00      	cmp	r3, #0
    53b2:	d006      	beq.n	53c2 <udd_ctrl_out_received+0xba>
				/* Stall ZLP */
				udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
    53b4:	4b24      	ldr	r3, [pc, #144]	; (5448 <udd_ctrl_out_received+0x140>)
    53b6:	2205      	movs	r2, #5
    53b8:	701a      	strb	r2, [r3, #0]
				/* Stall all packets on IN & OUT control endpoint */
				udd_ep_set_halt(0);
    53ba:	2000      	movs	r0, #0
    53bc:	4b23      	ldr	r3, [pc, #140]	; (544c <udd_ctrl_out_received+0x144>)
    53be:	4798      	blx	r3
				/* Ack reception of OUT to replace NAK by a STALL */
				return;
    53c0:	e035      	b.n	542e <udd_ctrl_out_received+0x126>
			}
		}
		/* Send IN ZLP to ACK setup request */
		udd_ctrl_send_zlp_in();
    53c2:	4b23      	ldr	r3, [pc, #140]	; (5450 <udd_ctrl_out_received+0x148>)
    53c4:	4798      	blx	r3
		return;
    53c6:	e032      	b.n	542e <udd_ctrl_out_received+0x126>
	}

	if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_nb_trans) {
    53c8:	4b1a      	ldr	r3, [pc, #104]	; (5434 <udd_ctrl_out_received+0x12c>)
    53ca:	899a      	ldrh	r2, [r3, #12]
    53cc:	4b1a      	ldr	r3, [pc, #104]	; (5438 <udd_ctrl_out_received+0x130>)
    53ce:	881b      	ldrh	r3, [r3, #0]
    53d0:	429a      	cmp	r2, r3
    53d2:	d126      	bne.n	5422 <udd_ctrl_out_received+0x11a>
		/* Overrun then request a new payload buffer */
		if (!udd_g_ctrlreq.over_under_run) {
    53d4:	4b17      	ldr	r3, [pc, #92]	; (5434 <udd_ctrl_out_received+0x12c>)
    53d6:	695b      	ldr	r3, [r3, #20]
    53d8:	2b00      	cmp	r3, #0
    53da:	d106      	bne.n	53ea <udd_ctrl_out_received+0xe2>
			/* No callback available to request a new payload buffer
			 * Stall ZLP */
			udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
    53dc:	4b1a      	ldr	r3, [pc, #104]	; (5448 <udd_ctrl_out_received+0x140>)
    53de:	2205      	movs	r2, #5
    53e0:	701a      	strb	r2, [r3, #0]
			/* Stall all packets on IN & OUT control endpoint */
			udd_ep_set_halt(0);
    53e2:	2000      	movs	r0, #0
    53e4:	4b19      	ldr	r3, [pc, #100]	; (544c <udd_ctrl_out_received+0x144>)
    53e6:	4798      	blx	r3
			return;
    53e8:	e021      	b.n	542e <udd_ctrl_out_received+0x126>
		}
		if (!udd_g_ctrlreq.over_under_run()) {
    53ea:	4b12      	ldr	r3, [pc, #72]	; (5434 <udd_ctrl_out_received+0x12c>)
    53ec:	695b      	ldr	r3, [r3, #20]
    53ee:	4798      	blx	r3
    53f0:	0003      	movs	r3, r0
    53f2:	001a      	movs	r2, r3
    53f4:	2301      	movs	r3, #1
    53f6:	4053      	eors	r3, r2
    53f8:	b2db      	uxtb	r3, r3
    53fa:	2b00      	cmp	r3, #0
    53fc:	d006      	beq.n	540c <udd_ctrl_out_received+0x104>
			/* No new payload buffer delivered
			 * Stall ZLP */
			udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
    53fe:	4b12      	ldr	r3, [pc, #72]	; (5448 <udd_ctrl_out_received+0x140>)
    5400:	2205      	movs	r2, #5
    5402:	701a      	strb	r2, [r3, #0]
			/* Stall all packets on IN & OUT control endpoint */
			udd_ep_set_halt(0);
    5404:	2000      	movs	r0, #0
    5406:	4b11      	ldr	r3, [pc, #68]	; (544c <udd_ctrl_out_received+0x144>)
    5408:	4798      	blx	r3
			return;
    540a:	e010      	b.n	542e <udd_ctrl_out_received+0x126>
		}
		/* New payload buffer available
		 * Update number of total data received */
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
    540c:	4b0d      	ldr	r3, [pc, #52]	; (5444 <udd_ctrl_out_received+0x13c>)
    540e:	881a      	ldrh	r2, [r3, #0]
    5410:	4b09      	ldr	r3, [pc, #36]	; (5438 <udd_ctrl_out_received+0x130>)
    5412:	881b      	ldrh	r3, [r3, #0]
    5414:	18d3      	adds	r3, r2, r3
    5416:	b29a      	uxth	r2, r3
    5418:	4b0a      	ldr	r3, [pc, #40]	; (5444 <udd_ctrl_out_received+0x13c>)
    541a:	801a      	strh	r2, [r3, #0]

		/* Reinitialize reception on payload buffer */
		udd_ctrl_payload_nb_trans = 0;
    541c:	4b06      	ldr	r3, [pc, #24]	; (5438 <udd_ctrl_out_received+0x130>)
    541e:	2200      	movs	r2, #0
    5420:	801a      	strh	r2, [r3, #0]
	}
	usb_device_endpoint_read_buffer_job(&usb_device,0,udd_ctrl_buffer,USB_DEVICE_EP_CTRL_SIZE);
    5422:	4a06      	ldr	r2, [pc, #24]	; (543c <udd_ctrl_out_received+0x134>)
    5424:	480b      	ldr	r0, [pc, #44]	; (5454 <udd_ctrl_out_received+0x14c>)
    5426:	2340      	movs	r3, #64	; 0x40
    5428:	2100      	movs	r1, #0
    542a:	4c0b      	ldr	r4, [pc, #44]	; (5458 <udd_ctrl_out_received+0x150>)
    542c:	47a0      	blx	r4
}
    542e:	46bd      	mov	sp, r7
    5430:	b005      	add	sp, #20
    5432:	bd90      	pop	{r4, r7, pc}
    5434:	2000147c 	.word	0x2000147c
    5438:	20000762 	.word	0x20000762
    543c:	20001494 	.word	0x20001494
    5440:	000127e7 	.word	0x000127e7
    5444:	20000760 	.word	0x20000760
    5448:	2000075e 	.word	0x2000075e
    544c:	00004d11 	.word	0x00004d11
    5450:	000051d9 	.word	0x000051d9
    5454:	20001314 	.word	0x20001314
    5458:	00010429 	.word	0x00010429

0000545c <_usb_ep0_on_setup>:
 * \brief     Endpoint 0 (control) SETUP received callback
 * \param[in] module_inst pointer to USB module instance
 * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 */
static void _usb_ep0_on_setup(struct usb_module *module_inst, void* pointer)
{
    545c:	b590      	push	{r4, r7, lr}
    545e:	b085      	sub	sp, #20
    5460:	af00      	add	r7, sp, #0
    5462:	6078      	str	r0, [r7, #4]
    5464:	6039      	str	r1, [r7, #0]
	struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parameter*)pointer;
    5466:	683b      	ldr	r3, [r7, #0]
    5468:	60fb      	str	r3, [r7, #12]

	if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
    546a:	4b29      	ldr	r3, [pc, #164]	; (5510 <_usb_ep0_on_setup+0xb4>)
    546c:	781b      	ldrb	r3, [r3, #0]
    546e:	2b00      	cmp	r3, #0
    5470:	d009      	beq.n	5486 <_usb_ep0_on_setup+0x2a>
		if (NULL != udd_g_ctrlreq.callback) {
    5472:	4b28      	ldr	r3, [pc, #160]	; (5514 <_usb_ep0_on_setup+0xb8>)
    5474:	691b      	ldr	r3, [r3, #16]
    5476:	2b00      	cmp	r3, #0
    5478:	d002      	beq.n	5480 <_usb_ep0_on_setup+0x24>
			udd_g_ctrlreq.callback();
    547a:	4b26      	ldr	r3, [pc, #152]	; (5514 <_usb_ep0_on_setup+0xb8>)
    547c:	691b      	ldr	r3, [r3, #16]
    547e:	4798      	blx	r3
		}
		udd_ep_control_state = UDD_EPCTRL_SETUP;
    5480:	4b23      	ldr	r3, [pc, #140]	; (5510 <_usb_ep0_on_setup+0xb4>)
    5482:	2200      	movs	r2, #0
    5484:	701a      	strb	r2, [r3, #0]
	}
	if ( 8 != ep_callback_para->received_bytes) {
    5486:	68fb      	ldr	r3, [r7, #12]
    5488:	881b      	ldrh	r3, [r3, #0]
    548a:	2b08      	cmp	r3, #8
    548c:	d002      	beq.n	5494 <_usb_ep0_on_setup+0x38>
		udd_ctrl_stall_data();
    548e:	4b22      	ldr	r3, [pc, #136]	; (5518 <_usb_ep0_on_setup+0xbc>)
    5490:	4798      	blx	r3
		return;
    5492:	e03a      	b.n	550a <_usb_ep0_on_setup+0xae>
	} else {
		udd_ctrl_fetch_ram();
    5494:	4b21      	ldr	r3, [pc, #132]	; (551c <_usb_ep0_on_setup+0xc0>)
    5496:	4798      	blx	r3
		if (false == udc_process_setup()) {
    5498:	4b21      	ldr	r3, [pc, #132]	; (5520 <_usb_ep0_on_setup+0xc4>)
    549a:	4798      	blx	r3
    549c:	0003      	movs	r3, r0
    549e:	001a      	movs	r2, r3
    54a0:	2301      	movs	r3, #1
    54a2:	4053      	eors	r3, r2
    54a4:	b2db      	uxtb	r3, r3
    54a6:	2b00      	cmp	r3, #0
    54a8:	d002      	beq.n	54b0 <_usb_ep0_on_setup+0x54>
			udd_ctrl_stall_data();
    54aa:	4b1b      	ldr	r3, [pc, #108]	; (5518 <_usb_ep0_on_setup+0xbc>)
    54ac:	4798      	blx	r3
			return;
    54ae:	e02c      	b.n	550a <_usb_ep0_on_setup+0xae>
		} else if (Udd_setup_is_in()) {
    54b0:	4b18      	ldr	r3, [pc, #96]	; (5514 <_usb_ep0_on_setup+0xb8>)
    54b2:	781b      	ldrb	r3, [r3, #0]
    54b4:	b25b      	sxtb	r3, r3
    54b6:	2b00      	cmp	r3, #0
    54b8:	da11      	bge.n	54de <_usb_ep0_on_setup+0x82>
			udd_ctrl_prev_payload_nb_trans = 0;
    54ba:	4b1a      	ldr	r3, [pc, #104]	; (5524 <_usb_ep0_on_setup+0xc8>)
    54bc:	2200      	movs	r2, #0
    54be:	801a      	strh	r2, [r3, #0]
			udd_ctrl_payload_nb_trans = 0;
    54c0:	4b19      	ldr	r3, [pc, #100]	; (5528 <_usb_ep0_on_setup+0xcc>)
    54c2:	2200      	movs	r2, #0
    54c4:	801a      	strh	r2, [r3, #0]
			udd_ep_control_state = UDD_EPCTRL_DATA_IN;
    54c6:	4b12      	ldr	r3, [pc, #72]	; (5510 <_usb_ep0_on_setup+0xb4>)
    54c8:	2202      	movs	r2, #2
    54ca:	701a      	strb	r2, [r3, #0]
			usb_device_endpoint_read_buffer_job(&usb_device,0,udd_ctrl_buffer,USB_DEVICE_EP_CTRL_SIZE);
    54cc:	4a17      	ldr	r2, [pc, #92]	; (552c <_usb_ep0_on_setup+0xd0>)
    54ce:	4818      	ldr	r0, [pc, #96]	; (5530 <_usb_ep0_on_setup+0xd4>)
    54d0:	2340      	movs	r3, #64	; 0x40
    54d2:	2100      	movs	r1, #0
    54d4:	4c17      	ldr	r4, [pc, #92]	; (5534 <_usb_ep0_on_setup+0xd8>)
    54d6:	47a0      	blx	r4
			udd_ctrl_in_sent();
    54d8:	4b17      	ldr	r3, [pc, #92]	; (5538 <_usb_ep0_on_setup+0xdc>)
    54da:	4798      	blx	r3
    54dc:	e015      	b.n	550a <_usb_ep0_on_setup+0xae>
		} else {
			if(0 == udd_g_ctrlreq.req.wLength) {
    54de:	4b0d      	ldr	r3, [pc, #52]	; (5514 <_usb_ep0_on_setup+0xb8>)
    54e0:	88db      	ldrh	r3, [r3, #6]
    54e2:	2b00      	cmp	r3, #0
    54e4:	d102      	bne.n	54ec <_usb_ep0_on_setup+0x90>
				udd_ctrl_send_zlp_in();
    54e6:	4b15      	ldr	r3, [pc, #84]	; (553c <_usb_ep0_on_setup+0xe0>)
    54e8:	4798      	blx	r3
				return;
    54ea:	e00e      	b.n	550a <_usb_ep0_on_setup+0xae>
			} else {
				udd_ctrl_prev_payload_nb_trans = 0;
    54ec:	4b0d      	ldr	r3, [pc, #52]	; (5524 <_usb_ep0_on_setup+0xc8>)
    54ee:	2200      	movs	r2, #0
    54f0:	801a      	strh	r2, [r3, #0]
				udd_ctrl_payload_nb_trans = 0;
    54f2:	4b0d      	ldr	r3, [pc, #52]	; (5528 <_usb_ep0_on_setup+0xcc>)
    54f4:	2200      	movs	r2, #0
    54f6:	801a      	strh	r2, [r3, #0]
				udd_ep_control_state = UDD_EPCTRL_DATA_OUT;
    54f8:	4b05      	ldr	r3, [pc, #20]	; (5510 <_usb_ep0_on_setup+0xb4>)
    54fa:	2201      	movs	r2, #1
    54fc:	701a      	strb	r2, [r3, #0]
				/* Initialize buffer size and enable OUT bank */
				usb_device_endpoint_read_buffer_job(&usb_device,0,udd_ctrl_buffer,USB_DEVICE_EP_CTRL_SIZE);
    54fe:	4a0b      	ldr	r2, [pc, #44]	; (552c <_usb_ep0_on_setup+0xd0>)
    5500:	480b      	ldr	r0, [pc, #44]	; (5530 <_usb_ep0_on_setup+0xd4>)
    5502:	2340      	movs	r3, #64	; 0x40
    5504:	2100      	movs	r1, #0
    5506:	4c0b      	ldr	r4, [pc, #44]	; (5534 <_usb_ep0_on_setup+0xd8>)
    5508:	47a0      	blx	r4
			}
		}
	}
}
    550a:	46bd      	mov	sp, r7
    550c:	b005      	add	sp, #20
    550e:	bd90      	pop	{r4, r7, pc}
    5510:	2000075e 	.word	0x2000075e
    5514:	2000147c 	.word	0x2000147c
    5518:	00004de1 	.word	0x00004de1
    551c:	0000516d 	.word	0x0000516d
    5520:	000032f1 	.word	0x000032f1
    5524:	20000760 	.word	0x20000760
    5528:	20000762 	.word	0x20000762
    552c:	20001494 	.word	0x20001494
    5530:	20001314 	.word	0x20001314
    5534:	00010429 	.word	0x00010429
    5538:	0000521d 	.word	0x0000521d
    553c:	000051d9 	.word	0x000051d9

00005540 <udd_ctrl_underflow>:
/**
 * \brief Control Endpoint Process when underflow condition has occurred
 * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 */
static void udd_ctrl_underflow(void* pointer)
{
    5540:	b580      	push	{r7, lr}
    5542:	b084      	sub	sp, #16
    5544:	af00      	add	r7, sp, #0
    5546:	6078      	str	r0, [r7, #4]
	struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parameter*)pointer;
    5548:	687b      	ldr	r3, [r7, #4]
    554a:	60fb      	str	r3, [r7, #12]

	if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
    554c:	4b0a      	ldr	r3, [pc, #40]	; (5578 <udd_ctrl_underflow+0x38>)
    554e:	781b      	ldrb	r3, [r3, #0]
    5550:	2b01      	cmp	r3, #1
    5552:	d102      	bne.n	555a <udd_ctrl_underflow+0x1a>
		/* Host want to stop OUT transaction
		 * then stop to wait OUT data phase and wait IN ZLP handshake */
		udd_ctrl_send_zlp_in();
    5554:	4b09      	ldr	r3, [pc, #36]	; (557c <udd_ctrl_underflow+0x3c>)
    5556:	4798      	blx	r3
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
		/* A OUT handshake is waiting by device,
		 * but host want extra IN data then stall extra IN data */
		usb_device_endpoint_set_halt(&usb_device, ep_callback_para->endpoint_address);
	}
}
    5558:	e00a      	b.n	5570 <udd_ctrl_underflow+0x30>

	if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
		/* Host want to stop OUT transaction
		 * then stop to wait OUT data phase and wait IN ZLP handshake */
		udd_ctrl_send_zlp_in();
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
    555a:	4b07      	ldr	r3, [pc, #28]	; (5578 <udd_ctrl_underflow+0x38>)
    555c:	781b      	ldrb	r3, [r3, #0]
    555e:	2b04      	cmp	r3, #4
    5560:	d106      	bne.n	5570 <udd_ctrl_underflow+0x30>
		/* A OUT handshake is waiting by device,
		 * but host want extra IN data then stall extra IN data */
		usb_device_endpoint_set_halt(&usb_device, ep_callback_para->endpoint_address);
    5562:	68fb      	ldr	r3, [r7, #12]
    5564:	799a      	ldrb	r2, [r3, #6]
    5566:	4b06      	ldr	r3, [pc, #24]	; (5580 <udd_ctrl_underflow+0x40>)
    5568:	0011      	movs	r1, r2
    556a:	0018      	movs	r0, r3
    556c:	4b05      	ldr	r3, [pc, #20]	; (5584 <udd_ctrl_underflow+0x44>)
    556e:	4798      	blx	r3
	}
}
    5570:	46c0      	nop			; (mov r8, r8)
    5572:	46bd      	mov	sp, r7
    5574:	b004      	add	sp, #16
    5576:	bd80      	pop	{r7, pc}
    5578:	2000075e 	.word	0x2000075e
    557c:	000051d9 	.word	0x000051d9
    5580:	20001314 	.word	0x20001314
    5584:	000101ed 	.word	0x000101ed

00005588 <udd_ctrl_overflow>:
/**
 * \brief Control Endpoint Process when overflow condition has occurred
 * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 */
static void udd_ctrl_overflow(void* pointer)
{
    5588:	b580      	push	{r7, lr}
    558a:	b084      	sub	sp, #16
    558c:	af00      	add	r7, sp, #0
    558e:	6078      	str	r0, [r7, #4]
	struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parameter*)pointer;
    5590:	687b      	ldr	r3, [r7, #4]
    5592:	60fb      	str	r3, [r7, #12]

	if (UDD_EPCTRL_DATA_IN == udd_ep_control_state) {
    5594:	4b0b      	ldr	r3, [pc, #44]	; (55c4 <udd_ctrl_overflow+0x3c>)
    5596:	781b      	ldrb	r3, [r3, #0]
    5598:	2b02      	cmp	r3, #2
    559a:	d103      	bne.n	55a4 <udd_ctrl_overflow+0x1c>
		/* Host want to stop IN transaction
		 * then stop to wait IN data phase and wait OUT ZLP handshake */
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
    559c:	4b09      	ldr	r3, [pc, #36]	; (55c4 <udd_ctrl_overflow+0x3c>)
    559e:	2204      	movs	r2, #4
    55a0:	701a      	strb	r2, [r3, #0]
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
		/* A IN handshake is waiting by device,
		 * but host want extra OUT data then stall extra OUT data and following status stage */
		usb_device_endpoint_set_halt(&usb_device, ep_callback_para->endpoint_address);
	}
}
    55a2:	e00a      	b.n	55ba <udd_ctrl_overflow+0x32>

	if (UDD_EPCTRL_DATA_IN == udd_ep_control_state) {
		/* Host want to stop IN transaction
		 * then stop to wait IN data phase and wait OUT ZLP handshake */
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
    55a4:	4b07      	ldr	r3, [pc, #28]	; (55c4 <udd_ctrl_overflow+0x3c>)
    55a6:	781b      	ldrb	r3, [r3, #0]
    55a8:	2b03      	cmp	r3, #3
    55aa:	d106      	bne.n	55ba <udd_ctrl_overflow+0x32>
		/* A IN handshake is waiting by device,
		 * but host want extra OUT data then stall extra OUT data and following status stage */
		usb_device_endpoint_set_halt(&usb_device, ep_callback_para->endpoint_address);
    55ac:	68fb      	ldr	r3, [r7, #12]
    55ae:	799a      	ldrb	r2, [r3, #6]
    55b0:	4b05      	ldr	r3, [pc, #20]	; (55c8 <udd_ctrl_overflow+0x40>)
    55b2:	0011      	movs	r1, r2
    55b4:	0018      	movs	r0, r3
    55b6:	4b05      	ldr	r3, [pc, #20]	; (55cc <udd_ctrl_overflow+0x44>)
    55b8:	4798      	blx	r3
	}
}
    55ba:	46c0      	nop			; (mov r8, r8)
    55bc:	46bd      	mov	sp, r7
    55be:	b004      	add	sp, #16
    55c0:	bd80      	pop	{r7, pc}
    55c2:	46c0      	nop			; (mov r8, r8)
    55c4:	2000075e 	.word	0x2000075e
    55c8:	20001314 	.word	0x20001314
    55cc:	000101ed 	.word	0x000101ed

000055d0 <_usb_ep0_on_tansfer_fail>:
 * \brief Control endpoint transfer fail callback function
 * \param[in] module_inst Pointer to USB module instance
 * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 */
static void _usb_ep0_on_tansfer_fail(struct usb_module *module_inst, void* pointer)
{
    55d0:	b580      	push	{r7, lr}
    55d2:	b084      	sub	sp, #16
    55d4:	af00      	add	r7, sp, #0
    55d6:	6078      	str	r0, [r7, #4]
    55d8:	6039      	str	r1, [r7, #0]
	struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parameter*)pointer;
    55da:	683b      	ldr	r3, [r7, #0]
    55dc:	60fb      	str	r3, [r7, #12]

	if(ep_callback_para->endpoint_address & USB_EP_DIR_IN) {
    55de:	68fb      	ldr	r3, [r7, #12]
    55e0:	799b      	ldrb	r3, [r3, #6]
    55e2:	b25b      	sxtb	r3, r3
    55e4:	2b00      	cmp	r3, #0
    55e6:	da04      	bge.n	55f2 <_usb_ep0_on_tansfer_fail+0x22>
		udd_ctrl_underflow(pointer);
    55e8:	683b      	ldr	r3, [r7, #0]
    55ea:	0018      	movs	r0, r3
    55ec:	4b05      	ldr	r3, [pc, #20]	; (5604 <_usb_ep0_on_tansfer_fail+0x34>)
    55ee:	4798      	blx	r3
	} else {
		udd_ctrl_overflow(pointer);
	}
}
    55f0:	e003      	b.n	55fa <_usb_ep0_on_tansfer_fail+0x2a>
	struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parameter*)pointer;

	if(ep_callback_para->endpoint_address & USB_EP_DIR_IN) {
		udd_ctrl_underflow(pointer);
	} else {
		udd_ctrl_overflow(pointer);
    55f2:	683b      	ldr	r3, [r7, #0]
    55f4:	0018      	movs	r0, r3
    55f6:	4b04      	ldr	r3, [pc, #16]	; (5608 <_usb_ep0_on_tansfer_fail+0x38>)
    55f8:	4798      	blx	r3
	}
}
    55fa:	46c0      	nop			; (mov r8, r8)
    55fc:	46bd      	mov	sp, r7
    55fe:	b004      	add	sp, #16
    5600:	bd80      	pop	{r7, pc}
    5602:	46c0      	nop			; (mov r8, r8)
    5604:	00005541 	.word	0x00005541
    5608:	00005589 	.word	0x00005589

0000560c <_usb_ep0_on_tansfer_ok>:
 * \brief Control endpoint transfer complete callback function
 * \param[in] module_inst Pointer to USB module instance
 * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 */
static void _usb_ep0_on_tansfer_ok(struct usb_module *module_inst, void * pointer)
{
    560c:	b580      	push	{r7, lr}
    560e:	b082      	sub	sp, #8
    5610:	af00      	add	r7, sp, #0
    5612:	6078      	str	r0, [r7, #4]
    5614:	6039      	str	r1, [r7, #0]
		if (UDD_EPCTRL_DATA_OUT  == udd_ep_control_state) { /* handshake Out for status stage */
    5616:	4b0f      	ldr	r3, [pc, #60]	; (5654 <_usb_ep0_on_tansfer_ok+0x48>)
    5618:	781b      	ldrb	r3, [r3, #0]
    561a:	2b01      	cmp	r3, #1
    561c:	d104      	bne.n	5628 <_usb_ep0_on_tansfer_ok+0x1c>
			udd_ctrl_out_received(pointer);
    561e:	683b      	ldr	r3, [r7, #0]
    5620:	0018      	movs	r0, r3
    5622:	4b0d      	ldr	r3, [pc, #52]	; (5658 <_usb_ep0_on_tansfer_ok+0x4c>)
    5624:	4798      	blx	r3
			if (NULL != udd_g_ctrlreq.callback) {
				udd_g_ctrlreq.callback();
			}
			udd_ep_control_state = UDD_EPCTRL_SETUP;
		}
}
    5626:	e010      	b.n	564a <_usb_ep0_on_tansfer_ok+0x3e>
 */
static void _usb_ep0_on_tansfer_ok(struct usb_module *module_inst, void * pointer)
{
		if (UDD_EPCTRL_DATA_OUT  == udd_ep_control_state) { /* handshake Out for status stage */
			udd_ctrl_out_received(pointer);
		} else if (UDD_EPCTRL_DATA_IN == udd_ep_control_state) { /* handshake In for status stage */
    5628:	4b0a      	ldr	r3, [pc, #40]	; (5654 <_usb_ep0_on_tansfer_ok+0x48>)
    562a:	781b      	ldrb	r3, [r3, #0]
    562c:	2b02      	cmp	r3, #2
    562e:	d102      	bne.n	5636 <_usb_ep0_on_tansfer_ok+0x2a>
			udd_ctrl_in_sent();
    5630:	4b0a      	ldr	r3, [pc, #40]	; (565c <_usb_ep0_on_tansfer_ok+0x50>)
    5632:	4798      	blx	r3
			if (NULL != udd_g_ctrlreq.callback) {
				udd_g_ctrlreq.callback();
			}
			udd_ep_control_state = UDD_EPCTRL_SETUP;
		}
}
    5634:	e009      	b.n	564a <_usb_ep0_on_tansfer_ok+0x3e>
		if (UDD_EPCTRL_DATA_OUT  == udd_ep_control_state) { /* handshake Out for status stage */
			udd_ctrl_out_received(pointer);
		} else if (UDD_EPCTRL_DATA_IN == udd_ep_control_state) { /* handshake In for status stage */
			udd_ctrl_in_sent();
		} else {
			if (NULL != udd_g_ctrlreq.callback) {
    5636:	4b0a      	ldr	r3, [pc, #40]	; (5660 <_usb_ep0_on_tansfer_ok+0x54>)
    5638:	691b      	ldr	r3, [r3, #16]
    563a:	2b00      	cmp	r3, #0
    563c:	d002      	beq.n	5644 <_usb_ep0_on_tansfer_ok+0x38>
				udd_g_ctrlreq.callback();
    563e:	4b08      	ldr	r3, [pc, #32]	; (5660 <_usb_ep0_on_tansfer_ok+0x54>)
    5640:	691b      	ldr	r3, [r3, #16]
    5642:	4798      	blx	r3
			}
			udd_ep_control_state = UDD_EPCTRL_SETUP;
    5644:	4b03      	ldr	r3, [pc, #12]	; (5654 <_usb_ep0_on_tansfer_ok+0x48>)
    5646:	2200      	movs	r2, #0
    5648:	701a      	strb	r2, [r3, #0]
		}
}
    564a:	46c0      	nop			; (mov r8, r8)
    564c:	46bd      	mov	sp, r7
    564e:	b002      	add	sp, #8
    5650:	bd80      	pop	{r7, pc}
    5652:	46c0      	nop			; (mov r8, r8)
    5654:	2000075e 	.word	0x2000075e
    5658:	00005309 	.word	0x00005309
    565c:	0000521d 	.word	0x0000521d
    5660:	2000147c 	.word	0x2000147c

00005664 <udd_ctrl_ep_enable>:
/**
 * \brief Enable Control Endpoint
 * \param[in] module_inst Pointer to USB module instance
 */
static void udd_ctrl_ep_enable(struct usb_module *module_inst)
{
    5664:	b590      	push	{r4, r7, lr}
    5666:	b085      	sub	sp, #20
    5668:	af00      	add	r7, sp, #0
    566a:	6078      	str	r0, [r7, #4]
	/* USB Device Endpoint0 Configuration */
	 struct usb_device_endpoint_config config_ep0;

	 usb_device_endpoint_get_config_defaults(&config_ep0);
    566c:	230c      	movs	r3, #12
    566e:	18fb      	adds	r3, r7, r3
    5670:	0018      	movs	r0, r3
    5672:	4b21      	ldr	r3, [pc, #132]	; (56f8 <udd_ctrl_ep_enable+0x94>)
    5674:	4798      	blx	r3
	 config_ep0.ep_size = (enum usb_endpoint_size)(32 - clz(((uint32_t)Min(Max(USB_DEVICE_EP_CTRL_SIZE, 8), 1024) << 1) - 1) - 1 - 3);
    5676:	230c      	movs	r3, #12
    5678:	18fb      	adds	r3, r7, r3
    567a:	2203      	movs	r2, #3
    567c:	705a      	strb	r2, [r3, #1]
	 usb_device_endpoint_set_config(module_inst,&config_ep0);
    567e:	230c      	movs	r3, #12
    5680:	18fa      	adds	r2, r7, r3
    5682:	687b      	ldr	r3, [r7, #4]
    5684:	0011      	movs	r1, r2
    5686:	0018      	movs	r0, r3
    5688:	4b1c      	ldr	r3, [pc, #112]	; (56fc <udd_ctrl_ep_enable+0x98>)
    568a:	4798      	blx	r3

	 usb_device_endpoint_setup_buffer_job(module_inst,udd_ctrl_buffer);
    568c:	4a1c      	ldr	r2, [pc, #112]	; (5700 <udd_ctrl_ep_enable+0x9c>)
    568e:	687b      	ldr	r3, [r7, #4]
    5690:	0011      	movs	r1, r2
    5692:	0018      	movs	r0, r3
    5694:	4b1b      	ldr	r3, [pc, #108]	; (5704 <udd_ctrl_ep_enable+0xa0>)
    5696:	4798      	blx	r3

	 usb_device_endpoint_register_callback(module_inst,0,USB_DEVICE_ENDPOINT_CALLBACK_RXSTP, _usb_ep0_on_setup );
    5698:	4b1b      	ldr	r3, [pc, #108]	; (5708 <udd_ctrl_ep_enable+0xa4>)
    569a:	6878      	ldr	r0, [r7, #4]
    569c:	2202      	movs	r2, #2
    569e:	2100      	movs	r1, #0
    56a0:	4c1a      	ldr	r4, [pc, #104]	; (570c <udd_ctrl_ep_enable+0xa8>)
    56a2:	47a0      	blx	r4
	 usb_device_endpoint_register_callback(module_inst,0,USB_DEVICE_ENDPOINT_CALLBACK_TRCPT,_usb_ep0_on_tansfer_ok );
    56a4:	4b1a      	ldr	r3, [pc, #104]	; (5710 <udd_ctrl_ep_enable+0xac>)
    56a6:	6878      	ldr	r0, [r7, #4]
    56a8:	2200      	movs	r2, #0
    56aa:	2100      	movs	r1, #0
    56ac:	4c17      	ldr	r4, [pc, #92]	; (570c <udd_ctrl_ep_enable+0xa8>)
    56ae:	47a0      	blx	r4
	 usb_device_endpoint_register_callback(module_inst,0,USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL,_usb_ep0_on_tansfer_fail );
    56b0:	4b18      	ldr	r3, [pc, #96]	; (5714 <udd_ctrl_ep_enable+0xb0>)
    56b2:	6878      	ldr	r0, [r7, #4]
    56b4:	2201      	movs	r2, #1
    56b6:	2100      	movs	r1, #0
    56b8:	4c14      	ldr	r4, [pc, #80]	; (570c <udd_ctrl_ep_enable+0xa8>)
    56ba:	47a0      	blx	r4
	 usb_device_endpoint_enable_callback(module_inst,0,USB_DEVICE_ENDPOINT_CALLBACK_RXSTP);
    56bc:	687b      	ldr	r3, [r7, #4]
    56be:	2202      	movs	r2, #2
    56c0:	2100      	movs	r1, #0
    56c2:	0018      	movs	r0, r3
    56c4:	4b14      	ldr	r3, [pc, #80]	; (5718 <udd_ctrl_ep_enable+0xb4>)
    56c6:	4798      	blx	r3
	 usb_device_endpoint_enable_callback(module_inst,0,USB_DEVICE_ENDPOINT_CALLBACK_TRCPT);
    56c8:	687b      	ldr	r3, [r7, #4]
    56ca:	2200      	movs	r2, #0
    56cc:	2100      	movs	r1, #0
    56ce:	0018      	movs	r0, r3
    56d0:	4b11      	ldr	r3, [pc, #68]	; (5718 <udd_ctrl_ep_enable+0xb4>)
    56d2:	4798      	blx	r3
	 usb_device_endpoint_enable_callback(module_inst,0,USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL);
    56d4:	687b      	ldr	r3, [r7, #4]
    56d6:	2201      	movs	r2, #1
    56d8:	2100      	movs	r1, #0
    56da:	0018      	movs	r0, r3
    56dc:	4b0e      	ldr	r3, [pc, #56]	; (5718 <udd_ctrl_ep_enable+0xb4>)
    56de:	4798      	blx	r3

#ifdef  USB_DEVICE_LPM_SUPPORT
	 // Enable LPM feature
	 usb_device_set_lpm_mode(module_inst, USB_DEVICE_LPM_ACK);
    56e0:	687b      	ldr	r3, [r7, #4]
    56e2:	2101      	movs	r1, #1
    56e4:	0018      	movs	r0, r3
    56e6:	4b0d      	ldr	r3, [pc, #52]	; (571c <udd_ctrl_ep_enable+0xb8>)
    56e8:	4798      	blx	r3
#endif

	 udd_ep_control_state = UDD_EPCTRL_SETUP;
    56ea:	4b0d      	ldr	r3, [pc, #52]	; (5720 <udd_ctrl_ep_enable+0xbc>)
    56ec:	2200      	movs	r2, #0
    56ee:	701a      	strb	r2, [r3, #0]
}
    56f0:	46c0      	nop			; (mov r8, r8)
    56f2:	46bd      	mov	sp, r7
    56f4:	b005      	add	sp, #20
    56f6:	bd90      	pop	{r4, r7, pc}
    56f8:	0000fbd1 	.word	0x0000fbd1
    56fc:	0000fbf9 	.word	0x0000fbf9
    5700:	20001494 	.word	0x20001494
    5704:	000104d9 	.word	0x000104d9
    5708:	0000545d 	.word	0x0000545d
    570c:	0000f799 	.word	0x0000f799
    5710:	0000560d 	.word	0x0000560d
    5714:	000055d1 	.word	0x000055d1
    5718:	0000f891 	.word	0x0000f891
    571c:	00004479 	.word	0x00004479
    5720:	2000075e 	.word	0x2000075e

00005724 <_usb_on_suspend>:
 * \brief Control endpoint Suspend callback function
 * \param[in] module_inst Pointer to USB module instance
 * \param[in] pointer Pointer to the callback parameter from driver layer.
 */
static void _usb_on_suspend(struct usb_module *module_inst, void *pointer)
{
    5724:	b580      	push	{r7, lr}
    5726:	b082      	sub	sp, #8
    5728:	af00      	add	r7, sp, #0
    572a:	6078      	str	r0, [r7, #4]
    572c:	6039      	str	r1, [r7, #0]
	usb_device_disable_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND);
    572e:	4b08      	ldr	r3, [pc, #32]	; (5750 <_usb_on_suspend+0x2c>)
    5730:	2104      	movs	r1, #4
    5732:	0018      	movs	r0, r3
    5734:	4b07      	ldr	r3, [pc, #28]	; (5754 <_usb_on_suspend+0x30>)
    5736:	4798      	blx	r3
	usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
    5738:	4b05      	ldr	r3, [pc, #20]	; (5750 <_usb_on_suspend+0x2c>)
    573a:	2102      	movs	r1, #2
    573c:	0018      	movs	r0, r3
    573e:	4b06      	ldr	r3, [pc, #24]	; (5758 <_usb_on_suspend+0x34>)
    5740:	4798      	blx	r3
	udd_sleep_mode(UDD_STATE_SUSPEND);
    5742:	2001      	movs	r0, #1
    5744:	4b05      	ldr	r3, [pc, #20]	; (575c <_usb_on_suspend+0x38>)
    5746:	4798      	blx	r3
#ifdef UDC_SUSPEND_EVENT
	UDC_SUSPEND_EVENT();
#endif
}
    5748:	46c0      	nop			; (mov r8, r8)
    574a:	46bd      	mov	sp, r7
    574c:	b002      	add	sp, #8
    574e:	bd80      	pop	{r7, pc}
    5750:	20001314 	.word	0x20001314
    5754:	0000f745 	.word	0x0000f745
    5758:	0000f6e9 	.word	0x0000f6e9
    575c:	00004591 	.word	0x00004591

00005760 <_usb_device_lpm_suspend>:

#ifdef  USB_DEVICE_LPM_SUPPORT
static void _usb_device_lpm_suspend(struct usb_module *module_inst, void *pointer)
{
    5760:	b580      	push	{r7, lr}
    5762:	b084      	sub	sp, #16
    5764:	af00      	add	r7, sp, #0
    5766:	6078      	str	r0, [r7, #4]
    5768:	6039      	str	r1, [r7, #0]
	dbg_print("LPM_SUSP\n");

	uint32_t *lpm_wakeup_enable;
	lpm_wakeup_enable = (uint32_t *)pointer;
    576a:	683b      	ldr	r3, [r7, #0]
    576c:	60fb      	str	r3, [r7, #12]

	usb_device_disable_callback(&usb_device, USB_DEVICE_CALLBACK_LPMSUSP);
    576e:	4b0b      	ldr	r3, [pc, #44]	; (579c <_usb_device_lpm_suspend+0x3c>)
    5770:	2106      	movs	r1, #6
    5772:	0018      	movs	r0, r3
    5774:	4b0a      	ldr	r3, [pc, #40]	; (57a0 <_usb_device_lpm_suspend+0x40>)
    5776:	4798      	blx	r3
	usb_device_disable_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND);
    5778:	4b08      	ldr	r3, [pc, #32]	; (579c <_usb_device_lpm_suspend+0x3c>)
    577a:	2104      	movs	r1, #4
    577c:	0018      	movs	r0, r3
    577e:	4b08      	ldr	r3, [pc, #32]	; (57a0 <_usb_device_lpm_suspend+0x40>)
    5780:	4798      	blx	r3
	usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
    5782:	4b06      	ldr	r3, [pc, #24]	; (579c <_usb_device_lpm_suspend+0x3c>)
    5784:	2102      	movs	r1, #2
    5786:	0018      	movs	r0, r3
    5788:	4b06      	ldr	r3, [pc, #24]	; (57a4 <_usb_device_lpm_suspend+0x44>)
    578a:	4798      	blx	r3

//#warning Here the sleep mode must be choose to have a DFLL startup time < bmAttribut.HIRD
	udd_sleep_mode(UDD_STATE_SUSPEND_LPM);  // Enter in LPM SUSPEND mode
    578c:	2002      	movs	r0, #2
    578e:	4b06      	ldr	r3, [pc, #24]	; (57a8 <_usb_device_lpm_suspend+0x48>)
    5790:	4798      	blx	r3
	}
	if (!(*lpm_wakeup_enable)) {
		UDC_REMOTEWAKEUP_LPM_DISABLE();
	}
	UDC_SUSPEND_LPM_EVENT();
}
    5792:	46c0      	nop			; (mov r8, r8)
    5794:	46bd      	mov	sp, r7
    5796:	b004      	add	sp, #16
    5798:	bd80      	pop	{r7, pc}
    579a:	46c0      	nop			; (mov r8, r8)
    579c:	20001314 	.word	0x20001314
    57a0:	0000f745 	.word	0x0000f745
    57a4:	0000f6e9 	.word	0x0000f6e9
    57a8:	00004591 	.word	0x00004591

000057ac <_usb_on_sof_notify>:
 * \brief Control endpoint SOF callback function
 * \param[in] module_inst Pointer to USB module instance
 * \param[in] pointer Pointer to the callback parameter from driver layer.
 */
static void _usb_on_sof_notify(struct usb_module *module_inst, void *pointer)
{
    57ac:	b580      	push	{r7, lr}
    57ae:	b082      	sub	sp, #8
    57b0:	af00      	add	r7, sp, #0
    57b2:	6078      	str	r0, [r7, #4]
    57b4:	6039      	str	r1, [r7, #0]
	udc_sof_notify();
    57b6:	4b03      	ldr	r3, [pc, #12]	; (57c4 <_usb_on_sof_notify+0x18>)
    57b8:	4798      	blx	r3
#ifdef UDC_SOF_EVENT
	UDC_SOF_EVENT();
#endif
}
    57ba:	46c0      	nop			; (mov r8, r8)
    57bc:	46bd      	mov	sp, r7
    57be:	b002      	add	sp, #8
    57c0:	bd80      	pop	{r7, pc}
    57c2:	46c0      	nop			; (mov r8, r8)
    57c4:	00002a45 	.word	0x00002a45

000057c8 <_usb_on_bus_reset>:
 * \brief Control endpoint Reset callback function
 * \param[in] module_inst Pointer to USB module instance
 * \param[in] pointer Pointer to the callback parameter from driver layer.
 */
static void _usb_on_bus_reset(struct usb_module *module_inst, void *pointer)
{
    57c8:	b580      	push	{r7, lr}
    57ca:	b082      	sub	sp, #8
    57cc:	af00      	add	r7, sp, #0
    57ce:	6078      	str	r0, [r7, #4]
    57d0:	6039      	str	r1, [r7, #0]
	// Reset USB Device Stack Core
	udc_reset();
    57d2:	4b07      	ldr	r3, [pc, #28]	; (57f0 <_usb_on_bus_reset+0x28>)
    57d4:	4798      	blx	r3
	usb_device_set_address(module_inst,0);
    57d6:	687b      	ldr	r3, [r7, #4]
    57d8:	2100      	movs	r1, #0
    57da:	0018      	movs	r0, r3
    57dc:	4b05      	ldr	r3, [pc, #20]	; (57f4 <_usb_on_bus_reset+0x2c>)
    57de:	4798      	blx	r3
	udd_ctrl_ep_enable(module_inst);
    57e0:	687b      	ldr	r3, [r7, #4]
    57e2:	0018      	movs	r0, r3
    57e4:	4b04      	ldr	r3, [pc, #16]	; (57f8 <_usb_on_bus_reset+0x30>)
    57e6:	4798      	blx	r3
}
    57e8:	46c0      	nop			; (mov r8, r8)
    57ea:	46bd      	mov	sp, r7
    57ec:	b002      	add	sp, #8
    57ee:	bd80      	pop	{r7, pc}
    57f0:	000029e5 	.word	0x000029e5
    57f4:	0000441d 	.word	0x0000441d
    57f8:	00005665 	.word	0x00005665

000057fc <_usb_on_wakeup>:
 * \brief Control endpoint Wakeup callback function
 * \param[in] module_inst Pointer to USB module instance
 * \param[in] pointer Pointer to the callback parameter from driver layer.
 */
static void _usb_on_wakeup(struct usb_module *module_inst, void *pointer)
{
    57fc:	b580      	push	{r7, lr}
    57fe:	b082      	sub	sp, #8
    5800:	af00      	add	r7, sp, #0
    5802:	6078      	str	r0, [r7, #4]
    5804:	6039      	str	r1, [r7, #0]
	udd_wait_clock_ready();
    5806:	4b0f      	ldr	r3, [pc, #60]	; (5844 <_usb_on_wakeup+0x48>)
    5808:	4798      	blx	r3

	usb_device_disable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
    580a:	4b0f      	ldr	r3, [pc, #60]	; (5848 <_usb_on_wakeup+0x4c>)
    580c:	2102      	movs	r1, #2
    580e:	0018      	movs	r0, r3
    5810:	4b0e      	ldr	r3, [pc, #56]	; (584c <_usb_on_wakeup+0x50>)
    5812:	4798      	blx	r3
	usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND);
    5814:	4b0c      	ldr	r3, [pc, #48]	; (5848 <_usb_on_wakeup+0x4c>)
    5816:	2104      	movs	r1, #4
    5818:	0018      	movs	r0, r3
    581a:	4b0d      	ldr	r3, [pc, #52]	; (5850 <_usb_on_wakeup+0x54>)
    581c:	4798      	blx	r3
#ifdef  USB_DEVICE_LPM_SUPPORT
	usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_LPMSUSP, _usb_device_lpm_suspend);
    581e:	4a0d      	ldr	r2, [pc, #52]	; (5854 <_usb_on_wakeup+0x58>)
    5820:	4b09      	ldr	r3, [pc, #36]	; (5848 <_usb_on_wakeup+0x4c>)
    5822:	2106      	movs	r1, #6
    5824:	0018      	movs	r0, r3
    5826:	4b0c      	ldr	r3, [pc, #48]	; (5858 <_usb_on_wakeup+0x5c>)
    5828:	4798      	blx	r3
	usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_LPMSUSP);
    582a:	4b07      	ldr	r3, [pc, #28]	; (5848 <_usb_on_wakeup+0x4c>)
    582c:	2106      	movs	r1, #6
    582e:	0018      	movs	r0, r3
    5830:	4b07      	ldr	r3, [pc, #28]	; (5850 <_usb_on_wakeup+0x54>)
    5832:	4798      	blx	r3
#endif
	udd_sleep_mode(UDD_STATE_IDLE);
    5834:	2003      	movs	r0, #3
    5836:	4b09      	ldr	r3, [pc, #36]	; (585c <_usb_on_wakeup+0x60>)
    5838:	4798      	blx	r3
#ifdef UDC_RESUME_EVENT
	UDC_RESUME_EVENT();
#endif
}
    583a:	46c0      	nop			; (mov r8, r8)
    583c:	46bd      	mov	sp, r7
    583e:	b002      	add	sp, #8
    5840:	bd80      	pop	{r7, pc}
    5842:	46c0      	nop			; (mov r8, r8)
    5844:	00004559 	.word	0x00004559
    5848:	20001314 	.word	0x20001314
    584c:	0000f745 	.word	0x0000f745
    5850:	0000f6e9 	.word	0x0000f6e9
    5854:	00005761 	.word	0x00005761
    5858:	0000f699 	.word	0x0000f699
    585c:	00004591 	.word	0x00004591

00005860 <udd_attach>:
	usb_device_detach(&usb_device);
	udd_sleep_mode(UDD_STATE_SUSPEND);
}

void udd_attach(void)
{
    5860:	b580      	push	{r7, lr}
    5862:	af00      	add	r7, sp, #0
	udd_sleep_mode(UDD_STATE_IDLE);
    5864:	2003      	movs	r0, #3
    5866:	4b20      	ldr	r3, [pc, #128]	; (58e8 <udd_attach+0x88>)
    5868:	4798      	blx	r3
	usb_device_attach(&usb_device);
    586a:	4b20      	ldr	r3, [pc, #128]	; (58ec <udd_attach+0x8c>)
    586c:	0018      	movs	r0, r3
    586e:	4b20      	ldr	r3, [pc, #128]	; (58f0 <udd_attach+0x90>)
    5870:	4798      	blx	r3

	usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND, _usb_on_suspend);
    5872:	4a20      	ldr	r2, [pc, #128]	; (58f4 <udd_attach+0x94>)
    5874:	4b1d      	ldr	r3, [pc, #116]	; (58ec <udd_attach+0x8c>)
    5876:	2104      	movs	r1, #4
    5878:	0018      	movs	r0, r3
    587a:	4b1f      	ldr	r3, [pc, #124]	; (58f8 <udd_attach+0x98>)
    587c:	4798      	blx	r3
	usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_SOF, _usb_on_sof_notify);
    587e:	4a1f      	ldr	r2, [pc, #124]	; (58fc <udd_attach+0x9c>)
    5880:	4b1a      	ldr	r3, [pc, #104]	; (58ec <udd_attach+0x8c>)
    5882:	2100      	movs	r1, #0
    5884:	0018      	movs	r0, r3
    5886:	4b1c      	ldr	r3, [pc, #112]	; (58f8 <udd_attach+0x98>)
    5888:	4798      	blx	r3
	usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_RESET, _usb_on_bus_reset);
    588a:	4a1d      	ldr	r2, [pc, #116]	; (5900 <udd_attach+0xa0>)
    588c:	4b17      	ldr	r3, [pc, #92]	; (58ec <udd_attach+0x8c>)
    588e:	2101      	movs	r1, #1
    5890:	0018      	movs	r0, r3
    5892:	4b19      	ldr	r3, [pc, #100]	; (58f8 <udd_attach+0x98>)
    5894:	4798      	blx	r3
	usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP, _usb_on_wakeup);
    5896:	4a1b      	ldr	r2, [pc, #108]	; (5904 <udd_attach+0xa4>)
    5898:	4b14      	ldr	r3, [pc, #80]	; (58ec <udd_attach+0x8c>)
    589a:	2102      	movs	r1, #2
    589c:	0018      	movs	r0, r3
    589e:	4b16      	ldr	r3, [pc, #88]	; (58f8 <udd_attach+0x98>)
    58a0:	4798      	blx	r3

	usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND);
    58a2:	4b12      	ldr	r3, [pc, #72]	; (58ec <udd_attach+0x8c>)
    58a4:	2104      	movs	r1, #4
    58a6:	0018      	movs	r0, r3
    58a8:	4b17      	ldr	r3, [pc, #92]	; (5908 <udd_attach+0xa8>)
    58aa:	4798      	blx	r3
	usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_SOF);
    58ac:	4b0f      	ldr	r3, [pc, #60]	; (58ec <udd_attach+0x8c>)
    58ae:	2100      	movs	r1, #0
    58b0:	0018      	movs	r0, r3
    58b2:	4b15      	ldr	r3, [pc, #84]	; (5908 <udd_attach+0xa8>)
    58b4:	4798      	blx	r3
	usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_RESET);
    58b6:	4b0d      	ldr	r3, [pc, #52]	; (58ec <udd_attach+0x8c>)
    58b8:	2101      	movs	r1, #1
    58ba:	0018      	movs	r0, r3
    58bc:	4b12      	ldr	r3, [pc, #72]	; (5908 <udd_attach+0xa8>)
    58be:	4798      	blx	r3
	usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
    58c0:	4b0a      	ldr	r3, [pc, #40]	; (58ec <udd_attach+0x8c>)
    58c2:	2102      	movs	r1, #2
    58c4:	0018      	movs	r0, r3
    58c6:	4b10      	ldr	r3, [pc, #64]	; (5908 <udd_attach+0xa8>)
    58c8:	4798      	blx	r3
#ifdef  USB_DEVICE_LPM_SUPPORT
	usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_LPMSUSP, _usb_device_lpm_suspend);
    58ca:	4a10      	ldr	r2, [pc, #64]	; (590c <udd_attach+0xac>)
    58cc:	4b07      	ldr	r3, [pc, #28]	; (58ec <udd_attach+0x8c>)
    58ce:	2106      	movs	r1, #6
    58d0:	0018      	movs	r0, r3
    58d2:	4b09      	ldr	r3, [pc, #36]	; (58f8 <udd_attach+0x98>)
    58d4:	4798      	blx	r3
	usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_LPMSUSP);
    58d6:	4b05      	ldr	r3, [pc, #20]	; (58ec <udd_attach+0x8c>)
    58d8:	2106      	movs	r1, #6
    58da:	0018      	movs	r0, r3
    58dc:	4b0a      	ldr	r3, [pc, #40]	; (5908 <udd_attach+0xa8>)
    58de:	4798      	blx	r3
#endif
}
    58e0:	46c0      	nop			; (mov r8, r8)
    58e2:	46bd      	mov	sp, r7
    58e4:	bd80      	pop	{r7, pc}
    58e6:	46c0      	nop			; (mov r8, r8)
    58e8:	00004591 	.word	0x00004591
    58ec:	20001314 	.word	0x20001314
    58f0:	000043dd 	.word	0x000043dd
    58f4:	00005725 	.word	0x00005725
    58f8:	0000f699 	.word	0x0000f699
    58fc:	000057ad 	.word	0x000057ad
    5900:	000057c9 	.word	0x000057c9
    5904:	000057fd 	.word	0x000057fd
    5908:	0000f6e9 	.word	0x0000f6e9
    590c:	00005761 	.word	0x00005761

00005910 <udd_enable>:
	return false;
#endif
}

void udd_enable(void)
{
    5910:	b580      	push	{r7, lr}
    5912:	b082      	sub	sp, #8
    5914:	af00      	add	r7, sp, #0
	irqflags_t flags;

	/* To avoid USB interrupt before end of initialization */
	flags = cpu_irq_save();
    5916:	4b12      	ldr	r3, [pc, #72]	; (5960 <udd_enable+0x50>)
    5918:	4798      	blx	r3
    591a:	0003      	movs	r3, r0
    591c:	607b      	str	r3, [r7, #4]
	}
#endif
	struct usb_config config_usb;

	/* USB Module configuration */
	usb_get_config_defaults(&config_usb);
    591e:	003b      	movs	r3, r7
    5920:	0018      	movs	r0, r3
    5922:	4b10      	ldr	r3, [pc, #64]	; (5964 <udd_enable+0x54>)
    5924:	4798      	blx	r3
	config_usb.source_generator = UDD_CLOCK_GEN;
    5926:	003b      	movs	r3, r7
    5928:	2200      	movs	r2, #0
    592a:	709a      	strb	r2, [r3, #2]
	usb_init(&usb_device, USB, &config_usb);
    592c:	003a      	movs	r2, r7
    592e:	490e      	ldr	r1, [pc, #56]	; (5968 <udd_enable+0x58>)
    5930:	4b0e      	ldr	r3, [pc, #56]	; (596c <udd_enable+0x5c>)
    5932:	0018      	movs	r0, r3
    5934:	4b0e      	ldr	r3, [pc, #56]	; (5970 <udd_enable+0x60>)
    5936:	4798      	blx	r3

	/* USB Module Enable */
	usb_enable(&usb_device);
    5938:	4b0c      	ldr	r3, [pc, #48]	; (596c <udd_enable+0x5c>)
    593a:	0018      	movs	r0, r3
    593c:	4b0d      	ldr	r3, [pc, #52]	; (5974 <udd_enable+0x64>)
    593e:	4798      	blx	r3

	/* Check clock after enable module, request the clock */
	udd_wait_clock_ready();
    5940:	4b0d      	ldr	r3, [pc, #52]	; (5978 <udd_enable+0x68>)
    5942:	4798      	blx	r3

	udd_sleep_mode(UDD_STATE_SUSPEND);
    5944:	2001      	movs	r0, #1
    5946:	4b0d      	ldr	r3, [pc, #52]	; (597c <udd_enable+0x6c>)
    5948:	4798      	blx	r3
		_uhd_vbus_handler();
	}
#else
	// No VBus detect, assume always high
# ifndef USB_DEVICE_ATTACH_AUTO_DISABLE
	udd_attach();
    594a:	4b0d      	ldr	r3, [pc, #52]	; (5980 <udd_enable+0x70>)
    594c:	4798      	blx	r3
# endif
#endif

	cpu_irq_restore(flags);
    594e:	687b      	ldr	r3, [r7, #4]
    5950:	0018      	movs	r0, r3
    5952:	4b0c      	ldr	r3, [pc, #48]	; (5984 <udd_enable+0x74>)
    5954:	4798      	blx	r3
}
    5956:	46c0      	nop			; (mov r8, r8)
    5958:	46bd      	mov	sp, r7
    595a:	b002      	add	sp, #8
    595c:	bd80      	pop	{r7, pc}
    595e:	46c0      	nop			; (mov r8, r8)
    5960:	00004365 	.word	0x00004365
    5964:	00010b09 	.word	0x00010b09
    5968:	41005000 	.word	0x41005000
    596c:	20001314 	.word	0x20001314
    5970:	00010b31 	.word	0x00010b31
    5974:	00010aa1 	.word	0x00010aa1
    5978:	00004559 	.word	0x00004559
    597c:	00004591 	.word	0x00004591
    5980:	00005861 	.word	0x00005861
    5984:	000043ad 	.word	0x000043ad

00005988 <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
    5988:	b580      	push	{r7, lr}
    598a:	b086      	sub	sp, #24
    598c:	af00      	add	r7, sp, #0
    598e:	60f8      	str	r0, [r7, #12]
    5990:	60b9      	str	r1, [r7, #8]
    5992:	607a      	str	r2, [r7, #4]
	int nChars = 0;
    5994:	2300      	movs	r3, #0
    5996:	617b      	str	r3, [r7, #20]

	if (file != 0) {
    5998:	68fb      	ldr	r3, [r7, #12]
    599a:	2b00      	cmp	r3, #0
    599c:	d012      	beq.n	59c4 <_read+0x3c>
		return -1;
    599e:	2301      	movs	r3, #1
    59a0:	425b      	negs	r3, r3
    59a2:	e013      	b.n	59cc <_read+0x44>
	}

	for (; len > 0; --len) {
		ptr_get(stdio_base, ptr);
    59a4:	4b0b      	ldr	r3, [pc, #44]	; (59d4 <_read+0x4c>)
    59a6:	681a      	ldr	r2, [r3, #0]
    59a8:	4b0b      	ldr	r3, [pc, #44]	; (59d8 <_read+0x50>)
    59aa:	681b      	ldr	r3, [r3, #0]
    59ac:	68b9      	ldr	r1, [r7, #8]
    59ae:	0018      	movs	r0, r3
    59b0:	4790      	blx	r2
		ptr++;
    59b2:	68bb      	ldr	r3, [r7, #8]
    59b4:	3301      	adds	r3, #1
    59b6:	60bb      	str	r3, [r7, #8]
		nChars++;
    59b8:	697b      	ldr	r3, [r7, #20]
    59ba:	3301      	adds	r3, #1
    59bc:	617b      	str	r3, [r7, #20]

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
    59be:	687b      	ldr	r3, [r7, #4]
    59c0:	3b01      	subs	r3, #1
    59c2:	607b      	str	r3, [r7, #4]
    59c4:	687b      	ldr	r3, [r7, #4]
    59c6:	2b00      	cmp	r3, #0
    59c8:	dcec      	bgt.n	59a4 <_read+0x1c>
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
    59ca:	697b      	ldr	r3, [r7, #20]
}
    59cc:	0018      	movs	r0, r3
    59ce:	46bd      	mov	sp, r7
    59d0:	b006      	add	sp, #24
    59d2:	bd80      	pop	{r7, pc}
    59d4:	200014d4 	.word	0x200014d4
    59d8:	200014dc 	.word	0x200014dc

000059dc <_write>:
int __attribute__((weak))
_write (int file, char * ptr, int len);

int __attribute__((weak))
_write (int file, char * ptr, int len)
{
    59dc:	b580      	push	{r7, lr}
    59de:	b086      	sub	sp, #24
    59e0:	af00      	add	r7, sp, #0
    59e2:	60f8      	str	r0, [r7, #12]
    59e4:	60b9      	str	r1, [r7, #8]
    59e6:	607a      	str	r2, [r7, #4]
	int nChars = 0;
    59e8:	2300      	movs	r3, #0
    59ea:	617b      	str	r3, [r7, #20]

	if ((file != 1) && (file != 2) && (file!=3)) {
    59ec:	68fb      	ldr	r3, [r7, #12]
    59ee:	2b01      	cmp	r3, #1
    59f0:	d01d      	beq.n	5a2e <_write+0x52>
    59f2:	68fb      	ldr	r3, [r7, #12]
    59f4:	2b02      	cmp	r3, #2
    59f6:	d01a      	beq.n	5a2e <_write+0x52>
    59f8:	68fb      	ldr	r3, [r7, #12]
    59fa:	2b03      	cmp	r3, #3
    59fc:	d017      	beq.n	5a2e <_write+0x52>
		return -1;
    59fe:	2301      	movs	r3, #1
    5a00:	425b      	negs	r3, r3
    5a02:	e018      	b.n	5a36 <_write+0x5a>
	}

	for (; len != 0; --len) {
		if (ptr_put(stdio_base, *ptr++) < 0) {
    5a04:	4b0e      	ldr	r3, [pc, #56]	; (5a40 <_write+0x64>)
    5a06:	681a      	ldr	r2, [r3, #0]
    5a08:	4b0e      	ldr	r3, [pc, #56]	; (5a44 <_write+0x68>)
    5a0a:	6818      	ldr	r0, [r3, #0]
    5a0c:	68bb      	ldr	r3, [r7, #8]
    5a0e:	1c59      	adds	r1, r3, #1
    5a10:	60b9      	str	r1, [r7, #8]
    5a12:	781b      	ldrb	r3, [r3, #0]
    5a14:	0019      	movs	r1, r3
    5a16:	4790      	blx	r2
    5a18:	1e03      	subs	r3, r0, #0
    5a1a:	da02      	bge.n	5a22 <_write+0x46>
			return -1;
    5a1c:	2301      	movs	r3, #1
    5a1e:	425b      	negs	r3, r3
    5a20:	e009      	b.n	5a36 <_write+0x5a>
		}
		++nChars;
    5a22:	697b      	ldr	r3, [r7, #20]
    5a24:	3301      	adds	r3, #1
    5a26:	617b      	str	r3, [r7, #20]

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
    5a28:	687b      	ldr	r3, [r7, #4]
    5a2a:	3b01      	subs	r3, #1
    5a2c:	607b      	str	r3, [r7, #4]
    5a2e:	687b      	ldr	r3, [r7, #4]
    5a30:	2b00      	cmp	r3, #0
    5a32:	d1e7      	bne.n	5a04 <_write+0x28>
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
		}
		++nChars;
	}
	return nChars;
    5a34:	697b      	ldr	r3, [r7, #20]
}
    5a36:	0018      	movs	r0, r3
    5a38:	46bd      	mov	sp, r7
    5a3a:	b006      	add	sp, #24
    5a3c:	bd80      	pop	{r7, pc}
    5a3e:	46c0      	nop			; (mov r8, r8)
    5a40:	200014d8 	.word	0x200014d8
    5a44:	200014dc 	.word	0x200014dc

00005a48 <atcacert_read_cert>:

int atcacert_read_cert( const atcacert_def_t* cert_def,
                        const uint8_t ca_public_key[64],
                        uint8_t*              cert,
                        size_t*               cert_size)
{
    5a48:	b5b0      	push	{r4, r5, r7, lr}
    5a4a:	4cce      	ldr	r4, [pc, #824]	; (5d84 <atcacert_read_cert+0x33c>)
    5a4c:	44a5      	add	sp, r4
    5a4e:	af02      	add	r7, sp, #8
    5a50:	60f8      	str	r0, [r7, #12]
    5a52:	60b9      	str	r1, [r7, #8]
    5a54:	607a      	str	r2, [r7, #4]
    5a56:	603b      	str	r3, [r7, #0]
	int ret = 0;
    5a58:	2300      	movs	r3, #0
    5a5a:	2293      	movs	r2, #147	; 0x93
    5a5c:	0092      	lsls	r2, r2, #2
    5a5e:	18ba      	adds	r2, r7, r2
    5a60:	6013      	str	r3, [r2, #0]
	atcacert_device_loc_t device_locs[16];
	size_t device_locs_count = 0;
    5a62:	2300      	movs	r3, #0
    5a64:	22e8      	movs	r2, #232	; 0xe8
    5a66:	0052      	lsls	r2, r2, #1
    5a68:	18ba      	adds	r2, r7, r2
    5a6a:	6013      	str	r3, [r2, #0]
	size_t i = 0;
    5a6c:	2300      	movs	r3, #0
    5a6e:	2295      	movs	r2, #149	; 0x95
    5a70:	0092      	lsls	r2, r2, #2
    5a72:	18ba      	adds	r2, r7, r2
    5a74:	6013      	str	r3, [r2, #0]
	atcacert_build_state_t build_state;

	if (cert_def == NULL || ca_public_key == NULL || cert == NULL || cert_size == NULL)
    5a76:	68fb      	ldr	r3, [r7, #12]
    5a78:	2b00      	cmp	r3, #0
    5a7a:	d008      	beq.n	5a8e <atcacert_read_cert+0x46>
    5a7c:	68bb      	ldr	r3, [r7, #8]
    5a7e:	2b00      	cmp	r3, #0
    5a80:	d005      	beq.n	5a8e <atcacert_read_cert+0x46>
    5a82:	687b      	ldr	r3, [r7, #4]
    5a84:	2b00      	cmp	r3, #0
    5a86:	d002      	beq.n	5a8e <atcacert_read_cert+0x46>
    5a88:	683b      	ldr	r3, [r7, #0]
    5a8a:	2b00      	cmp	r3, #0
    5a8c:	d101      	bne.n	5a92 <atcacert_read_cert+0x4a>
		return ATCACERT_E_BAD_PARAMS;
    5a8e:	2302      	movs	r3, #2
    5a90:	e172      	b.n	5d78 <atcacert_read_cert+0x330>

	ret = atcacert_get_device_locs(
    5a92:	23e8      	movs	r3, #232	; 0xe8
    5a94:	005b      	lsls	r3, r3, #1
    5a96:	18fa      	adds	r2, r7, r3
    5a98:	23ea      	movs	r3, #234	; 0xea
    5a9a:	005b      	lsls	r3, r3, #1
    5a9c:	18f9      	adds	r1, r7, r3
    5a9e:	68f8      	ldr	r0, [r7, #12]
    5aa0:	2320      	movs	r3, #32
    5aa2:	9300      	str	r3, [sp, #0]
    5aa4:	2310      	movs	r3, #16
    5aa6:	4cb8      	ldr	r4, [pc, #736]	; (5d88 <atcacert_read_cert+0x340>)
    5aa8:	47a0      	blx	r4
    5aaa:	0003      	movs	r3, r0
    5aac:	2293      	movs	r2, #147	; 0x93
    5aae:	0092      	lsls	r2, r2, #2
    5ab0:	18ba      	adds	r2, r7, r2
    5ab2:	6013      	str	r3, [r2, #0]
	    cert_def,
	    device_locs,
	    &device_locs_count,
	    sizeof(device_locs) / sizeof(device_locs[0]),
	    32);
	if (ret != ATCACERT_E_SUCCESS)
    5ab4:	2393      	movs	r3, #147	; 0x93
    5ab6:	009b      	lsls	r3, r3, #2
    5ab8:	18fb      	adds	r3, r7, r3
    5aba:	681b      	ldr	r3, [r3, #0]
    5abc:	2b00      	cmp	r3, #0
    5abe:	d004      	beq.n	5aca <atcacert_read_cert+0x82>
		return ret;
    5ac0:	2393      	movs	r3, #147	; 0x93
    5ac2:	009b      	lsls	r3, r3, #2
    5ac4:	18fb      	adds	r3, r7, r3
    5ac6:	681b      	ldr	r3, [r3, #0]
    5ac8:	e156      	b.n	5d78 <atcacert_read_cert+0x330>

	ret = atcacert_cert_build_start(&build_state, cert_def, cert, cert_size, ca_public_key);
    5aca:	683c      	ldr	r4, [r7, #0]
    5acc:	687a      	ldr	r2, [r7, #4]
    5ace:	68f9      	ldr	r1, [r7, #12]
    5ad0:	23da      	movs	r3, #218	; 0xda
    5ad2:	005b      	lsls	r3, r3, #1
    5ad4:	18f8      	adds	r0, r7, r3
    5ad6:	68bb      	ldr	r3, [r7, #8]
    5ad8:	9300      	str	r3, [sp, #0]
    5ada:	0023      	movs	r3, r4
    5adc:	4cab      	ldr	r4, [pc, #684]	; (5d8c <atcacert_read_cert+0x344>)
    5ade:	47a0      	blx	r4
    5ae0:	0003      	movs	r3, r0
    5ae2:	2293      	movs	r2, #147	; 0x93
    5ae4:	0092      	lsls	r2, r2, #2
    5ae6:	18ba      	adds	r2, r7, r2
    5ae8:	6013      	str	r3, [r2, #0]
	if (ret != ATCACERT_E_SUCCESS)
    5aea:	2393      	movs	r3, #147	; 0x93
    5aec:	009b      	lsls	r3, r3, #2
    5aee:	18fb      	adds	r3, r7, r3
    5af0:	681b      	ldr	r3, [r3, #0]
    5af2:	2b00      	cmp	r3, #0
    5af4:	d004      	beq.n	5b00 <atcacert_read_cert+0xb8>
		return ret;
    5af6:	2393      	movs	r3, #147	; 0x93
    5af8:	009b      	lsls	r3, r3, #2
    5afa:	18fb      	adds	r3, r7, r3
    5afc:	681b      	ldr	r3, [r3, #0]
    5afe:	e13b      	b.n	5d78 <atcacert_read_cert+0x330>

	for (i = 0; i < device_locs_count; i++) {
    5b00:	2300      	movs	r3, #0
    5b02:	2295      	movs	r2, #149	; 0x95
    5b04:	0092      	lsls	r2, r2, #2
    5b06:	18ba      	adds	r2, r7, r2
    5b08:	6013      	str	r3, [r2, #0]
    5b0a:	e113      	b.n	5d34 <atcacert_read_cert+0x2ec>
		uint8_t data[416];
		if (device_locs[i].zone == DEVZONE_DATA && device_locs[i].is_genkey) {
    5b0c:	23ea      	movs	r3, #234	; 0xea
    5b0e:	005b      	lsls	r3, r3, #1
    5b10:	18f9      	adds	r1, r7, r3
    5b12:	2395      	movs	r3, #149	; 0x95
    5b14:	009b      	lsls	r3, r3, #2
    5b16:	18fb      	adds	r3, r7, r3
    5b18:	681a      	ldr	r2, [r3, #0]
    5b1a:	0013      	movs	r3, r2
    5b1c:	00db      	lsls	r3, r3, #3
    5b1e:	1a9b      	subs	r3, r3, r2
    5b20:	5c5b      	ldrb	r3, [r3, r1]
    5b22:	2b02      	cmp	r3, #2
    5b24:	d132      	bne.n	5b8c <atcacert_read_cert+0x144>
    5b26:	23ea      	movs	r3, #234	; 0xea
    5b28:	005b      	lsls	r3, r3, #1
    5b2a:	18f9      	adds	r1, r7, r3
    5b2c:	2395      	movs	r3, #149	; 0x95
    5b2e:	009b      	lsls	r3, r3, #2
    5b30:	18fb      	adds	r3, r7, r3
    5b32:	681a      	ldr	r2, [r3, #0]
    5b34:	0013      	movs	r3, r2
    5b36:	00db      	lsls	r3, r3, #3
    5b38:	1a9b      	subs	r3, r3, r2
    5b3a:	18cb      	adds	r3, r1, r3
    5b3c:	3302      	adds	r3, #2
    5b3e:	781b      	ldrb	r3, [r3, #0]
    5b40:	2b00      	cmp	r3, #0
    5b42:	d023      	beq.n	5b8c <atcacert_read_cert+0x144>
			ret = atcab_get_pubkey(device_locs[i].slot, data);
    5b44:	23ea      	movs	r3, #234	; 0xea
    5b46:	005b      	lsls	r3, r3, #1
    5b48:	18f9      	adds	r1, r7, r3
    5b4a:	2395      	movs	r3, #149	; 0x95
    5b4c:	009b      	lsls	r3, r3, #2
    5b4e:	18fb      	adds	r3, r7, r3
    5b50:	681a      	ldr	r2, [r3, #0]
    5b52:	0013      	movs	r3, r2
    5b54:	00db      	lsls	r3, r3, #3
    5b56:	1a9b      	subs	r3, r3, r2
    5b58:	18cb      	adds	r3, r1, r3
    5b5a:	3301      	adds	r3, #1
    5b5c:	781b      	ldrb	r3, [r3, #0]
    5b5e:	2214      	movs	r2, #20
    5b60:	18ba      	adds	r2, r7, r2
    5b62:	0011      	movs	r1, r2
    5b64:	0018      	movs	r0, r3
    5b66:	4b8a      	ldr	r3, [pc, #552]	; (5d90 <atcacert_read_cert+0x348>)
    5b68:	4798      	blx	r3
    5b6a:	0003      	movs	r3, r0
    5b6c:	2293      	movs	r2, #147	; 0x93
    5b6e:	0092      	lsls	r2, r2, #2
    5b70:	18ba      	adds	r2, r7, r2
    5b72:	6013      	str	r3, [r2, #0]
			if (ret != ATCA_SUCCESS)
    5b74:	2393      	movs	r3, #147	; 0x93
    5b76:	009b      	lsls	r3, r3, #2
    5b78:	18fb      	adds	r3, r7, r3
    5b7a:	681b      	ldr	r3, [r3, #0]
    5b7c:	2b00      	cmp	r3, #0
    5b7e:	d100      	bne.n	5b82 <atcacert_read_cert+0x13a>
    5b80:	e0ac      	b.n	5cdc <atcacert_read_cert+0x294>
				return ret;
    5b82:	2393      	movs	r3, #147	; 0x93
    5b84:	009b      	lsls	r3, r3, #2
    5b86:	18fb      	adds	r3, r7, r3
    5b88:	681b      	ldr	r3, [r3, #0]
    5b8a:	e0f5      	b.n	5d78 <atcacert_read_cert+0x330>
		}else {
			size_t start_block = device_locs[i].offset / 32;
    5b8c:	23ea      	movs	r3, #234	; 0xea
    5b8e:	005b      	lsls	r3, r3, #1
    5b90:	18fa      	adds	r2, r7, r3
    5b92:	2395      	movs	r3, #149	; 0x95
    5b94:	009b      	lsls	r3, r3, #2
    5b96:	18fb      	adds	r3, r7, r3
    5b98:	6819      	ldr	r1, [r3, #0]
    5b9a:	000b      	movs	r3, r1
    5b9c:	00db      	lsls	r3, r3, #3
    5b9e:	1a5b      	subs	r3, r3, r1
    5ba0:	18d1      	adds	r1, r2, r3
    5ba2:	78c9      	ldrb	r1, [r1, #3]
    5ba4:	18d3      	adds	r3, r2, r3
    5ba6:	791b      	ldrb	r3, [r3, #4]
    5ba8:	021b      	lsls	r3, r3, #8
    5baa:	430b      	orrs	r3, r1
    5bac:	b29b      	uxth	r3, r3
    5bae:	095b      	lsrs	r3, r3, #5
    5bb0:	b29b      	uxth	r3, r3
    5bb2:	2292      	movs	r2, #146	; 0x92
    5bb4:	0092      	lsls	r2, r2, #2
    5bb6:	18ba      	adds	r2, r7, r2
    5bb8:	6013      	str	r3, [r2, #0]
			uint8_t block;
			size_t end_block = (device_locs[i].offset + device_locs[i].count) / 32;
    5bba:	23ea      	movs	r3, #234	; 0xea
    5bbc:	005b      	lsls	r3, r3, #1
    5bbe:	18fa      	adds	r2, r7, r3
    5bc0:	2395      	movs	r3, #149	; 0x95
    5bc2:	009b      	lsls	r3, r3, #2
    5bc4:	18fb      	adds	r3, r7, r3
    5bc6:	6819      	ldr	r1, [r3, #0]
    5bc8:	000b      	movs	r3, r1
    5bca:	00db      	lsls	r3, r3, #3
    5bcc:	1a5b      	subs	r3, r3, r1
    5bce:	18d1      	adds	r1, r2, r3
    5bd0:	78c9      	ldrb	r1, [r1, #3]
    5bd2:	18d3      	adds	r3, r2, r3
    5bd4:	791b      	ldrb	r3, [r3, #4]
    5bd6:	021b      	lsls	r3, r3, #8
    5bd8:	430b      	orrs	r3, r1
    5bda:	b29b      	uxth	r3, r3
    5bdc:	0018      	movs	r0, r3
    5bde:	23ea      	movs	r3, #234	; 0xea
    5be0:	005b      	lsls	r3, r3, #1
    5be2:	18fa      	adds	r2, r7, r3
    5be4:	2395      	movs	r3, #149	; 0x95
    5be6:	009b      	lsls	r3, r3, #2
    5be8:	18fb      	adds	r3, r7, r3
    5bea:	6819      	ldr	r1, [r3, #0]
    5bec:	000b      	movs	r3, r1
    5bee:	00db      	lsls	r3, r3, #3
    5bf0:	1a5b      	subs	r3, r3, r1
    5bf2:	18d1      	adds	r1, r2, r3
    5bf4:	7949      	ldrb	r1, [r1, #5]
    5bf6:	18d3      	adds	r3, r2, r3
    5bf8:	799b      	ldrb	r3, [r3, #6]
    5bfa:	021b      	lsls	r3, r3, #8
    5bfc:	430b      	orrs	r3, r1
    5bfe:	b29b      	uxth	r3, r3
    5c00:	18c3      	adds	r3, r0, r3
    5c02:	2b00      	cmp	r3, #0
    5c04:	da00      	bge.n	5c08 <atcacert_read_cert+0x1c0>
    5c06:	331f      	adds	r3, #31
    5c08:	115b      	asrs	r3, r3, #5
    5c0a:	2291      	movs	r2, #145	; 0x91
    5c0c:	0092      	lsls	r2, r2, #2
    5c0e:	18ba      	adds	r2, r7, r2
    5c10:	6013      	str	r3, [r2, #0]
			for (block = (uint8_t)start_block; block < end_block; block++) {
    5c12:	4b60      	ldr	r3, [pc, #384]	; (5d94 <atcacert_read_cert+0x34c>)
    5c14:	18fb      	adds	r3, r7, r3
    5c16:	2292      	movs	r2, #146	; 0x92
    5c18:	0092      	lsls	r2, r2, #2
    5c1a:	18ba      	adds	r2, r7, r2
    5c1c:	6812      	ldr	r2, [r2, #0]
    5c1e:	701a      	strb	r2, [r3, #0]
    5c20:	e053      	b.n	5cca <atcacert_read_cert+0x282>
				ret = atcab_read_zone(device_locs[i].zone, device_locs[i].slot, block, 0, &data[block * 32 - device_locs[i].offset], 32);
    5c22:	23ea      	movs	r3, #234	; 0xea
    5c24:	005b      	lsls	r3, r3, #1
    5c26:	18f9      	adds	r1, r7, r3
    5c28:	2395      	movs	r3, #149	; 0x95
    5c2a:	009b      	lsls	r3, r3, #2
    5c2c:	18fb      	adds	r3, r7, r3
    5c2e:	681a      	ldr	r2, [r3, #0]
    5c30:	0013      	movs	r3, r2
    5c32:	00db      	lsls	r3, r3, #3
    5c34:	1a9b      	subs	r3, r3, r2
    5c36:	5c5c      	ldrb	r4, [r3, r1]
    5c38:	23ea      	movs	r3, #234	; 0xea
    5c3a:	005b      	lsls	r3, r3, #1
    5c3c:	18f9      	adds	r1, r7, r3
    5c3e:	2395      	movs	r3, #149	; 0x95
    5c40:	009b      	lsls	r3, r3, #2
    5c42:	18fb      	adds	r3, r7, r3
    5c44:	681a      	ldr	r2, [r3, #0]
    5c46:	0013      	movs	r3, r2
    5c48:	00db      	lsls	r3, r3, #3
    5c4a:	1a9b      	subs	r3, r3, r2
    5c4c:	18cb      	adds	r3, r1, r3
    5c4e:	3301      	adds	r3, #1
    5c50:	781d      	ldrb	r5, [r3, #0]
    5c52:	4b50      	ldr	r3, [pc, #320]	; (5d94 <atcacert_read_cert+0x34c>)
    5c54:	18fb      	adds	r3, r7, r3
    5c56:	781b      	ldrb	r3, [r3, #0]
    5c58:	0158      	lsls	r0, r3, #5
    5c5a:	23ea      	movs	r3, #234	; 0xea
    5c5c:	005b      	lsls	r3, r3, #1
    5c5e:	18fa      	adds	r2, r7, r3
    5c60:	2395      	movs	r3, #149	; 0x95
    5c62:	009b      	lsls	r3, r3, #2
    5c64:	18fb      	adds	r3, r7, r3
    5c66:	6819      	ldr	r1, [r3, #0]
    5c68:	000b      	movs	r3, r1
    5c6a:	00db      	lsls	r3, r3, #3
    5c6c:	1a5b      	subs	r3, r3, r1
    5c6e:	18d1      	adds	r1, r2, r3
    5c70:	78c9      	ldrb	r1, [r1, #3]
    5c72:	18d3      	adds	r3, r2, r3
    5c74:	791b      	ldrb	r3, [r3, #4]
    5c76:	021b      	lsls	r3, r3, #8
    5c78:	430b      	orrs	r3, r1
    5c7a:	b29b      	uxth	r3, r3
    5c7c:	1ac3      	subs	r3, r0, r3
    5c7e:	2214      	movs	r2, #20
    5c80:	18ba      	adds	r2, r7, r2
    5c82:	18d3      	adds	r3, r2, r3
    5c84:	4a43      	ldr	r2, [pc, #268]	; (5d94 <atcacert_read_cert+0x34c>)
    5c86:	18ba      	adds	r2, r7, r2
    5c88:	7811      	ldrb	r1, [r2, #0]
    5c8a:	2220      	movs	r2, #32
    5c8c:	9201      	str	r2, [sp, #4]
    5c8e:	9300      	str	r3, [sp, #0]
    5c90:	2300      	movs	r3, #0
    5c92:	000a      	movs	r2, r1
    5c94:	0029      	movs	r1, r5
    5c96:	0020      	movs	r0, r4
    5c98:	4c3f      	ldr	r4, [pc, #252]	; (5d98 <atcacert_read_cert+0x350>)
    5c9a:	47a0      	blx	r4
    5c9c:	0003      	movs	r3, r0
    5c9e:	2293      	movs	r2, #147	; 0x93
    5ca0:	0092      	lsls	r2, r2, #2
    5ca2:	18ba      	adds	r2, r7, r2
    5ca4:	6013      	str	r3, [r2, #0]
				if (ret != ATCA_SUCCESS)
    5ca6:	2393      	movs	r3, #147	; 0x93
    5ca8:	009b      	lsls	r3, r3, #2
    5caa:	18fb      	adds	r3, r7, r3
    5cac:	681b      	ldr	r3, [r3, #0]
    5cae:	2b00      	cmp	r3, #0
    5cb0:	d004      	beq.n	5cbc <atcacert_read_cert+0x274>
					return ret;
    5cb2:	2393      	movs	r3, #147	; 0x93
    5cb4:	009b      	lsls	r3, r3, #2
    5cb6:	18fb      	adds	r3, r7, r3
    5cb8:	681b      	ldr	r3, [r3, #0]
    5cba:	e05d      	b.n	5d78 <atcacert_read_cert+0x330>
				return ret;
		}else {
			size_t start_block = device_locs[i].offset / 32;
			uint8_t block;
			size_t end_block = (device_locs[i].offset + device_locs[i].count) / 32;
			for (block = (uint8_t)start_block; block < end_block; block++) {
    5cbc:	4b35      	ldr	r3, [pc, #212]	; (5d94 <atcacert_read_cert+0x34c>)
    5cbe:	18fb      	adds	r3, r7, r3
    5cc0:	781a      	ldrb	r2, [r3, #0]
    5cc2:	4b34      	ldr	r3, [pc, #208]	; (5d94 <atcacert_read_cert+0x34c>)
    5cc4:	18fb      	adds	r3, r7, r3
    5cc6:	3201      	adds	r2, #1
    5cc8:	701a      	strb	r2, [r3, #0]
    5cca:	4b32      	ldr	r3, [pc, #200]	; (5d94 <atcacert_read_cert+0x34c>)
    5ccc:	18fb      	adds	r3, r7, r3
    5cce:	781a      	ldrb	r2, [r3, #0]
    5cd0:	2391      	movs	r3, #145	; 0x91
    5cd2:	009b      	lsls	r3, r3, #2
    5cd4:	18fb      	adds	r3, r7, r3
    5cd6:	681b      	ldr	r3, [r3, #0]
    5cd8:	429a      	cmp	r2, r3
    5cda:	d3a2      	bcc.n	5c22 <atcacert_read_cert+0x1da>
				if (ret != ATCA_SUCCESS)
					return ret;
			}
		}

		ret = atcacert_cert_build_process(&build_state, &device_locs[i], data);
    5cdc:	23ea      	movs	r3, #234	; 0xea
    5cde:	005b      	lsls	r3, r3, #1
    5ce0:	18f9      	adds	r1, r7, r3
    5ce2:	2395      	movs	r3, #149	; 0x95
    5ce4:	009b      	lsls	r3, r3, #2
    5ce6:	18fb      	adds	r3, r7, r3
    5ce8:	681a      	ldr	r2, [r3, #0]
    5cea:	0013      	movs	r3, r2
    5cec:	00db      	lsls	r3, r3, #3
    5cee:	1a9b      	subs	r3, r3, r2
    5cf0:	18c9      	adds	r1, r1, r3
    5cf2:	2314      	movs	r3, #20
    5cf4:	18fa      	adds	r2, r7, r3
    5cf6:	23da      	movs	r3, #218	; 0xda
    5cf8:	005b      	lsls	r3, r3, #1
    5cfa:	18fb      	adds	r3, r7, r3
    5cfc:	0018      	movs	r0, r3
    5cfe:	4b27      	ldr	r3, [pc, #156]	; (5d9c <atcacert_read_cert+0x354>)
    5d00:	4798      	blx	r3
    5d02:	0003      	movs	r3, r0
    5d04:	2293      	movs	r2, #147	; 0x93
    5d06:	0092      	lsls	r2, r2, #2
    5d08:	18ba      	adds	r2, r7, r2
    5d0a:	6013      	str	r3, [r2, #0]
		if (ret != ATCACERT_E_SUCCESS)
    5d0c:	2393      	movs	r3, #147	; 0x93
    5d0e:	009b      	lsls	r3, r3, #2
    5d10:	18fb      	adds	r3, r7, r3
    5d12:	681b      	ldr	r3, [r3, #0]
    5d14:	2b00      	cmp	r3, #0
    5d16:	d004      	beq.n	5d22 <atcacert_read_cert+0x2da>
			return ret;
    5d18:	2393      	movs	r3, #147	; 0x93
    5d1a:	009b      	lsls	r3, r3, #2
    5d1c:	18fb      	adds	r3, r7, r3
    5d1e:	681b      	ldr	r3, [r3, #0]
    5d20:	e02a      	b.n	5d78 <atcacert_read_cert+0x330>

	ret = atcacert_cert_build_start(&build_state, cert_def, cert, cert_size, ca_public_key);
	if (ret != ATCACERT_E_SUCCESS)
		return ret;

	for (i = 0; i < device_locs_count; i++) {
    5d22:	2395      	movs	r3, #149	; 0x95
    5d24:	009b      	lsls	r3, r3, #2
    5d26:	18fb      	adds	r3, r7, r3
    5d28:	681b      	ldr	r3, [r3, #0]
    5d2a:	3301      	adds	r3, #1
    5d2c:	2295      	movs	r2, #149	; 0x95
    5d2e:	0092      	lsls	r2, r2, #2
    5d30:	18ba      	adds	r2, r7, r2
    5d32:	6013      	str	r3, [r2, #0]
    5d34:	23e8      	movs	r3, #232	; 0xe8
    5d36:	005b      	lsls	r3, r3, #1
    5d38:	18fb      	adds	r3, r7, r3
    5d3a:	681b      	ldr	r3, [r3, #0]
    5d3c:	2295      	movs	r2, #149	; 0x95
    5d3e:	0092      	lsls	r2, r2, #2
    5d40:	18ba      	adds	r2, r7, r2
    5d42:	6812      	ldr	r2, [r2, #0]
    5d44:	429a      	cmp	r2, r3
    5d46:	d200      	bcs.n	5d4a <atcacert_read_cert+0x302>
    5d48:	e6e0      	b.n	5b0c <atcacert_read_cert+0xc4>
		ret = atcacert_cert_build_process(&build_state, &device_locs[i], data);
		if (ret != ATCACERT_E_SUCCESS)
			return ret;
	}

	ret = atcacert_cert_build_finish(&build_state);
    5d4a:	23da      	movs	r3, #218	; 0xda
    5d4c:	005b      	lsls	r3, r3, #1
    5d4e:	18fb      	adds	r3, r7, r3
    5d50:	0018      	movs	r0, r3
    5d52:	4b13      	ldr	r3, [pc, #76]	; (5da0 <atcacert_read_cert+0x358>)
    5d54:	4798      	blx	r3
    5d56:	0003      	movs	r3, r0
    5d58:	2293      	movs	r2, #147	; 0x93
    5d5a:	0092      	lsls	r2, r2, #2
    5d5c:	18ba      	adds	r2, r7, r2
    5d5e:	6013      	str	r3, [r2, #0]
	if (ret != ATCACERT_E_SUCCESS)
    5d60:	2393      	movs	r3, #147	; 0x93
    5d62:	009b      	lsls	r3, r3, #2
    5d64:	18fb      	adds	r3, r7, r3
    5d66:	681b      	ldr	r3, [r3, #0]
    5d68:	2b00      	cmp	r3, #0
    5d6a:	d004      	beq.n	5d76 <atcacert_read_cert+0x32e>
		return ret;
    5d6c:	2393      	movs	r3, #147	; 0x93
    5d6e:	009b      	lsls	r3, r3, #2
    5d70:	18fb      	adds	r3, r7, r3
    5d72:	681b      	ldr	r3, [r3, #0]
    5d74:	e000      	b.n	5d78 <atcacert_read_cert+0x330>

	return ATCACERT_E_SUCCESS;
    5d76:	2300      	movs	r3, #0
}
    5d78:	0018      	movs	r0, r3
    5d7a:	46bd      	mov	sp, r7
    5d7c:	2396      	movs	r3, #150	; 0x96
    5d7e:	009b      	lsls	r3, r3, #2
    5d80:	449d      	add	sp, r3
    5d82:	bdb0      	pop	{r4, r5, r7, pc}
    5d84:	fffffda0 	.word	0xfffffda0
    5d88:	00007681 	.word	0x00007681
    5d8c:	00007959 	.word	0x00007959
    5d90:	0000ca7d 	.word	0x0000ca7d
    5d94:	00000253 	.word	0x00000253
    5d98:	0000bd1d 	.word	0x0000bd1d
    5d9c:	00007d35 	.word	0x00007d35
    5da0:	000082f5 	.word	0x000082f5

00005da4 <atcacert_get_response>:

int atcacert_get_response( uint8_t device_private_key_slot,
                           const uint8_t challenge[32],
                           uint8_t response[64])
{
    5da4:	b580      	push	{r7, lr}
    5da6:	b084      	sub	sp, #16
    5da8:	af00      	add	r7, sp, #0
    5daa:	60b9      	str	r1, [r7, #8]
    5dac:	607a      	str	r2, [r7, #4]
    5dae:	230f      	movs	r3, #15
    5db0:	18fb      	adds	r3, r7, r3
    5db2:	1c02      	adds	r2, r0, #0
    5db4:	701a      	strb	r2, [r3, #0]
	if (device_private_key_slot > 15 || challenge == NULL || response == NULL)
    5db6:	230f      	movs	r3, #15
    5db8:	18fb      	adds	r3, r7, r3
    5dba:	781b      	ldrb	r3, [r3, #0]
    5dbc:	2b0f      	cmp	r3, #15
    5dbe:	d805      	bhi.n	5dcc <atcacert_get_response+0x28>
    5dc0:	68bb      	ldr	r3, [r7, #8]
    5dc2:	2b00      	cmp	r3, #0
    5dc4:	d002      	beq.n	5dcc <atcacert_get_response+0x28>
    5dc6:	687b      	ldr	r3, [r7, #4]
    5dc8:	2b00      	cmp	r3, #0
    5dca:	d101      	bne.n	5dd0 <atcacert_get_response+0x2c>
		return ATCACERT_E_BAD_PARAMS;
    5dcc:	2302      	movs	r3, #2
    5dce:	e009      	b.n	5de4 <atcacert_get_response+0x40>

	return atcab_sign(device_private_key_slot, challenge, response);
    5dd0:	230f      	movs	r3, #15
    5dd2:	18fb      	adds	r3, r7, r3
    5dd4:	781b      	ldrb	r3, [r3, #0]
    5dd6:	b29b      	uxth	r3, r3
    5dd8:	687a      	ldr	r2, [r7, #4]
    5dda:	68b9      	ldr	r1, [r7, #8]
    5ddc:	0018      	movs	r0, r3
    5dde:	4b03      	ldr	r3, [pc, #12]	; (5dec <atcacert_get_response+0x48>)
    5de0:	4798      	blx	r3
    5de2:	0003      	movs	r3, r0
    5de4:	0018      	movs	r0, r3
    5de6:	46bd      	mov	sp, r7
    5de8:	b004      	add	sp, #16
    5dea:	bd80      	pop	{r7, pc}
    5dec:	0000c6b1 	.word	0x0000c6b1

00005df0 <atcacert_date_enc>:

int atcacert_date_enc( atcacert_date_format_t format,
                       const atcacert_tm_utc_t*  timestamp,
                       uint8_t*                  formatted_date,
                       size_t*                   formatted_date_size)
{
    5df0:	b580      	push	{r7, lr}
    5df2:	b084      	sub	sp, #16
    5df4:	af00      	add	r7, sp, #0
    5df6:	60b9      	str	r1, [r7, #8]
    5df8:	607a      	str	r2, [r7, #4]
    5dfa:	603b      	str	r3, [r7, #0]
    5dfc:	230f      	movs	r3, #15
    5dfe:	18fb      	adds	r3, r7, r3
    5e00:	1c02      	adds	r2, r0, #0
    5e02:	701a      	strb	r2, [r3, #0]
	if (timestamp == NULL || formatted_date_size == NULL || format < 0 || format >= sizeof(ATCACERT_DATE_FORMAT_SIZES) / sizeof(ATCACERT_DATE_FORMAT_SIZES[0]))
    5e04:	68bb      	ldr	r3, [r7, #8]
    5e06:	2b00      	cmp	r3, #0
    5e08:	d007      	beq.n	5e1a <atcacert_date_enc+0x2a>
    5e0a:	683b      	ldr	r3, [r7, #0]
    5e0c:	2b00      	cmp	r3, #0
    5e0e:	d004      	beq.n	5e1a <atcacert_date_enc+0x2a>
    5e10:	230f      	movs	r3, #15
    5e12:	18fb      	adds	r3, r7, r3
    5e14:	781b      	ldrb	r3, [r3, #0]
    5e16:	2b04      	cmp	r3, #4
    5e18:	d901      	bls.n	5e1e <atcacert_date_enc+0x2e>
		return ATCACERT_E_BAD_PARAMS;
    5e1a:	2302      	movs	r3, #2
    5e1c:	e056      	b.n	5ecc <atcacert_date_enc+0xdc>

	if (formatted_date != NULL && *formatted_date_size < ATCACERT_DATE_FORMAT_SIZES[format]) {
    5e1e:	687b      	ldr	r3, [r7, #4]
    5e20:	2b00      	cmp	r3, #0
    5e22:	d013      	beq.n	5e4c <atcacert_date_enc+0x5c>
    5e24:	683b      	ldr	r3, [r7, #0]
    5e26:	681a      	ldr	r2, [r3, #0]
    5e28:	230f      	movs	r3, #15
    5e2a:	18fb      	adds	r3, r7, r3
    5e2c:	7819      	ldrb	r1, [r3, #0]
    5e2e:	4b29      	ldr	r3, [pc, #164]	; (5ed4 <atcacert_date_enc+0xe4>)
    5e30:	0089      	lsls	r1, r1, #2
    5e32:	58cb      	ldr	r3, [r1, r3]
    5e34:	429a      	cmp	r2, r3
    5e36:	d209      	bcs.n	5e4c <atcacert_date_enc+0x5c>
		*formatted_date_size = ATCACERT_DATE_FORMAT_SIZES[format];
    5e38:	230f      	movs	r3, #15
    5e3a:	18fb      	adds	r3, r7, r3
    5e3c:	781a      	ldrb	r2, [r3, #0]
    5e3e:	4b25      	ldr	r3, [pc, #148]	; (5ed4 <atcacert_date_enc+0xe4>)
    5e40:	0092      	lsls	r2, r2, #2
    5e42:	58d2      	ldr	r2, [r2, r3]
    5e44:	683b      	ldr	r3, [r7, #0]
    5e46:	601a      	str	r2, [r3, #0]
		return ATCACERT_E_BUFFER_TOO_SMALL;
    5e48:	2303      	movs	r3, #3
    5e4a:	e03f      	b.n	5ecc <atcacert_date_enc+0xdc>
	}
	*formatted_date_size = ATCACERT_DATE_FORMAT_SIZES[format];
    5e4c:	230f      	movs	r3, #15
    5e4e:	18fb      	adds	r3, r7, r3
    5e50:	781a      	ldrb	r2, [r3, #0]
    5e52:	4b20      	ldr	r3, [pc, #128]	; (5ed4 <atcacert_date_enc+0xe4>)
    5e54:	0092      	lsls	r2, r2, #2
    5e56:	58d2      	ldr	r2, [r2, r3]
    5e58:	683b      	ldr	r3, [r7, #0]
    5e5a:	601a      	str	r2, [r3, #0]
	if (formatted_date == NULL)
    5e5c:	687b      	ldr	r3, [r7, #4]
    5e5e:	2b00      	cmp	r3, #0
    5e60:	d101      	bne.n	5e66 <atcacert_date_enc+0x76>
		return ATCACERT_E_SUCCESS; // Caller just wanted
    5e62:	2300      	movs	r3, #0
    5e64:	e032      	b.n	5ecc <atcacert_date_enc+0xdc>

	switch (format) {
    5e66:	230f      	movs	r3, #15
    5e68:	18fb      	adds	r3, r7, r3
    5e6a:	781b      	ldrb	r3, [r3, #0]
    5e6c:	2b04      	cmp	r3, #4
    5e6e:	d82c      	bhi.n	5eca <atcacert_date_enc+0xda>
    5e70:	009a      	lsls	r2, r3, #2
    5e72:	4b19      	ldr	r3, [pc, #100]	; (5ed8 <atcacert_date_enc+0xe8>)
    5e74:	18d3      	adds	r3, r2, r3
    5e76:	681b      	ldr	r3, [r3, #0]
    5e78:	469f      	mov	pc, r3
	case DATEFMT_ISO8601_SEP:     return atcacert_date_enc_iso8601_sep(timestamp, formatted_date);
    5e7a:	687a      	ldr	r2, [r7, #4]
    5e7c:	68bb      	ldr	r3, [r7, #8]
    5e7e:	0011      	movs	r1, r2
    5e80:	0018      	movs	r0, r3
    5e82:	4b16      	ldr	r3, [pc, #88]	; (5edc <atcacert_date_enc+0xec>)
    5e84:	4798      	blx	r3
    5e86:	0003      	movs	r3, r0
    5e88:	e020      	b.n	5ecc <atcacert_date_enc+0xdc>
	case DATEFMT_RFC5280_UTC:     return atcacert_date_enc_rfc5280_utc(timestamp, formatted_date);
    5e8a:	687a      	ldr	r2, [r7, #4]
    5e8c:	68bb      	ldr	r3, [r7, #8]
    5e8e:	0011      	movs	r1, r2
    5e90:	0018      	movs	r0, r3
    5e92:	4b13      	ldr	r3, [pc, #76]	; (5ee0 <atcacert_date_enc+0xf0>)
    5e94:	4798      	blx	r3
    5e96:	0003      	movs	r3, r0
    5e98:	e018      	b.n	5ecc <atcacert_date_enc+0xdc>
	case DATEFMT_POSIX_UINT32_BE: return atcacert_date_enc_posix_uint32_be(timestamp, formatted_date);
    5e9a:	687a      	ldr	r2, [r7, #4]
    5e9c:	68bb      	ldr	r3, [r7, #8]
    5e9e:	0011      	movs	r1, r2
    5ea0:	0018      	movs	r0, r3
    5ea2:	4b10      	ldr	r3, [pc, #64]	; (5ee4 <atcacert_date_enc+0xf4>)
    5ea4:	4798      	blx	r3
    5ea6:	0003      	movs	r3, r0
    5ea8:	e010      	b.n	5ecc <atcacert_date_enc+0xdc>
	case DATEFMT_POSIX_UINT32_LE: return atcacert_date_enc_posix_uint32_le(timestamp, formatted_date);
    5eaa:	687a      	ldr	r2, [r7, #4]
    5eac:	68bb      	ldr	r3, [r7, #8]
    5eae:	0011      	movs	r1, r2
    5eb0:	0018      	movs	r0, r3
    5eb2:	4b0d      	ldr	r3, [pc, #52]	; (5ee8 <atcacert_date_enc+0xf8>)
    5eb4:	4798      	blx	r3
    5eb6:	0003      	movs	r3, r0
    5eb8:	e008      	b.n	5ecc <atcacert_date_enc+0xdc>
	case DATEFMT_RFC5280_GEN:     return atcacert_date_enc_rfc5280_gen(timestamp, formatted_date);
    5eba:	687a      	ldr	r2, [r7, #4]
    5ebc:	68bb      	ldr	r3, [r7, #8]
    5ebe:	0011      	movs	r1, r2
    5ec0:	0018      	movs	r0, r3
    5ec2:	4b0a      	ldr	r3, [pc, #40]	; (5eec <atcacert_date_enc+0xfc>)
    5ec4:	4798      	blx	r3
    5ec6:	0003      	movs	r3, r0
    5ec8:	e000      	b.n	5ecc <atcacert_date_enc+0xdc>
	default: return ATCACERT_E_BAD_PARAMS;
    5eca:	2302      	movs	r3, #2
	}

	return ATCACERT_E_BAD_PARAMS;
}
    5ecc:	0018      	movs	r0, r3
    5ece:	46bd      	mov	sp, r7
    5ed0:	b004      	add	sp, #16
    5ed2:	bd80      	pop	{r7, pc}
    5ed4:	000151f8 	.word	0x000151f8
    5ed8:	0001520c 	.word	0x0001520c
    5edc:	00006255 	.word	0x00006255
    5ee0:	0000654d 	.word	0x0000654d
    5ee4:	00006ec1 	.word	0x00006ec1
    5ee8:	00006fb9 	.word	0x00006fb9
    5eec:	00006825 	.word	0x00006825

00005ef0 <atcacert_date_dec>:

int atcacert_date_dec( atcacert_date_format_t format,
                       const uint8_t*          formatted_date,
                       size_t formatted_date_size,
                       atcacert_tm_utc_t*      timestamp)
{
    5ef0:	b580      	push	{r7, lr}
    5ef2:	b084      	sub	sp, #16
    5ef4:	af00      	add	r7, sp, #0
    5ef6:	60b9      	str	r1, [r7, #8]
    5ef8:	607a      	str	r2, [r7, #4]
    5efa:	603b      	str	r3, [r7, #0]
    5efc:	230f      	movs	r3, #15
    5efe:	18fb      	adds	r3, r7, r3
    5f00:	1c02      	adds	r2, r0, #0
    5f02:	701a      	strb	r2, [r3, #0]
	if (formatted_date == NULL || timestamp == NULL || format < 0 || format >= sizeof(ATCACERT_DATE_FORMAT_SIZES) / sizeof(ATCACERT_DATE_FORMAT_SIZES[0]))
    5f04:	68bb      	ldr	r3, [r7, #8]
    5f06:	2b00      	cmp	r3, #0
    5f08:	d007      	beq.n	5f1a <atcacert_date_dec+0x2a>
    5f0a:	683b      	ldr	r3, [r7, #0]
    5f0c:	2b00      	cmp	r3, #0
    5f0e:	d004      	beq.n	5f1a <atcacert_date_dec+0x2a>
    5f10:	230f      	movs	r3, #15
    5f12:	18fb      	adds	r3, r7, r3
    5f14:	781b      	ldrb	r3, [r3, #0]
    5f16:	2b04      	cmp	r3, #4
    5f18:	d901      	bls.n	5f1e <atcacert_date_dec+0x2e>
		return ATCACERT_E_BAD_PARAMS;
    5f1a:	2302      	movs	r3, #2
    5f1c:	e03d      	b.n	5f9a <atcacert_date_dec+0xaa>

	if (formatted_date_size < ATCACERT_DATE_FORMAT_SIZES[format])
    5f1e:	230f      	movs	r3, #15
    5f20:	18fb      	adds	r3, r7, r3
    5f22:	781a      	ldrb	r2, [r3, #0]
    5f24:	4b1f      	ldr	r3, [pc, #124]	; (5fa4 <atcacert_date_dec+0xb4>)
    5f26:	0092      	lsls	r2, r2, #2
    5f28:	58d2      	ldr	r2, [r2, r3]
    5f2a:	687b      	ldr	r3, [r7, #4]
    5f2c:	429a      	cmp	r2, r3
    5f2e:	d901      	bls.n	5f34 <atcacert_date_dec+0x44>
		return ATCACERT_E_DECODING_ERROR; // Not enough data to parse this date format
    5f30:	2304      	movs	r3, #4
    5f32:	e032      	b.n	5f9a <atcacert_date_dec+0xaa>

	switch (format) {
    5f34:	230f      	movs	r3, #15
    5f36:	18fb      	adds	r3, r7, r3
    5f38:	781b      	ldrb	r3, [r3, #0]
    5f3a:	2b04      	cmp	r3, #4
    5f3c:	d82c      	bhi.n	5f98 <atcacert_date_dec+0xa8>
    5f3e:	009a      	lsls	r2, r3, #2
    5f40:	4b19      	ldr	r3, [pc, #100]	; (5fa8 <atcacert_date_dec+0xb8>)
    5f42:	18d3      	adds	r3, r2, r3
    5f44:	681b      	ldr	r3, [r3, #0]
    5f46:	469f      	mov	pc, r3
	case DATEFMT_ISO8601_SEP:     return atcacert_date_dec_iso8601_sep(formatted_date, timestamp);
    5f48:	683a      	ldr	r2, [r7, #0]
    5f4a:	68bb      	ldr	r3, [r7, #8]
    5f4c:	0011      	movs	r1, r2
    5f4e:	0018      	movs	r0, r3
    5f50:	4b16      	ldr	r3, [pc, #88]	; (5fac <atcacert_date_dec+0xbc>)
    5f52:	4798      	blx	r3
    5f54:	0003      	movs	r3, r0
    5f56:	e020      	b.n	5f9a <atcacert_date_dec+0xaa>
	case DATEFMT_RFC5280_UTC:     return atcacert_date_dec_rfc5280_utc(formatted_date, timestamp);
    5f58:	683a      	ldr	r2, [r7, #0]
    5f5a:	68bb      	ldr	r3, [r7, #8]
    5f5c:	0011      	movs	r1, r2
    5f5e:	0018      	movs	r0, r3
    5f60:	4b13      	ldr	r3, [pc, #76]	; (5fb0 <atcacert_date_dec+0xc0>)
    5f62:	4798      	blx	r3
    5f64:	0003      	movs	r3, r0
    5f66:	e018      	b.n	5f9a <atcacert_date_dec+0xaa>
	case DATEFMT_POSIX_UINT32_BE: return atcacert_date_dec_posix_uint32_be(formatted_date, timestamp);
    5f68:	683a      	ldr	r2, [r7, #0]
    5f6a:	68bb      	ldr	r3, [r7, #8]
    5f6c:	0011      	movs	r1, r2
    5f6e:	0018      	movs	r0, r3
    5f70:	4b10      	ldr	r3, [pc, #64]	; (5fb4 <atcacert_date_dec+0xc4>)
    5f72:	4798      	blx	r3
    5f74:	0003      	movs	r3, r0
    5f76:	e010      	b.n	5f9a <atcacert_date_dec+0xaa>
	case DATEFMT_POSIX_UINT32_LE: return atcacert_date_dec_posix_uint32_le(formatted_date, timestamp);
    5f78:	683a      	ldr	r2, [r7, #0]
    5f7a:	68bb      	ldr	r3, [r7, #8]
    5f7c:	0011      	movs	r1, r2
    5f7e:	0018      	movs	r0, r3
    5f80:	4b0d      	ldr	r3, [pc, #52]	; (5fb8 <atcacert_date_dec+0xc8>)
    5f82:	4798      	blx	r3
    5f84:	0003      	movs	r3, r0
    5f86:	e008      	b.n	5f9a <atcacert_date_dec+0xaa>
	case DATEFMT_RFC5280_GEN:     return atcacert_date_dec_rfc5280_gen(formatted_date, timestamp);
    5f88:	683a      	ldr	r2, [r7, #0]
    5f8a:	68bb      	ldr	r3, [r7, #8]
    5f8c:	0011      	movs	r1, r2
    5f8e:	0018      	movs	r0, r3
    5f90:	4b0a      	ldr	r3, [pc, #40]	; (5fbc <atcacert_date_dec+0xcc>)
    5f92:	4798      	blx	r3
    5f94:	0003      	movs	r3, r0
    5f96:	e000      	b.n	5f9a <atcacert_date_dec+0xaa>
	default: return ATCACERT_E_BAD_PARAMS;
    5f98:	2302      	movs	r3, #2
	}

	return ATCACERT_E_SUCCESS;
}
    5f9a:	0018      	movs	r0, r3
    5f9c:	46bd      	mov	sp, r7
    5f9e:	b004      	add	sp, #16
    5fa0:	bd80      	pop	{r7, pc}
    5fa2:	46c0      	nop			; (mov r8, r8)
    5fa4:	000151f8 	.word	0x000151f8
    5fa8:	00015220 	.word	0x00015220
    5fac:	000063c1 	.word	0x000063c1
    5fb0:	000066c1 	.word	0x000066c1
    5fb4:	00006f5d 	.word	0x00006f5d
    5fb8:	00007031 	.word	0x00007031
    5fbc:	00006961 	.word	0x00006961

00005fc0 <atcacert_date_get_max_date>:

int atcacert_date_get_max_date( atcacert_date_format_t format, atcacert_tm_utc_t* timestamp )
{
    5fc0:	b580      	push	{r7, lr}
    5fc2:	b082      	sub	sp, #8
    5fc4:	af00      	add	r7, sp, #0
    5fc6:	0002      	movs	r2, r0
    5fc8:	6039      	str	r1, [r7, #0]
    5fca:	1dfb      	adds	r3, r7, #7
    5fcc:	701a      	strb	r2, [r3, #0]

	if (timestamp == NULL || format < 0 || format >= sizeof(ATCACERT_DATE_FORMAT_SIZES) / sizeof(ATCACERT_DATE_FORMAT_SIZES[0]))
    5fce:	683b      	ldr	r3, [r7, #0]
    5fd0:	2b00      	cmp	r3, #0
    5fd2:	d003      	beq.n	5fdc <atcacert_date_get_max_date+0x1c>
    5fd4:	1dfb      	adds	r3, r7, #7
    5fd6:	781b      	ldrb	r3, [r3, #0]
    5fd8:	2b04      	cmp	r3, #4
    5fda:	d901      	bls.n	5fe0 <atcacert_date_get_max_date+0x20>
		return ATCACERT_E_BAD_PARAMS;
    5fdc:	2302      	movs	r3, #2
    5fde:	e06a      	b.n	60b6 <atcacert_date_get_max_date+0xf6>

	switch (format) {
    5fe0:	1dfb      	adds	r3, r7, #7
    5fe2:	781b      	ldrb	r3, [r3, #0]
    5fe4:	2b04      	cmp	r3, #4
    5fe6:	d863      	bhi.n	60b0 <atcacert_date_get_max_date+0xf0>
    5fe8:	009a      	lsls	r2, r3, #2
    5fea:	4b35      	ldr	r3, [pc, #212]	; (60c0 <atcacert_date_get_max_date+0x100>)
    5fec:	18d3      	adds	r3, r2, r3
    5fee:	681b      	ldr	r3, [r3, #0]
    5ff0:	469f      	mov	pc, r3
	case DATEFMT_ISO8601_SEP:
		timestamp->tm_year = 9999 - 1900;
    5ff2:	683b      	ldr	r3, [r7, #0]
    5ff4:	4a33      	ldr	r2, [pc, #204]	; (60c4 <atcacert_date_get_max_date+0x104>)
    5ff6:	615a      	str	r2, [r3, #20]
		timestamp->tm_mon  = 12 - 1;
    5ff8:	683b      	ldr	r3, [r7, #0]
    5ffa:	220b      	movs	r2, #11
    5ffc:	611a      	str	r2, [r3, #16]
		timestamp->tm_mday = 31;
    5ffe:	683b      	ldr	r3, [r7, #0]
    6000:	221f      	movs	r2, #31
    6002:	60da      	str	r2, [r3, #12]
		timestamp->tm_hour = 23;
    6004:	683b      	ldr	r3, [r7, #0]
    6006:	2217      	movs	r2, #23
    6008:	609a      	str	r2, [r3, #8]
		timestamp->tm_min  = 59;
    600a:	683b      	ldr	r3, [r7, #0]
    600c:	223b      	movs	r2, #59	; 0x3b
    600e:	605a      	str	r2, [r3, #4]
		timestamp->tm_sec  = 59;
    6010:	683b      	ldr	r3, [r7, #0]
    6012:	223b      	movs	r2, #59	; 0x3b
    6014:	601a      	str	r2, [r3, #0]
		break;
    6016:	e04d      	b.n	60b4 <atcacert_date_get_max_date+0xf4>

	case DATEFMT_RFC5280_UTC:
		timestamp->tm_year = 2049 - 1900;
    6018:	683b      	ldr	r3, [r7, #0]
    601a:	2295      	movs	r2, #149	; 0x95
    601c:	615a      	str	r2, [r3, #20]
		timestamp->tm_mon  = 12 - 1;
    601e:	683b      	ldr	r3, [r7, #0]
    6020:	220b      	movs	r2, #11
    6022:	611a      	str	r2, [r3, #16]
		timestamp->tm_mday = 31;
    6024:	683b      	ldr	r3, [r7, #0]
    6026:	221f      	movs	r2, #31
    6028:	60da      	str	r2, [r3, #12]
		timestamp->tm_hour = 23;
    602a:	683b      	ldr	r3, [r7, #0]
    602c:	2217      	movs	r2, #23
    602e:	609a      	str	r2, [r3, #8]
		timestamp->tm_min  = 59;
    6030:	683b      	ldr	r3, [r7, #0]
    6032:	223b      	movs	r2, #59	; 0x3b
    6034:	605a      	str	r2, [r3, #4]
		timestamp->tm_sec  = 59;
    6036:	683b      	ldr	r3, [r7, #0]
    6038:	223b      	movs	r2, #59	; 0x3b
    603a:	601a      	str	r2, [r3, #0]
		break;
    603c:	e03a      	b.n	60b4 <atcacert_date_get_max_date+0xf4>

	case DATEFMT_POSIX_UINT32_BE:
		timestamp->tm_year = 2106 - 1900;
    603e:	683b      	ldr	r3, [r7, #0]
    6040:	22ce      	movs	r2, #206	; 0xce
    6042:	615a      	str	r2, [r3, #20]
		timestamp->tm_mon  = 2 - 1;
    6044:	683b      	ldr	r3, [r7, #0]
    6046:	2201      	movs	r2, #1
    6048:	611a      	str	r2, [r3, #16]
		timestamp->tm_mday = 7;
    604a:	683b      	ldr	r3, [r7, #0]
    604c:	2207      	movs	r2, #7
    604e:	60da      	str	r2, [r3, #12]
		timestamp->tm_hour = 6;
    6050:	683b      	ldr	r3, [r7, #0]
    6052:	2206      	movs	r2, #6
    6054:	609a      	str	r2, [r3, #8]
		timestamp->tm_min  = 28;
    6056:	683b      	ldr	r3, [r7, #0]
    6058:	221c      	movs	r2, #28
    605a:	605a      	str	r2, [r3, #4]
		timestamp->tm_sec  = 15;
    605c:	683b      	ldr	r3, [r7, #0]
    605e:	220f      	movs	r2, #15
    6060:	601a      	str	r2, [r3, #0]
		break;
    6062:	e027      	b.n	60b4 <atcacert_date_get_max_date+0xf4>

	case DATEFMT_POSIX_UINT32_LE:
		timestamp->tm_year = 2106 - 1900;
    6064:	683b      	ldr	r3, [r7, #0]
    6066:	22ce      	movs	r2, #206	; 0xce
    6068:	615a      	str	r2, [r3, #20]
		timestamp->tm_mon  = 2 - 1;
    606a:	683b      	ldr	r3, [r7, #0]
    606c:	2201      	movs	r2, #1
    606e:	611a      	str	r2, [r3, #16]
		timestamp->tm_mday = 7;
    6070:	683b      	ldr	r3, [r7, #0]
    6072:	2207      	movs	r2, #7
    6074:	60da      	str	r2, [r3, #12]
		timestamp->tm_hour = 6;
    6076:	683b      	ldr	r3, [r7, #0]
    6078:	2206      	movs	r2, #6
    607a:	609a      	str	r2, [r3, #8]
		timestamp->tm_min  = 28;
    607c:	683b      	ldr	r3, [r7, #0]
    607e:	221c      	movs	r2, #28
    6080:	605a      	str	r2, [r3, #4]
		timestamp->tm_sec  = 15;
    6082:	683b      	ldr	r3, [r7, #0]
    6084:	220f      	movs	r2, #15
    6086:	601a      	str	r2, [r3, #0]
		break;
    6088:	e014      	b.n	60b4 <atcacert_date_get_max_date+0xf4>

	case DATEFMT_RFC5280_GEN:
		timestamp->tm_year = 9999 - 1900;
    608a:	683b      	ldr	r3, [r7, #0]
    608c:	4a0d      	ldr	r2, [pc, #52]	; (60c4 <atcacert_date_get_max_date+0x104>)
    608e:	615a      	str	r2, [r3, #20]
		timestamp->tm_mon  = 12 - 1;
    6090:	683b      	ldr	r3, [r7, #0]
    6092:	220b      	movs	r2, #11
    6094:	611a      	str	r2, [r3, #16]
		timestamp->tm_mday = 31;
    6096:	683b      	ldr	r3, [r7, #0]
    6098:	221f      	movs	r2, #31
    609a:	60da      	str	r2, [r3, #12]
		timestamp->tm_hour = 23;
    609c:	683b      	ldr	r3, [r7, #0]
    609e:	2217      	movs	r2, #23
    60a0:	609a      	str	r2, [r3, #8]
		timestamp->tm_min  = 59;
    60a2:	683b      	ldr	r3, [r7, #0]
    60a4:	223b      	movs	r2, #59	; 0x3b
    60a6:	605a      	str	r2, [r3, #4]
		timestamp->tm_sec  = 59;
    60a8:	683b      	ldr	r3, [r7, #0]
    60aa:	223b      	movs	r2, #59	; 0x3b
    60ac:	601a      	str	r2, [r3, #0]
		break;
    60ae:	e001      	b.n	60b4 <atcacert_date_get_max_date+0xf4>

	default: return ATCACERT_E_BAD_PARAMS;
    60b0:	2302      	movs	r3, #2
    60b2:	e000      	b.n	60b6 <atcacert_date_get_max_date+0xf6>
	}

	return ATCACERT_E_SUCCESS;
    60b4:	2300      	movs	r3, #0
}
    60b6:	0018      	movs	r0, r3
    60b8:	46bd      	mov	sp, r7
    60ba:	b002      	add	sp, #8
    60bc:	bd80      	pop	{r7, pc}
    60be:	46c0      	nop			; (mov r8, r8)
    60c0:	00015234 	.word	0x00015234
    60c4:	00001fa3 	.word	0x00001fa3

000060c8 <uint_to_str>:

/**
 * \brief Convert an unsigned integer to a zero padded string with no terminating null.
 */
static uint8_t* uint_to_str(uint32_t num, int width, uint8_t* str)
{
    60c8:	b580      	push	{r7, lr}
    60ca:	b086      	sub	sp, #24
    60cc:	af00      	add	r7, sp, #0
    60ce:	60f8      	str	r0, [r7, #12]
    60d0:	60b9      	str	r1, [r7, #8]
    60d2:	607a      	str	r2, [r7, #4]
	uint8_t* ret = str + width;
    60d4:	68bb      	ldr	r3, [r7, #8]
    60d6:	687a      	ldr	r2, [r7, #4]
    60d8:	18d3      	adds	r3, r2, r3
    60da:	613b      	str	r3, [r7, #16]
	int i;

	// Pre-fill the string width with zeros
	for (i = 0; i < width; i++)
    60dc:	2300      	movs	r3, #0
    60de:	617b      	str	r3, [r7, #20]
    60e0:	e007      	b.n	60f2 <uint_to_str+0x2a>
		*(str++) = '0';
    60e2:	687b      	ldr	r3, [r7, #4]
    60e4:	1c5a      	adds	r2, r3, #1
    60e6:	607a      	str	r2, [r7, #4]
    60e8:	2230      	movs	r2, #48	; 0x30
    60ea:	701a      	strb	r2, [r3, #0]
{
	uint8_t* ret = str + width;
	int i;

	// Pre-fill the string width with zeros
	for (i = 0; i < width; i++)
    60ec:	697b      	ldr	r3, [r7, #20]
    60ee:	3301      	adds	r3, #1
    60f0:	617b      	str	r3, [r7, #20]
    60f2:	697a      	ldr	r2, [r7, #20]
    60f4:	68bb      	ldr	r3, [r7, #8]
    60f6:	429a      	cmp	r2, r3
    60f8:	dbf3      	blt.n	60e2 <uint_to_str+0x1a>
		*(str++) = '0';
	// Convert the number from right to left
	for (; num; num /= 10)
    60fa:	e014      	b.n	6126 <uint_to_str+0x5e>
		*(--str) = '0' + (num % 10);
    60fc:	687b      	ldr	r3, [r7, #4]
    60fe:	3b01      	subs	r3, #1
    6100:	607b      	str	r3, [r7, #4]
    6102:	68fa      	ldr	r2, [r7, #12]
    6104:	4b0c      	ldr	r3, [pc, #48]	; (6138 <uint_to_str+0x70>)
    6106:	210a      	movs	r1, #10
    6108:	0010      	movs	r0, r2
    610a:	4798      	blx	r3
    610c:	000b      	movs	r3, r1
    610e:	b2db      	uxtb	r3, r3
    6110:	3330      	adds	r3, #48	; 0x30
    6112:	b2da      	uxtb	r2, r3
    6114:	687b      	ldr	r3, [r7, #4]
    6116:	701a      	strb	r2, [r3, #0]

	// Pre-fill the string width with zeros
	for (i = 0; i < width; i++)
		*(str++) = '0';
	// Convert the number from right to left
	for (; num; num /= 10)
    6118:	68fa      	ldr	r2, [r7, #12]
    611a:	4b08      	ldr	r3, [pc, #32]	; (613c <uint_to_str+0x74>)
    611c:	210a      	movs	r1, #10
    611e:	0010      	movs	r0, r2
    6120:	4798      	blx	r3
    6122:	0003      	movs	r3, r0
    6124:	60fb      	str	r3, [r7, #12]
    6126:	68fb      	ldr	r3, [r7, #12]
    6128:	2b00      	cmp	r3, #0
    612a:	d1e7      	bne.n	60fc <uint_to_str+0x34>
		*(--str) = '0' + (num % 10);

	return ret;
    612c:	693b      	ldr	r3, [r7, #16]
}
    612e:	0018      	movs	r0, r3
    6130:	46bd      	mov	sp, r7
    6132:	b006      	add	sp, #24
    6134:	bd80      	pop	{r7, pc}
    6136:	46c0      	nop			; (mov r8, r8)
    6138:	000122c9 	.word	0x000122c9
    613c:	000121bd 	.word	0x000121bd

00006140 <str_to_uint>:

/**
 * \brief Convert a number string as a zero padded unsigned integer back into a number
 */
static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)
{
    6140:	b580      	push	{r7, lr}
    6142:	b08a      	sub	sp, #40	; 0x28
    6144:	af00      	add	r7, sp, #0
    6146:	60f8      	str	r0, [r7, #12]
    6148:	60b9      	str	r1, [r7, #8]
    614a:	607a      	str	r2, [r7, #4]
	const uint8_t* error_ret = str;
    614c:	68fb      	ldr	r3, [r7, #12]
    614e:	61bb      	str	r3, [r7, #24]
	const uint8_t* good_ret = str + width;
    6150:	68bb      	ldr	r3, [r7, #8]
    6152:	68fa      	ldr	r2, [r7, #12]
    6154:	18d3      	adds	r3, r2, r3
    6156:	617b      	str	r3, [r7, #20]
	uint32_t prev_num = 0;
    6158:	2300      	movs	r3, #0
    615a:	627b      	str	r3, [r7, #36]	; 0x24
	uint32_t digit_value = 1;
    615c:	2301      	movs	r3, #1
    615e:	623b      	str	r3, [r7, #32]
	int digit;

	str += width - 1;
    6160:	68bb      	ldr	r3, [r7, #8]
    6162:	3b01      	subs	r3, #1
    6164:	68fa      	ldr	r2, [r7, #12]
    6166:	18d3      	adds	r3, r2, r3
    6168:	60fb      	str	r3, [r7, #12]
	*num = 0;
    616a:	687b      	ldr	r3, [r7, #4]
    616c:	2200      	movs	r2, #0
    616e:	601a      	str	r2, [r3, #0]
	for (digit = 0; digit < width; digit++) {
    6170:	2300      	movs	r3, #0
    6172:	61fb      	str	r3, [r7, #28]
    6174:	e03e      	b.n	61f4 <str_to_uint+0xb4>
		if (*str < '0' || *str > '9')
    6176:	68fb      	ldr	r3, [r7, #12]
    6178:	781b      	ldrb	r3, [r3, #0]
    617a:	2b2f      	cmp	r3, #47	; 0x2f
    617c:	d903      	bls.n	6186 <str_to_uint+0x46>
    617e:	68fb      	ldr	r3, [r7, #12]
    6180:	781b      	ldrb	r3, [r3, #0]
    6182:	2b39      	cmp	r3, #57	; 0x39
    6184:	d901      	bls.n	618a <str_to_uint+0x4a>
			return error_ret; // Character is not a digit
    6186:	69bb      	ldr	r3, [r7, #24]
    6188:	e039      	b.n	61fe <str_to_uint+0xbe>
		if (digit >= 10) {
    618a:	69fb      	ldr	r3, [r7, #28]
    618c:	2b09      	cmp	r3, #9
    618e:	dd05      	ble.n	619c <str_to_uint+0x5c>
			if (*str != '0')
    6190:	68fb      	ldr	r3, [r7, #12]
    6192:	781b      	ldrb	r3, [r3, #0]
    6194:	2b30      	cmp	r3, #48	; 0x30
    6196:	d029      	beq.n	61ec <str_to_uint+0xac>
				return error_ret; // Number is larger than the output can handle
    6198:	69bb      	ldr	r3, [r7, #24]
    619a:	e030      	b.n	61fe <str_to_uint+0xbe>
			continue;
		}
		if (digit == 9 && *str > '4')
    619c:	69fb      	ldr	r3, [r7, #28]
    619e:	2b09      	cmp	r3, #9
    61a0:	d105      	bne.n	61ae <str_to_uint+0x6e>
    61a2:	68fb      	ldr	r3, [r7, #12]
    61a4:	781b      	ldrb	r3, [r3, #0]
    61a6:	2b34      	cmp	r3, #52	; 0x34
    61a8:	d901      	bls.n	61ae <str_to_uint+0x6e>
			return error_ret; // Number is larger than the output can handle
    61aa:	69bb      	ldr	r3, [r7, #24]
    61ac:	e027      	b.n	61fe <str_to_uint+0xbe>

		*num += digit_value * (*str - '0');
    61ae:	687b      	ldr	r3, [r7, #4]
    61b0:	681a      	ldr	r2, [r3, #0]
    61b2:	68fb      	ldr	r3, [r7, #12]
    61b4:	781b      	ldrb	r3, [r3, #0]
    61b6:	3b30      	subs	r3, #48	; 0x30
    61b8:	0019      	movs	r1, r3
    61ba:	6a3b      	ldr	r3, [r7, #32]
    61bc:	434b      	muls	r3, r1
    61be:	18d2      	adds	r2, r2, r3
    61c0:	687b      	ldr	r3, [r7, #4]
    61c2:	601a      	str	r2, [r3, #0]
		if (*num < prev_num)
    61c4:	687b      	ldr	r3, [r7, #4]
    61c6:	681a      	ldr	r2, [r3, #0]
    61c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    61ca:	429a      	cmp	r2, r3
    61cc:	d201      	bcs.n	61d2 <str_to_uint+0x92>
			return error_ret; // Number rolled over, it is larger than the output can handle
    61ce:	69bb      	ldr	r3, [r7, #24]
    61d0:	e015      	b.n	61fe <str_to_uint+0xbe>

		digit_value *= 10;
    61d2:	6a3a      	ldr	r2, [r7, #32]
    61d4:	0013      	movs	r3, r2
    61d6:	009b      	lsls	r3, r3, #2
    61d8:	189b      	adds	r3, r3, r2
    61da:	005b      	lsls	r3, r3, #1
    61dc:	623b      	str	r3, [r7, #32]
		prev_num = *num;
    61de:	687b      	ldr	r3, [r7, #4]
    61e0:	681b      	ldr	r3, [r3, #0]
    61e2:	627b      	str	r3, [r7, #36]	; 0x24
		str--;
    61e4:	68fb      	ldr	r3, [r7, #12]
    61e6:	3b01      	subs	r3, #1
    61e8:	60fb      	str	r3, [r7, #12]
    61ea:	e000      	b.n	61ee <str_to_uint+0xae>
		if (*str < '0' || *str > '9')
			return error_ret; // Character is not a digit
		if (digit >= 10) {
			if (*str != '0')
				return error_ret; // Number is larger than the output can handle
			continue;
    61ec:	46c0      	nop			; (mov r8, r8)
	uint32_t digit_value = 1;
	int digit;

	str += width - 1;
	*num = 0;
	for (digit = 0; digit < width; digit++) {
    61ee:	69fb      	ldr	r3, [r7, #28]
    61f0:	3301      	adds	r3, #1
    61f2:	61fb      	str	r3, [r7, #28]
    61f4:	69fa      	ldr	r2, [r7, #28]
    61f6:	68bb      	ldr	r3, [r7, #8]
    61f8:	429a      	cmp	r2, r3
    61fa:	dbbc      	blt.n	6176 <str_to_uint+0x36>
		digit_value *= 10;
		prev_num = *num;
		str--;
	}

	return good_ret;
    61fc:	697b      	ldr	r3, [r7, #20]
}
    61fe:	0018      	movs	r0, r3
    6200:	46bd      	mov	sp, r7
    6202:	b00a      	add	sp, #40	; 0x28
    6204:	bd80      	pop	{r7, pc}
    6206:	46c0      	nop			; (mov r8, r8)

00006208 <str_to_int>:
/**
 * \brief Convert a number string as a zero padded unsigned integer back into a number constrained
 *        to an integer's size.
 */
static const uint8_t* str_to_int(const uint8_t* str, int width, int* num)
{
    6208:	b580      	push	{r7, lr}
    620a:	b086      	sub	sp, #24
    620c:	af00      	add	r7, sp, #0
    620e:	60f8      	str	r0, [r7, #12]
    6210:	60b9      	str	r1, [r7, #8]
    6212:	607a      	str	r2, [r7, #4]
	uint32_t unum = 0;
    6214:	2300      	movs	r3, #0
    6216:	613b      	str	r3, [r7, #16]
	const uint8_t* ret = str_to_uint(str, width, &unum);
    6218:	2310      	movs	r3, #16
    621a:	18fa      	adds	r2, r7, r3
    621c:	68b9      	ldr	r1, [r7, #8]
    621e:	68fb      	ldr	r3, [r7, #12]
    6220:	0018      	movs	r0, r3
    6222:	4b0b      	ldr	r3, [pc, #44]	; (6250 <str_to_int+0x48>)
    6224:	4798      	blx	r3
    6226:	0003      	movs	r3, r0
    6228:	617b      	str	r3, [r7, #20]

	if (ret != str && unum > 2147483647UL)
    622a:	697a      	ldr	r2, [r7, #20]
    622c:	68fb      	ldr	r3, [r7, #12]
    622e:	429a      	cmp	r2, r3
    6230:	d004      	beq.n	623c <str_to_int+0x34>
    6232:	693b      	ldr	r3, [r7, #16]
    6234:	2b00      	cmp	r3, #0
    6236:	da01      	bge.n	623c <str_to_int+0x34>
		ret = str; // Number exceeds int32's range
    6238:	68fb      	ldr	r3, [r7, #12]
    623a:	617b      	str	r3, [r7, #20]
	*num = (int)unum;
    623c:	693b      	ldr	r3, [r7, #16]
    623e:	001a      	movs	r2, r3
    6240:	687b      	ldr	r3, [r7, #4]
    6242:	601a      	str	r2, [r3, #0]
	return ret;
    6244:	697b      	ldr	r3, [r7, #20]
}
    6246:	0018      	movs	r0, r3
    6248:	46bd      	mov	sp, r7
    624a:	b006      	add	sp, #24
    624c:	bd80      	pop	{r7, pc}
    624e:	46c0      	nop			; (mov r8, r8)
    6250:	00006141 	.word	0x00006141

00006254 <atcacert_date_enc_iso8601_sep>:

int atcacert_date_enc_iso8601_sep( const atcacert_tm_utc_t*  timestamp,
                                   uint8_t formatted_date[DATEFMT_ISO8601_SEP_SIZE])
{
    6254:	b580      	push	{r7, lr}
    6256:	b084      	sub	sp, #16
    6258:	af00      	add	r7, sp, #0
    625a:	6078      	str	r0, [r7, #4]
    625c:	6039      	str	r1, [r7, #0]
	uint8_t* cur_pos = formatted_date;
    625e:	683b      	ldr	r3, [r7, #0]
    6260:	60fb      	str	r3, [r7, #12]
	int year = 0;
    6262:	2300      	movs	r3, #0
    6264:	60bb      	str	r3, [r7, #8]

	if (timestamp == NULL || formatted_date == NULL)
    6266:	687b      	ldr	r3, [r7, #4]
    6268:	2b00      	cmp	r3, #0
    626a:	d002      	beq.n	6272 <atcacert_date_enc_iso8601_sep+0x1e>
    626c:	683b      	ldr	r3, [r7, #0]
    626e:	2b00      	cmp	r3, #0
    6270:	d101      	bne.n	6276 <atcacert_date_enc_iso8601_sep+0x22>
		return ATCACERT_E_BAD_PARAMS;
    6272:	2302      	movs	r3, #2
    6274:	e09a      	b.n	63ac <atcacert_date_enc_iso8601_sep+0x158>

	year = timestamp->tm_year + 1900;
    6276:	687b      	ldr	r3, [r7, #4]
    6278:	695b      	ldr	r3, [r3, #20]
    627a:	4a4e      	ldr	r2, [pc, #312]	; (63b4 <atcacert_date_enc_iso8601_sep+0x160>)
    627c:	4694      	mov	ip, r2
    627e:	4463      	add	r3, ip
    6280:	60bb      	str	r3, [r7, #8]

	if (year < 0 || year > 9999)
    6282:	68bb      	ldr	r3, [r7, #8]
    6284:	2b00      	cmp	r3, #0
    6286:	db03      	blt.n	6290 <atcacert_date_enc_iso8601_sep+0x3c>
    6288:	68bb      	ldr	r3, [r7, #8]
    628a:	4a4b      	ldr	r2, [pc, #300]	; (63b8 <atcacert_date_enc_iso8601_sep+0x164>)
    628c:	4293      	cmp	r3, r2
    628e:	dd01      	ble.n	6294 <atcacert_date_enc_iso8601_sep+0x40>
		return ATCACERT_E_INVALID_DATE;
    6290:	2305      	movs	r3, #5
    6292:	e08b      	b.n	63ac <atcacert_date_enc_iso8601_sep+0x158>
	cur_pos = uint_to_str(year, 4, cur_pos);
    6294:	68bb      	ldr	r3, [r7, #8]
    6296:	68fa      	ldr	r2, [r7, #12]
    6298:	2104      	movs	r1, #4
    629a:	0018      	movs	r0, r3
    629c:	4b47      	ldr	r3, [pc, #284]	; (63bc <atcacert_date_enc_iso8601_sep+0x168>)
    629e:	4798      	blx	r3
    62a0:	0003      	movs	r3, r0
    62a2:	60fb      	str	r3, [r7, #12]

	*(cur_pos++) = '-';
    62a4:	68fb      	ldr	r3, [r7, #12]
    62a6:	1c5a      	adds	r2, r3, #1
    62a8:	60fa      	str	r2, [r7, #12]
    62aa:	222d      	movs	r2, #45	; 0x2d
    62ac:	701a      	strb	r2, [r3, #0]

	if (timestamp->tm_mon < 0 || timestamp->tm_mon > 11)
    62ae:	687b      	ldr	r3, [r7, #4]
    62b0:	691b      	ldr	r3, [r3, #16]
    62b2:	2b00      	cmp	r3, #0
    62b4:	db03      	blt.n	62be <atcacert_date_enc_iso8601_sep+0x6a>
    62b6:	687b      	ldr	r3, [r7, #4]
    62b8:	691b      	ldr	r3, [r3, #16]
    62ba:	2b0b      	cmp	r3, #11
    62bc:	dd01      	ble.n	62c2 <atcacert_date_enc_iso8601_sep+0x6e>
		return ATCACERT_E_INVALID_DATE;
    62be:	2305      	movs	r3, #5
    62c0:	e074      	b.n	63ac <atcacert_date_enc_iso8601_sep+0x158>
	cur_pos = uint_to_str(timestamp->tm_mon + 1, 2, cur_pos);
    62c2:	687b      	ldr	r3, [r7, #4]
    62c4:	691b      	ldr	r3, [r3, #16]
    62c6:	3301      	adds	r3, #1
    62c8:	0018      	movs	r0, r3
    62ca:	68fb      	ldr	r3, [r7, #12]
    62cc:	001a      	movs	r2, r3
    62ce:	2102      	movs	r1, #2
    62d0:	4b3a      	ldr	r3, [pc, #232]	; (63bc <atcacert_date_enc_iso8601_sep+0x168>)
    62d2:	4798      	blx	r3
    62d4:	0003      	movs	r3, r0
    62d6:	60fb      	str	r3, [r7, #12]

	*(cur_pos++) = '-';
    62d8:	68fb      	ldr	r3, [r7, #12]
    62da:	1c5a      	adds	r2, r3, #1
    62dc:	60fa      	str	r2, [r7, #12]
    62de:	222d      	movs	r2, #45	; 0x2d
    62e0:	701a      	strb	r2, [r3, #0]

	if (timestamp->tm_mday < 1 || timestamp->tm_mday > 31)
    62e2:	687b      	ldr	r3, [r7, #4]
    62e4:	68db      	ldr	r3, [r3, #12]
    62e6:	2b00      	cmp	r3, #0
    62e8:	dd03      	ble.n	62f2 <atcacert_date_enc_iso8601_sep+0x9e>
    62ea:	687b      	ldr	r3, [r7, #4]
    62ec:	68db      	ldr	r3, [r3, #12]
    62ee:	2b1f      	cmp	r3, #31
    62f0:	dd01      	ble.n	62f6 <atcacert_date_enc_iso8601_sep+0xa2>
		return ATCACERT_E_INVALID_DATE;
    62f2:	2305      	movs	r3, #5
    62f4:	e05a      	b.n	63ac <atcacert_date_enc_iso8601_sep+0x158>
	cur_pos = uint_to_str(timestamp->tm_mday, 2, cur_pos);
    62f6:	687b      	ldr	r3, [r7, #4]
    62f8:	68db      	ldr	r3, [r3, #12]
    62fa:	0018      	movs	r0, r3
    62fc:	68fb      	ldr	r3, [r7, #12]
    62fe:	001a      	movs	r2, r3
    6300:	2102      	movs	r1, #2
    6302:	4b2e      	ldr	r3, [pc, #184]	; (63bc <atcacert_date_enc_iso8601_sep+0x168>)
    6304:	4798      	blx	r3
    6306:	0003      	movs	r3, r0
    6308:	60fb      	str	r3, [r7, #12]

	*(cur_pos++) = 'T';
    630a:	68fb      	ldr	r3, [r7, #12]
    630c:	1c5a      	adds	r2, r3, #1
    630e:	60fa      	str	r2, [r7, #12]
    6310:	2254      	movs	r2, #84	; 0x54
    6312:	701a      	strb	r2, [r3, #0]

	if (timestamp->tm_hour < 0 || timestamp->tm_hour > 23)
    6314:	687b      	ldr	r3, [r7, #4]
    6316:	689b      	ldr	r3, [r3, #8]
    6318:	2b00      	cmp	r3, #0
    631a:	db03      	blt.n	6324 <atcacert_date_enc_iso8601_sep+0xd0>
    631c:	687b      	ldr	r3, [r7, #4]
    631e:	689b      	ldr	r3, [r3, #8]
    6320:	2b17      	cmp	r3, #23
    6322:	dd01      	ble.n	6328 <atcacert_date_enc_iso8601_sep+0xd4>
		return ATCACERT_E_INVALID_DATE;
    6324:	2305      	movs	r3, #5
    6326:	e041      	b.n	63ac <atcacert_date_enc_iso8601_sep+0x158>
	cur_pos = uint_to_str(timestamp->tm_hour, 2, cur_pos);
    6328:	687b      	ldr	r3, [r7, #4]
    632a:	689b      	ldr	r3, [r3, #8]
    632c:	0018      	movs	r0, r3
    632e:	68fb      	ldr	r3, [r7, #12]
    6330:	001a      	movs	r2, r3
    6332:	2102      	movs	r1, #2
    6334:	4b21      	ldr	r3, [pc, #132]	; (63bc <atcacert_date_enc_iso8601_sep+0x168>)
    6336:	4798      	blx	r3
    6338:	0003      	movs	r3, r0
    633a:	60fb      	str	r3, [r7, #12]

	*(cur_pos++) = ':';
    633c:	68fb      	ldr	r3, [r7, #12]
    633e:	1c5a      	adds	r2, r3, #1
    6340:	60fa      	str	r2, [r7, #12]
    6342:	223a      	movs	r2, #58	; 0x3a
    6344:	701a      	strb	r2, [r3, #0]

	if (timestamp->tm_min < 0 || timestamp->tm_min > 59)
    6346:	687b      	ldr	r3, [r7, #4]
    6348:	685b      	ldr	r3, [r3, #4]
    634a:	2b00      	cmp	r3, #0
    634c:	db03      	blt.n	6356 <atcacert_date_enc_iso8601_sep+0x102>
    634e:	687b      	ldr	r3, [r7, #4]
    6350:	685b      	ldr	r3, [r3, #4]
    6352:	2b3b      	cmp	r3, #59	; 0x3b
    6354:	dd01      	ble.n	635a <atcacert_date_enc_iso8601_sep+0x106>
		return ATCACERT_E_INVALID_DATE;
    6356:	2305      	movs	r3, #5
    6358:	e028      	b.n	63ac <atcacert_date_enc_iso8601_sep+0x158>
	cur_pos = uint_to_str(timestamp->tm_min, 2, cur_pos);
    635a:	687b      	ldr	r3, [r7, #4]
    635c:	685b      	ldr	r3, [r3, #4]
    635e:	0018      	movs	r0, r3
    6360:	68fb      	ldr	r3, [r7, #12]
    6362:	001a      	movs	r2, r3
    6364:	2102      	movs	r1, #2
    6366:	4b15      	ldr	r3, [pc, #84]	; (63bc <atcacert_date_enc_iso8601_sep+0x168>)
    6368:	4798      	blx	r3
    636a:	0003      	movs	r3, r0
    636c:	60fb      	str	r3, [r7, #12]

	*(cur_pos++) = ':';
    636e:	68fb      	ldr	r3, [r7, #12]
    6370:	1c5a      	adds	r2, r3, #1
    6372:	60fa      	str	r2, [r7, #12]
    6374:	223a      	movs	r2, #58	; 0x3a
    6376:	701a      	strb	r2, [r3, #0]

	if (timestamp->tm_sec < 0 || timestamp->tm_sec > 59)
    6378:	687b      	ldr	r3, [r7, #4]
    637a:	681b      	ldr	r3, [r3, #0]
    637c:	2b00      	cmp	r3, #0
    637e:	db03      	blt.n	6388 <atcacert_date_enc_iso8601_sep+0x134>
    6380:	687b      	ldr	r3, [r7, #4]
    6382:	681b      	ldr	r3, [r3, #0]
    6384:	2b3b      	cmp	r3, #59	; 0x3b
    6386:	dd01      	ble.n	638c <atcacert_date_enc_iso8601_sep+0x138>
		return ATCACERT_E_INVALID_DATE;
    6388:	2305      	movs	r3, #5
    638a:	e00f      	b.n	63ac <atcacert_date_enc_iso8601_sep+0x158>
	cur_pos = uint_to_str(timestamp->tm_sec, 2, cur_pos);
    638c:	687b      	ldr	r3, [r7, #4]
    638e:	681b      	ldr	r3, [r3, #0]
    6390:	0018      	movs	r0, r3
    6392:	68fb      	ldr	r3, [r7, #12]
    6394:	001a      	movs	r2, r3
    6396:	2102      	movs	r1, #2
    6398:	4b08      	ldr	r3, [pc, #32]	; (63bc <atcacert_date_enc_iso8601_sep+0x168>)
    639a:	4798      	blx	r3
    639c:	0003      	movs	r3, r0
    639e:	60fb      	str	r3, [r7, #12]

	*(cur_pos++) = 'Z';
    63a0:	68fb      	ldr	r3, [r7, #12]
    63a2:	1c5a      	adds	r2, r3, #1
    63a4:	60fa      	str	r2, [r7, #12]
    63a6:	225a      	movs	r2, #90	; 0x5a
    63a8:	701a      	strb	r2, [r3, #0]

	return ATCACERT_E_SUCCESS;
    63aa:	2300      	movs	r3, #0
}
    63ac:	0018      	movs	r0, r3
    63ae:	46bd      	mov	sp, r7
    63b0:	b004      	add	sp, #16
    63b2:	bd80      	pop	{r7, pc}
    63b4:	0000076c 	.word	0x0000076c
    63b8:	0000270f 	.word	0x0000270f
    63bc:	000060c9 	.word	0x000060c9

000063c0 <atcacert_date_dec_iso8601_sep>:

int atcacert_date_dec_iso8601_sep( const uint8_t formatted_date[DATEFMT_ISO8601_SEP_SIZE],
                                   atcacert_tm_utc_t*  timestamp)
{
    63c0:	b580      	push	{r7, lr}
    63c2:	b084      	sub	sp, #16
    63c4:	af00      	add	r7, sp, #0
    63c6:	6078      	str	r0, [r7, #4]
    63c8:	6039      	str	r1, [r7, #0]
	const uint8_t* cur_pos = formatted_date;
    63ca:	687b      	ldr	r3, [r7, #4]
    63cc:	60fb      	str	r3, [r7, #12]
	const uint8_t* new_pos = NULL;
    63ce:	2300      	movs	r3, #0
    63d0:	60bb      	str	r3, [r7, #8]

	if (formatted_date == NULL || timestamp == NULL)
    63d2:	687b      	ldr	r3, [r7, #4]
    63d4:	2b00      	cmp	r3, #0
    63d6:	d002      	beq.n	63de <atcacert_date_dec_iso8601_sep+0x1e>
    63d8:	683b      	ldr	r3, [r7, #0]
    63da:	2b00      	cmp	r3, #0
    63dc:	d101      	bne.n	63e2 <atcacert_date_dec_iso8601_sep+0x22>
		return ATCACERT_E_BAD_PARAMS;
    63de:	2302      	movs	r3, #2
    63e0:	e0aa      	b.n	6538 <atcacert_date_dec_iso8601_sep+0x178>

	memset(timestamp, 0, sizeof(*timestamp));
    63e2:	683b      	ldr	r3, [r7, #0]
    63e4:	2218      	movs	r2, #24
    63e6:	2100      	movs	r1, #0
    63e8:	0018      	movs	r0, r3
    63ea:	4b55      	ldr	r3, [pc, #340]	; (6540 <atcacert_date_dec_iso8601_sep+0x180>)
    63ec:	4798      	blx	r3

	new_pos = str_to_int(cur_pos, 4, &timestamp->tm_year);
    63ee:	683b      	ldr	r3, [r7, #0]
    63f0:	3314      	adds	r3, #20
    63f2:	001a      	movs	r2, r3
    63f4:	68fb      	ldr	r3, [r7, #12]
    63f6:	2104      	movs	r1, #4
    63f8:	0018      	movs	r0, r3
    63fa:	4b52      	ldr	r3, [pc, #328]	; (6544 <atcacert_date_dec_iso8601_sep+0x184>)
    63fc:	4798      	blx	r3
    63fe:	0003      	movs	r3, r0
    6400:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    6402:	68ba      	ldr	r2, [r7, #8]
    6404:	68fb      	ldr	r3, [r7, #12]
    6406:	429a      	cmp	r2, r3
    6408:	d101      	bne.n	640e <atcacert_date_dec_iso8601_sep+0x4e>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    640a:	2304      	movs	r3, #4
    640c:	e094      	b.n	6538 <atcacert_date_dec_iso8601_sep+0x178>
	cur_pos = new_pos;
    640e:	68bb      	ldr	r3, [r7, #8]
    6410:	60fb      	str	r3, [r7, #12]
	timestamp->tm_year -= 1900;
    6412:	683b      	ldr	r3, [r7, #0]
    6414:	695b      	ldr	r3, [r3, #20]
    6416:	4a4c      	ldr	r2, [pc, #304]	; (6548 <atcacert_date_dec_iso8601_sep+0x188>)
    6418:	189a      	adds	r2, r3, r2
    641a:	683b      	ldr	r3, [r7, #0]
    641c:	615a      	str	r2, [r3, #20]

	if (*(cur_pos++) != '-')
    641e:	68fb      	ldr	r3, [r7, #12]
    6420:	1c5a      	adds	r2, r3, #1
    6422:	60fa      	str	r2, [r7, #12]
    6424:	781b      	ldrb	r3, [r3, #0]
    6426:	2b2d      	cmp	r3, #45	; 0x2d
    6428:	d001      	beq.n	642e <atcacert_date_dec_iso8601_sep+0x6e>
		return ATCACERT_E_DECODING_ERROR; // Unexpected separator
    642a:	2304      	movs	r3, #4
    642c:	e084      	b.n	6538 <atcacert_date_dec_iso8601_sep+0x178>

	new_pos = str_to_int(cur_pos, 2, &timestamp->tm_mon);
    642e:	683b      	ldr	r3, [r7, #0]
    6430:	3310      	adds	r3, #16
    6432:	001a      	movs	r2, r3
    6434:	68fb      	ldr	r3, [r7, #12]
    6436:	2102      	movs	r1, #2
    6438:	0018      	movs	r0, r3
    643a:	4b42      	ldr	r3, [pc, #264]	; (6544 <atcacert_date_dec_iso8601_sep+0x184>)
    643c:	4798      	blx	r3
    643e:	0003      	movs	r3, r0
    6440:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    6442:	68ba      	ldr	r2, [r7, #8]
    6444:	68fb      	ldr	r3, [r7, #12]
    6446:	429a      	cmp	r2, r3
    6448:	d101      	bne.n	644e <atcacert_date_dec_iso8601_sep+0x8e>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    644a:	2304      	movs	r3, #4
    644c:	e074      	b.n	6538 <atcacert_date_dec_iso8601_sep+0x178>
	cur_pos = new_pos;
    644e:	68bb      	ldr	r3, [r7, #8]
    6450:	60fb      	str	r3, [r7, #12]
	timestamp->tm_mon -= 1;
    6452:	683b      	ldr	r3, [r7, #0]
    6454:	691b      	ldr	r3, [r3, #16]
    6456:	1e5a      	subs	r2, r3, #1
    6458:	683b      	ldr	r3, [r7, #0]
    645a:	611a      	str	r2, [r3, #16]

	if (*(cur_pos++) != '-')
    645c:	68fb      	ldr	r3, [r7, #12]
    645e:	1c5a      	adds	r2, r3, #1
    6460:	60fa      	str	r2, [r7, #12]
    6462:	781b      	ldrb	r3, [r3, #0]
    6464:	2b2d      	cmp	r3, #45	; 0x2d
    6466:	d001      	beq.n	646c <atcacert_date_dec_iso8601_sep+0xac>
		return ATCACERT_E_DECODING_ERROR; // Unexpected separator
    6468:	2304      	movs	r3, #4
    646a:	e065      	b.n	6538 <atcacert_date_dec_iso8601_sep+0x178>

	new_pos = str_to_int(cur_pos, 2, &timestamp->tm_mday);
    646c:	683b      	ldr	r3, [r7, #0]
    646e:	330c      	adds	r3, #12
    6470:	001a      	movs	r2, r3
    6472:	68fb      	ldr	r3, [r7, #12]
    6474:	2102      	movs	r1, #2
    6476:	0018      	movs	r0, r3
    6478:	4b32      	ldr	r3, [pc, #200]	; (6544 <atcacert_date_dec_iso8601_sep+0x184>)
    647a:	4798      	blx	r3
    647c:	0003      	movs	r3, r0
    647e:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    6480:	68ba      	ldr	r2, [r7, #8]
    6482:	68fb      	ldr	r3, [r7, #12]
    6484:	429a      	cmp	r2, r3
    6486:	d101      	bne.n	648c <atcacert_date_dec_iso8601_sep+0xcc>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    6488:	2304      	movs	r3, #4
    648a:	e055      	b.n	6538 <atcacert_date_dec_iso8601_sep+0x178>
	cur_pos = new_pos;
    648c:	68bb      	ldr	r3, [r7, #8]
    648e:	60fb      	str	r3, [r7, #12]

	if (*(cur_pos++) != 'T')
    6490:	68fb      	ldr	r3, [r7, #12]
    6492:	1c5a      	adds	r2, r3, #1
    6494:	60fa      	str	r2, [r7, #12]
    6496:	781b      	ldrb	r3, [r3, #0]
    6498:	2b54      	cmp	r3, #84	; 0x54
    649a:	d001      	beq.n	64a0 <atcacert_date_dec_iso8601_sep+0xe0>
		return ATCACERT_E_DECODING_ERROR; // Unexpected separator
    649c:	2304      	movs	r3, #4
    649e:	e04b      	b.n	6538 <atcacert_date_dec_iso8601_sep+0x178>

	new_pos = str_to_int(cur_pos, 2, &timestamp->tm_hour);
    64a0:	683b      	ldr	r3, [r7, #0]
    64a2:	3308      	adds	r3, #8
    64a4:	001a      	movs	r2, r3
    64a6:	68fb      	ldr	r3, [r7, #12]
    64a8:	2102      	movs	r1, #2
    64aa:	0018      	movs	r0, r3
    64ac:	4b25      	ldr	r3, [pc, #148]	; (6544 <atcacert_date_dec_iso8601_sep+0x184>)
    64ae:	4798      	blx	r3
    64b0:	0003      	movs	r3, r0
    64b2:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    64b4:	68ba      	ldr	r2, [r7, #8]
    64b6:	68fb      	ldr	r3, [r7, #12]
    64b8:	429a      	cmp	r2, r3
    64ba:	d101      	bne.n	64c0 <atcacert_date_dec_iso8601_sep+0x100>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    64bc:	2304      	movs	r3, #4
    64be:	e03b      	b.n	6538 <atcacert_date_dec_iso8601_sep+0x178>
	cur_pos = new_pos;
    64c0:	68bb      	ldr	r3, [r7, #8]
    64c2:	60fb      	str	r3, [r7, #12]

	if (*(cur_pos++) != ':')
    64c4:	68fb      	ldr	r3, [r7, #12]
    64c6:	1c5a      	adds	r2, r3, #1
    64c8:	60fa      	str	r2, [r7, #12]
    64ca:	781b      	ldrb	r3, [r3, #0]
    64cc:	2b3a      	cmp	r3, #58	; 0x3a
    64ce:	d001      	beq.n	64d4 <atcacert_date_dec_iso8601_sep+0x114>
		return ATCACERT_E_DECODING_ERROR; // Unexpected separator
    64d0:	2304      	movs	r3, #4
    64d2:	e031      	b.n	6538 <atcacert_date_dec_iso8601_sep+0x178>

	new_pos = str_to_int(cur_pos, 2, &timestamp->tm_min);
    64d4:	683b      	ldr	r3, [r7, #0]
    64d6:	1d1a      	adds	r2, r3, #4
    64d8:	68fb      	ldr	r3, [r7, #12]
    64da:	2102      	movs	r1, #2
    64dc:	0018      	movs	r0, r3
    64de:	4b19      	ldr	r3, [pc, #100]	; (6544 <atcacert_date_dec_iso8601_sep+0x184>)
    64e0:	4798      	blx	r3
    64e2:	0003      	movs	r3, r0
    64e4:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    64e6:	68ba      	ldr	r2, [r7, #8]
    64e8:	68fb      	ldr	r3, [r7, #12]
    64ea:	429a      	cmp	r2, r3
    64ec:	d101      	bne.n	64f2 <atcacert_date_dec_iso8601_sep+0x132>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    64ee:	2304      	movs	r3, #4
    64f0:	e022      	b.n	6538 <atcacert_date_dec_iso8601_sep+0x178>
	cur_pos = new_pos;
    64f2:	68bb      	ldr	r3, [r7, #8]
    64f4:	60fb      	str	r3, [r7, #12]

	if (*(cur_pos++) != ':')
    64f6:	68fb      	ldr	r3, [r7, #12]
    64f8:	1c5a      	adds	r2, r3, #1
    64fa:	60fa      	str	r2, [r7, #12]
    64fc:	781b      	ldrb	r3, [r3, #0]
    64fe:	2b3a      	cmp	r3, #58	; 0x3a
    6500:	d001      	beq.n	6506 <atcacert_date_dec_iso8601_sep+0x146>
		return ATCACERT_E_DECODING_ERROR; // Unexpected separator
    6502:	2304      	movs	r3, #4
    6504:	e018      	b.n	6538 <atcacert_date_dec_iso8601_sep+0x178>

	new_pos = str_to_int(cur_pos, 2, &timestamp->tm_sec);
    6506:	683a      	ldr	r2, [r7, #0]
    6508:	68fb      	ldr	r3, [r7, #12]
    650a:	2102      	movs	r1, #2
    650c:	0018      	movs	r0, r3
    650e:	4b0d      	ldr	r3, [pc, #52]	; (6544 <atcacert_date_dec_iso8601_sep+0x184>)
    6510:	4798      	blx	r3
    6512:	0003      	movs	r3, r0
    6514:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    6516:	68ba      	ldr	r2, [r7, #8]
    6518:	68fb      	ldr	r3, [r7, #12]
    651a:	429a      	cmp	r2, r3
    651c:	d101      	bne.n	6522 <atcacert_date_dec_iso8601_sep+0x162>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    651e:	2304      	movs	r3, #4
    6520:	e00a      	b.n	6538 <atcacert_date_dec_iso8601_sep+0x178>
	cur_pos = new_pos;
    6522:	68bb      	ldr	r3, [r7, #8]
    6524:	60fb      	str	r3, [r7, #12]

	if (*(cur_pos++) != 'Z')
    6526:	68fb      	ldr	r3, [r7, #12]
    6528:	1c5a      	adds	r2, r3, #1
    652a:	60fa      	str	r2, [r7, #12]
    652c:	781b      	ldrb	r3, [r3, #0]
    652e:	2b5a      	cmp	r3, #90	; 0x5a
    6530:	d001      	beq.n	6536 <atcacert_date_dec_iso8601_sep+0x176>
		return ATCACERT_E_DECODING_ERROR; // Unexpected UTC marker
    6532:	2304      	movs	r3, #4
    6534:	e000      	b.n	6538 <atcacert_date_dec_iso8601_sep+0x178>

	return ATCACERT_E_SUCCESS;
    6536:	2300      	movs	r3, #0
}
    6538:	0018      	movs	r0, r3
    653a:	46bd      	mov	sp, r7
    653c:	b004      	add	sp, #16
    653e:	bd80      	pop	{r7, pc}
    6540:	00012823 	.word	0x00012823
    6544:	00006209 	.word	0x00006209
    6548:	fffff894 	.word	0xfffff894

0000654c <atcacert_date_enc_rfc5280_utc>:

int atcacert_date_enc_rfc5280_utc( const atcacert_tm_utc_t*  timestamp,
                                   uint8_t formatted_date[DATEFMT_RFC5280_UTC_SIZE])
{
    654c:	b580      	push	{r7, lr}
    654e:	b084      	sub	sp, #16
    6550:	af00      	add	r7, sp, #0
    6552:	6078      	str	r0, [r7, #4]
    6554:	6039      	str	r1, [r7, #0]
	uint8_t* cur_pos = formatted_date;
    6556:	683b      	ldr	r3, [r7, #0]
    6558:	60bb      	str	r3, [r7, #8]
	int year = 0;
    655a:	2300      	movs	r3, #0
    655c:	60fb      	str	r3, [r7, #12]

	if (timestamp == NULL || formatted_date == NULL)
    655e:	687b      	ldr	r3, [r7, #4]
    6560:	2b00      	cmp	r3, #0
    6562:	d002      	beq.n	656a <atcacert_date_enc_rfc5280_utc+0x1e>
    6564:	683b      	ldr	r3, [r7, #0]
    6566:	2b00      	cmp	r3, #0
    6568:	d101      	bne.n	656e <atcacert_date_enc_rfc5280_utc+0x22>
		return ATCACERT_E_BAD_PARAMS;
    656a:	2302      	movs	r3, #2
    656c:	e096      	b.n	669c <atcacert_date_enc_rfc5280_utc+0x150>

	year = timestamp->tm_year + 1900;
    656e:	687b      	ldr	r3, [r7, #4]
    6570:	695b      	ldr	r3, [r3, #20]
    6572:	4a4c      	ldr	r2, [pc, #304]	; (66a4 <atcacert_date_enc_rfc5280_utc+0x158>)
    6574:	4694      	mov	ip, r2
    6576:	4463      	add	r3, ip
    6578:	60fb      	str	r3, [r7, #12]

	if (year >= 1950 && year <= 1999)
    657a:	68fb      	ldr	r3, [r7, #12]
    657c:	4a4a      	ldr	r2, [pc, #296]	; (66a8 <atcacert_date_enc_rfc5280_utc+0x15c>)
    657e:	4293      	cmp	r3, r2
    6580:	dd09      	ble.n	6596 <atcacert_date_enc_rfc5280_utc+0x4a>
    6582:	68fb      	ldr	r3, [r7, #12]
    6584:	4a49      	ldr	r2, [pc, #292]	; (66ac <atcacert_date_enc_rfc5280_utc+0x160>)
    6586:	4293      	cmp	r3, r2
    6588:	dc05      	bgt.n	6596 <atcacert_date_enc_rfc5280_utc+0x4a>
		year = year - 1900;
    658a:	68fb      	ldr	r3, [r7, #12]
    658c:	4a48      	ldr	r2, [pc, #288]	; (66b0 <atcacert_date_enc_rfc5280_utc+0x164>)
    658e:	4694      	mov	ip, r2
    6590:	4463      	add	r3, ip
    6592:	60fb      	str	r3, [r7, #12]
    6594:	e00f      	b.n	65b6 <atcacert_date_enc_rfc5280_utc+0x6a>
	else if (year >= 2000 && year <= 2049)
    6596:	68fb      	ldr	r3, [r7, #12]
    6598:	4a44      	ldr	r2, [pc, #272]	; (66ac <atcacert_date_enc_rfc5280_utc+0x160>)
    659a:	4293      	cmp	r3, r2
    659c:	dd09      	ble.n	65b2 <atcacert_date_enc_rfc5280_utc+0x66>
    659e:	68fb      	ldr	r3, [r7, #12]
    65a0:	4a44      	ldr	r2, [pc, #272]	; (66b4 <atcacert_date_enc_rfc5280_utc+0x168>)
    65a2:	4293      	cmp	r3, r2
    65a4:	dc05      	bgt.n	65b2 <atcacert_date_enc_rfc5280_utc+0x66>
		year = year - 2000;
    65a6:	68fb      	ldr	r3, [r7, #12]
    65a8:	4a43      	ldr	r2, [pc, #268]	; (66b8 <atcacert_date_enc_rfc5280_utc+0x16c>)
    65aa:	4694      	mov	ip, r2
    65ac:	4463      	add	r3, ip
    65ae:	60fb      	str	r3, [r7, #12]
    65b0:	e001      	b.n	65b6 <atcacert_date_enc_rfc5280_utc+0x6a>
	else
		return ATCACERT_E_INVALID_DATE;  // Year out of range for RFC2459 UTC format
    65b2:	2305      	movs	r3, #5
    65b4:	e072      	b.n	669c <atcacert_date_enc_rfc5280_utc+0x150>
	cur_pos = uint_to_str(year, 2, cur_pos);
    65b6:	68fb      	ldr	r3, [r7, #12]
    65b8:	68ba      	ldr	r2, [r7, #8]
    65ba:	2102      	movs	r1, #2
    65bc:	0018      	movs	r0, r3
    65be:	4b3f      	ldr	r3, [pc, #252]	; (66bc <atcacert_date_enc_rfc5280_utc+0x170>)
    65c0:	4798      	blx	r3
    65c2:	0003      	movs	r3, r0
    65c4:	60bb      	str	r3, [r7, #8]

	if (timestamp->tm_mon < 0 || timestamp->tm_mon > 11)
    65c6:	687b      	ldr	r3, [r7, #4]
    65c8:	691b      	ldr	r3, [r3, #16]
    65ca:	2b00      	cmp	r3, #0
    65cc:	db03      	blt.n	65d6 <atcacert_date_enc_rfc5280_utc+0x8a>
    65ce:	687b      	ldr	r3, [r7, #4]
    65d0:	691b      	ldr	r3, [r3, #16]
    65d2:	2b0b      	cmp	r3, #11
    65d4:	dd01      	ble.n	65da <atcacert_date_enc_rfc5280_utc+0x8e>
		return ATCACERT_E_INVALID_DATE;
    65d6:	2305      	movs	r3, #5
    65d8:	e060      	b.n	669c <atcacert_date_enc_rfc5280_utc+0x150>
	cur_pos = uint_to_str(timestamp->tm_mon + 1, 2, cur_pos);
    65da:	687b      	ldr	r3, [r7, #4]
    65dc:	691b      	ldr	r3, [r3, #16]
    65de:	3301      	adds	r3, #1
    65e0:	0018      	movs	r0, r3
    65e2:	68bb      	ldr	r3, [r7, #8]
    65e4:	001a      	movs	r2, r3
    65e6:	2102      	movs	r1, #2
    65e8:	4b34      	ldr	r3, [pc, #208]	; (66bc <atcacert_date_enc_rfc5280_utc+0x170>)
    65ea:	4798      	blx	r3
    65ec:	0003      	movs	r3, r0
    65ee:	60bb      	str	r3, [r7, #8]

	if (timestamp->tm_mday < 1 || timestamp->tm_mday > 31)
    65f0:	687b      	ldr	r3, [r7, #4]
    65f2:	68db      	ldr	r3, [r3, #12]
    65f4:	2b00      	cmp	r3, #0
    65f6:	dd03      	ble.n	6600 <atcacert_date_enc_rfc5280_utc+0xb4>
    65f8:	687b      	ldr	r3, [r7, #4]
    65fa:	68db      	ldr	r3, [r3, #12]
    65fc:	2b1f      	cmp	r3, #31
    65fe:	dd01      	ble.n	6604 <atcacert_date_enc_rfc5280_utc+0xb8>
		return ATCACERT_E_INVALID_DATE;
    6600:	2305      	movs	r3, #5
    6602:	e04b      	b.n	669c <atcacert_date_enc_rfc5280_utc+0x150>
	cur_pos = uint_to_str(timestamp->tm_mday, 2, cur_pos);
    6604:	687b      	ldr	r3, [r7, #4]
    6606:	68db      	ldr	r3, [r3, #12]
    6608:	0018      	movs	r0, r3
    660a:	68bb      	ldr	r3, [r7, #8]
    660c:	001a      	movs	r2, r3
    660e:	2102      	movs	r1, #2
    6610:	4b2a      	ldr	r3, [pc, #168]	; (66bc <atcacert_date_enc_rfc5280_utc+0x170>)
    6612:	4798      	blx	r3
    6614:	0003      	movs	r3, r0
    6616:	60bb      	str	r3, [r7, #8]

	if (timestamp->tm_hour < 0 || timestamp->tm_hour > 23)
    6618:	687b      	ldr	r3, [r7, #4]
    661a:	689b      	ldr	r3, [r3, #8]
    661c:	2b00      	cmp	r3, #0
    661e:	db03      	blt.n	6628 <atcacert_date_enc_rfc5280_utc+0xdc>
    6620:	687b      	ldr	r3, [r7, #4]
    6622:	689b      	ldr	r3, [r3, #8]
    6624:	2b17      	cmp	r3, #23
    6626:	dd01      	ble.n	662c <atcacert_date_enc_rfc5280_utc+0xe0>
		return ATCACERT_E_INVALID_DATE;
    6628:	2305      	movs	r3, #5
    662a:	e037      	b.n	669c <atcacert_date_enc_rfc5280_utc+0x150>
	cur_pos = uint_to_str(timestamp->tm_hour, 2, cur_pos);
    662c:	687b      	ldr	r3, [r7, #4]
    662e:	689b      	ldr	r3, [r3, #8]
    6630:	0018      	movs	r0, r3
    6632:	68bb      	ldr	r3, [r7, #8]
    6634:	001a      	movs	r2, r3
    6636:	2102      	movs	r1, #2
    6638:	4b20      	ldr	r3, [pc, #128]	; (66bc <atcacert_date_enc_rfc5280_utc+0x170>)
    663a:	4798      	blx	r3
    663c:	0003      	movs	r3, r0
    663e:	60bb      	str	r3, [r7, #8]

	if (timestamp->tm_min < 0 || timestamp->tm_min > 59)
    6640:	687b      	ldr	r3, [r7, #4]
    6642:	685b      	ldr	r3, [r3, #4]
    6644:	2b00      	cmp	r3, #0
    6646:	db03      	blt.n	6650 <atcacert_date_enc_rfc5280_utc+0x104>
    6648:	687b      	ldr	r3, [r7, #4]
    664a:	685b      	ldr	r3, [r3, #4]
    664c:	2b3b      	cmp	r3, #59	; 0x3b
    664e:	dd01      	ble.n	6654 <atcacert_date_enc_rfc5280_utc+0x108>
		return ATCACERT_E_INVALID_DATE;
    6650:	2305      	movs	r3, #5
    6652:	e023      	b.n	669c <atcacert_date_enc_rfc5280_utc+0x150>
	cur_pos = uint_to_str(timestamp->tm_min, 2, cur_pos);
    6654:	687b      	ldr	r3, [r7, #4]
    6656:	685b      	ldr	r3, [r3, #4]
    6658:	0018      	movs	r0, r3
    665a:	68bb      	ldr	r3, [r7, #8]
    665c:	001a      	movs	r2, r3
    665e:	2102      	movs	r1, #2
    6660:	4b16      	ldr	r3, [pc, #88]	; (66bc <atcacert_date_enc_rfc5280_utc+0x170>)
    6662:	4798      	blx	r3
    6664:	0003      	movs	r3, r0
    6666:	60bb      	str	r3, [r7, #8]

	if (timestamp->tm_sec < 0 || timestamp->tm_sec > 59)
    6668:	687b      	ldr	r3, [r7, #4]
    666a:	681b      	ldr	r3, [r3, #0]
    666c:	2b00      	cmp	r3, #0
    666e:	db03      	blt.n	6678 <atcacert_date_enc_rfc5280_utc+0x12c>
    6670:	687b      	ldr	r3, [r7, #4]
    6672:	681b      	ldr	r3, [r3, #0]
    6674:	2b3b      	cmp	r3, #59	; 0x3b
    6676:	dd01      	ble.n	667c <atcacert_date_enc_rfc5280_utc+0x130>
		return ATCACERT_E_INVALID_DATE;
    6678:	2305      	movs	r3, #5
    667a:	e00f      	b.n	669c <atcacert_date_enc_rfc5280_utc+0x150>
	cur_pos = uint_to_str(timestamp->tm_sec, 2, cur_pos);
    667c:	687b      	ldr	r3, [r7, #4]
    667e:	681b      	ldr	r3, [r3, #0]
    6680:	0018      	movs	r0, r3
    6682:	68bb      	ldr	r3, [r7, #8]
    6684:	001a      	movs	r2, r3
    6686:	2102      	movs	r1, #2
    6688:	4b0c      	ldr	r3, [pc, #48]	; (66bc <atcacert_date_enc_rfc5280_utc+0x170>)
    668a:	4798      	blx	r3
    668c:	0003      	movs	r3, r0
    668e:	60bb      	str	r3, [r7, #8]

	*(cur_pos++) = 'Z';
    6690:	68bb      	ldr	r3, [r7, #8]
    6692:	1c5a      	adds	r2, r3, #1
    6694:	60ba      	str	r2, [r7, #8]
    6696:	225a      	movs	r2, #90	; 0x5a
    6698:	701a      	strb	r2, [r3, #0]

	return ATCACERT_E_SUCCESS;
    669a:	2300      	movs	r3, #0
}
    669c:	0018      	movs	r0, r3
    669e:	46bd      	mov	sp, r7
    66a0:	b004      	add	sp, #16
    66a2:	bd80      	pop	{r7, pc}
    66a4:	0000076c 	.word	0x0000076c
    66a8:	0000079d 	.word	0x0000079d
    66ac:	000007cf 	.word	0x000007cf
    66b0:	fffff894 	.word	0xfffff894
    66b4:	00000801 	.word	0x00000801
    66b8:	fffff830 	.word	0xfffff830
    66bc:	000060c9 	.word	0x000060c9

000066c0 <atcacert_date_dec_rfc5280_utc>:

int atcacert_date_dec_rfc5280_utc( const uint8_t formatted_date[DATEFMT_RFC5280_UTC_SIZE],
                                   atcacert_tm_utc_t*  timestamp)
{
    66c0:	b580      	push	{r7, lr}
    66c2:	b084      	sub	sp, #16
    66c4:	af00      	add	r7, sp, #0
    66c6:	6078      	str	r0, [r7, #4]
    66c8:	6039      	str	r1, [r7, #0]
	const uint8_t* cur_pos = formatted_date;
    66ca:	687b      	ldr	r3, [r7, #4]
    66cc:	60fb      	str	r3, [r7, #12]
	const uint8_t* new_pos = NULL;
    66ce:	2300      	movs	r3, #0
    66d0:	60bb      	str	r3, [r7, #8]

	if (formatted_date == NULL || timestamp == NULL)
    66d2:	687b      	ldr	r3, [r7, #4]
    66d4:	2b00      	cmp	r3, #0
    66d6:	d002      	beq.n	66de <atcacert_date_dec_rfc5280_utc+0x1e>
    66d8:	683b      	ldr	r3, [r7, #0]
    66da:	2b00      	cmp	r3, #0
    66dc:	d101      	bne.n	66e2 <atcacert_date_dec_rfc5280_utc+0x22>
		return ATCACERT_E_BAD_PARAMS;
    66de:	2302      	movs	r3, #2
    66e0:	e094      	b.n	680c <atcacert_date_dec_rfc5280_utc+0x14c>

	memset(timestamp, 0, sizeof(*timestamp));
    66e2:	683b      	ldr	r3, [r7, #0]
    66e4:	2218      	movs	r2, #24
    66e6:	2100      	movs	r1, #0
    66e8:	0018      	movs	r0, r3
    66ea:	4b4a      	ldr	r3, [pc, #296]	; (6814 <atcacert_date_dec_rfc5280_utc+0x154>)
    66ec:	4798      	blx	r3

	new_pos = str_to_int(cur_pos, 2, &timestamp->tm_year);
    66ee:	683b      	ldr	r3, [r7, #0]
    66f0:	3314      	adds	r3, #20
    66f2:	001a      	movs	r2, r3
    66f4:	68fb      	ldr	r3, [r7, #12]
    66f6:	2102      	movs	r1, #2
    66f8:	0018      	movs	r0, r3
    66fa:	4b47      	ldr	r3, [pc, #284]	; (6818 <atcacert_date_dec_rfc5280_utc+0x158>)
    66fc:	4798      	blx	r3
    66fe:	0003      	movs	r3, r0
    6700:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    6702:	68ba      	ldr	r2, [r7, #8]
    6704:	68fb      	ldr	r3, [r7, #12]
    6706:	429a      	cmp	r2, r3
    6708:	d101      	bne.n	670e <atcacert_date_dec_rfc5280_utc+0x4e>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    670a:	2304      	movs	r3, #4
    670c:	e07e      	b.n	680c <atcacert_date_dec_rfc5280_utc+0x14c>
	cur_pos = new_pos;
    670e:	68bb      	ldr	r3, [r7, #8]
    6710:	60fb      	str	r3, [r7, #12]
	if (timestamp->tm_year < 50)
    6712:	683b      	ldr	r3, [r7, #0]
    6714:	695b      	ldr	r3, [r3, #20]
    6716:	2b31      	cmp	r3, #49	; 0x31
    6718:	dc07      	bgt.n	672a <atcacert_date_dec_rfc5280_utc+0x6a>
		timestamp->tm_year += 2000;
    671a:	683b      	ldr	r3, [r7, #0]
    671c:	695b      	ldr	r3, [r3, #20]
    671e:	22fa      	movs	r2, #250	; 0xfa
    6720:	00d2      	lsls	r2, r2, #3
    6722:	189a      	adds	r2, r3, r2
    6724:	683b      	ldr	r3, [r7, #0]
    6726:	615a      	str	r2, [r3, #20]
    6728:	e005      	b.n	6736 <atcacert_date_dec_rfc5280_utc+0x76>
	else
		timestamp->tm_year += 1900;
    672a:	683b      	ldr	r3, [r7, #0]
    672c:	695b      	ldr	r3, [r3, #20]
    672e:	4a3b      	ldr	r2, [pc, #236]	; (681c <atcacert_date_dec_rfc5280_utc+0x15c>)
    6730:	189a      	adds	r2, r3, r2
    6732:	683b      	ldr	r3, [r7, #0]
    6734:	615a      	str	r2, [r3, #20]
	timestamp->tm_year -= 1900;
    6736:	683b      	ldr	r3, [r7, #0]
    6738:	695b      	ldr	r3, [r3, #20]
    673a:	4a39      	ldr	r2, [pc, #228]	; (6820 <atcacert_date_dec_rfc5280_utc+0x160>)
    673c:	189a      	adds	r2, r3, r2
    673e:	683b      	ldr	r3, [r7, #0]
    6740:	615a      	str	r2, [r3, #20]

	new_pos = str_to_int(cur_pos, 2, &timestamp->tm_mon);
    6742:	683b      	ldr	r3, [r7, #0]
    6744:	3310      	adds	r3, #16
    6746:	001a      	movs	r2, r3
    6748:	68fb      	ldr	r3, [r7, #12]
    674a:	2102      	movs	r1, #2
    674c:	0018      	movs	r0, r3
    674e:	4b32      	ldr	r3, [pc, #200]	; (6818 <atcacert_date_dec_rfc5280_utc+0x158>)
    6750:	4798      	blx	r3
    6752:	0003      	movs	r3, r0
    6754:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    6756:	68ba      	ldr	r2, [r7, #8]
    6758:	68fb      	ldr	r3, [r7, #12]
    675a:	429a      	cmp	r2, r3
    675c:	d101      	bne.n	6762 <atcacert_date_dec_rfc5280_utc+0xa2>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    675e:	2304      	movs	r3, #4
    6760:	e054      	b.n	680c <atcacert_date_dec_rfc5280_utc+0x14c>
	cur_pos = new_pos;
    6762:	68bb      	ldr	r3, [r7, #8]
    6764:	60fb      	str	r3, [r7, #12]
	timestamp->tm_mon -= 1;
    6766:	683b      	ldr	r3, [r7, #0]
    6768:	691b      	ldr	r3, [r3, #16]
    676a:	1e5a      	subs	r2, r3, #1
    676c:	683b      	ldr	r3, [r7, #0]
    676e:	611a      	str	r2, [r3, #16]

	new_pos = str_to_int(cur_pos, 2, &timestamp->tm_mday);
    6770:	683b      	ldr	r3, [r7, #0]
    6772:	330c      	adds	r3, #12
    6774:	001a      	movs	r2, r3
    6776:	68fb      	ldr	r3, [r7, #12]
    6778:	2102      	movs	r1, #2
    677a:	0018      	movs	r0, r3
    677c:	4b26      	ldr	r3, [pc, #152]	; (6818 <atcacert_date_dec_rfc5280_utc+0x158>)
    677e:	4798      	blx	r3
    6780:	0003      	movs	r3, r0
    6782:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    6784:	68ba      	ldr	r2, [r7, #8]
    6786:	68fb      	ldr	r3, [r7, #12]
    6788:	429a      	cmp	r2, r3
    678a:	d101      	bne.n	6790 <atcacert_date_dec_rfc5280_utc+0xd0>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    678c:	2304      	movs	r3, #4
    678e:	e03d      	b.n	680c <atcacert_date_dec_rfc5280_utc+0x14c>
	cur_pos = new_pos;
    6790:	68bb      	ldr	r3, [r7, #8]
    6792:	60fb      	str	r3, [r7, #12]

	new_pos = str_to_int(cur_pos, 2, &timestamp->tm_hour);
    6794:	683b      	ldr	r3, [r7, #0]
    6796:	3308      	adds	r3, #8
    6798:	001a      	movs	r2, r3
    679a:	68fb      	ldr	r3, [r7, #12]
    679c:	2102      	movs	r1, #2
    679e:	0018      	movs	r0, r3
    67a0:	4b1d      	ldr	r3, [pc, #116]	; (6818 <atcacert_date_dec_rfc5280_utc+0x158>)
    67a2:	4798      	blx	r3
    67a4:	0003      	movs	r3, r0
    67a6:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    67a8:	68ba      	ldr	r2, [r7, #8]
    67aa:	68fb      	ldr	r3, [r7, #12]
    67ac:	429a      	cmp	r2, r3
    67ae:	d101      	bne.n	67b4 <atcacert_date_dec_rfc5280_utc+0xf4>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    67b0:	2304      	movs	r3, #4
    67b2:	e02b      	b.n	680c <atcacert_date_dec_rfc5280_utc+0x14c>
	cur_pos = new_pos;
    67b4:	68bb      	ldr	r3, [r7, #8]
    67b6:	60fb      	str	r3, [r7, #12]

	new_pos = str_to_int(cur_pos, 2, &timestamp->tm_min);
    67b8:	683b      	ldr	r3, [r7, #0]
    67ba:	1d1a      	adds	r2, r3, #4
    67bc:	68fb      	ldr	r3, [r7, #12]
    67be:	2102      	movs	r1, #2
    67c0:	0018      	movs	r0, r3
    67c2:	4b15      	ldr	r3, [pc, #84]	; (6818 <atcacert_date_dec_rfc5280_utc+0x158>)
    67c4:	4798      	blx	r3
    67c6:	0003      	movs	r3, r0
    67c8:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    67ca:	68ba      	ldr	r2, [r7, #8]
    67cc:	68fb      	ldr	r3, [r7, #12]
    67ce:	429a      	cmp	r2, r3
    67d0:	d101      	bne.n	67d6 <atcacert_date_dec_rfc5280_utc+0x116>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    67d2:	2304      	movs	r3, #4
    67d4:	e01a      	b.n	680c <atcacert_date_dec_rfc5280_utc+0x14c>
	cur_pos = new_pos;
    67d6:	68bb      	ldr	r3, [r7, #8]
    67d8:	60fb      	str	r3, [r7, #12]

	new_pos = str_to_int(cur_pos, 2, &timestamp->tm_sec);
    67da:	683a      	ldr	r2, [r7, #0]
    67dc:	68fb      	ldr	r3, [r7, #12]
    67de:	2102      	movs	r1, #2
    67e0:	0018      	movs	r0, r3
    67e2:	4b0d      	ldr	r3, [pc, #52]	; (6818 <atcacert_date_dec_rfc5280_utc+0x158>)
    67e4:	4798      	blx	r3
    67e6:	0003      	movs	r3, r0
    67e8:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    67ea:	68ba      	ldr	r2, [r7, #8]
    67ec:	68fb      	ldr	r3, [r7, #12]
    67ee:	429a      	cmp	r2, r3
    67f0:	d101      	bne.n	67f6 <atcacert_date_dec_rfc5280_utc+0x136>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    67f2:	2304      	movs	r3, #4
    67f4:	e00a      	b.n	680c <atcacert_date_dec_rfc5280_utc+0x14c>
	cur_pos = new_pos;
    67f6:	68bb      	ldr	r3, [r7, #8]
    67f8:	60fb      	str	r3, [r7, #12]

	if (*(cur_pos++) != 'Z')
    67fa:	68fb      	ldr	r3, [r7, #12]
    67fc:	1c5a      	adds	r2, r3, #1
    67fe:	60fa      	str	r2, [r7, #12]
    6800:	781b      	ldrb	r3, [r3, #0]
    6802:	2b5a      	cmp	r3, #90	; 0x5a
    6804:	d001      	beq.n	680a <atcacert_date_dec_rfc5280_utc+0x14a>
		return ATCACERT_E_DECODING_ERROR; // Unexpected UTC marker
    6806:	2304      	movs	r3, #4
    6808:	e000      	b.n	680c <atcacert_date_dec_rfc5280_utc+0x14c>

	return ATCACERT_E_SUCCESS;
    680a:	2300      	movs	r3, #0
}
    680c:	0018      	movs	r0, r3
    680e:	46bd      	mov	sp, r7
    6810:	b004      	add	sp, #16
    6812:	bd80      	pop	{r7, pc}
    6814:	00012823 	.word	0x00012823
    6818:	00006209 	.word	0x00006209
    681c:	0000076c 	.word	0x0000076c
    6820:	fffff894 	.word	0xfffff894

00006824 <atcacert_date_enc_rfc5280_gen>:

int atcacert_date_enc_rfc5280_gen( const atcacert_tm_utc_t*  timestamp,
                                   uint8_t formatted_date[DATEFMT_RFC5280_GEN_SIZE])
{
    6824:	b580      	push	{r7, lr}
    6826:	b084      	sub	sp, #16
    6828:	af00      	add	r7, sp, #0
    682a:	6078      	str	r0, [r7, #4]
    682c:	6039      	str	r1, [r7, #0]
	uint8_t* cur_pos = formatted_date;
    682e:	683b      	ldr	r3, [r7, #0]
    6830:	60fb      	str	r3, [r7, #12]
	int year = 0;
    6832:	2300      	movs	r3, #0
    6834:	60bb      	str	r3, [r7, #8]

	if (timestamp == NULL || formatted_date == NULL)
    6836:	687b      	ldr	r3, [r7, #4]
    6838:	2b00      	cmp	r3, #0
    683a:	d002      	beq.n	6842 <atcacert_date_enc_rfc5280_gen+0x1e>
    683c:	683b      	ldr	r3, [r7, #0]
    683e:	2b00      	cmp	r3, #0
    6840:	d101      	bne.n	6846 <atcacert_date_enc_rfc5280_gen+0x22>
		return ATCACERT_E_BAD_PARAMS;
    6842:	2302      	movs	r3, #2
    6844:	e081      	b.n	694a <atcacert_date_enc_rfc5280_gen+0x126>

	year = timestamp->tm_year + 1900;
    6846:	687b      	ldr	r3, [r7, #4]
    6848:	695b      	ldr	r3, [r3, #20]
    684a:	4a42      	ldr	r2, [pc, #264]	; (6954 <atcacert_date_enc_rfc5280_gen+0x130>)
    684c:	4694      	mov	ip, r2
    684e:	4463      	add	r3, ip
    6850:	60bb      	str	r3, [r7, #8]

	if (year < 0 || year > 9999)
    6852:	68bb      	ldr	r3, [r7, #8]
    6854:	2b00      	cmp	r3, #0
    6856:	db03      	blt.n	6860 <atcacert_date_enc_rfc5280_gen+0x3c>
    6858:	68bb      	ldr	r3, [r7, #8]
    685a:	4a3f      	ldr	r2, [pc, #252]	; (6958 <atcacert_date_enc_rfc5280_gen+0x134>)
    685c:	4293      	cmp	r3, r2
    685e:	dd01      	ble.n	6864 <atcacert_date_enc_rfc5280_gen+0x40>
		return ATCACERT_E_INVALID_DATE;
    6860:	2305      	movs	r3, #5
    6862:	e072      	b.n	694a <atcacert_date_enc_rfc5280_gen+0x126>
	cur_pos = uint_to_str(year, 4, cur_pos);
    6864:	68bb      	ldr	r3, [r7, #8]
    6866:	68fa      	ldr	r2, [r7, #12]
    6868:	2104      	movs	r1, #4
    686a:	0018      	movs	r0, r3
    686c:	4b3b      	ldr	r3, [pc, #236]	; (695c <atcacert_date_enc_rfc5280_gen+0x138>)
    686e:	4798      	blx	r3
    6870:	0003      	movs	r3, r0
    6872:	60fb      	str	r3, [r7, #12]

	if (timestamp->tm_mon < 0 || timestamp->tm_mon > 11)
    6874:	687b      	ldr	r3, [r7, #4]
    6876:	691b      	ldr	r3, [r3, #16]
    6878:	2b00      	cmp	r3, #0
    687a:	db03      	blt.n	6884 <atcacert_date_enc_rfc5280_gen+0x60>
    687c:	687b      	ldr	r3, [r7, #4]
    687e:	691b      	ldr	r3, [r3, #16]
    6880:	2b0b      	cmp	r3, #11
    6882:	dd01      	ble.n	6888 <atcacert_date_enc_rfc5280_gen+0x64>
		return ATCACERT_E_INVALID_DATE;
    6884:	2305      	movs	r3, #5
    6886:	e060      	b.n	694a <atcacert_date_enc_rfc5280_gen+0x126>
	cur_pos = uint_to_str(timestamp->tm_mon + 1, 2, cur_pos);
    6888:	687b      	ldr	r3, [r7, #4]
    688a:	691b      	ldr	r3, [r3, #16]
    688c:	3301      	adds	r3, #1
    688e:	0018      	movs	r0, r3
    6890:	68fb      	ldr	r3, [r7, #12]
    6892:	001a      	movs	r2, r3
    6894:	2102      	movs	r1, #2
    6896:	4b31      	ldr	r3, [pc, #196]	; (695c <atcacert_date_enc_rfc5280_gen+0x138>)
    6898:	4798      	blx	r3
    689a:	0003      	movs	r3, r0
    689c:	60fb      	str	r3, [r7, #12]

	if (timestamp->tm_mday < 1 || timestamp->tm_mday > 31)
    689e:	687b      	ldr	r3, [r7, #4]
    68a0:	68db      	ldr	r3, [r3, #12]
    68a2:	2b00      	cmp	r3, #0
    68a4:	dd03      	ble.n	68ae <atcacert_date_enc_rfc5280_gen+0x8a>
    68a6:	687b      	ldr	r3, [r7, #4]
    68a8:	68db      	ldr	r3, [r3, #12]
    68aa:	2b1f      	cmp	r3, #31
    68ac:	dd01      	ble.n	68b2 <atcacert_date_enc_rfc5280_gen+0x8e>
		return ATCACERT_E_INVALID_DATE;
    68ae:	2305      	movs	r3, #5
    68b0:	e04b      	b.n	694a <atcacert_date_enc_rfc5280_gen+0x126>
	cur_pos = uint_to_str(timestamp->tm_mday, 2, cur_pos);
    68b2:	687b      	ldr	r3, [r7, #4]
    68b4:	68db      	ldr	r3, [r3, #12]
    68b6:	0018      	movs	r0, r3
    68b8:	68fb      	ldr	r3, [r7, #12]
    68ba:	001a      	movs	r2, r3
    68bc:	2102      	movs	r1, #2
    68be:	4b27      	ldr	r3, [pc, #156]	; (695c <atcacert_date_enc_rfc5280_gen+0x138>)
    68c0:	4798      	blx	r3
    68c2:	0003      	movs	r3, r0
    68c4:	60fb      	str	r3, [r7, #12]

	if (timestamp->tm_hour < 0 || timestamp->tm_hour > 23)
    68c6:	687b      	ldr	r3, [r7, #4]
    68c8:	689b      	ldr	r3, [r3, #8]
    68ca:	2b00      	cmp	r3, #0
    68cc:	db03      	blt.n	68d6 <atcacert_date_enc_rfc5280_gen+0xb2>
    68ce:	687b      	ldr	r3, [r7, #4]
    68d0:	689b      	ldr	r3, [r3, #8]
    68d2:	2b17      	cmp	r3, #23
    68d4:	dd01      	ble.n	68da <atcacert_date_enc_rfc5280_gen+0xb6>
		return ATCACERT_E_INVALID_DATE;
    68d6:	2305      	movs	r3, #5
    68d8:	e037      	b.n	694a <atcacert_date_enc_rfc5280_gen+0x126>
	cur_pos = uint_to_str(timestamp->tm_hour, 2, cur_pos);
    68da:	687b      	ldr	r3, [r7, #4]
    68dc:	689b      	ldr	r3, [r3, #8]
    68de:	0018      	movs	r0, r3
    68e0:	68fb      	ldr	r3, [r7, #12]
    68e2:	001a      	movs	r2, r3
    68e4:	2102      	movs	r1, #2
    68e6:	4b1d      	ldr	r3, [pc, #116]	; (695c <atcacert_date_enc_rfc5280_gen+0x138>)
    68e8:	4798      	blx	r3
    68ea:	0003      	movs	r3, r0
    68ec:	60fb      	str	r3, [r7, #12]

	if (timestamp->tm_min < 0 || timestamp->tm_min > 59)
    68ee:	687b      	ldr	r3, [r7, #4]
    68f0:	685b      	ldr	r3, [r3, #4]
    68f2:	2b00      	cmp	r3, #0
    68f4:	db03      	blt.n	68fe <atcacert_date_enc_rfc5280_gen+0xda>
    68f6:	687b      	ldr	r3, [r7, #4]
    68f8:	685b      	ldr	r3, [r3, #4]
    68fa:	2b3b      	cmp	r3, #59	; 0x3b
    68fc:	dd01      	ble.n	6902 <atcacert_date_enc_rfc5280_gen+0xde>
		return ATCACERT_E_INVALID_DATE;
    68fe:	2305      	movs	r3, #5
    6900:	e023      	b.n	694a <atcacert_date_enc_rfc5280_gen+0x126>
	cur_pos = uint_to_str(timestamp->tm_min, 2, cur_pos);
    6902:	687b      	ldr	r3, [r7, #4]
    6904:	685b      	ldr	r3, [r3, #4]
    6906:	0018      	movs	r0, r3
    6908:	68fb      	ldr	r3, [r7, #12]
    690a:	001a      	movs	r2, r3
    690c:	2102      	movs	r1, #2
    690e:	4b13      	ldr	r3, [pc, #76]	; (695c <atcacert_date_enc_rfc5280_gen+0x138>)
    6910:	4798      	blx	r3
    6912:	0003      	movs	r3, r0
    6914:	60fb      	str	r3, [r7, #12]

	if (timestamp->tm_sec < 0 || timestamp->tm_sec > 59)
    6916:	687b      	ldr	r3, [r7, #4]
    6918:	681b      	ldr	r3, [r3, #0]
    691a:	2b00      	cmp	r3, #0
    691c:	db03      	blt.n	6926 <atcacert_date_enc_rfc5280_gen+0x102>
    691e:	687b      	ldr	r3, [r7, #4]
    6920:	681b      	ldr	r3, [r3, #0]
    6922:	2b3b      	cmp	r3, #59	; 0x3b
    6924:	dd01      	ble.n	692a <atcacert_date_enc_rfc5280_gen+0x106>
		return ATCACERT_E_INVALID_DATE;
    6926:	2305      	movs	r3, #5
    6928:	e00f      	b.n	694a <atcacert_date_enc_rfc5280_gen+0x126>
	cur_pos = uint_to_str(timestamp->tm_sec, 2, cur_pos);
    692a:	687b      	ldr	r3, [r7, #4]
    692c:	681b      	ldr	r3, [r3, #0]
    692e:	0018      	movs	r0, r3
    6930:	68fb      	ldr	r3, [r7, #12]
    6932:	001a      	movs	r2, r3
    6934:	2102      	movs	r1, #2
    6936:	4b09      	ldr	r3, [pc, #36]	; (695c <atcacert_date_enc_rfc5280_gen+0x138>)
    6938:	4798      	blx	r3
    693a:	0003      	movs	r3, r0
    693c:	60fb      	str	r3, [r7, #12]

	*(cur_pos++) = 'Z';
    693e:	68fb      	ldr	r3, [r7, #12]
    6940:	1c5a      	adds	r2, r3, #1
    6942:	60fa      	str	r2, [r7, #12]
    6944:	225a      	movs	r2, #90	; 0x5a
    6946:	701a      	strb	r2, [r3, #0]

	return ATCACERT_E_SUCCESS;
    6948:	2300      	movs	r3, #0
}
    694a:	0018      	movs	r0, r3
    694c:	46bd      	mov	sp, r7
    694e:	b004      	add	sp, #16
    6950:	bd80      	pop	{r7, pc}
    6952:	46c0      	nop			; (mov r8, r8)
    6954:	0000076c 	.word	0x0000076c
    6958:	0000270f 	.word	0x0000270f
    695c:	000060c9 	.word	0x000060c9

00006960 <atcacert_date_dec_rfc5280_gen>:

int atcacert_date_dec_rfc5280_gen( const uint8_t formatted_date[DATEFMT_RFC5280_GEN_SIZE],
                                   atcacert_tm_utc_t*  timestamp)
{
    6960:	b580      	push	{r7, lr}
    6962:	b084      	sub	sp, #16
    6964:	af00      	add	r7, sp, #0
    6966:	6078      	str	r0, [r7, #4]
    6968:	6039      	str	r1, [r7, #0]
	const uint8_t* cur_pos = formatted_date;
    696a:	687b      	ldr	r3, [r7, #4]
    696c:	60fb      	str	r3, [r7, #12]
	const uint8_t* new_pos = NULL;
    696e:	2300      	movs	r3, #0
    6970:	60bb      	str	r3, [r7, #8]

	if (formatted_date == NULL || timestamp == NULL)
    6972:	687b      	ldr	r3, [r7, #4]
    6974:	2b00      	cmp	r3, #0
    6976:	d002      	beq.n	697e <atcacert_date_dec_rfc5280_gen+0x1e>
    6978:	683b      	ldr	r3, [r7, #0]
    697a:	2b00      	cmp	r3, #0
    697c:	d101      	bne.n	6982 <atcacert_date_dec_rfc5280_gen+0x22>
		return ATCACERT_E_BAD_PARAMS;
    697e:	2302      	movs	r3, #2
    6980:	e082      	b.n	6a88 <atcacert_date_dec_rfc5280_gen+0x128>

	memset(timestamp, 0, sizeof(*timestamp));
    6982:	683b      	ldr	r3, [r7, #0]
    6984:	2218      	movs	r2, #24
    6986:	2100      	movs	r1, #0
    6988:	0018      	movs	r0, r3
    698a:	4b41      	ldr	r3, [pc, #260]	; (6a90 <atcacert_date_dec_rfc5280_gen+0x130>)
    698c:	4798      	blx	r3

	new_pos = str_to_int(cur_pos, 4, &timestamp->tm_year);
    698e:	683b      	ldr	r3, [r7, #0]
    6990:	3314      	adds	r3, #20
    6992:	001a      	movs	r2, r3
    6994:	68fb      	ldr	r3, [r7, #12]
    6996:	2104      	movs	r1, #4
    6998:	0018      	movs	r0, r3
    699a:	4b3e      	ldr	r3, [pc, #248]	; (6a94 <atcacert_date_dec_rfc5280_gen+0x134>)
    699c:	4798      	blx	r3
    699e:	0003      	movs	r3, r0
    69a0:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    69a2:	68ba      	ldr	r2, [r7, #8]
    69a4:	68fb      	ldr	r3, [r7, #12]
    69a6:	429a      	cmp	r2, r3
    69a8:	d101      	bne.n	69ae <atcacert_date_dec_rfc5280_gen+0x4e>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    69aa:	2304      	movs	r3, #4
    69ac:	e06c      	b.n	6a88 <atcacert_date_dec_rfc5280_gen+0x128>
	cur_pos = new_pos;
    69ae:	68bb      	ldr	r3, [r7, #8]
    69b0:	60fb      	str	r3, [r7, #12]
	timestamp->tm_year -= 1900;
    69b2:	683b      	ldr	r3, [r7, #0]
    69b4:	695b      	ldr	r3, [r3, #20]
    69b6:	4a38      	ldr	r2, [pc, #224]	; (6a98 <atcacert_date_dec_rfc5280_gen+0x138>)
    69b8:	189a      	adds	r2, r3, r2
    69ba:	683b      	ldr	r3, [r7, #0]
    69bc:	615a      	str	r2, [r3, #20]

	new_pos = str_to_int(cur_pos, 2, &timestamp->tm_mon);
    69be:	683b      	ldr	r3, [r7, #0]
    69c0:	3310      	adds	r3, #16
    69c2:	001a      	movs	r2, r3
    69c4:	68fb      	ldr	r3, [r7, #12]
    69c6:	2102      	movs	r1, #2
    69c8:	0018      	movs	r0, r3
    69ca:	4b32      	ldr	r3, [pc, #200]	; (6a94 <atcacert_date_dec_rfc5280_gen+0x134>)
    69cc:	4798      	blx	r3
    69ce:	0003      	movs	r3, r0
    69d0:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    69d2:	68ba      	ldr	r2, [r7, #8]
    69d4:	68fb      	ldr	r3, [r7, #12]
    69d6:	429a      	cmp	r2, r3
    69d8:	d101      	bne.n	69de <atcacert_date_dec_rfc5280_gen+0x7e>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    69da:	2304      	movs	r3, #4
    69dc:	e054      	b.n	6a88 <atcacert_date_dec_rfc5280_gen+0x128>
	cur_pos = new_pos;
    69de:	68bb      	ldr	r3, [r7, #8]
    69e0:	60fb      	str	r3, [r7, #12]
	timestamp->tm_mon -= 1;
    69e2:	683b      	ldr	r3, [r7, #0]
    69e4:	691b      	ldr	r3, [r3, #16]
    69e6:	1e5a      	subs	r2, r3, #1
    69e8:	683b      	ldr	r3, [r7, #0]
    69ea:	611a      	str	r2, [r3, #16]

	new_pos = str_to_int(cur_pos, 2, &timestamp->tm_mday);
    69ec:	683b      	ldr	r3, [r7, #0]
    69ee:	330c      	adds	r3, #12
    69f0:	001a      	movs	r2, r3
    69f2:	68fb      	ldr	r3, [r7, #12]
    69f4:	2102      	movs	r1, #2
    69f6:	0018      	movs	r0, r3
    69f8:	4b26      	ldr	r3, [pc, #152]	; (6a94 <atcacert_date_dec_rfc5280_gen+0x134>)
    69fa:	4798      	blx	r3
    69fc:	0003      	movs	r3, r0
    69fe:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    6a00:	68ba      	ldr	r2, [r7, #8]
    6a02:	68fb      	ldr	r3, [r7, #12]
    6a04:	429a      	cmp	r2, r3
    6a06:	d101      	bne.n	6a0c <atcacert_date_dec_rfc5280_gen+0xac>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    6a08:	2304      	movs	r3, #4
    6a0a:	e03d      	b.n	6a88 <atcacert_date_dec_rfc5280_gen+0x128>
	cur_pos = new_pos;
    6a0c:	68bb      	ldr	r3, [r7, #8]
    6a0e:	60fb      	str	r3, [r7, #12]

	new_pos = str_to_int(cur_pos, 2, &timestamp->tm_hour);
    6a10:	683b      	ldr	r3, [r7, #0]
    6a12:	3308      	adds	r3, #8
    6a14:	001a      	movs	r2, r3
    6a16:	68fb      	ldr	r3, [r7, #12]
    6a18:	2102      	movs	r1, #2
    6a1a:	0018      	movs	r0, r3
    6a1c:	4b1d      	ldr	r3, [pc, #116]	; (6a94 <atcacert_date_dec_rfc5280_gen+0x134>)
    6a1e:	4798      	blx	r3
    6a20:	0003      	movs	r3, r0
    6a22:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    6a24:	68ba      	ldr	r2, [r7, #8]
    6a26:	68fb      	ldr	r3, [r7, #12]
    6a28:	429a      	cmp	r2, r3
    6a2a:	d101      	bne.n	6a30 <atcacert_date_dec_rfc5280_gen+0xd0>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    6a2c:	2304      	movs	r3, #4
    6a2e:	e02b      	b.n	6a88 <atcacert_date_dec_rfc5280_gen+0x128>
	cur_pos = new_pos;
    6a30:	68bb      	ldr	r3, [r7, #8]
    6a32:	60fb      	str	r3, [r7, #12]

	new_pos = str_to_int(cur_pos, 2, &timestamp->tm_min);
    6a34:	683b      	ldr	r3, [r7, #0]
    6a36:	1d1a      	adds	r2, r3, #4
    6a38:	68fb      	ldr	r3, [r7, #12]
    6a3a:	2102      	movs	r1, #2
    6a3c:	0018      	movs	r0, r3
    6a3e:	4b15      	ldr	r3, [pc, #84]	; (6a94 <atcacert_date_dec_rfc5280_gen+0x134>)
    6a40:	4798      	blx	r3
    6a42:	0003      	movs	r3, r0
    6a44:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    6a46:	68ba      	ldr	r2, [r7, #8]
    6a48:	68fb      	ldr	r3, [r7, #12]
    6a4a:	429a      	cmp	r2, r3
    6a4c:	d101      	bne.n	6a52 <atcacert_date_dec_rfc5280_gen+0xf2>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    6a4e:	2304      	movs	r3, #4
    6a50:	e01a      	b.n	6a88 <atcacert_date_dec_rfc5280_gen+0x128>
	cur_pos = new_pos;
    6a52:	68bb      	ldr	r3, [r7, #8]
    6a54:	60fb      	str	r3, [r7, #12]

	new_pos = str_to_int(cur_pos, 2, &timestamp->tm_sec);
    6a56:	683a      	ldr	r2, [r7, #0]
    6a58:	68fb      	ldr	r3, [r7, #12]
    6a5a:	2102      	movs	r1, #2
    6a5c:	0018      	movs	r0, r3
    6a5e:	4b0d      	ldr	r3, [pc, #52]	; (6a94 <atcacert_date_dec_rfc5280_gen+0x134>)
    6a60:	4798      	blx	r3
    6a62:	0003      	movs	r3, r0
    6a64:	60bb      	str	r3, [r7, #8]
	if (new_pos == cur_pos)
    6a66:	68ba      	ldr	r2, [r7, #8]
    6a68:	68fb      	ldr	r3, [r7, #12]
    6a6a:	429a      	cmp	r2, r3
    6a6c:	d101      	bne.n	6a72 <atcacert_date_dec_rfc5280_gen+0x112>
		return ATCACERT_E_DECODING_ERROR; // There was a problem converting the string to a number
    6a6e:	2304      	movs	r3, #4
    6a70:	e00a      	b.n	6a88 <atcacert_date_dec_rfc5280_gen+0x128>
	cur_pos = new_pos;
    6a72:	68bb      	ldr	r3, [r7, #8]
    6a74:	60fb      	str	r3, [r7, #12]

	if (*(cur_pos++) != 'Z')
    6a76:	68fb      	ldr	r3, [r7, #12]
    6a78:	1c5a      	adds	r2, r3, #1
    6a7a:	60fa      	str	r2, [r7, #12]
    6a7c:	781b      	ldrb	r3, [r3, #0]
    6a7e:	2b5a      	cmp	r3, #90	; 0x5a
    6a80:	d001      	beq.n	6a86 <atcacert_date_dec_rfc5280_gen+0x126>
		return ATCACERT_E_DECODING_ERROR; // Unexpected UTC marker
    6a82:	2304      	movs	r3, #4
    6a84:	e000      	b.n	6a88 <atcacert_date_dec_rfc5280_gen+0x128>

	return ATCACERT_E_SUCCESS;
    6a86:	2300      	movs	r3, #0
}
    6a88:	0018      	movs	r0, r3
    6a8a:	46bd      	mov	sp, r7
    6a8c:	b004      	add	sp, #16
    6a8e:	bd80      	pop	{r7, pc}
    6a90:	00012823 	.word	0x00012823
    6a94:	00006209 	.word	0x00006209
    6a98:	fffff894 	.word	0xfffff894

00006a9c <is_leap_year>:

static int is_leap_year(int year)
{
    6a9c:	b580      	push	{r7, lr}
    6a9e:	b082      	sub	sp, #8
    6aa0:	af00      	add	r7, sp, #0
    6aa2:	6078      	str	r0, [r7, #4]
	return (year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0));
    6aa4:	6878      	ldr	r0, [r7, #4]
    6aa6:	4b0c      	ldr	r3, [pc, #48]	; (6ad8 <is_leap_year+0x3c>)
    6aa8:	22c8      	movs	r2, #200	; 0xc8
    6aaa:	0051      	lsls	r1, r2, #1
    6aac:	4798      	blx	r3
    6aae:	1e0b      	subs	r3, r1, #0
    6ab0:	d00a      	beq.n	6ac8 <is_leap_year+0x2c>
    6ab2:	687b      	ldr	r3, [r7, #4]
    6ab4:	2203      	movs	r2, #3
    6ab6:	4013      	ands	r3, r2
    6ab8:	d108      	bne.n	6acc <is_leap_year+0x30>
    6aba:	687a      	ldr	r2, [r7, #4]
    6abc:	4b06      	ldr	r3, [pc, #24]	; (6ad8 <is_leap_year+0x3c>)
    6abe:	2164      	movs	r1, #100	; 0x64
    6ac0:	0010      	movs	r0, r2
    6ac2:	4798      	blx	r3
    6ac4:	1e0b      	subs	r3, r1, #0
    6ac6:	d001      	beq.n	6acc <is_leap_year+0x30>
    6ac8:	2301      	movs	r3, #1
    6aca:	e000      	b.n	6ace <is_leap_year+0x32>
    6acc:	2300      	movs	r3, #0
}
    6ace:	0018      	movs	r0, r3
    6ad0:	46bd      	mov	sp, r7
    6ad2:	b002      	add	sp, #8
    6ad4:	bd80      	pop	{r7, pc}
    6ad6:	46c0      	nop			; (mov r8, r8)
    6ad8:	0001249d 	.word	0x0001249d

00006adc <get_year_secs>:

static uint32_t get_year_secs(int year)
{
    6adc:	b580      	push	{r7, lr}
    6ade:	b082      	sub	sp, #8
    6ae0:	af00      	add	r7, sp, #0
    6ae2:	6078      	str	r0, [r7, #4]
	if (is_leap_year(year))
    6ae4:	687b      	ldr	r3, [r7, #4]
    6ae6:	0018      	movs	r0, r3
    6ae8:	4b05      	ldr	r3, [pc, #20]	; (6b00 <get_year_secs+0x24>)
    6aea:	4798      	blx	r3
    6aec:	1e03      	subs	r3, r0, #0
    6aee:	d001      	beq.n	6af4 <get_year_secs+0x18>
		return (31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31) * 86400;
    6af0:	4b04      	ldr	r3, [pc, #16]	; (6b04 <get_year_secs+0x28>)
    6af2:	e000      	b.n	6af6 <get_year_secs+0x1a>
	else
		return (31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31) * 86400;
    6af4:	4b04      	ldr	r3, [pc, #16]	; (6b08 <get_year_secs+0x2c>)
}
    6af6:	0018      	movs	r0, r3
    6af8:	46bd      	mov	sp, r7
    6afa:	b002      	add	sp, #8
    6afc:	bd80      	pop	{r7, pc}
    6afe:	46c0      	nop			; (mov r8, r8)
    6b00:	00006a9d 	.word	0x00006a9d
    6b04:	01e28500 	.word	0x01e28500
    6b08:	01e13380 	.word	0x01e13380

00006b0c <get_month_secs>:

static uint32_t get_month_secs(int year, int mon)
{
    6b0c:	b580      	push	{r7, lr}
    6b0e:	b082      	sub	sp, #8
    6b10:	af00      	add	r7, sp, #0
    6b12:	6078      	str	r0, [r7, #4]
    6b14:	6039      	str	r1, [r7, #0]
	static const uint32_t month_secs[] = { 2678400, 2419200, 2678400, 2592000, 2678400, 2592000, 2678400, 2678400, 2592000, 2678400, 2592000, 2678400 };

	if (mon == 1 && is_leap_year(year))
    6b16:	683b      	ldr	r3, [r7, #0]
    6b18:	2b01      	cmp	r3, #1
    6b1a:	d107      	bne.n	6b2c <get_month_secs+0x20>
    6b1c:	687b      	ldr	r3, [r7, #4]
    6b1e:	0018      	movs	r0, r3
    6b20:	4b09      	ldr	r3, [pc, #36]	; (6b48 <get_month_secs+0x3c>)
    6b22:	4798      	blx	r3
    6b24:	1e03      	subs	r3, r0, #0
    6b26:	d001      	beq.n	6b2c <get_month_secs+0x20>
		return 2505600;
    6b28:	4b08      	ldr	r3, [pc, #32]	; (6b4c <get_month_secs+0x40>)
    6b2a:	e008      	b.n	6b3e <get_month_secs+0x32>
	else if (mon < 12)
    6b2c:	683b      	ldr	r3, [r7, #0]
    6b2e:	2b0b      	cmp	r3, #11
    6b30:	dc04      	bgt.n	6b3c <get_month_secs+0x30>
		return month_secs[mon];
    6b32:	4b07      	ldr	r3, [pc, #28]	; (6b50 <get_month_secs+0x44>)
    6b34:	683a      	ldr	r2, [r7, #0]
    6b36:	0092      	lsls	r2, r2, #2
    6b38:	58d3      	ldr	r3, [r2, r3]
    6b3a:	e000      	b.n	6b3e <get_month_secs+0x32>
	else
		return 0;
    6b3c:	2300      	movs	r3, #0
}
    6b3e:	0018      	movs	r0, r3
    6b40:	46bd      	mov	sp, r7
    6b42:	b002      	add	sp, #8
    6b44:	bd80      	pop	{r7, pc}
    6b46:	46c0      	nop			; (mov r8, r8)
    6b48:	00006a9d 	.word	0x00006a9d
    6b4c:	00263b80 	.word	0x00263b80
    6b50:	00015248 	.word	0x00015248

00006b54 <atcacert_gmtime32>:

static atcacert_tm_utc_t *atcacert_gmtime32(const uint32_t *posix_time, atcacert_tm_utc_t *result)
{
    6b54:	b590      	push	{r4, r7, lr}
    6b56:	b085      	sub	sp, #20
    6b58:	af00      	add	r7, sp, #0
    6b5a:	6078      	str	r0, [r7, #4]
    6b5c:	6039      	str	r1, [r7, #0]
	uint32_t secs_remaining = *posix_time;
    6b5e:	687b      	ldr	r3, [r7, #4]
    6b60:	681b      	ldr	r3, [r3, #0]
    6b62:	60fb      	str	r3, [r7, #12]
	uint32_t secs = 0;
    6b64:	2300      	movs	r3, #0
    6b66:	60bb      	str	r3, [r7, #8]

	result->tm_year = 1970;
    6b68:	683b      	ldr	r3, [r7, #0]
    6b6a:	4a4f      	ldr	r2, [pc, #316]	; (6ca8 <atcacert_gmtime32+0x154>)
    6b6c:	615a      	str	r2, [r3, #20]
	result->tm_mon = 0;
    6b6e:	683b      	ldr	r3, [r7, #0]
    6b70:	2200      	movs	r2, #0
    6b72:	611a      	str	r2, [r3, #16]
	result->tm_mday = 1;
    6b74:	683b      	ldr	r3, [r7, #0]
    6b76:	2201      	movs	r2, #1
    6b78:	60da      	str	r2, [r3, #12]
	result->tm_hour = 0;
    6b7a:	683b      	ldr	r3, [r7, #0]
    6b7c:	2200      	movs	r2, #0
    6b7e:	609a      	str	r2, [r3, #8]
	result->tm_min = 0;
    6b80:	683b      	ldr	r3, [r7, #0]
    6b82:	2200      	movs	r2, #0
    6b84:	605a      	str	r2, [r3, #4]
	result->tm_sec = 0;
    6b86:	683b      	ldr	r3, [r7, #0]
    6b88:	2200      	movs	r2, #0
    6b8a:	601a      	str	r2, [r3, #0]

	secs = get_year_secs(result->tm_year);
    6b8c:	683b      	ldr	r3, [r7, #0]
    6b8e:	695b      	ldr	r3, [r3, #20]
    6b90:	0018      	movs	r0, r3
    6b92:	4b46      	ldr	r3, [pc, #280]	; (6cac <atcacert_gmtime32+0x158>)
    6b94:	4798      	blx	r3
    6b96:	0003      	movs	r3, r0
    6b98:	60bb      	str	r3, [r7, #8]
	while (secs_remaining >= secs) {
    6b9a:	e00f      	b.n	6bbc <atcacert_gmtime32+0x68>
		result->tm_year++;
    6b9c:	683b      	ldr	r3, [r7, #0]
    6b9e:	695b      	ldr	r3, [r3, #20]
    6ba0:	1c5a      	adds	r2, r3, #1
    6ba2:	683b      	ldr	r3, [r7, #0]
    6ba4:	615a      	str	r2, [r3, #20]
		secs_remaining -= secs;
    6ba6:	68fa      	ldr	r2, [r7, #12]
    6ba8:	68bb      	ldr	r3, [r7, #8]
    6baa:	1ad3      	subs	r3, r2, r3
    6bac:	60fb      	str	r3, [r7, #12]
		secs = get_year_secs(result->tm_year);
    6bae:	683b      	ldr	r3, [r7, #0]
    6bb0:	695b      	ldr	r3, [r3, #20]
    6bb2:	0018      	movs	r0, r3
    6bb4:	4b3d      	ldr	r3, [pc, #244]	; (6cac <atcacert_gmtime32+0x158>)
    6bb6:	4798      	blx	r3
    6bb8:	0003      	movs	r3, r0
    6bba:	60bb      	str	r3, [r7, #8]
	result->tm_hour = 0;
	result->tm_min = 0;
	result->tm_sec = 0;

	secs = get_year_secs(result->tm_year);
	while (secs_remaining >= secs) {
    6bbc:	68fa      	ldr	r2, [r7, #12]
    6bbe:	68bb      	ldr	r3, [r7, #8]
    6bc0:	429a      	cmp	r2, r3
    6bc2:	d2eb      	bcs.n	6b9c <atcacert_gmtime32+0x48>
		result->tm_year++;
		secs_remaining -= secs;
		secs = get_year_secs(result->tm_year);
	}

	secs = get_month_secs(result->tm_year, result->tm_mon);
    6bc4:	683b      	ldr	r3, [r7, #0]
    6bc6:	695a      	ldr	r2, [r3, #20]
    6bc8:	683b      	ldr	r3, [r7, #0]
    6bca:	691b      	ldr	r3, [r3, #16]
    6bcc:	0019      	movs	r1, r3
    6bce:	0010      	movs	r0, r2
    6bd0:	4b37      	ldr	r3, [pc, #220]	; (6cb0 <atcacert_gmtime32+0x15c>)
    6bd2:	4798      	blx	r3
    6bd4:	0003      	movs	r3, r0
    6bd6:	60bb      	str	r3, [r7, #8]
	while (secs_remaining >= secs) {
    6bd8:	e012      	b.n	6c00 <atcacert_gmtime32+0xac>
		result->tm_mon++;
    6bda:	683b      	ldr	r3, [r7, #0]
    6bdc:	691b      	ldr	r3, [r3, #16]
    6bde:	1c5a      	adds	r2, r3, #1
    6be0:	683b      	ldr	r3, [r7, #0]
    6be2:	611a      	str	r2, [r3, #16]
		secs_remaining -= secs;
    6be4:	68fa      	ldr	r2, [r7, #12]
    6be6:	68bb      	ldr	r3, [r7, #8]
    6be8:	1ad3      	subs	r3, r2, r3
    6bea:	60fb      	str	r3, [r7, #12]
		secs = get_month_secs(result->tm_year, result->tm_mon);
    6bec:	683b      	ldr	r3, [r7, #0]
    6bee:	695a      	ldr	r2, [r3, #20]
    6bf0:	683b      	ldr	r3, [r7, #0]
    6bf2:	691b      	ldr	r3, [r3, #16]
    6bf4:	0019      	movs	r1, r3
    6bf6:	0010      	movs	r0, r2
    6bf8:	4b2d      	ldr	r3, [pc, #180]	; (6cb0 <atcacert_gmtime32+0x15c>)
    6bfa:	4798      	blx	r3
    6bfc:	0003      	movs	r3, r0
    6bfe:	60bb      	str	r3, [r7, #8]
		secs_remaining -= secs;
		secs = get_year_secs(result->tm_year);
	}

	secs = get_month_secs(result->tm_year, result->tm_mon);
	while (secs_remaining >= secs) {
    6c00:	68fa      	ldr	r2, [r7, #12]
    6c02:	68bb      	ldr	r3, [r7, #8]
    6c04:	429a      	cmp	r2, r3
    6c06:	d2e8      	bcs.n	6bda <atcacert_gmtime32+0x86>
		result->tm_mon++;
		secs_remaining -= secs;
		secs = get_month_secs(result->tm_year, result->tm_mon);
	}

	result->tm_year -= 1900;
    6c08:	683b      	ldr	r3, [r7, #0]
    6c0a:	695b      	ldr	r3, [r3, #20]
    6c0c:	4a29      	ldr	r2, [pc, #164]	; (6cb4 <atcacert_gmtime32+0x160>)
    6c0e:	189a      	adds	r2, r3, r2
    6c10:	683b      	ldr	r3, [r7, #0]
    6c12:	615a      	str	r2, [r3, #20]

	result->tm_mday += secs_remaining / 86400;
    6c14:	683b      	ldr	r3, [r7, #0]
    6c16:	68db      	ldr	r3, [r3, #12]
    6c18:	001c      	movs	r4, r3
    6c1a:	68fa      	ldr	r2, [r7, #12]
    6c1c:	4b26      	ldr	r3, [pc, #152]	; (6cb8 <atcacert_gmtime32+0x164>)
    6c1e:	4927      	ldr	r1, [pc, #156]	; (6cbc <atcacert_gmtime32+0x168>)
    6c20:	0010      	movs	r0, r2
    6c22:	4798      	blx	r3
    6c24:	0003      	movs	r3, r0
    6c26:	18e3      	adds	r3, r4, r3
    6c28:	001a      	movs	r2, r3
    6c2a:	683b      	ldr	r3, [r7, #0]
    6c2c:	60da      	str	r2, [r3, #12]
	secs_remaining %= 86400;
    6c2e:	68fa      	ldr	r2, [r7, #12]
    6c30:	4b23      	ldr	r3, [pc, #140]	; (6cc0 <atcacert_gmtime32+0x16c>)
    6c32:	4922      	ldr	r1, [pc, #136]	; (6cbc <atcacert_gmtime32+0x168>)
    6c34:	0010      	movs	r0, r2
    6c36:	4798      	blx	r3
    6c38:	000b      	movs	r3, r1
    6c3a:	60fb      	str	r3, [r7, #12]

	result->tm_hour += secs_remaining / 3600;
    6c3c:	683b      	ldr	r3, [r7, #0]
    6c3e:	689b      	ldr	r3, [r3, #8]
    6c40:	001c      	movs	r4, r3
    6c42:	68f8      	ldr	r0, [r7, #12]
    6c44:	4b1c      	ldr	r3, [pc, #112]	; (6cb8 <atcacert_gmtime32+0x164>)
    6c46:	22e1      	movs	r2, #225	; 0xe1
    6c48:	0111      	lsls	r1, r2, #4
    6c4a:	4798      	blx	r3
    6c4c:	0003      	movs	r3, r0
    6c4e:	18e3      	adds	r3, r4, r3
    6c50:	001a      	movs	r2, r3
    6c52:	683b      	ldr	r3, [r7, #0]
    6c54:	609a      	str	r2, [r3, #8]
	secs_remaining %= 3600;
    6c56:	68f8      	ldr	r0, [r7, #12]
    6c58:	4b19      	ldr	r3, [pc, #100]	; (6cc0 <atcacert_gmtime32+0x16c>)
    6c5a:	22e1      	movs	r2, #225	; 0xe1
    6c5c:	0111      	lsls	r1, r2, #4
    6c5e:	4798      	blx	r3
    6c60:	000b      	movs	r3, r1
    6c62:	60fb      	str	r3, [r7, #12]

	result->tm_min += secs_remaining / 60;
    6c64:	683b      	ldr	r3, [r7, #0]
    6c66:	685b      	ldr	r3, [r3, #4]
    6c68:	001c      	movs	r4, r3
    6c6a:	68fa      	ldr	r2, [r7, #12]
    6c6c:	4b12      	ldr	r3, [pc, #72]	; (6cb8 <atcacert_gmtime32+0x164>)
    6c6e:	213c      	movs	r1, #60	; 0x3c
    6c70:	0010      	movs	r0, r2
    6c72:	4798      	blx	r3
    6c74:	0003      	movs	r3, r0
    6c76:	18e3      	adds	r3, r4, r3
    6c78:	001a      	movs	r2, r3
    6c7a:	683b      	ldr	r3, [r7, #0]
    6c7c:	605a      	str	r2, [r3, #4]
	secs_remaining %= 60;
    6c7e:	68fa      	ldr	r2, [r7, #12]
    6c80:	4b0f      	ldr	r3, [pc, #60]	; (6cc0 <atcacert_gmtime32+0x16c>)
    6c82:	213c      	movs	r1, #60	; 0x3c
    6c84:	0010      	movs	r0, r2
    6c86:	4798      	blx	r3
    6c88:	000b      	movs	r3, r1
    6c8a:	60fb      	str	r3, [r7, #12]

	result->tm_sec += secs_remaining;
    6c8c:	683b      	ldr	r3, [r7, #0]
    6c8e:	681b      	ldr	r3, [r3, #0]
    6c90:	001a      	movs	r2, r3
    6c92:	68fb      	ldr	r3, [r7, #12]
    6c94:	18d3      	adds	r3, r2, r3
    6c96:	001a      	movs	r2, r3
    6c98:	683b      	ldr	r3, [r7, #0]
    6c9a:	601a      	str	r2, [r3, #0]

	return result;
    6c9c:	683b      	ldr	r3, [r7, #0]
}
    6c9e:	0018      	movs	r0, r3
    6ca0:	46bd      	mov	sp, r7
    6ca2:	b005      	add	sp, #20
    6ca4:	bd90      	pop	{r4, r7, pc}
    6ca6:	46c0      	nop			; (mov r8, r8)
    6ca8:	000007b2 	.word	0x000007b2
    6cac:	00006add 	.word	0x00006add
    6cb0:	00006b0d 	.word	0x00006b0d
    6cb4:	fffff894 	.word	0xfffff894
    6cb8:	000121bd 	.word	0x000121bd
    6cbc:	00015180 	.word	0x00015180
    6cc0:	000122c9 	.word	0x000122c9

00006cc4 <atcacert_mkgmtime32>:

static uint32_t atcacert_mkgmtime32(const atcacert_tm_utc_t *timeptr)
{
    6cc4:	b580      	push	{r7, lr}
    6cc6:	b086      	sub	sp, #24
    6cc8:	af00      	add	r7, sp, #0
    6cca:	6078      	str	r0, [r7, #4]
	uint32_t posix_time = 0;
    6ccc:	2300      	movs	r3, #0
    6cce:	617b      	str	r3, [r7, #20]
	int cur_value = 0;
    6cd0:	2300      	movs	r3, #0
    6cd2:	613b      	str	r3, [r7, #16]
	int year = timeptr->tm_year + 1900;
    6cd4:	687b      	ldr	r3, [r7, #4]
    6cd6:	695b      	ldr	r3, [r3, #20]
    6cd8:	4a28      	ldr	r2, [pc, #160]	; (6d7c <atcacert_mkgmtime32+0xb8>)
    6cda:	4694      	mov	ip, r2
    6cdc:	4463      	add	r3, ip
    6cde:	60fb      	str	r3, [r7, #12]

	cur_value = year - 1;
    6ce0:	68fb      	ldr	r3, [r7, #12]
    6ce2:	3b01      	subs	r3, #1
    6ce4:	613b      	str	r3, [r7, #16]
	while (cur_value >= 1970)
    6ce6:	e009      	b.n	6cfc <atcacert_mkgmtime32+0x38>
		posix_time += get_year_secs(cur_value--);
    6ce8:	693b      	ldr	r3, [r7, #16]
    6cea:	1e5a      	subs	r2, r3, #1
    6cec:	613a      	str	r2, [r7, #16]
    6cee:	0018      	movs	r0, r3
    6cf0:	4b23      	ldr	r3, [pc, #140]	; (6d80 <atcacert_mkgmtime32+0xbc>)
    6cf2:	4798      	blx	r3
    6cf4:	0002      	movs	r2, r0
    6cf6:	697b      	ldr	r3, [r7, #20]
    6cf8:	189b      	adds	r3, r3, r2
    6cfa:	617b      	str	r3, [r7, #20]
	uint32_t posix_time = 0;
	int cur_value = 0;
	int year = timeptr->tm_year + 1900;

	cur_value = year - 1;
	while (cur_value >= 1970)
    6cfc:	693b      	ldr	r3, [r7, #16]
    6cfe:	4a21      	ldr	r2, [pc, #132]	; (6d84 <atcacert_mkgmtime32+0xc0>)
    6d00:	4293      	cmp	r3, r2
    6d02:	dcf1      	bgt.n	6ce8 <atcacert_mkgmtime32+0x24>
		posix_time += get_year_secs(cur_value--);

	cur_value = timeptr->tm_mon - 1;
    6d04:	687b      	ldr	r3, [r7, #4]
    6d06:	691b      	ldr	r3, [r3, #16]
    6d08:	3b01      	subs	r3, #1
    6d0a:	613b      	str	r3, [r7, #16]
	while (cur_value >= 0)
    6d0c:	e00b      	b.n	6d26 <atcacert_mkgmtime32+0x62>
		posix_time += get_month_secs(year, cur_value--);
    6d0e:	693b      	ldr	r3, [r7, #16]
    6d10:	1e5a      	subs	r2, r3, #1
    6d12:	613a      	str	r2, [r7, #16]
    6d14:	68fa      	ldr	r2, [r7, #12]
    6d16:	0019      	movs	r1, r3
    6d18:	0010      	movs	r0, r2
    6d1a:	4b1b      	ldr	r3, [pc, #108]	; (6d88 <atcacert_mkgmtime32+0xc4>)
    6d1c:	4798      	blx	r3
    6d1e:	0002      	movs	r2, r0
    6d20:	697b      	ldr	r3, [r7, #20]
    6d22:	189b      	adds	r3, r3, r2
    6d24:	617b      	str	r3, [r7, #20]
	cur_value = year - 1;
	while (cur_value >= 1970)
		posix_time += get_year_secs(cur_value--);

	cur_value = timeptr->tm_mon - 1;
	while (cur_value >= 0)
    6d26:	693b      	ldr	r3, [r7, #16]
    6d28:	2b00      	cmp	r3, #0
    6d2a:	daf0      	bge.n	6d0e <atcacert_mkgmtime32+0x4a>
		posix_time += get_month_secs(year, cur_value--);

	posix_time += (uint32_t)(timeptr->tm_mday - 1) * 86400;
    6d2c:	687b      	ldr	r3, [r7, #4]
    6d2e:	68db      	ldr	r3, [r3, #12]
    6d30:	3b01      	subs	r3, #1
    6d32:	001a      	movs	r2, r3
    6d34:	4b15      	ldr	r3, [pc, #84]	; (6d8c <atcacert_mkgmtime32+0xc8>)
    6d36:	4353      	muls	r3, r2
    6d38:	697a      	ldr	r2, [r7, #20]
    6d3a:	18d3      	adds	r3, r2, r3
    6d3c:	617b      	str	r3, [r7, #20]
	posix_time += (uint32_t)timeptr->tm_hour * 3600;
    6d3e:	687b      	ldr	r3, [r7, #4]
    6d40:	689b      	ldr	r3, [r3, #8]
    6d42:	001a      	movs	r2, r3
    6d44:	23e1      	movs	r3, #225	; 0xe1
    6d46:	011b      	lsls	r3, r3, #4
    6d48:	4353      	muls	r3, r2
    6d4a:	697a      	ldr	r2, [r7, #20]
    6d4c:	18d3      	adds	r3, r2, r3
    6d4e:	617b      	str	r3, [r7, #20]
	posix_time += (uint32_t)timeptr->tm_min * 60;
    6d50:	687b      	ldr	r3, [r7, #4]
    6d52:	685b      	ldr	r3, [r3, #4]
    6d54:	001a      	movs	r2, r3
    6d56:	0013      	movs	r3, r2
    6d58:	011b      	lsls	r3, r3, #4
    6d5a:	1a9b      	subs	r3, r3, r2
    6d5c:	009b      	lsls	r3, r3, #2
    6d5e:	001a      	movs	r2, r3
    6d60:	697b      	ldr	r3, [r7, #20]
    6d62:	189b      	adds	r3, r3, r2
    6d64:	617b      	str	r3, [r7, #20]
	posix_time += (uint32_t)timeptr->tm_sec;
    6d66:	687b      	ldr	r3, [r7, #4]
    6d68:	681b      	ldr	r3, [r3, #0]
    6d6a:	001a      	movs	r2, r3
    6d6c:	697b      	ldr	r3, [r7, #20]
    6d6e:	189b      	adds	r3, r3, r2
    6d70:	617b      	str	r3, [r7, #20]

	return posix_time;
    6d72:	697b      	ldr	r3, [r7, #20]
}
    6d74:	0018      	movs	r0, r3
    6d76:	46bd      	mov	sp, r7
    6d78:	b006      	add	sp, #24
    6d7a:	bd80      	pop	{r7, pc}
    6d7c:	0000076c 	.word	0x0000076c
    6d80:	00006add 	.word	0x00006add
    6d84:	000007b1 	.word	0x000007b1
    6d88:	00006b0d 	.word	0x00006b0d
    6d8c:	00015180 	.word	0x00015180

00006d90 <atcacert_date_enc_posix_uint32>:

static int atcacert_date_enc_posix_uint32(const atcacert_tm_utc_t* timestamp, uint32_t* posix_uint32)
{
    6d90:	b580      	push	{r7, lr}
    6d92:	b084      	sub	sp, #16
    6d94:	af00      	add	r7, sp, #0
    6d96:	6078      	str	r0, [r7, #4]
    6d98:	6039      	str	r1, [r7, #0]
	//atcacert_tm_utc_t timestamp_nc;
	//time_t posix_time = 0;
	int year = 0;
    6d9a:	2300      	movs	r3, #0
    6d9c:	60fb      	str	r3, [r7, #12]

	if (timestamp == NULL || posix_uint32 == NULL)
    6d9e:	687b      	ldr	r3, [r7, #4]
    6da0:	2b00      	cmp	r3, #0
    6da2:	d002      	beq.n	6daa <atcacert_date_enc_posix_uint32+0x1a>
    6da4:	683b      	ldr	r3, [r7, #0]
    6da6:	2b00      	cmp	r3, #0
    6da8:	d101      	bne.n	6dae <atcacert_date_enc_posix_uint32+0x1e>
		return ATCACERT_E_BAD_PARAMS;
    6daa:	2302      	movs	r3, #2
    6dac:	e07b      	b.n	6ea6 <atcacert_date_enc_posix_uint32+0x116>

	year = timestamp->tm_year + 1900;
    6dae:	687b      	ldr	r3, [r7, #4]
    6db0:	695b      	ldr	r3, [r3, #20]
    6db2:	4a3f      	ldr	r2, [pc, #252]	; (6eb0 <atcacert_date_enc_posix_uint32+0x120>)
    6db4:	4694      	mov	ip, r2
    6db6:	4463      	add	r3, ip
    6db8:	60fb      	str	r3, [r7, #12]

	if (year > 2106 || year < 1970)
    6dba:	68fb      	ldr	r3, [r7, #12]
    6dbc:	4a3d      	ldr	r2, [pc, #244]	; (6eb4 <atcacert_date_enc_posix_uint32+0x124>)
    6dbe:	4293      	cmp	r3, r2
    6dc0:	dc03      	bgt.n	6dca <atcacert_date_enc_posix_uint32+0x3a>
    6dc2:	68fb      	ldr	r3, [r7, #12]
    6dc4:	4a3c      	ldr	r2, [pc, #240]	; (6eb8 <atcacert_date_enc_posix_uint32+0x128>)
    6dc6:	4293      	cmp	r3, r2
    6dc8:	dc01      	bgt.n	6dce <atcacert_date_enc_posix_uint32+0x3e>
		return ATCACERT_E_INVALID_DATE; //Timestamp out of range for POSIX time.
    6dca:	2305      	movs	r3, #5
    6dcc:	e06b      	b.n	6ea6 <atcacert_date_enc_posix_uint32+0x116>
	if (timestamp->tm_mon < 0 || timestamp->tm_mon > 11)
    6dce:	687b      	ldr	r3, [r7, #4]
    6dd0:	691b      	ldr	r3, [r3, #16]
    6dd2:	2b00      	cmp	r3, #0
    6dd4:	db03      	blt.n	6dde <atcacert_date_enc_posix_uint32+0x4e>
    6dd6:	687b      	ldr	r3, [r7, #4]
    6dd8:	691b      	ldr	r3, [r3, #16]
    6dda:	2b0b      	cmp	r3, #11
    6ddc:	dd01      	ble.n	6de2 <atcacert_date_enc_posix_uint32+0x52>
		return ATCACERT_E_INVALID_DATE;
    6dde:	2305      	movs	r3, #5
    6de0:	e061      	b.n	6ea6 <atcacert_date_enc_posix_uint32+0x116>
	if (timestamp->tm_mday < 1 || timestamp->tm_mday > 31)
    6de2:	687b      	ldr	r3, [r7, #4]
    6de4:	68db      	ldr	r3, [r3, #12]
    6de6:	2b00      	cmp	r3, #0
    6de8:	dd03      	ble.n	6df2 <atcacert_date_enc_posix_uint32+0x62>
    6dea:	687b      	ldr	r3, [r7, #4]
    6dec:	68db      	ldr	r3, [r3, #12]
    6dee:	2b1f      	cmp	r3, #31
    6df0:	dd01      	ble.n	6df6 <atcacert_date_enc_posix_uint32+0x66>
		return ATCACERT_E_INVALID_DATE;
    6df2:	2305      	movs	r3, #5
    6df4:	e057      	b.n	6ea6 <atcacert_date_enc_posix_uint32+0x116>
	if (timestamp->tm_hour < 0 || timestamp->tm_hour > 23)
    6df6:	687b      	ldr	r3, [r7, #4]
    6df8:	689b      	ldr	r3, [r3, #8]
    6dfa:	2b00      	cmp	r3, #0
    6dfc:	db03      	blt.n	6e06 <atcacert_date_enc_posix_uint32+0x76>
    6dfe:	687b      	ldr	r3, [r7, #4]
    6e00:	689b      	ldr	r3, [r3, #8]
    6e02:	2b17      	cmp	r3, #23
    6e04:	dd01      	ble.n	6e0a <atcacert_date_enc_posix_uint32+0x7a>
		return ATCACERT_E_INVALID_DATE;
    6e06:	2305      	movs	r3, #5
    6e08:	e04d      	b.n	6ea6 <atcacert_date_enc_posix_uint32+0x116>
	if (timestamp->tm_min < 0 || timestamp->tm_min > 59)
    6e0a:	687b      	ldr	r3, [r7, #4]
    6e0c:	685b      	ldr	r3, [r3, #4]
    6e0e:	2b00      	cmp	r3, #0
    6e10:	db03      	blt.n	6e1a <atcacert_date_enc_posix_uint32+0x8a>
    6e12:	687b      	ldr	r3, [r7, #4]
    6e14:	685b      	ldr	r3, [r3, #4]
    6e16:	2b3b      	cmp	r3, #59	; 0x3b
    6e18:	dd01      	ble.n	6e1e <atcacert_date_enc_posix_uint32+0x8e>
		return ATCACERT_E_INVALID_DATE;
    6e1a:	2305      	movs	r3, #5
    6e1c:	e043      	b.n	6ea6 <atcacert_date_enc_posix_uint32+0x116>
	if (timestamp->tm_sec < 0 || timestamp->tm_sec > 59)
    6e1e:	687b      	ldr	r3, [r7, #4]
    6e20:	681b      	ldr	r3, [r3, #0]
    6e22:	2b00      	cmp	r3, #0
    6e24:	db03      	blt.n	6e2e <atcacert_date_enc_posix_uint32+0x9e>
    6e26:	687b      	ldr	r3, [r7, #4]
    6e28:	681b      	ldr	r3, [r3, #0]
    6e2a:	2b3b      	cmp	r3, #59	; 0x3b
    6e2c:	dd01      	ble.n	6e32 <atcacert_date_enc_posix_uint32+0xa2>
		return ATCACERT_E_INVALID_DATE;
    6e2e:	2305      	movs	r3, #5
    6e30:	e039      	b.n	6ea6 <atcacert_date_enc_posix_uint32+0x116>
	// Check for date past max date for POSIX time
	if (year == 2106) {
    6e32:	68fb      	ldr	r3, [r7, #12]
    6e34:	4a1f      	ldr	r2, [pc, #124]	; (6eb4 <atcacert_date_enc_posix_uint32+0x124>)
    6e36:	4293      	cmp	r3, r2
    6e38:	d12d      	bne.n	6e96 <atcacert_date_enc_posix_uint32+0x106>
		if (timestamp->tm_mon > 1)
    6e3a:	687b      	ldr	r3, [r7, #4]
    6e3c:	691b      	ldr	r3, [r3, #16]
    6e3e:	2b01      	cmp	r3, #1
    6e40:	dd01      	ble.n	6e46 <atcacert_date_enc_posix_uint32+0xb6>
			return ATCACERT_E_INVALID_DATE;
    6e42:	2305      	movs	r3, #5
    6e44:	e02f      	b.n	6ea6 <atcacert_date_enc_posix_uint32+0x116>
		if (timestamp->tm_mon == 1) {
    6e46:	687b      	ldr	r3, [r7, #4]
    6e48:	691b      	ldr	r3, [r3, #16]
    6e4a:	2b01      	cmp	r3, #1
    6e4c:	d123      	bne.n	6e96 <atcacert_date_enc_posix_uint32+0x106>
			if (timestamp->tm_mday > 7)
    6e4e:	687b      	ldr	r3, [r7, #4]
    6e50:	68db      	ldr	r3, [r3, #12]
    6e52:	2b07      	cmp	r3, #7
    6e54:	dd01      	ble.n	6e5a <atcacert_date_enc_posix_uint32+0xca>
				return ATCACERT_E_INVALID_DATE;
    6e56:	2305      	movs	r3, #5
    6e58:	e025      	b.n	6ea6 <atcacert_date_enc_posix_uint32+0x116>
			if (timestamp->tm_mday == 7) {
    6e5a:	687b      	ldr	r3, [r7, #4]
    6e5c:	68db      	ldr	r3, [r3, #12]
    6e5e:	2b07      	cmp	r3, #7
    6e60:	d119      	bne.n	6e96 <atcacert_date_enc_posix_uint32+0x106>
				if (timestamp->tm_hour > 6)
    6e62:	687b      	ldr	r3, [r7, #4]
    6e64:	689b      	ldr	r3, [r3, #8]
    6e66:	2b06      	cmp	r3, #6
    6e68:	dd01      	ble.n	6e6e <atcacert_date_enc_posix_uint32+0xde>
					return ATCACERT_E_INVALID_DATE;
    6e6a:	2305      	movs	r3, #5
    6e6c:	e01b      	b.n	6ea6 <atcacert_date_enc_posix_uint32+0x116>
				if (timestamp->tm_hour == 6) {
    6e6e:	687b      	ldr	r3, [r7, #4]
    6e70:	689b      	ldr	r3, [r3, #8]
    6e72:	2b06      	cmp	r3, #6
    6e74:	d10f      	bne.n	6e96 <atcacert_date_enc_posix_uint32+0x106>
					if (timestamp->tm_min > 28)
    6e76:	687b      	ldr	r3, [r7, #4]
    6e78:	685b      	ldr	r3, [r3, #4]
    6e7a:	2b1c      	cmp	r3, #28
    6e7c:	dd01      	ble.n	6e82 <atcacert_date_enc_posix_uint32+0xf2>
						return ATCACERT_E_INVALID_DATE;
    6e7e:	2305      	movs	r3, #5
    6e80:	e011      	b.n	6ea6 <atcacert_date_enc_posix_uint32+0x116>
					if (timestamp->tm_min == 28)
    6e82:	687b      	ldr	r3, [r7, #4]
    6e84:	685b      	ldr	r3, [r3, #4]
    6e86:	2b1c      	cmp	r3, #28
    6e88:	d105      	bne.n	6e96 <atcacert_date_enc_posix_uint32+0x106>
						if (timestamp->tm_sec > 14)
    6e8a:	687b      	ldr	r3, [r7, #4]
    6e8c:	681b      	ldr	r3, [r3, #0]
    6e8e:	2b0e      	cmp	r3, #14
    6e90:	dd01      	ble.n	6e96 <atcacert_date_enc_posix_uint32+0x106>
							return ATCACERT_E_INVALID_DATE;
    6e92:	2305      	movs	r3, #5
    6e94:	e007      	b.n	6ea6 <atcacert_date_enc_posix_uint32+0x116>
//		return ATCACERT_E_INVALID_DATE;
//#endif
//
//	*posix_uint32 = (uint32_t)posix_time;

	*posix_uint32 = atcacert_mkgmtime32(timestamp);
    6e96:	687b      	ldr	r3, [r7, #4]
    6e98:	0018      	movs	r0, r3
    6e9a:	4b08      	ldr	r3, [pc, #32]	; (6ebc <atcacert_date_enc_posix_uint32+0x12c>)
    6e9c:	4798      	blx	r3
    6e9e:	0002      	movs	r2, r0
    6ea0:	683b      	ldr	r3, [r7, #0]
    6ea2:	601a      	str	r2, [r3, #0]

	return ATCACERT_E_SUCCESS;
    6ea4:	2300      	movs	r3, #0
}
    6ea6:	0018      	movs	r0, r3
    6ea8:	46bd      	mov	sp, r7
    6eaa:	b004      	add	sp, #16
    6eac:	bd80      	pop	{r7, pc}
    6eae:	46c0      	nop			; (mov r8, r8)
    6eb0:	0000076c 	.word	0x0000076c
    6eb4:	0000083a 	.word	0x0000083a
    6eb8:	000007b1 	.word	0x000007b1
    6ebc:	00006cc5 	.word	0x00006cc5

00006ec0 <atcacert_date_enc_posix_uint32_be>:

int atcacert_date_enc_posix_uint32_be( const atcacert_tm_utc_t*  timestamp,
                                       uint8_t formatted_date[DATEFMT_POSIX_UINT32_BE_SIZE])
{
    6ec0:	b580      	push	{r7, lr}
    6ec2:	b084      	sub	sp, #16
    6ec4:	af00      	add	r7, sp, #0
    6ec6:	6078      	str	r0, [r7, #4]
    6ec8:	6039      	str	r1, [r7, #0]
	uint32_t posix_uint32 = 0;
    6eca:	2300      	movs	r3, #0
    6ecc:	60bb      	str	r3, [r7, #8]
	int ret = 0;
    6ece:	2300      	movs	r3, #0
    6ed0:	60fb      	str	r3, [r7, #12]

	if (timestamp == NULL || formatted_date == NULL)
    6ed2:	687b      	ldr	r3, [r7, #4]
    6ed4:	2b00      	cmp	r3, #0
    6ed6:	d002      	beq.n	6ede <atcacert_date_enc_posix_uint32_be+0x1e>
    6ed8:	683b      	ldr	r3, [r7, #0]
    6eda:	2b00      	cmp	r3, #0
    6edc:	d101      	bne.n	6ee2 <atcacert_date_enc_posix_uint32_be+0x22>
		return ATCACERT_E_BAD_PARAMS;
    6ede:	2302      	movs	r3, #2
    6ee0:	e024      	b.n	6f2c <atcacert_date_enc_posix_uint32_be+0x6c>

	ret = atcacert_date_enc_posix_uint32(timestamp, &posix_uint32);
    6ee2:	2308      	movs	r3, #8
    6ee4:	18fa      	adds	r2, r7, r3
    6ee6:	687b      	ldr	r3, [r7, #4]
    6ee8:	0011      	movs	r1, r2
    6eea:	0018      	movs	r0, r3
    6eec:	4b11      	ldr	r3, [pc, #68]	; (6f34 <atcacert_date_enc_posix_uint32_be+0x74>)
    6eee:	4798      	blx	r3
    6ef0:	0003      	movs	r3, r0
    6ef2:	60fb      	str	r3, [r7, #12]
	if (ret != ATCACERT_E_SUCCESS)
    6ef4:	68fb      	ldr	r3, [r7, #12]
    6ef6:	2b00      	cmp	r3, #0
    6ef8:	d001      	beq.n	6efe <atcacert_date_enc_posix_uint32_be+0x3e>
		return ret;
    6efa:	68fb      	ldr	r3, [r7, #12]
    6efc:	e016      	b.n	6f2c <atcacert_date_enc_posix_uint32_be+0x6c>

	formatted_date[0] = (uint8_t)((posix_uint32 >> 24) & 0xFF);
    6efe:	68bb      	ldr	r3, [r7, #8]
    6f00:	0e1b      	lsrs	r3, r3, #24
    6f02:	b2da      	uxtb	r2, r3
    6f04:	683b      	ldr	r3, [r7, #0]
    6f06:	701a      	strb	r2, [r3, #0]
	formatted_date[1] = (uint8_t)((posix_uint32 >> 16) & 0xFF);
    6f08:	683b      	ldr	r3, [r7, #0]
    6f0a:	3301      	adds	r3, #1
    6f0c:	68ba      	ldr	r2, [r7, #8]
    6f0e:	0c12      	lsrs	r2, r2, #16
    6f10:	b2d2      	uxtb	r2, r2
    6f12:	701a      	strb	r2, [r3, #0]
	formatted_date[2] = (uint8_t)((posix_uint32 >> 8) & 0xFF);
    6f14:	683b      	ldr	r3, [r7, #0]
    6f16:	3302      	adds	r3, #2
    6f18:	68ba      	ldr	r2, [r7, #8]
    6f1a:	0a12      	lsrs	r2, r2, #8
    6f1c:	b2d2      	uxtb	r2, r2
    6f1e:	701a      	strb	r2, [r3, #0]
	formatted_date[3] = (uint8_t)((posix_uint32 >> 0) & 0xFF);
    6f20:	683b      	ldr	r3, [r7, #0]
    6f22:	3303      	adds	r3, #3
    6f24:	68ba      	ldr	r2, [r7, #8]
    6f26:	b2d2      	uxtb	r2, r2
    6f28:	701a      	strb	r2, [r3, #0]

	return ATCACERT_E_SUCCESS;
    6f2a:	2300      	movs	r3, #0
}
    6f2c:	0018      	movs	r0, r3
    6f2e:	46bd      	mov	sp, r7
    6f30:	b004      	add	sp, #16
    6f32:	bd80      	pop	{r7, pc}
    6f34:	00006d91 	.word	0x00006d91

00006f38 <atcacert_date_dec_posix_uint32>:

static int atcacert_date_dec_posix_uint32( uint32_t posix_uint32,
                                           atcacert_tm_utc_t*  timestamp)
{
    6f38:	b580      	push	{r7, lr}
    6f3a:	b082      	sub	sp, #8
    6f3c:	af00      	add	r7, sp, #0
    6f3e:	6078      	str	r0, [r7, #4]
    6f40:	6039      	str	r1, [r7, #0]
//	memset(timestamp, 0, sizeof(*timestamp));
//	ret = gmtime_r(&posix_time, timestamp);
//	if (ret == NULL)
//		return ATCACERT_E_DECODING_ERROR; // Failed to convert to timestamp structure
//#endif
	atcacert_gmtime32(&posix_uint32, timestamp);
    6f42:	683a      	ldr	r2, [r7, #0]
    6f44:	1d3b      	adds	r3, r7, #4
    6f46:	0011      	movs	r1, r2
    6f48:	0018      	movs	r0, r3
    6f4a:	4b03      	ldr	r3, [pc, #12]	; (6f58 <atcacert_date_dec_posix_uint32+0x20>)
    6f4c:	4798      	blx	r3

	return ATCACERT_E_SUCCESS;
    6f4e:	2300      	movs	r3, #0
}
    6f50:	0018      	movs	r0, r3
    6f52:	46bd      	mov	sp, r7
    6f54:	b002      	add	sp, #8
    6f56:	bd80      	pop	{r7, pc}
    6f58:	00006b55 	.word	0x00006b55

00006f5c <atcacert_date_dec_posix_uint32_be>:

int atcacert_date_dec_posix_uint32_be( const uint8_t formatted_date[DATEFMT_POSIX_UINT32_BE_SIZE],
                                       atcacert_tm_utc_t*  timestamp)
{
    6f5c:	b580      	push	{r7, lr}
    6f5e:	b084      	sub	sp, #16
    6f60:	af00      	add	r7, sp, #0
    6f62:	6078      	str	r0, [r7, #4]
    6f64:	6039      	str	r1, [r7, #0]
	uint32_t posix_uint32 = 0;
    6f66:	2300      	movs	r3, #0
    6f68:	60fb      	str	r3, [r7, #12]

	if (formatted_date == NULL || timestamp == NULL)
    6f6a:	687b      	ldr	r3, [r7, #4]
    6f6c:	2b00      	cmp	r3, #0
    6f6e:	d002      	beq.n	6f76 <atcacert_date_dec_posix_uint32_be+0x1a>
    6f70:	683b      	ldr	r3, [r7, #0]
    6f72:	2b00      	cmp	r3, #0
    6f74:	d101      	bne.n	6f7a <atcacert_date_dec_posix_uint32_be+0x1e>
		return ATCACERT_E_BAD_PARAMS;
    6f76:	2302      	movs	r3, #2
    6f78:	e018      	b.n	6fac <atcacert_date_dec_posix_uint32_be+0x50>

	posix_uint32 =
	    ((uint32_t)formatted_date[0] << 24) |
    6f7a:	687b      	ldr	r3, [r7, #4]
    6f7c:	781b      	ldrb	r3, [r3, #0]
    6f7e:	061a      	lsls	r2, r3, #24
	    ((uint32_t)formatted_date[1] << 16) |
    6f80:	687b      	ldr	r3, [r7, #4]
    6f82:	3301      	adds	r3, #1
    6f84:	781b      	ldrb	r3, [r3, #0]
    6f86:	041b      	lsls	r3, r3, #16

	if (formatted_date == NULL || timestamp == NULL)
		return ATCACERT_E_BAD_PARAMS;

	posix_uint32 =
	    ((uint32_t)formatted_date[0] << 24) |
    6f88:	431a      	orrs	r2, r3
	    ((uint32_t)formatted_date[1] << 16) |
	    ((uint32_t)formatted_date[2] << 8) |
    6f8a:	687b      	ldr	r3, [r7, #4]
    6f8c:	3302      	adds	r3, #2
    6f8e:	781b      	ldrb	r3, [r3, #0]
    6f90:	021b      	lsls	r3, r3, #8
	if (formatted_date == NULL || timestamp == NULL)
		return ATCACERT_E_BAD_PARAMS;

	posix_uint32 =
	    ((uint32_t)formatted_date[0] << 24) |
	    ((uint32_t)formatted_date[1] << 16) |
    6f92:	4313      	orrs	r3, r2
	    ((uint32_t)formatted_date[2] << 8) |
	    ((uint32_t)formatted_date[3]);
    6f94:	687a      	ldr	r2, [r7, #4]
    6f96:	3203      	adds	r2, #3
    6f98:	7812      	ldrb	r2, [r2, #0]
	uint32_t posix_uint32 = 0;

	if (formatted_date == NULL || timestamp == NULL)
		return ATCACERT_E_BAD_PARAMS;

	posix_uint32 =
    6f9a:	4313      	orrs	r3, r2
    6f9c:	60fb      	str	r3, [r7, #12]
	    ((uint32_t)formatted_date[0] << 24) |
	    ((uint32_t)formatted_date[1] << 16) |
	    ((uint32_t)formatted_date[2] << 8) |
	    ((uint32_t)formatted_date[3]);

	return atcacert_date_dec_posix_uint32(posix_uint32, timestamp);
    6f9e:	683a      	ldr	r2, [r7, #0]
    6fa0:	68fb      	ldr	r3, [r7, #12]
    6fa2:	0011      	movs	r1, r2
    6fa4:	0018      	movs	r0, r3
    6fa6:	4b03      	ldr	r3, [pc, #12]	; (6fb4 <atcacert_date_dec_posix_uint32_be+0x58>)
    6fa8:	4798      	blx	r3
    6faa:	0003      	movs	r3, r0
}
    6fac:	0018      	movs	r0, r3
    6fae:	46bd      	mov	sp, r7
    6fb0:	b004      	add	sp, #16
    6fb2:	bd80      	pop	{r7, pc}
    6fb4:	00006f39 	.word	0x00006f39

00006fb8 <atcacert_date_enc_posix_uint32_le>:

int atcacert_date_enc_posix_uint32_le( const atcacert_tm_utc_t*  timestamp,
                                       uint8_t formatted_date[DATEFMT_POSIX_UINT32_LE_SIZE])
{
    6fb8:	b580      	push	{r7, lr}
    6fba:	b084      	sub	sp, #16
    6fbc:	af00      	add	r7, sp, #0
    6fbe:	6078      	str	r0, [r7, #4]
    6fc0:	6039      	str	r1, [r7, #0]
	uint32_t posix_uint32 = 0;
    6fc2:	2300      	movs	r3, #0
    6fc4:	60bb      	str	r3, [r7, #8]
	int ret = 0;
    6fc6:	2300      	movs	r3, #0
    6fc8:	60fb      	str	r3, [r7, #12]

	if (timestamp == NULL || formatted_date == NULL)
    6fca:	687b      	ldr	r3, [r7, #4]
    6fcc:	2b00      	cmp	r3, #0
    6fce:	d002      	beq.n	6fd6 <atcacert_date_enc_posix_uint32_le+0x1e>
    6fd0:	683b      	ldr	r3, [r7, #0]
    6fd2:	2b00      	cmp	r3, #0
    6fd4:	d101      	bne.n	6fda <atcacert_date_enc_posix_uint32_le+0x22>
		return ATCACERT_E_BAD_PARAMS;
    6fd6:	2302      	movs	r3, #2
    6fd8:	e024      	b.n	7024 <atcacert_date_enc_posix_uint32_le+0x6c>

	ret = atcacert_date_enc_posix_uint32(timestamp, &posix_uint32);
    6fda:	2308      	movs	r3, #8
    6fdc:	18fa      	adds	r2, r7, r3
    6fde:	687b      	ldr	r3, [r7, #4]
    6fe0:	0011      	movs	r1, r2
    6fe2:	0018      	movs	r0, r3
    6fe4:	4b11      	ldr	r3, [pc, #68]	; (702c <atcacert_date_enc_posix_uint32_le+0x74>)
    6fe6:	4798      	blx	r3
    6fe8:	0003      	movs	r3, r0
    6fea:	60fb      	str	r3, [r7, #12]
	if (ret != ATCACERT_E_SUCCESS)
    6fec:	68fb      	ldr	r3, [r7, #12]
    6fee:	2b00      	cmp	r3, #0
    6ff0:	d001      	beq.n	6ff6 <atcacert_date_enc_posix_uint32_le+0x3e>
		return ret;
    6ff2:	68fb      	ldr	r3, [r7, #12]
    6ff4:	e016      	b.n	7024 <atcacert_date_enc_posix_uint32_le+0x6c>

	formatted_date[0] = (uint8_t)((posix_uint32 >> 0) & 0xFF);
    6ff6:	68bb      	ldr	r3, [r7, #8]
    6ff8:	b2da      	uxtb	r2, r3
    6ffa:	683b      	ldr	r3, [r7, #0]
    6ffc:	701a      	strb	r2, [r3, #0]
	formatted_date[1] = (uint8_t)((posix_uint32 >> 8) & 0xFF);
    6ffe:	683b      	ldr	r3, [r7, #0]
    7000:	3301      	adds	r3, #1
    7002:	68ba      	ldr	r2, [r7, #8]
    7004:	0a12      	lsrs	r2, r2, #8
    7006:	b2d2      	uxtb	r2, r2
    7008:	701a      	strb	r2, [r3, #0]
	formatted_date[2] = (uint8_t)((posix_uint32 >> 16) & 0xFF);
    700a:	683b      	ldr	r3, [r7, #0]
    700c:	3302      	adds	r3, #2
    700e:	68ba      	ldr	r2, [r7, #8]
    7010:	0c12      	lsrs	r2, r2, #16
    7012:	b2d2      	uxtb	r2, r2
    7014:	701a      	strb	r2, [r3, #0]
	formatted_date[3] = (uint8_t)((posix_uint32 >> 24) & 0xFF);
    7016:	683b      	ldr	r3, [r7, #0]
    7018:	3303      	adds	r3, #3
    701a:	68ba      	ldr	r2, [r7, #8]
    701c:	0e12      	lsrs	r2, r2, #24
    701e:	b2d2      	uxtb	r2, r2
    7020:	701a      	strb	r2, [r3, #0]

	return ATCACERT_E_SUCCESS;
    7022:	2300      	movs	r3, #0
}
    7024:	0018      	movs	r0, r3
    7026:	46bd      	mov	sp, r7
    7028:	b004      	add	sp, #16
    702a:	bd80      	pop	{r7, pc}
    702c:	00006d91 	.word	0x00006d91

00007030 <atcacert_date_dec_posix_uint32_le>:

int atcacert_date_dec_posix_uint32_le( const uint8_t formatted_date[DATEFMT_POSIX_UINT32_LE_SIZE],
                                       atcacert_tm_utc_t*  timestamp)
{
    7030:	b580      	push	{r7, lr}
    7032:	b084      	sub	sp, #16
    7034:	af00      	add	r7, sp, #0
    7036:	6078      	str	r0, [r7, #4]
    7038:	6039      	str	r1, [r7, #0]
	uint32_t posix_uint32 = 0;
    703a:	2300      	movs	r3, #0
    703c:	60fb      	str	r3, [r7, #12]

	if (formatted_date == NULL || timestamp == NULL)
    703e:	687b      	ldr	r3, [r7, #4]
    7040:	2b00      	cmp	r3, #0
    7042:	d002      	beq.n	704a <atcacert_date_dec_posix_uint32_le+0x1a>
    7044:	683b      	ldr	r3, [r7, #0]
    7046:	2b00      	cmp	r3, #0
    7048:	d101      	bne.n	704e <atcacert_date_dec_posix_uint32_le+0x1e>
		return ATCACERT_E_BAD_PARAMS;
    704a:	2302      	movs	r3, #2
    704c:	e018      	b.n	7080 <atcacert_date_dec_posix_uint32_le+0x50>

	posix_uint32 =
	    ((uint32_t)formatted_date[3] << 24) |
    704e:	687b      	ldr	r3, [r7, #4]
    7050:	3303      	adds	r3, #3
    7052:	781b      	ldrb	r3, [r3, #0]
    7054:	061a      	lsls	r2, r3, #24
	    ((uint32_t)formatted_date[2] << 16) |
    7056:	687b      	ldr	r3, [r7, #4]
    7058:	3302      	adds	r3, #2
    705a:	781b      	ldrb	r3, [r3, #0]
    705c:	041b      	lsls	r3, r3, #16

	if (formatted_date == NULL || timestamp == NULL)
		return ATCACERT_E_BAD_PARAMS;

	posix_uint32 =
	    ((uint32_t)formatted_date[3] << 24) |
    705e:	431a      	orrs	r2, r3
	    ((uint32_t)formatted_date[2] << 16) |
	    ((uint32_t)formatted_date[1] << 8) |
    7060:	687b      	ldr	r3, [r7, #4]
    7062:	3301      	adds	r3, #1
    7064:	781b      	ldrb	r3, [r3, #0]
    7066:	021b      	lsls	r3, r3, #8
	if (formatted_date == NULL || timestamp == NULL)
		return ATCACERT_E_BAD_PARAMS;

	posix_uint32 =
	    ((uint32_t)formatted_date[3] << 24) |
	    ((uint32_t)formatted_date[2] << 16) |
    7068:	4313      	orrs	r3, r2
	    ((uint32_t)formatted_date[1] << 8) |
	    ((uint32_t)formatted_date[0]);
    706a:	687a      	ldr	r2, [r7, #4]
    706c:	7812      	ldrb	r2, [r2, #0]
	uint32_t posix_uint32 = 0;

	if (formatted_date == NULL || timestamp == NULL)
		return ATCACERT_E_BAD_PARAMS;

	posix_uint32 =
    706e:	4313      	orrs	r3, r2
    7070:	60fb      	str	r3, [r7, #12]
	    ((uint32_t)formatted_date[3] << 24) |
	    ((uint32_t)formatted_date[2] << 16) |
	    ((uint32_t)formatted_date[1] << 8) |
	    ((uint32_t)formatted_date[0]);

	return atcacert_date_dec_posix_uint32(posix_uint32, timestamp);
    7072:	683a      	ldr	r2, [r7, #0]
    7074:	68fb      	ldr	r3, [r7, #12]
    7076:	0011      	movs	r1, r2
    7078:	0018      	movs	r0, r3
    707a:	4b03      	ldr	r3, [pc, #12]	; (7088 <atcacert_date_dec_posix_uint32_le+0x58>)
    707c:	4798      	blx	r3
    707e:	0003      	movs	r3, r0
}
    7080:	0018      	movs	r0, r3
    7082:	46bd      	mov	sp, r7
    7084:	b004      	add	sp, #16
    7086:	bd80      	pop	{r7, pc}
    7088:	00006f39 	.word	0x00006f39

0000708c <atcacert_date_enc_compcert>:

int atcacert_date_enc_compcert( const atcacert_tm_utc_t*  issue_date,
                                uint8_t expire_years,
                                uint8_t enc_dates[3])
{
    708c:	b580      	push	{r7, lr}
    708e:	b084      	sub	sp, #16
    7090:	af00      	add	r7, sp, #0
    7092:	60f8      	str	r0, [r7, #12]
    7094:	607a      	str	r2, [r7, #4]
    7096:	230b      	movs	r3, #11
    7098:	18fb      	adds	r3, r7, r3
    709a:	1c0a      	adds	r2, r1, #0
    709c:	701a      	strb	r2, [r3, #0]
	 * |         |       |         |         | Years   |
	 * +---------+-------+---------+---------+---------+
	 *
	 * Minutes and seconds are always zero.
	 */
	if (issue_date == NULL || enc_dates == NULL)
    709e:	68fb      	ldr	r3, [r7, #12]
    70a0:	2b00      	cmp	r3, #0
    70a2:	d002      	beq.n	70aa <atcacert_date_enc_compcert+0x1e>
    70a4:	687b      	ldr	r3, [r7, #4]
    70a6:	2b00      	cmp	r3, #0
    70a8:	d101      	bne.n	70ae <atcacert_date_enc_compcert+0x22>
		return ATCACERT_E_BAD_PARAMS;
    70aa:	2302      	movs	r3, #2
    70ac:	e0c5      	b.n	723a <atcacert_date_enc_compcert+0x1ae>

	if ((issue_date->tm_year + 1900) < 2000 || (issue_date->tm_year + 1900) > 2031)
    70ae:	68fb      	ldr	r3, [r7, #12]
    70b0:	695b      	ldr	r3, [r3, #20]
    70b2:	4a64      	ldr	r2, [pc, #400]	; (7244 <atcacert_date_enc_compcert+0x1b8>)
    70b4:	4694      	mov	ip, r2
    70b6:	4463      	add	r3, ip
    70b8:	4a63      	ldr	r2, [pc, #396]	; (7248 <atcacert_date_enc_compcert+0x1bc>)
    70ba:	4293      	cmp	r3, r2
    70bc:	dd07      	ble.n	70ce <atcacert_date_enc_compcert+0x42>
    70be:	68fb      	ldr	r3, [r7, #12]
    70c0:	695b      	ldr	r3, [r3, #20]
    70c2:	4a60      	ldr	r2, [pc, #384]	; (7244 <atcacert_date_enc_compcert+0x1b8>)
    70c4:	4694      	mov	ip, r2
    70c6:	4463      	add	r3, ip
    70c8:	4a60      	ldr	r2, [pc, #384]	; (724c <atcacert_date_enc_compcert+0x1c0>)
    70ca:	4293      	cmp	r3, r2
    70cc:	dd01      	ble.n	70d2 <atcacert_date_enc_compcert+0x46>
		return ATCACERT_E_INVALID_DATE;
    70ce:	2305      	movs	r3, #5
    70d0:	e0b3      	b.n	723a <atcacert_date_enc_compcert+0x1ae>
	if (issue_date->tm_mon < 0 || issue_date->tm_mon > 11)
    70d2:	68fb      	ldr	r3, [r7, #12]
    70d4:	691b      	ldr	r3, [r3, #16]
    70d6:	2b00      	cmp	r3, #0
    70d8:	db03      	blt.n	70e2 <atcacert_date_enc_compcert+0x56>
    70da:	68fb      	ldr	r3, [r7, #12]
    70dc:	691b      	ldr	r3, [r3, #16]
    70de:	2b0b      	cmp	r3, #11
    70e0:	dd01      	ble.n	70e6 <atcacert_date_enc_compcert+0x5a>
		return ATCACERT_E_INVALID_DATE;
    70e2:	2305      	movs	r3, #5
    70e4:	e0a9      	b.n	723a <atcacert_date_enc_compcert+0x1ae>
	if (issue_date->tm_mday < 1 || issue_date->tm_mday > 31)
    70e6:	68fb      	ldr	r3, [r7, #12]
    70e8:	68db      	ldr	r3, [r3, #12]
    70ea:	2b00      	cmp	r3, #0
    70ec:	dd03      	ble.n	70f6 <atcacert_date_enc_compcert+0x6a>
    70ee:	68fb      	ldr	r3, [r7, #12]
    70f0:	68db      	ldr	r3, [r3, #12]
    70f2:	2b1f      	cmp	r3, #31
    70f4:	dd01      	ble.n	70fa <atcacert_date_enc_compcert+0x6e>
		return ATCACERT_E_INVALID_DATE;
    70f6:	2305      	movs	r3, #5
    70f8:	e09f      	b.n	723a <atcacert_date_enc_compcert+0x1ae>
	if (issue_date->tm_hour < 0 || issue_date->tm_hour > 23)
    70fa:	68fb      	ldr	r3, [r7, #12]
    70fc:	689b      	ldr	r3, [r3, #8]
    70fe:	2b00      	cmp	r3, #0
    7100:	db03      	blt.n	710a <atcacert_date_enc_compcert+0x7e>
    7102:	68fb      	ldr	r3, [r7, #12]
    7104:	689b      	ldr	r3, [r3, #8]
    7106:	2b17      	cmp	r3, #23
    7108:	dd01      	ble.n	710e <atcacert_date_enc_compcert+0x82>
		return ATCACERT_E_INVALID_DATE;
    710a:	2305      	movs	r3, #5
    710c:	e095      	b.n	723a <atcacert_date_enc_compcert+0x1ae>
	if (expire_years > 31)
    710e:	230b      	movs	r3, #11
    7110:	18fb      	adds	r3, r7, r3
    7112:	781b      	ldrb	r3, [r3, #0]
    7114:	2b1f      	cmp	r3, #31
    7116:	d901      	bls.n	711c <atcacert_date_enc_compcert+0x90>
		return ATCACERT_E_INVALID_DATE;
    7118:	2305      	movs	r3, #5
    711a:	e08e      	b.n	723a <atcacert_date_enc_compcert+0x1ae>

	memset(enc_dates, 0, 3);
    711c:	687b      	ldr	r3, [r7, #4]
    711e:	2203      	movs	r2, #3
    7120:	2100      	movs	r1, #0
    7122:	0018      	movs	r0, r3
    7124:	4b4a      	ldr	r3, [pc, #296]	; (7250 <atcacert_date_enc_compcert+0x1c4>)
    7126:	4798      	blx	r3

	enc_dates[0] = (enc_dates[0] & 0x07) | (((issue_date->tm_year + 1900 - 2000) & 0x1F) << 3);
    7128:	687b      	ldr	r3, [r7, #4]
    712a:	781b      	ldrb	r3, [r3, #0]
    712c:	b25b      	sxtb	r3, r3
    712e:	2207      	movs	r2, #7
    7130:	4013      	ands	r3, r2
    7132:	b25a      	sxtb	r2, r3
    7134:	68fb      	ldr	r3, [r7, #12]
    7136:	695b      	ldr	r3, [r3, #20]
    7138:	3b64      	subs	r3, #100	; 0x64
    713a:	00db      	lsls	r3, r3, #3
    713c:	b25b      	sxtb	r3, r3
    713e:	4313      	orrs	r3, r2
    7140:	b25b      	sxtb	r3, r3
    7142:	b2da      	uxtb	r2, r3
    7144:	687b      	ldr	r3, [r7, #4]
    7146:	701a      	strb	r2, [r3, #0]
	enc_dates[0] = (enc_dates[0] & 0xF8) | (((issue_date->tm_mon + 1) & 0x0F) >> 1);
    7148:	687b      	ldr	r3, [r7, #4]
    714a:	781b      	ldrb	r3, [r3, #0]
    714c:	b25b      	sxtb	r3, r3
    714e:	2207      	movs	r2, #7
    7150:	4393      	bics	r3, r2
    7152:	b25a      	sxtb	r2, r3
    7154:	68fb      	ldr	r3, [r7, #12]
    7156:	691b      	ldr	r3, [r3, #16]
    7158:	3301      	adds	r3, #1
    715a:	105b      	asrs	r3, r3, #1
    715c:	b25b      	sxtb	r3, r3
    715e:	2107      	movs	r1, #7
    7160:	400b      	ands	r3, r1
    7162:	b25b      	sxtb	r3, r3
    7164:	4313      	orrs	r3, r2
    7166:	b25b      	sxtb	r3, r3
    7168:	b2da      	uxtb	r2, r3
    716a:	687b      	ldr	r3, [r7, #4]
    716c:	701a      	strb	r2, [r3, #0]
	enc_dates[1] = (enc_dates[1] & 0x7F) | (((issue_date->tm_mon + 1) & 0x0F) << 7);
    716e:	687b      	ldr	r3, [r7, #4]
    7170:	1c5a      	adds	r2, r3, #1
    7172:	687b      	ldr	r3, [r7, #4]
    7174:	3301      	adds	r3, #1
    7176:	781b      	ldrb	r3, [r3, #0]
    7178:	b25b      	sxtb	r3, r3
    717a:	217f      	movs	r1, #127	; 0x7f
    717c:	400b      	ands	r3, r1
    717e:	b259      	sxtb	r1, r3
    7180:	68fb      	ldr	r3, [r7, #12]
    7182:	691b      	ldr	r3, [r3, #16]
    7184:	3301      	adds	r3, #1
    7186:	01db      	lsls	r3, r3, #7
    7188:	b25b      	sxtb	r3, r3
    718a:	207f      	movs	r0, #127	; 0x7f
    718c:	4383      	bics	r3, r0
    718e:	b25b      	sxtb	r3, r3
    7190:	430b      	orrs	r3, r1
    7192:	b25b      	sxtb	r3, r3
    7194:	b2db      	uxtb	r3, r3
    7196:	7013      	strb	r3, [r2, #0]
	enc_dates[1] = (enc_dates[1] & 0x83) | ((issue_date->tm_mday & 0x1F) << 2);
    7198:	687b      	ldr	r3, [r7, #4]
    719a:	1c5a      	adds	r2, r3, #1
    719c:	687b      	ldr	r3, [r7, #4]
    719e:	3301      	adds	r3, #1
    71a0:	781b      	ldrb	r3, [r3, #0]
    71a2:	b25b      	sxtb	r3, r3
    71a4:	217c      	movs	r1, #124	; 0x7c
    71a6:	438b      	bics	r3, r1
    71a8:	b259      	sxtb	r1, r3
    71aa:	68fb      	ldr	r3, [r7, #12]
    71ac:	68db      	ldr	r3, [r3, #12]
    71ae:	009b      	lsls	r3, r3, #2
    71b0:	b25b      	sxtb	r3, r3
    71b2:	207c      	movs	r0, #124	; 0x7c
    71b4:	4003      	ands	r3, r0
    71b6:	b25b      	sxtb	r3, r3
    71b8:	430b      	orrs	r3, r1
    71ba:	b25b      	sxtb	r3, r3
    71bc:	b2db      	uxtb	r3, r3
    71be:	7013      	strb	r3, [r2, #0]
	enc_dates[1] = (enc_dates[1] & 0xFC) | ((issue_date->tm_hour & 0x1F) >> 3);
    71c0:	687b      	ldr	r3, [r7, #4]
    71c2:	1c5a      	adds	r2, r3, #1
    71c4:	687b      	ldr	r3, [r7, #4]
    71c6:	3301      	adds	r3, #1
    71c8:	781b      	ldrb	r3, [r3, #0]
    71ca:	b25b      	sxtb	r3, r3
    71cc:	2103      	movs	r1, #3
    71ce:	438b      	bics	r3, r1
    71d0:	b259      	sxtb	r1, r3
    71d2:	68fb      	ldr	r3, [r7, #12]
    71d4:	689b      	ldr	r3, [r3, #8]
    71d6:	10db      	asrs	r3, r3, #3
    71d8:	b25b      	sxtb	r3, r3
    71da:	2003      	movs	r0, #3
    71dc:	4003      	ands	r3, r0
    71de:	b25b      	sxtb	r3, r3
    71e0:	430b      	orrs	r3, r1
    71e2:	b25b      	sxtb	r3, r3
    71e4:	b2db      	uxtb	r3, r3
    71e6:	7013      	strb	r3, [r2, #0]
	enc_dates[2] = (enc_dates[2] & 0x1F) | ((issue_date->tm_hour & 0x1F) << 5);
    71e8:	687b      	ldr	r3, [r7, #4]
    71ea:	1c9a      	adds	r2, r3, #2
    71ec:	687b      	ldr	r3, [r7, #4]
    71ee:	3302      	adds	r3, #2
    71f0:	781b      	ldrb	r3, [r3, #0]
    71f2:	b25b      	sxtb	r3, r3
    71f4:	211f      	movs	r1, #31
    71f6:	400b      	ands	r3, r1
    71f8:	b259      	sxtb	r1, r3
    71fa:	68fb      	ldr	r3, [r7, #12]
    71fc:	689b      	ldr	r3, [r3, #8]
    71fe:	015b      	lsls	r3, r3, #5
    7200:	b25b      	sxtb	r3, r3
    7202:	201f      	movs	r0, #31
    7204:	4383      	bics	r3, r0
    7206:	b25b      	sxtb	r3, r3
    7208:	430b      	orrs	r3, r1
    720a:	b25b      	sxtb	r3, r3
    720c:	b2db      	uxtb	r3, r3
    720e:	7013      	strb	r3, [r2, #0]
	enc_dates[2] = (enc_dates[2] & 0xE0) | (expire_years & 0x1F);
    7210:	687b      	ldr	r3, [r7, #4]
    7212:	3302      	adds	r3, #2
    7214:	687a      	ldr	r2, [r7, #4]
    7216:	3202      	adds	r2, #2
    7218:	7812      	ldrb	r2, [r2, #0]
    721a:	b252      	sxtb	r2, r2
    721c:	211f      	movs	r1, #31
    721e:	438a      	bics	r2, r1
    7220:	b251      	sxtb	r1, r2
    7222:	220b      	movs	r2, #11
    7224:	18ba      	adds	r2, r7, r2
    7226:	7812      	ldrb	r2, [r2, #0]
    7228:	b252      	sxtb	r2, r2
    722a:	201f      	movs	r0, #31
    722c:	4002      	ands	r2, r0
    722e:	b252      	sxtb	r2, r2
    7230:	430a      	orrs	r2, r1
    7232:	b252      	sxtb	r2, r2
    7234:	b2d2      	uxtb	r2, r2
    7236:	701a      	strb	r2, [r3, #0]

	return ATCACERT_E_SUCCESS;
    7238:	2300      	movs	r3, #0
}
    723a:	0018      	movs	r0, r3
    723c:	46bd      	mov	sp, r7
    723e:	b004      	add	sp, #16
    7240:	bd80      	pop	{r7, pc}
    7242:	46c0      	nop			; (mov r8, r8)
    7244:	0000076c 	.word	0x0000076c
    7248:	000007cf 	.word	0x000007cf
    724c:	000007ef 	.word	0x000007ef
    7250:	00012823 	.word	0x00012823

00007254 <atcacert_date_dec_compcert>:

int atcacert_date_dec_compcert( const uint8_t enc_dates[3],
                                atcacert_date_format_t expire_date_format,
                                atcacert_tm_utc_t*      issue_date,
                                atcacert_tm_utc_t*      expire_date)
{
    7254:	b580      	push	{r7, lr}
    7256:	b086      	sub	sp, #24
    7258:	af00      	add	r7, sp, #0
    725a:	60f8      	str	r0, [r7, #12]
    725c:	607a      	str	r2, [r7, #4]
    725e:	603b      	str	r3, [r7, #0]
    7260:	230b      	movs	r3, #11
    7262:	18fb      	adds	r3, r7, r3
    7264:	1c0a      	adds	r2, r1, #0
    7266:	701a      	strb	r2, [r3, #0]
	int ret = ATCACERT_E_SUCCESS;
    7268:	2300      	movs	r3, #0
    726a:	617b      	str	r3, [r7, #20]
	uint8_t expire_years = 0;
    726c:	2313      	movs	r3, #19
    726e:	18fb      	adds	r3, r7, r3
    7270:	2200      	movs	r2, #0
    7272:	701a      	strb	r2, [r3, #0]
	 * +---------+-------+---------+---------+---------+
	 *
	 * Minutes and seconds are always zero.
	 */

	if (enc_dates == NULL || issue_date == NULL || expire_date == NULL || expire_date_format < 0 || expire_date_format >= sizeof(ATCACERT_DATE_FORMAT_SIZES) / sizeof(ATCACERT_DATE_FORMAT_SIZES[0]))
    7274:	68fb      	ldr	r3, [r7, #12]
    7276:	2b00      	cmp	r3, #0
    7278:	d00a      	beq.n	7290 <atcacert_date_dec_compcert+0x3c>
    727a:	687b      	ldr	r3, [r7, #4]
    727c:	2b00      	cmp	r3, #0
    727e:	d007      	beq.n	7290 <atcacert_date_dec_compcert+0x3c>
    7280:	683b      	ldr	r3, [r7, #0]
    7282:	2b00      	cmp	r3, #0
    7284:	d004      	beq.n	7290 <atcacert_date_dec_compcert+0x3c>
    7286:	230b      	movs	r3, #11
    7288:	18fb      	adds	r3, r7, r3
    728a:	781b      	ldrb	r3, [r3, #0]
    728c:	2b04      	cmp	r3, #4
    728e:	d901      	bls.n	7294 <atcacert_date_dec_compcert+0x40>
		return ATCACERT_E_BAD_PARAMS;
    7290:	2302      	movs	r3, #2
    7292:	e069      	b.n	7368 <atcacert_date_dec_compcert+0x114>

	memset(issue_date, 0, sizeof(*issue_date));
    7294:	687b      	ldr	r3, [r7, #4]
    7296:	2218      	movs	r2, #24
    7298:	2100      	movs	r1, #0
    729a:	0018      	movs	r0, r3
    729c:	4b34      	ldr	r3, [pc, #208]	; (7370 <atcacert_date_dec_compcert+0x11c>)
    729e:	4798      	blx	r3
	memset(expire_date, 0, sizeof(*expire_date));
    72a0:	683b      	ldr	r3, [r7, #0]
    72a2:	2218      	movs	r2, #24
    72a4:	2100      	movs	r1, #0
    72a6:	0018      	movs	r0, r3
    72a8:	4b31      	ldr	r3, [pc, #196]	; (7370 <atcacert_date_dec_compcert+0x11c>)
    72aa:	4798      	blx	r3

	issue_date->tm_year = (enc_dates[0] >> 3) + 2000 - 1900;
    72ac:	68fb      	ldr	r3, [r7, #12]
    72ae:	781b      	ldrb	r3, [r3, #0]
    72b0:	08db      	lsrs	r3, r3, #3
    72b2:	b2db      	uxtb	r3, r3
    72b4:	3364      	adds	r3, #100	; 0x64
    72b6:	001a      	movs	r2, r3
    72b8:	687b      	ldr	r3, [r7, #4]
    72ba:	615a      	str	r2, [r3, #20]
	issue_date->tm_mon  = (((enc_dates[0] & 0x07) << 1) | ((enc_dates[1] & 0x80) >> 7)) - 1;
    72bc:	68fb      	ldr	r3, [r7, #12]
    72be:	781b      	ldrb	r3, [r3, #0]
    72c0:	005b      	lsls	r3, r3, #1
    72c2:	220e      	movs	r2, #14
    72c4:	4013      	ands	r3, r2
    72c6:	68fa      	ldr	r2, [r7, #12]
    72c8:	3201      	adds	r2, #1
    72ca:	7812      	ldrb	r2, [r2, #0]
    72cc:	09d2      	lsrs	r2, r2, #7
    72ce:	b2d2      	uxtb	r2, r2
    72d0:	4313      	orrs	r3, r2
    72d2:	1e5a      	subs	r2, r3, #1
    72d4:	687b      	ldr	r3, [r7, #4]
    72d6:	611a      	str	r2, [r3, #16]
	issue_date->tm_mday = ((enc_dates[1] & 0x7C) >> 2);
    72d8:	68fb      	ldr	r3, [r7, #12]
    72da:	3301      	adds	r3, #1
    72dc:	781b      	ldrb	r3, [r3, #0]
    72de:	109b      	asrs	r3, r3, #2
    72e0:	221f      	movs	r2, #31
    72e2:	401a      	ands	r2, r3
    72e4:	687b      	ldr	r3, [r7, #4]
    72e6:	60da      	str	r2, [r3, #12]
	issue_date->tm_hour = ((enc_dates[1] & 0x03) << 3) | ((enc_dates[2] & 0xE0) >> 5);
    72e8:	68fb      	ldr	r3, [r7, #12]
    72ea:	3301      	adds	r3, #1
    72ec:	781b      	ldrb	r3, [r3, #0]
    72ee:	00db      	lsls	r3, r3, #3
    72f0:	2218      	movs	r2, #24
    72f2:	4013      	ands	r3, r2
    72f4:	68fa      	ldr	r2, [r7, #12]
    72f6:	3202      	adds	r2, #2
    72f8:	7812      	ldrb	r2, [r2, #0]
    72fa:	0952      	lsrs	r2, r2, #5
    72fc:	b2d2      	uxtb	r2, r2
    72fe:	431a      	orrs	r2, r3
    7300:	687b      	ldr	r3, [r7, #4]
    7302:	609a      	str	r2, [r3, #8]

	expire_years = (enc_dates[2] & 0x1F);
    7304:	68fb      	ldr	r3, [r7, #12]
    7306:	3302      	adds	r3, #2
    7308:	781a      	ldrb	r2, [r3, #0]
    730a:	2313      	movs	r3, #19
    730c:	18fb      	adds	r3, r7, r3
    730e:	211f      	movs	r1, #31
    7310:	400a      	ands	r2, r1
    7312:	701a      	strb	r2, [r3, #0]

	if (expire_years != 0) {
    7314:	2313      	movs	r3, #19
    7316:	18fb      	adds	r3, r7, r3
    7318:	781b      	ldrb	r3, [r3, #0]
    731a:	2b00      	cmp	r3, #0
    731c:	d014      	beq.n	7348 <atcacert_date_dec_compcert+0xf4>
		expire_date->tm_year = issue_date->tm_year + expire_years;
    731e:	687b      	ldr	r3, [r7, #4]
    7320:	695a      	ldr	r2, [r3, #20]
    7322:	2313      	movs	r3, #19
    7324:	18fb      	adds	r3, r7, r3
    7326:	781b      	ldrb	r3, [r3, #0]
    7328:	18d2      	adds	r2, r2, r3
    732a:	683b      	ldr	r3, [r7, #0]
    732c:	615a      	str	r2, [r3, #20]
		expire_date->tm_mon  = issue_date->tm_mon;
    732e:	687b      	ldr	r3, [r7, #4]
    7330:	691a      	ldr	r2, [r3, #16]
    7332:	683b      	ldr	r3, [r7, #0]
    7334:	611a      	str	r2, [r3, #16]
		expire_date->tm_mday = issue_date->tm_mday;
    7336:	687b      	ldr	r3, [r7, #4]
    7338:	68da      	ldr	r2, [r3, #12]
    733a:	683b      	ldr	r3, [r7, #0]
    733c:	60da      	str	r2, [r3, #12]
		expire_date->tm_hour = issue_date->tm_hour;
    733e:	687b      	ldr	r3, [r7, #4]
    7340:	689a      	ldr	r2, [r3, #8]
    7342:	683b      	ldr	r3, [r7, #0]
    7344:	609a      	str	r2, [r3, #8]
    7346:	e00e      	b.n	7366 <atcacert_date_dec_compcert+0x112>
	}else {
		// Expire years of 0, means no expiration. Set to max date for the given expiration date format.
		ret = atcacert_date_get_max_date(expire_date_format, expire_date);
    7348:	683a      	ldr	r2, [r7, #0]
    734a:	230b      	movs	r3, #11
    734c:	18fb      	adds	r3, r7, r3
    734e:	781b      	ldrb	r3, [r3, #0]
    7350:	0011      	movs	r1, r2
    7352:	0018      	movs	r0, r3
    7354:	4b07      	ldr	r3, [pc, #28]	; (7374 <atcacert_date_dec_compcert+0x120>)
    7356:	4798      	blx	r3
    7358:	0003      	movs	r3, r0
    735a:	617b      	str	r3, [r7, #20]
		if (ret != ATCACERT_E_SUCCESS)
    735c:	697b      	ldr	r3, [r7, #20]
    735e:	2b00      	cmp	r3, #0
    7360:	d001      	beq.n	7366 <atcacert_date_dec_compcert+0x112>
			return ret;
    7362:	697b      	ldr	r3, [r7, #20]
    7364:	e000      	b.n	7368 <atcacert_date_dec_compcert+0x114>
	}

	return ATCACERT_E_SUCCESS;
    7366:	2300      	movs	r3, #0
    7368:	0018      	movs	r0, r3
    736a:	46bd      	mov	sp, r7
    736c:	b006      	add	sp, #24
    736e:	bd80      	pop	{r7, pc}
    7370:	00012823 	.word	0x00012823
    7374:	00005fc1 	.word	0x00005fc1

00007378 <atcacert_merge_device_loc>:
int atcacert_merge_device_loc( atcacert_device_loc_t*       device_locs,
                               size_t*                      device_locs_count,
                               size_t device_locs_max_count,
                               const atcacert_device_loc_t* device_loc,
                               size_t block_size)
{
    7378:	b590      	push	{r4, r7, lr}
    737a:	b08b      	sub	sp, #44	; 0x2c
    737c:	af00      	add	r7, sp, #0
    737e:	60f8      	str	r0, [r7, #12]
    7380:	60b9      	str	r1, [r7, #8]
    7382:	607a      	str	r2, [r7, #4]
    7384:	603b      	str	r3, [r7, #0]
	size_t i = 0;
    7386:	2300      	movs	r3, #0
    7388:	627b      	str	r3, [r7, #36]	; 0x24
	size_t new_offset;
	size_t new_end;

	if (device_locs == NULL || device_locs_count == NULL || device_loc == NULL || block_size <= 0)
    738a:	68fb      	ldr	r3, [r7, #12]
    738c:	2b00      	cmp	r3, #0
    738e:	d008      	beq.n	73a2 <atcacert_merge_device_loc+0x2a>
    7390:	68bb      	ldr	r3, [r7, #8]
    7392:	2b00      	cmp	r3, #0
    7394:	d005      	beq.n	73a2 <atcacert_merge_device_loc+0x2a>
    7396:	683b      	ldr	r3, [r7, #0]
    7398:	2b00      	cmp	r3, #0
    739a:	d002      	beq.n	73a2 <atcacert_merge_device_loc+0x2a>
    739c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    739e:	2b00      	cmp	r3, #0
    73a0:	d101      	bne.n	73a6 <atcacert_merge_device_loc+0x2e>
		return ATCACERT_E_BAD_PARAMS;
    73a2:	2302      	movs	r3, #2
    73a4:	e162      	b.n	766c <atcacert_merge_device_loc+0x2f4>

	if (device_loc->zone == DEVZONE_NONE || device_loc->count == 0)
    73a6:	683b      	ldr	r3, [r7, #0]
    73a8:	781b      	ldrb	r3, [r3, #0]
    73aa:	2b07      	cmp	r3, #7
    73ac:	d007      	beq.n	73be <atcacert_merge_device_loc+0x46>
    73ae:	683b      	ldr	r3, [r7, #0]
    73b0:	795a      	ldrb	r2, [r3, #5]
    73b2:	799b      	ldrb	r3, [r3, #6]
    73b4:	021b      	lsls	r3, r3, #8
    73b6:	4313      	orrs	r3, r2
    73b8:	b29b      	uxth	r3, r3
    73ba:	2b00      	cmp	r3, #0
    73bc:	d101      	bne.n	73c2 <atcacert_merge_device_loc+0x4a>
		return ATCACERT_E_SUCCESS;                                                                      // New device location doesn't exist
    73be:	2300      	movs	r3, #0
    73c0:	e154      	b.n	766c <atcacert_merge_device_loc+0x2f4>

	new_offset = (device_loc->offset / block_size) * block_size;                                        // Round down to block_size
    73c2:	683b      	ldr	r3, [r7, #0]
    73c4:	78da      	ldrb	r2, [r3, #3]
    73c6:	791b      	ldrb	r3, [r3, #4]
    73c8:	021b      	lsls	r3, r3, #8
    73ca:	4313      	orrs	r3, r2
    73cc:	b29b      	uxth	r3, r3
    73ce:	001a      	movs	r2, r3
    73d0:	4ba8      	ldr	r3, [pc, #672]	; (7674 <atcacert_merge_device_loc+0x2fc>)
    73d2:	6bb9      	ldr	r1, [r7, #56]	; 0x38
    73d4:	0010      	movs	r0, r2
    73d6:	4798      	blx	r3
    73d8:	0003      	movs	r3, r0
    73da:	001a      	movs	r2, r3
    73dc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    73de:	4353      	muls	r3, r2
    73e0:	623b      	str	r3, [r7, #32]
	new_end = device_loc->offset + device_loc->count;
    73e2:	683b      	ldr	r3, [r7, #0]
    73e4:	78da      	ldrb	r2, [r3, #3]
    73e6:	791b      	ldrb	r3, [r3, #4]
    73e8:	021b      	lsls	r3, r3, #8
    73ea:	4313      	orrs	r3, r2
    73ec:	b29b      	uxth	r3, r3
    73ee:	0019      	movs	r1, r3
    73f0:	683b      	ldr	r3, [r7, #0]
    73f2:	795a      	ldrb	r2, [r3, #5]
    73f4:	799b      	ldrb	r3, [r3, #6]
    73f6:	021b      	lsls	r3, r3, #8
    73f8:	4313      	orrs	r3, r2
    73fa:	b29b      	uxth	r3, r3
    73fc:	18cb      	adds	r3, r1, r3
    73fe:	61fb      	str	r3, [r7, #28]
	new_end = ((new_end % block_size) ? new_end / block_size + 1 : new_end / block_size) * block_size;  // Round up to block size
    7400:	69fa      	ldr	r2, [r7, #28]
    7402:	4b9d      	ldr	r3, [pc, #628]	; (7678 <atcacert_merge_device_loc+0x300>)
    7404:	6bb9      	ldr	r1, [r7, #56]	; 0x38
    7406:	0010      	movs	r0, r2
    7408:	4798      	blx	r3
    740a:	1e0b      	subs	r3, r1, #0
    740c:	d006      	beq.n	741c <atcacert_merge_device_loc+0xa4>
    740e:	4b99      	ldr	r3, [pc, #612]	; (7674 <atcacert_merge_device_loc+0x2fc>)
    7410:	6bb9      	ldr	r1, [r7, #56]	; 0x38
    7412:	69f8      	ldr	r0, [r7, #28]
    7414:	4798      	blx	r3
    7416:	0003      	movs	r3, r0
    7418:	3301      	adds	r3, #1
    741a:	e004      	b.n	7426 <atcacert_merge_device_loc+0xae>
    741c:	4b95      	ldr	r3, [pc, #596]	; (7674 <atcacert_merge_device_loc+0x2fc>)
    741e:	6bb9      	ldr	r1, [r7, #56]	; 0x38
    7420:	69f8      	ldr	r0, [r7, #28]
    7422:	4798      	blx	r3
    7424:	0003      	movs	r3, r0
    7426:	6bba      	ldr	r2, [r7, #56]	; 0x38
    7428:	4353      	muls	r3, r2
    742a:	61fb      	str	r3, [r7, #28]

	// Try to merge with an existing device location
	for (i = 0; i < *device_locs_count; ++i) {
    742c:	2300      	movs	r3, #0
    742e:	627b      	str	r3, [r7, #36]	; 0x24
    7430:	e0b8      	b.n	75a4 <atcacert_merge_device_loc+0x22c>
		atcacert_device_loc_t* cur_device_loc = &device_locs[i];
    7432:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    7434:	0013      	movs	r3, r2
    7436:	00db      	lsls	r3, r3, #3
    7438:	1a9b      	subs	r3, r3, r2
    743a:	68fa      	ldr	r2, [r7, #12]
    743c:	18d3      	adds	r3, r2, r3
    743e:	61bb      	str	r3, [r7, #24]
		size_t cur_end = cur_device_loc->offset + cur_device_loc->count;
    7440:	69bb      	ldr	r3, [r7, #24]
    7442:	78da      	ldrb	r2, [r3, #3]
    7444:	791b      	ldrb	r3, [r3, #4]
    7446:	021b      	lsls	r3, r3, #8
    7448:	4313      	orrs	r3, r2
    744a:	b29b      	uxth	r3, r3
    744c:	0019      	movs	r1, r3
    744e:	69bb      	ldr	r3, [r7, #24]
    7450:	795a      	ldrb	r2, [r3, #5]
    7452:	799b      	ldrb	r3, [r3, #6]
    7454:	021b      	lsls	r3, r3, #8
    7456:	4313      	orrs	r3, r2
    7458:	b29b      	uxth	r3, r3
    745a:	18cb      	adds	r3, r1, r3
    745c:	617b      	str	r3, [r7, #20]

		if (device_loc->zone != cur_device_loc->zone)
    745e:	683b      	ldr	r3, [r7, #0]
    7460:	781a      	ldrb	r2, [r3, #0]
    7462:	69bb      	ldr	r3, [r7, #24]
    7464:	781b      	ldrb	r3, [r3, #0]
    7466:	429a      	cmp	r2, r3
    7468:	d000      	beq.n	746c <atcacert_merge_device_loc+0xf4>
    746a:	e091      	b.n	7590 <atcacert_merge_device_loc+0x218>
			continue;   // Not the same zone, can't merge
		if (device_loc->zone == DEVZONE_DATA && device_loc->slot != cur_device_loc->slot)
    746c:	683b      	ldr	r3, [r7, #0]
    746e:	781b      	ldrb	r3, [r3, #0]
    7470:	2b02      	cmp	r3, #2
    7472:	d106      	bne.n	7482 <atcacert_merge_device_loc+0x10a>
    7474:	683b      	ldr	r3, [r7, #0]
    7476:	785a      	ldrb	r2, [r3, #1]
    7478:	69bb      	ldr	r3, [r7, #24]
    747a:	785b      	ldrb	r3, [r3, #1]
    747c:	429a      	cmp	r2, r3
    747e:	d000      	beq.n	7482 <atcacert_merge_device_loc+0x10a>
    7480:	e088      	b.n	7594 <atcacert_merge_device_loc+0x21c>
			continue;   // Not the same slot, can't merge
		if (device_loc->zone == DEVZONE_DATA && device_loc->is_genkey != cur_device_loc->is_genkey)
    7482:	683b      	ldr	r3, [r7, #0]
    7484:	781b      	ldrb	r3, [r3, #0]
    7486:	2b02      	cmp	r3, #2
    7488:	d106      	bne.n	7498 <atcacert_merge_device_loc+0x120>
    748a:	683b      	ldr	r3, [r7, #0]
    748c:	789a      	ldrb	r2, [r3, #2]
    748e:	69bb      	ldr	r3, [r7, #24]
    7490:	789b      	ldrb	r3, [r3, #2]
    7492:	429a      	cmp	r2, r3
    7494:	d000      	beq.n	7498 <atcacert_merge_device_loc+0x120>
    7496:	e07f      	b.n	7598 <atcacert_merge_device_loc+0x220>
			continue;   // Not the same read method, can't merge.
		if (new_end < cur_device_loc->offset || new_offset > cur_end)
    7498:	69bb      	ldr	r3, [r7, #24]
    749a:	78da      	ldrb	r2, [r3, #3]
    749c:	791b      	ldrb	r3, [r3, #4]
    749e:	021b      	lsls	r3, r3, #8
    74a0:	4313      	orrs	r3, r2
    74a2:	b29b      	uxth	r3, r3
    74a4:	1e1a      	subs	r2, r3, #0
    74a6:	69fb      	ldr	r3, [r7, #28]
    74a8:	429a      	cmp	r2, r3
    74aa:	d900      	bls.n	74ae <atcacert_merge_device_loc+0x136>
    74ac:	e076      	b.n	759c <atcacert_merge_device_loc+0x224>
    74ae:	6a3a      	ldr	r2, [r7, #32]
    74b0:	697b      	ldr	r3, [r7, #20]
    74b2:	429a      	cmp	r2, r3
    74b4:	d872      	bhi.n	759c <atcacert_merge_device_loc+0x224>
			continue;   // Same zone, but non-continuous areas

		if (device_loc->offset < cur_device_loc->offset)
    74b6:	683b      	ldr	r3, [r7, #0]
    74b8:	78da      	ldrb	r2, [r3, #3]
    74ba:	791b      	ldrb	r3, [r3, #4]
    74bc:	021b      	lsls	r3, r3, #8
    74be:	4313      	orrs	r3, r2
    74c0:	b29a      	uxth	r2, r3
    74c2:	69bb      	ldr	r3, [r7, #24]
    74c4:	78d9      	ldrb	r1, [r3, #3]
    74c6:	791b      	ldrb	r3, [r3, #4]
    74c8:	021b      	lsls	r3, r3, #8
    74ca:	430b      	orrs	r3, r1
    74cc:	b29b      	uxth	r3, r3
    74ce:	429a      	cmp	r2, r3
    74d0:	d21a      	bcs.n	7508 <atcacert_merge_device_loc+0x190>
			cur_device_loc->offset = device_loc->offset;
    74d2:	683b      	ldr	r3, [r7, #0]
    74d4:	78da      	ldrb	r2, [r3, #3]
    74d6:	791b      	ldrb	r3, [r3, #4]
    74d8:	021b      	lsls	r3, r3, #8
    74da:	4313      	orrs	r3, r2
    74dc:	b29a      	uxth	r2, r3
    74de:	69bb      	ldr	r3, [r7, #24]
    74e0:	3303      	adds	r3, #3
    74e2:	21ff      	movs	r1, #255	; 0xff
    74e4:	4011      	ands	r1, r2
    74e6:	000c      	movs	r4, r1
    74e8:	7819      	ldrb	r1, [r3, #0]
    74ea:	2000      	movs	r0, #0
    74ec:	4001      	ands	r1, r0
    74ee:	1c08      	adds	r0, r1, #0
    74f0:	1c21      	adds	r1, r4, #0
    74f2:	4301      	orrs	r1, r0
    74f4:	7019      	strb	r1, [r3, #0]
    74f6:	0a12      	lsrs	r2, r2, #8
    74f8:	b290      	uxth	r0, r2
    74fa:	785a      	ldrb	r2, [r3, #1]
    74fc:	2100      	movs	r1, #0
    74fe:	400a      	ands	r2, r1
    7500:	1c11      	adds	r1, r2, #0
    7502:	1c02      	adds	r2, r0, #0
    7504:	430a      	orrs	r2, r1
    7506:	705a      	strb	r2, [r3, #1]

		if (new_end > cur_end)
    7508:	69fa      	ldr	r2, [r7, #28]
    750a:	697b      	ldr	r3, [r7, #20]
    750c:	429a      	cmp	r2, r3
    750e:	d91f      	bls.n	7550 <atcacert_merge_device_loc+0x1d8>
			cur_device_loc->count = (uint16_t)(new_end - cur_device_loc->offset);
    7510:	69fb      	ldr	r3, [r7, #28]
    7512:	b29a      	uxth	r2, r3
    7514:	69bb      	ldr	r3, [r7, #24]
    7516:	78d9      	ldrb	r1, [r3, #3]
    7518:	791b      	ldrb	r3, [r3, #4]
    751a:	021b      	lsls	r3, r3, #8
    751c:	430b      	orrs	r3, r1
    751e:	b29b      	uxth	r3, r3
    7520:	1ad3      	subs	r3, r2, r3
    7522:	b29a      	uxth	r2, r3
    7524:	69bb      	ldr	r3, [r7, #24]
    7526:	3305      	adds	r3, #5
    7528:	21ff      	movs	r1, #255	; 0xff
    752a:	4011      	ands	r1, r2
    752c:	000c      	movs	r4, r1
    752e:	7819      	ldrb	r1, [r3, #0]
    7530:	2000      	movs	r0, #0
    7532:	4001      	ands	r1, r0
    7534:	1c08      	adds	r0, r1, #0
    7536:	1c21      	adds	r1, r4, #0
    7538:	4301      	orrs	r1, r0
    753a:	7019      	strb	r1, [r3, #0]
    753c:	0a12      	lsrs	r2, r2, #8
    753e:	b290      	uxth	r0, r2
    7540:	785a      	ldrb	r2, [r3, #1]
    7542:	2100      	movs	r1, #0
    7544:	400a      	ands	r2, r1
    7546:	1c11      	adds	r1, r2, #0
    7548:	1c02      	adds	r2, r0, #0
    754a:	430a      	orrs	r2, r1
    754c:	705a      	strb	r2, [r3, #1]
		else
			cur_device_loc->count = (uint16_t)(cur_end - cur_device_loc->offset);
		break;
    754e:	e02f      	b.n	75b0 <atcacert_merge_device_loc+0x238>
			cur_device_loc->offset = device_loc->offset;

		if (new_end > cur_end)
			cur_device_loc->count = (uint16_t)(new_end - cur_device_loc->offset);
		else
			cur_device_loc->count = (uint16_t)(cur_end - cur_device_loc->offset);
    7550:	697b      	ldr	r3, [r7, #20]
    7552:	b29a      	uxth	r2, r3
    7554:	69bb      	ldr	r3, [r7, #24]
    7556:	78d9      	ldrb	r1, [r3, #3]
    7558:	791b      	ldrb	r3, [r3, #4]
    755a:	021b      	lsls	r3, r3, #8
    755c:	430b      	orrs	r3, r1
    755e:	b29b      	uxth	r3, r3
    7560:	1ad3      	subs	r3, r2, r3
    7562:	b29a      	uxth	r2, r3
    7564:	69bb      	ldr	r3, [r7, #24]
    7566:	3305      	adds	r3, #5
    7568:	21ff      	movs	r1, #255	; 0xff
    756a:	4011      	ands	r1, r2
    756c:	000c      	movs	r4, r1
    756e:	7819      	ldrb	r1, [r3, #0]
    7570:	2000      	movs	r0, #0
    7572:	4001      	ands	r1, r0
    7574:	1c08      	adds	r0, r1, #0
    7576:	1c21      	adds	r1, r4, #0
    7578:	4301      	orrs	r1, r0
    757a:	7019      	strb	r1, [r3, #0]
    757c:	0a12      	lsrs	r2, r2, #8
    757e:	b290      	uxth	r0, r2
    7580:	785a      	ldrb	r2, [r3, #1]
    7582:	2100      	movs	r1, #0
    7584:	400a      	ands	r2, r1
    7586:	1c11      	adds	r1, r2, #0
    7588:	1c02      	adds	r2, r0, #0
    758a:	430a      	orrs	r2, r1
    758c:	705a      	strb	r2, [r3, #1]
		break;
    758e:	e00f      	b.n	75b0 <atcacert_merge_device_loc+0x238>
	for (i = 0; i < *device_locs_count; ++i) {
		atcacert_device_loc_t* cur_device_loc = &device_locs[i];
		size_t cur_end = cur_device_loc->offset + cur_device_loc->count;

		if (device_loc->zone != cur_device_loc->zone)
			continue;   // Not the same zone, can't merge
    7590:	46c0      	nop			; (mov r8, r8)
    7592:	e004      	b.n	759e <atcacert_merge_device_loc+0x226>
		if (device_loc->zone == DEVZONE_DATA && device_loc->slot != cur_device_loc->slot)
			continue;   // Not the same slot, can't merge
    7594:	46c0      	nop			; (mov r8, r8)
    7596:	e002      	b.n	759e <atcacert_merge_device_loc+0x226>
		if (device_loc->zone == DEVZONE_DATA && device_loc->is_genkey != cur_device_loc->is_genkey)
			continue;   // Not the same read method, can't merge.
    7598:	46c0      	nop			; (mov r8, r8)
    759a:	e000      	b.n	759e <atcacert_merge_device_loc+0x226>
		if (new_end < cur_device_loc->offset || new_offset > cur_end)
			continue;   // Same zone, but non-continuous areas
    759c:	46c0      	nop			; (mov r8, r8)
	new_offset = (device_loc->offset / block_size) * block_size;                                        // Round down to block_size
	new_end = device_loc->offset + device_loc->count;
	new_end = ((new_end % block_size) ? new_end / block_size + 1 : new_end / block_size) * block_size;  // Round up to block size

	// Try to merge with an existing device location
	for (i = 0; i < *device_locs_count; ++i) {
    759e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    75a0:	3301      	adds	r3, #1
    75a2:	627b      	str	r3, [r7, #36]	; 0x24
    75a4:	68bb      	ldr	r3, [r7, #8]
    75a6:	681a      	ldr	r2, [r3, #0]
    75a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    75aa:	429a      	cmp	r2, r3
    75ac:	d900      	bls.n	75b0 <atcacert_merge_device_loc+0x238>
    75ae:	e740      	b.n	7432 <atcacert_merge_device_loc+0xba>
		else
			cur_device_loc->count = (uint16_t)(cur_end - cur_device_loc->offset);
		break;
	}

	if (i == *device_locs_count) {
    75b0:	68bb      	ldr	r3, [r7, #8]
    75b2:	681a      	ldr	r2, [r3, #0]
    75b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    75b6:	429a      	cmp	r2, r3
    75b8:	d157      	bne.n	766a <atcacert_merge_device_loc+0x2f2>
		// New device_loc wasn't merged into an existing one, add to the end of the list
		if (*device_locs_count >= device_locs_max_count)
    75ba:	68bb      	ldr	r3, [r7, #8]
    75bc:	681a      	ldr	r2, [r3, #0]
    75be:	687b      	ldr	r3, [r7, #4]
    75c0:	429a      	cmp	r2, r3
    75c2:	d301      	bcc.n	75c8 <atcacert_merge_device_loc+0x250>
			return ATCACERT_E_BUFFER_TOO_SMALL; // No room to add to list
    75c4:	2303      	movs	r3, #3
    75c6:	e051      	b.n	766c <atcacert_merge_device_loc+0x2f4>

		device_locs[*device_locs_count] = *device_loc;
    75c8:	68bb      	ldr	r3, [r7, #8]
    75ca:	681a      	ldr	r2, [r3, #0]
    75cc:	0013      	movs	r3, r2
    75ce:	00db      	lsls	r3, r3, #3
    75d0:	1a9b      	subs	r3, r3, r2
    75d2:	68fa      	ldr	r2, [r7, #12]
    75d4:	18d2      	adds	r2, r2, r3
    75d6:	683b      	ldr	r3, [r7, #0]
    75d8:	0010      	movs	r0, r2
    75da:	0019      	movs	r1, r3
    75dc:	2307      	movs	r3, #7
    75de:	001a      	movs	r2, r3
    75e0:	4b26      	ldr	r3, [pc, #152]	; (767c <atcacert_merge_device_loc+0x304>)
    75e2:	4798      	blx	r3
		// Adjust for block size
		device_locs[*device_locs_count].offset = (uint16_t)new_offset;
    75e4:	68bb      	ldr	r3, [r7, #8]
    75e6:	681a      	ldr	r2, [r3, #0]
    75e8:	0013      	movs	r3, r2
    75ea:	00db      	lsls	r3, r3, #3
    75ec:	1a9b      	subs	r3, r3, r2
    75ee:	68fa      	ldr	r2, [r7, #12]
    75f0:	18d3      	adds	r3, r2, r3
    75f2:	6a3a      	ldr	r2, [r7, #32]
    75f4:	b292      	uxth	r2, r2
    75f6:	3303      	adds	r3, #3
    75f8:	21ff      	movs	r1, #255	; 0xff
    75fa:	4011      	ands	r1, r2
    75fc:	000c      	movs	r4, r1
    75fe:	7819      	ldrb	r1, [r3, #0]
    7600:	2000      	movs	r0, #0
    7602:	4001      	ands	r1, r0
    7604:	1c08      	adds	r0, r1, #0
    7606:	1c21      	adds	r1, r4, #0
    7608:	4301      	orrs	r1, r0
    760a:	7019      	strb	r1, [r3, #0]
    760c:	0a12      	lsrs	r2, r2, #8
    760e:	b290      	uxth	r0, r2
    7610:	785a      	ldrb	r2, [r3, #1]
    7612:	2100      	movs	r1, #0
    7614:	400a      	ands	r2, r1
    7616:	1c11      	adds	r1, r2, #0
    7618:	1c02      	adds	r2, r0, #0
    761a:	430a      	orrs	r2, r1
    761c:	705a      	strb	r2, [r3, #1]
		device_locs[*device_locs_count].count = (uint16_t)(new_end - new_offset);
    761e:	68bb      	ldr	r3, [r7, #8]
    7620:	681a      	ldr	r2, [r3, #0]
    7622:	0013      	movs	r3, r2
    7624:	00db      	lsls	r3, r3, #3
    7626:	1a9b      	subs	r3, r3, r2
    7628:	68fa      	ldr	r2, [r7, #12]
    762a:	18d3      	adds	r3, r2, r3
    762c:	69fa      	ldr	r2, [r7, #28]
    762e:	b291      	uxth	r1, r2
    7630:	6a3a      	ldr	r2, [r7, #32]
    7632:	b292      	uxth	r2, r2
    7634:	1a8a      	subs	r2, r1, r2
    7636:	b292      	uxth	r2, r2
    7638:	3305      	adds	r3, #5
    763a:	21ff      	movs	r1, #255	; 0xff
    763c:	4011      	ands	r1, r2
    763e:	000c      	movs	r4, r1
    7640:	7819      	ldrb	r1, [r3, #0]
    7642:	2000      	movs	r0, #0
    7644:	4001      	ands	r1, r0
    7646:	1c08      	adds	r0, r1, #0
    7648:	1c21      	adds	r1, r4, #0
    764a:	4301      	orrs	r1, r0
    764c:	7019      	strb	r1, [r3, #0]
    764e:	0a12      	lsrs	r2, r2, #8
    7650:	b290      	uxth	r0, r2
    7652:	785a      	ldrb	r2, [r3, #1]
    7654:	2100      	movs	r1, #0
    7656:	400a      	ands	r2, r1
    7658:	1c11      	adds	r1, r2, #0
    765a:	1c02      	adds	r2, r0, #0
    765c:	430a      	orrs	r2, r1
    765e:	705a      	strb	r2, [r3, #1]
		(*device_locs_count)++;
    7660:	68bb      	ldr	r3, [r7, #8]
    7662:	681b      	ldr	r3, [r3, #0]
    7664:	1c5a      	adds	r2, r3, #1
    7666:	68bb      	ldr	r3, [r7, #8]
    7668:	601a      	str	r2, [r3, #0]
	}

	return ATCACERT_E_SUCCESS;
    766a:	2300      	movs	r3, #0
}
    766c:	0018      	movs	r0, r3
    766e:	46bd      	mov	sp, r7
    7670:	b00b      	add	sp, #44	; 0x2c
    7672:	bd90      	pop	{r4, r7, pc}
    7674:	000121bd 	.word	0x000121bd
    7678:	000122c9 	.word	0x000122c9
    767c:	000127e7 	.word	0x000127e7

00007680 <atcacert_get_device_locs>:
int atcacert_get_device_locs( const atcacert_def_t*  cert_def,
                              atcacert_device_loc_t* device_locs,
                              size_t*                device_locs_count,
                              size_t device_locs_max_count,
                              size_t block_size)
{
    7680:	b590      	push	{r4, r7, lr}
    7682:	b08b      	sub	sp, #44	; 0x2c
    7684:	af02      	add	r7, sp, #8
    7686:	60f8      	str	r0, [r7, #12]
    7688:	60b9      	str	r1, [r7, #8]
    768a:	607a      	str	r2, [r7, #4]
    768c:	603b      	str	r3, [r7, #0]
	int ret = 0;
    768e:	2300      	movs	r3, #0
    7690:	61bb      	str	r3, [r7, #24]
	size_t i;

	if (cert_def == NULL || device_locs == NULL || device_locs_count == NULL)
    7692:	68fb      	ldr	r3, [r7, #12]
    7694:	2b00      	cmp	r3, #0
    7696:	d005      	beq.n	76a4 <atcacert_get_device_locs+0x24>
    7698:	68bb      	ldr	r3, [r7, #8]
    769a:	2b00      	cmp	r3, #0
    769c:	d002      	beq.n	76a4 <atcacert_get_device_locs+0x24>
    769e:	687b      	ldr	r3, [r7, #4]
    76a0:	2b00      	cmp	r3, #0
    76a2:	d101      	bne.n	76a8 <atcacert_get_device_locs+0x28>
		return ATCACERT_E_BAD_PARAMS;
    76a4:	2302      	movs	r3, #2
    76a6:	e0c7      	b.n	7838 <atcacert_get_device_locs+0x1b8>

	ret = atcacert_merge_device_loc(
    76a8:	68fb      	ldr	r3, [r7, #12]
    76aa:	1d5c      	adds	r4, r3, #5
    76ac:	683a      	ldr	r2, [r7, #0]
    76ae:	6879      	ldr	r1, [r7, #4]
    76b0:	68b8      	ldr	r0, [r7, #8]
    76b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    76b4:	9300      	str	r3, [sp, #0]
    76b6:	0023      	movs	r3, r4
    76b8:	4c61      	ldr	r4, [pc, #388]	; (7840 <atcacert_get_device_locs+0x1c0>)
    76ba:	47a0      	blx	r4
    76bc:	0003      	movs	r3, r0
    76be:	61bb      	str	r3, [r7, #24]
	    device_locs,
	    device_locs_count,
	    device_locs_max_count,
	    &cert_def->cert_sn_dev_loc,
	    block_size);
	if (ret != ATCACERT_E_SUCCESS)
    76c0:	69bb      	ldr	r3, [r7, #24]
    76c2:	2b00      	cmp	r3, #0
    76c4:	d001      	beq.n	76ca <atcacert_get_device_locs+0x4a>
		return ret;
    76c6:	69bb      	ldr	r3, [r7, #24]
    76c8:	e0b6      	b.n	7838 <atcacert_get_device_locs+0x1b8>

	ret = atcacert_merge_device_loc(
    76ca:	68fb      	ldr	r3, [r7, #12]
    76cc:	3313      	adds	r3, #19
    76ce:	001c      	movs	r4, r3
    76d0:	683a      	ldr	r2, [r7, #0]
    76d2:	6879      	ldr	r1, [r7, #4]
    76d4:	68b8      	ldr	r0, [r7, #8]
    76d6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    76d8:	9300      	str	r3, [sp, #0]
    76da:	0023      	movs	r3, r4
    76dc:	4c58      	ldr	r4, [pc, #352]	; (7840 <atcacert_get_device_locs+0x1c0>)
    76de:	47a0      	blx	r4
    76e0:	0003      	movs	r3, r0
    76e2:	61bb      	str	r3, [r7, #24]
	    device_locs,
	    device_locs_count,
	    device_locs_max_count,
	    &cert_def->public_key_dev_loc,
	    block_size);
	if (ret != ATCACERT_E_SUCCESS)
    76e4:	69bb      	ldr	r3, [r7, #24]
    76e6:	2b00      	cmp	r3, #0
    76e8:	d001      	beq.n	76ee <atcacert_get_device_locs+0x6e>
		return ret;
    76ea:	69bb      	ldr	r3, [r7, #24]
    76ec:	e0a4      	b.n	7838 <atcacert_get_device_locs+0x1b8>

	ret = atcacert_merge_device_loc(
    76ee:	68fb      	ldr	r3, [r7, #12]
    76f0:	331a      	adds	r3, #26
    76f2:	001c      	movs	r4, r3
    76f4:	683a      	ldr	r2, [r7, #0]
    76f6:	6879      	ldr	r1, [r7, #4]
    76f8:	68b8      	ldr	r0, [r7, #8]
    76fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    76fc:	9300      	str	r3, [sp, #0]
    76fe:	0023      	movs	r3, r4
    7700:	4c4f      	ldr	r4, [pc, #316]	; (7840 <atcacert_get_device_locs+0x1c0>)
    7702:	47a0      	blx	r4
    7704:	0003      	movs	r3, r0
    7706:	61bb      	str	r3, [r7, #24]
	    device_locs,
	    device_locs_count,
	    device_locs_max_count,
	    &cert_def->comp_cert_dev_loc,
	    block_size);
	if (ret != ATCACERT_E_SUCCESS)
    7708:	69bb      	ldr	r3, [r7, #24]
    770a:	2b00      	cmp	r3, #0
    770c:	d001      	beq.n	7712 <atcacert_get_device_locs+0x92>
		return ret;
    770e:	69bb      	ldr	r3, [r7, #24]
    7710:	e092      	b.n	7838 <atcacert_get_device_locs+0x1b8>

	if (cert_def->cert_elements_count > 0 && cert_def->cert_elements == NULL)
    7712:	68fb      	ldr	r3, [r7, #12]
    7714:	2245      	movs	r2, #69	; 0x45
    7716:	5c9b      	ldrb	r3, [r3, r2]
    7718:	2b00      	cmp	r3, #0
    771a:	d011      	beq.n	7740 <atcacert_get_device_locs+0xc0>
    771c:	68fb      	ldr	r3, [r7, #12]
    771e:	2241      	movs	r2, #65	; 0x41
    7720:	5c9a      	ldrb	r2, [r3, r2]
    7722:	2142      	movs	r1, #66	; 0x42
    7724:	5c59      	ldrb	r1, [r3, r1]
    7726:	0209      	lsls	r1, r1, #8
    7728:	430a      	orrs	r2, r1
    772a:	2143      	movs	r1, #67	; 0x43
    772c:	5c59      	ldrb	r1, [r3, r1]
    772e:	0409      	lsls	r1, r1, #16
    7730:	430a      	orrs	r2, r1
    7732:	2144      	movs	r1, #68	; 0x44
    7734:	5c5b      	ldrb	r3, [r3, r1]
    7736:	061b      	lsls	r3, r3, #24
    7738:	4313      	orrs	r3, r2
    773a:	d101      	bne.n	7740 <atcacert_get_device_locs+0xc0>
		return ATCACERT_E_BAD_CERT; // Cert def is in an invalid state
    773c:	230a      	movs	r3, #10
    773e:	e07b      	b.n	7838 <atcacert_get_device_locs+0x1b8>

	for (i = 0; i < cert_def->cert_elements_count; i++) {
    7740:	2300      	movs	r3, #0
    7742:	61fb      	str	r3, [r7, #28]
    7744:	e02a      	b.n	779c <atcacert_get_device_locs+0x11c>
		ret = atcacert_merge_device_loc(
		    device_locs,
		    device_locs_count,
		    device_locs_max_count,
		    &cert_def->cert_elements[i].device_loc,
    7746:	68fb      	ldr	r3, [r7, #12]
    7748:	2241      	movs	r2, #65	; 0x41
    774a:	5c9a      	ldrb	r2, [r3, r2]
    774c:	2142      	movs	r1, #66	; 0x42
    774e:	5c59      	ldrb	r1, [r3, r1]
    7750:	0209      	lsls	r1, r1, #8
    7752:	430a      	orrs	r2, r1
    7754:	2143      	movs	r1, #67	; 0x43
    7756:	5c59      	ldrb	r1, [r3, r1]
    7758:	0409      	lsls	r1, r1, #16
    775a:	430a      	orrs	r2, r1
    775c:	2144      	movs	r1, #68	; 0x44
    775e:	5c5b      	ldrb	r3, [r3, r1]
    7760:	061b      	lsls	r3, r3, #24
    7762:	4313      	orrs	r3, r2
    7764:	0019      	movs	r1, r3
    7766:	69fa      	ldr	r2, [r7, #28]
    7768:	0013      	movs	r3, r2
    776a:	005b      	lsls	r3, r3, #1
    776c:	189b      	adds	r3, r3, r2
    776e:	00da      	lsls	r2, r3, #3
    7770:	189b      	adds	r3, r3, r2
    7772:	18cb      	adds	r3, r1, r3

	if (cert_def->cert_elements_count > 0 && cert_def->cert_elements == NULL)
		return ATCACERT_E_BAD_CERT; // Cert def is in an invalid state

	for (i = 0; i < cert_def->cert_elements_count; i++) {
		ret = atcacert_merge_device_loc(
    7774:	3310      	adds	r3, #16
    7776:	001c      	movs	r4, r3
    7778:	683a      	ldr	r2, [r7, #0]
    777a:	6879      	ldr	r1, [r7, #4]
    777c:	68b8      	ldr	r0, [r7, #8]
    777e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    7780:	9300      	str	r3, [sp, #0]
    7782:	0023      	movs	r3, r4
    7784:	4c2e      	ldr	r4, [pc, #184]	; (7840 <atcacert_get_device_locs+0x1c0>)
    7786:	47a0      	blx	r4
    7788:	0003      	movs	r3, r0
    778a:	61bb      	str	r3, [r7, #24]
		    device_locs,
		    device_locs_count,
		    device_locs_max_count,
		    &cert_def->cert_elements[i].device_loc,
		    block_size);
		if (ret != ATCACERT_E_SUCCESS)
    778c:	69bb      	ldr	r3, [r7, #24]
    778e:	2b00      	cmp	r3, #0
    7790:	d001      	beq.n	7796 <atcacert_get_device_locs+0x116>
			return ret;
    7792:	69bb      	ldr	r3, [r7, #24]
    7794:	e050      	b.n	7838 <atcacert_get_device_locs+0x1b8>
		return ret;

	if (cert_def->cert_elements_count > 0 && cert_def->cert_elements == NULL)
		return ATCACERT_E_BAD_CERT; // Cert def is in an invalid state

	for (i = 0; i < cert_def->cert_elements_count; i++) {
    7796:	69fb      	ldr	r3, [r7, #28]
    7798:	3301      	adds	r3, #1
    779a:	61fb      	str	r3, [r7, #28]
    779c:	68fb      	ldr	r3, [r7, #12]
    779e:	2245      	movs	r2, #69	; 0x45
    77a0:	5c9b      	ldrb	r3, [r3, r2]
    77a2:	1e1a      	subs	r2, r3, #0
    77a4:	69fb      	ldr	r3, [r7, #28]
    77a6:	429a      	cmp	r2, r3
    77a8:	d8cd      	bhi.n	7746 <atcacert_get_device_locs+0xc6>
		if (ret != ATCACERT_E_SUCCESS)
			return ret;
	}

	// Add the device SN to the list if the cert serial number scheme requires it
	if (   cert_def->sn_source == SNSRC_DEVICE_SN
    77aa:	68fb      	ldr	r3, [r7, #12]
    77ac:	791b      	ldrb	r3, [r3, #4]
    77ae:	2b08      	cmp	r3, #8
    77b0:	d00b      	beq.n	77ca <atcacert_get_device_locs+0x14a>
	       || cert_def->sn_source == SNSRC_DEVICE_SN_HASH
    77b2:	68fb      	ldr	r3, [r7, #12]
    77b4:	791b      	ldrb	r3, [r3, #4]
    77b6:	2b0b      	cmp	r3, #11
    77b8:	d007      	beq.n	77ca <atcacert_get_device_locs+0x14a>
	       || cert_def->sn_source == SNSRC_DEVICE_SN_HASH_POS
    77ba:	68fb      	ldr	r3, [r7, #12]
    77bc:	791b      	ldrb	r3, [r3, #4]
    77be:	2b0d      	cmp	r3, #13
    77c0:	d003      	beq.n	77ca <atcacert_get_device_locs+0x14a>
	       || cert_def->sn_source == SNSRC_DEVICE_SN_HASH_RAW) {
    77c2:	68fb      	ldr	r3, [r7, #12]
    77c4:	791b      	ldrb	r3, [r3, #4]
    77c6:	2b0f      	cmp	r3, #15
    77c8:	d135      	bne.n	7836 <atcacert_get_device_locs+0x1b6>
		// Device SN is config zone bytes 0-3 and 8-12
		atcacert_device_loc_t device_sn_loc = {
    77ca:	2310      	movs	r3, #16
    77cc:	18fb      	adds	r3, r7, r3
    77ce:	2200      	movs	r2, #0
    77d0:	701a      	strb	r2, [r3, #0]
    77d2:	2310      	movs	r3, #16
    77d4:	18fb      	adds	r3, r7, r3
    77d6:	2200      	movs	r2, #0
    77d8:	705a      	strb	r2, [r3, #1]
    77da:	2310      	movs	r3, #16
    77dc:	18fb      	adds	r3, r7, r3
    77de:	2200      	movs	r2, #0
    77e0:	709a      	strb	r2, [r3, #2]
    77e2:	2310      	movs	r3, #16
    77e4:	18fb      	adds	r3, r7, r3
    77e6:	3303      	adds	r3, #3
    77e8:	781a      	ldrb	r2, [r3, #0]
    77ea:	2100      	movs	r1, #0
    77ec:	400a      	ands	r2, r1
    77ee:	701a      	strb	r2, [r3, #0]
    77f0:	785a      	ldrb	r2, [r3, #1]
    77f2:	2100      	movs	r1, #0
    77f4:	400a      	ands	r2, r1
    77f6:	705a      	strb	r2, [r3, #1]
    77f8:	2310      	movs	r3, #16
    77fa:	18fb      	adds	r3, r7, r3
    77fc:	3305      	adds	r3, #5
    77fe:	781a      	ldrb	r2, [r3, #0]
    7800:	2100      	movs	r1, #0
    7802:	400a      	ands	r2, r1
    7804:	1c11      	adds	r1, r2, #0
    7806:	220d      	movs	r2, #13
    7808:	430a      	orrs	r2, r1
    780a:	701a      	strb	r2, [r3, #0]
    780c:	785a      	ldrb	r2, [r3, #1]
    780e:	2100      	movs	r1, #0
    7810:	400a      	ands	r2, r1
    7812:	705a      	strb	r2, [r3, #1]
			.slot		= 0,                // Ignored
			.is_genkey	= FALSE,            // Ignored
			.offset		= 0,
			.count		= 13
		};
		ret = atcacert_merge_device_loc(
    7814:	2310      	movs	r3, #16
    7816:	18fc      	adds	r4, r7, r3
    7818:	683a      	ldr	r2, [r7, #0]
    781a:	6879      	ldr	r1, [r7, #4]
    781c:	68b8      	ldr	r0, [r7, #8]
    781e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    7820:	9300      	str	r3, [sp, #0]
    7822:	0023      	movs	r3, r4
    7824:	4c06      	ldr	r4, [pc, #24]	; (7840 <atcacert_get_device_locs+0x1c0>)
    7826:	47a0      	blx	r4
    7828:	0003      	movs	r3, r0
    782a:	61bb      	str	r3, [r7, #24]
		    device_locs,
		    device_locs_count,
		    device_locs_max_count,
		    &device_sn_loc,
		    block_size);
		if (ret != ATCACERT_E_SUCCESS)
    782c:	69bb      	ldr	r3, [r7, #24]
    782e:	2b00      	cmp	r3, #0
    7830:	d001      	beq.n	7836 <atcacert_get_device_locs+0x1b6>
			return ret;
    7832:	69bb      	ldr	r3, [r7, #24]
    7834:	e000      	b.n	7838 <atcacert_get_device_locs+0x1b8>
	}

	return ATCACERT_E_SUCCESS;
    7836:	2300      	movs	r3, #0
}
    7838:	0018      	movs	r0, r3
    783a:	46bd      	mov	sp, r7
    783c:	b009      	add	sp, #36	; 0x24
    783e:	bd90      	pop	{r4, r7, pc}
    7840:	00007379 	.word	0x00007379

00007844 <atcacert_is_device_loc_match>:

static const uint8_t* atcacert_is_device_loc_match( const atcacert_device_loc_t* device_loc_dest,
                                                    const atcacert_device_loc_t* device_loc_src,
                                                    const uint8_t* src_data)
{
    7844:	b580      	push	{r7, lr}
    7846:	b086      	sub	sp, #24
    7848:	af00      	add	r7, sp, #0
    784a:	60f8      	str	r0, [r7, #12]
    784c:	60b9      	str	r1, [r7, #8]
    784e:	607a      	str	r2, [r7, #4]
	size_t dest_end = device_loc_dest->offset + device_loc_dest->count;
    7850:	68fb      	ldr	r3, [r7, #12]
    7852:	78da      	ldrb	r2, [r3, #3]
    7854:	791b      	ldrb	r3, [r3, #4]
    7856:	021b      	lsls	r3, r3, #8
    7858:	4313      	orrs	r3, r2
    785a:	b29b      	uxth	r3, r3
    785c:	0019      	movs	r1, r3
    785e:	68fb      	ldr	r3, [r7, #12]
    7860:	795a      	ldrb	r2, [r3, #5]
    7862:	799b      	ldrb	r3, [r3, #6]
    7864:	021b      	lsls	r3, r3, #8
    7866:	4313      	orrs	r3, r2
    7868:	b29b      	uxth	r3, r3
    786a:	18cb      	adds	r3, r1, r3
    786c:	617b      	str	r3, [r7, #20]
	size_t src_end = device_loc_src->offset + device_loc_src->count;
    786e:	68bb      	ldr	r3, [r7, #8]
    7870:	78da      	ldrb	r2, [r3, #3]
    7872:	791b      	ldrb	r3, [r3, #4]
    7874:	021b      	lsls	r3, r3, #8
    7876:	4313      	orrs	r3, r2
    7878:	b29b      	uxth	r3, r3
    787a:	0019      	movs	r1, r3
    787c:	68bb      	ldr	r3, [r7, #8]
    787e:	795a      	ldrb	r2, [r3, #5]
    7880:	799b      	ldrb	r3, [r3, #6]
    7882:	021b      	lsls	r3, r3, #8
    7884:	4313      	orrs	r3, r2
    7886:	b29b      	uxth	r3, r3
    7888:	18cb      	adds	r3, r1, r3
    788a:	613b      	str	r3, [r7, #16]

	if (device_loc_dest->zone == DEVZONE_NONE || device_loc_dest->count <= 0)
    788c:	68fb      	ldr	r3, [r7, #12]
    788e:	781b      	ldrb	r3, [r3, #0]
    7890:	2b07      	cmp	r3, #7
    7892:	d007      	beq.n	78a4 <atcacert_is_device_loc_match+0x60>
    7894:	68fb      	ldr	r3, [r7, #12]
    7896:	795a      	ldrb	r2, [r3, #5]
    7898:	799b      	ldrb	r3, [r3, #6]
    789a:	021b      	lsls	r3, r3, #8
    789c:	4313      	orrs	r3, r2
    789e:	b29b      	uxth	r3, r3
    78a0:	2b00      	cmp	r3, #0
    78a2:	d101      	bne.n	78a8 <atcacert_is_device_loc_match+0x64>
		return NULL;    // device_loc_dest is a null location
    78a4:	2300      	movs	r3, #0
    78a6:	e052      	b.n	794e <atcacert_is_device_loc_match+0x10a>
	if (device_loc_src->zone == DEVZONE_NONE || device_loc_src->count <= 0)
    78a8:	68bb      	ldr	r3, [r7, #8]
    78aa:	781b      	ldrb	r3, [r3, #0]
    78ac:	2b07      	cmp	r3, #7
    78ae:	d007      	beq.n	78c0 <atcacert_is_device_loc_match+0x7c>
    78b0:	68bb      	ldr	r3, [r7, #8]
    78b2:	795a      	ldrb	r2, [r3, #5]
    78b4:	799b      	ldrb	r3, [r3, #6]
    78b6:	021b      	lsls	r3, r3, #8
    78b8:	4313      	orrs	r3, r2
    78ba:	b29b      	uxth	r3, r3
    78bc:	2b00      	cmp	r3, #0
    78be:	d101      	bne.n	78c4 <atcacert_is_device_loc_match+0x80>
		return NULL;    // device_loc_src is a null location
    78c0:	2300      	movs	r3, #0
    78c2:	e044      	b.n	794e <atcacert_is_device_loc_match+0x10a>
	if (device_loc_dest->zone != device_loc_src->zone)
    78c4:	68fb      	ldr	r3, [r7, #12]
    78c6:	781a      	ldrb	r2, [r3, #0]
    78c8:	68bb      	ldr	r3, [r7, #8]
    78ca:	781b      	ldrb	r3, [r3, #0]
    78cc:	429a      	cmp	r2, r3
    78ce:	d001      	beq.n	78d4 <atcacert_is_device_loc_match+0x90>
		return NULL;
    78d0:	2300      	movs	r3, #0
    78d2:	e03c      	b.n	794e <atcacert_is_device_loc_match+0x10a>
	if (device_loc_dest->zone == DEVZONE_DATA && device_loc_dest->slot != device_loc_src->slot)
    78d4:	68fb      	ldr	r3, [r7, #12]
    78d6:	781b      	ldrb	r3, [r3, #0]
    78d8:	2b02      	cmp	r3, #2
    78da:	d107      	bne.n	78ec <atcacert_is_device_loc_match+0xa8>
    78dc:	68fb      	ldr	r3, [r7, #12]
    78de:	785a      	ldrb	r2, [r3, #1]
    78e0:	68bb      	ldr	r3, [r7, #8]
    78e2:	785b      	ldrb	r3, [r3, #1]
    78e4:	429a      	cmp	r2, r3
    78e6:	d001      	beq.n	78ec <atcacert_is_device_loc_match+0xa8>
		return NULL;
    78e8:	2300      	movs	r3, #0
    78ea:	e030      	b.n	794e <atcacert_is_device_loc_match+0x10a>
	if (device_loc_dest->zone == DEVZONE_DATA && device_loc_dest->is_genkey != device_loc_src->is_genkey)
    78ec:	68fb      	ldr	r3, [r7, #12]
    78ee:	781b      	ldrb	r3, [r3, #0]
    78f0:	2b02      	cmp	r3, #2
    78f2:	d107      	bne.n	7904 <atcacert_is_device_loc_match+0xc0>
    78f4:	68fb      	ldr	r3, [r7, #12]
    78f6:	789a      	ldrb	r2, [r3, #2]
    78f8:	68bb      	ldr	r3, [r7, #8]
    78fa:	789b      	ldrb	r3, [r3, #2]
    78fc:	429a      	cmp	r2, r3
    78fe:	d001      	beq.n	7904 <atcacert_is_device_loc_match+0xc0>
		return NULL;
    7900:	2300      	movs	r3, #0
    7902:	e024      	b.n	794e <atcacert_is_device_loc_match+0x10a>

	if (device_loc_dest->offset < device_loc_src->offset || dest_end > src_end)
    7904:	68fb      	ldr	r3, [r7, #12]
    7906:	78da      	ldrb	r2, [r3, #3]
    7908:	791b      	ldrb	r3, [r3, #4]
    790a:	021b      	lsls	r3, r3, #8
    790c:	4313      	orrs	r3, r2
    790e:	b29a      	uxth	r2, r3
    7910:	68bb      	ldr	r3, [r7, #8]
    7912:	78d9      	ldrb	r1, [r3, #3]
    7914:	791b      	ldrb	r3, [r3, #4]
    7916:	021b      	lsls	r3, r3, #8
    7918:	430b      	orrs	r3, r1
    791a:	b29b      	uxth	r3, r3
    791c:	429a      	cmp	r2, r3
    791e:	d303      	bcc.n	7928 <atcacert_is_device_loc_match+0xe4>
    7920:	697a      	ldr	r2, [r7, #20]
    7922:	693b      	ldr	r3, [r7, #16]
    7924:	429a      	cmp	r2, r3
    7926:	d901      	bls.n	792c <atcacert_is_device_loc_match+0xe8>
		return NULL;
    7928:	2300      	movs	r3, #0
    792a:	e010      	b.n	794e <atcacert_is_device_loc_match+0x10a>

	// device_loc_dest is encompassed by device_loc_src, return a pointer to the data for device_loc_dest
	return src_data + (device_loc_dest->offset - device_loc_src->offset);
    792c:	68fb      	ldr	r3, [r7, #12]
    792e:	78da      	ldrb	r2, [r3, #3]
    7930:	791b      	ldrb	r3, [r3, #4]
    7932:	021b      	lsls	r3, r3, #8
    7934:	4313      	orrs	r3, r2
    7936:	b29b      	uxth	r3, r3
    7938:	0019      	movs	r1, r3
    793a:	68bb      	ldr	r3, [r7, #8]
    793c:	78da      	ldrb	r2, [r3, #3]
    793e:	791b      	ldrb	r3, [r3, #4]
    7940:	021b      	lsls	r3, r3, #8
    7942:	4313      	orrs	r3, r2
    7944:	b29b      	uxth	r3, r3
    7946:	1acb      	subs	r3, r1, r3
    7948:	001a      	movs	r2, r3
    794a:	687b      	ldr	r3, [r7, #4]
    794c:	189b      	adds	r3, r3, r2
}
    794e:	0018      	movs	r0, r3
    7950:	46bd      	mov	sp, r7
    7952:	b006      	add	sp, #24
    7954:	bd80      	pop	{r7, pc}
    7956:	46c0      	nop			; (mov r8, r8)

00007958 <atcacert_cert_build_start>:
int atcacert_cert_build_start( atcacert_build_state_t* build_state,
                               const atcacert_def_t*   cert_def,
                               uint8_t*                cert,
                               size_t*                 cert_size,
                               const uint8_t ca_public_key[64])
{
    7958:	b5b0      	push	{r4, r5, r7, lr}
    795a:	b098      	sub	sp, #96	; 0x60
    795c:	af02      	add	r7, sp, #8
    795e:	60f8      	str	r0, [r7, #12]
    7960:	60b9      	str	r1, [r7, #8]
    7962:	607a      	str	r2, [r7, #4]
    7964:	603b      	str	r3, [r7, #0]
	int ret = 0;
    7966:	2300      	movs	r3, #0
    7968:	657b      	str	r3, [r7, #84]	; 0x54

	if (build_state == NULL || cert_def == NULL || cert == NULL || cert_size == NULL || ca_public_key == NULL)
    796a:	68fb      	ldr	r3, [r7, #12]
    796c:	2b00      	cmp	r3, #0
    796e:	d00b      	beq.n	7988 <atcacert_cert_build_start+0x30>
    7970:	68bb      	ldr	r3, [r7, #8]
    7972:	2b00      	cmp	r3, #0
    7974:	d008      	beq.n	7988 <atcacert_cert_build_start+0x30>
    7976:	687b      	ldr	r3, [r7, #4]
    7978:	2b00      	cmp	r3, #0
    797a:	d005      	beq.n	7988 <atcacert_cert_build_start+0x30>
    797c:	683b      	ldr	r3, [r7, #0]
    797e:	2b00      	cmp	r3, #0
    7980:	d002      	beq.n	7988 <atcacert_cert_build_start+0x30>
    7982:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    7984:	2b00      	cmp	r3, #0
    7986:	d101      	bne.n	798c <atcacert_cert_build_start+0x34>
		return ATCACERT_E_BAD_PARAMS;
    7988:	2302      	movs	r3, #2
    798a:	e1c6      	b.n	7d1a <atcacert_cert_build_start+0x3c2>

	memset(build_state, 0, sizeof(*build_state));
    798c:	68fb      	ldr	r3, [r7, #12]
    798e:	221a      	movs	r2, #26
    7990:	2100      	movs	r1, #0
    7992:	0018      	movs	r0, r3
    7994:	4be3      	ldr	r3, [pc, #908]	; (7d24 <atcacert_cert_build_start+0x3cc>)
    7996:	4798      	blx	r3

	build_state->cert_def      = cert_def;
    7998:	68fb      	ldr	r3, [r7, #12]
    799a:	2208      	movs	r2, #8
    799c:	18ba      	adds	r2, r7, r2
    799e:	7810      	ldrb	r0, [r2, #0]
    79a0:	781a      	ldrb	r2, [r3, #0]
    79a2:	2100      	movs	r1, #0
    79a4:	400a      	ands	r2, r1
    79a6:	1c11      	adds	r1, r2, #0
    79a8:	1c02      	adds	r2, r0, #0
    79aa:	430a      	orrs	r2, r1
    79ac:	701a      	strb	r2, [r3, #0]
    79ae:	2209      	movs	r2, #9
    79b0:	18ba      	adds	r2, r7, r2
    79b2:	7810      	ldrb	r0, [r2, #0]
    79b4:	785a      	ldrb	r2, [r3, #1]
    79b6:	2100      	movs	r1, #0
    79b8:	400a      	ands	r2, r1
    79ba:	1c11      	adds	r1, r2, #0
    79bc:	1c02      	adds	r2, r0, #0
    79be:	430a      	orrs	r2, r1
    79c0:	705a      	strb	r2, [r3, #1]
    79c2:	220a      	movs	r2, #10
    79c4:	18ba      	adds	r2, r7, r2
    79c6:	7810      	ldrb	r0, [r2, #0]
    79c8:	789a      	ldrb	r2, [r3, #2]
    79ca:	2100      	movs	r1, #0
    79cc:	400a      	ands	r2, r1
    79ce:	1c11      	adds	r1, r2, #0
    79d0:	1c02      	adds	r2, r0, #0
    79d2:	430a      	orrs	r2, r1
    79d4:	709a      	strb	r2, [r3, #2]
    79d6:	220b      	movs	r2, #11
    79d8:	18ba      	adds	r2, r7, r2
    79da:	7810      	ldrb	r0, [r2, #0]
    79dc:	78da      	ldrb	r2, [r3, #3]
    79de:	2100      	movs	r1, #0
    79e0:	400a      	ands	r2, r1
    79e2:	1c11      	adds	r1, r2, #0
    79e4:	1c02      	adds	r2, r0, #0
    79e6:	430a      	orrs	r2, r1
    79e8:	70da      	strb	r2, [r3, #3]
	build_state->cert          = cert;
    79ea:	68fb      	ldr	r3, [r7, #12]
    79ec:	1d3a      	adds	r2, r7, #4
    79ee:	7810      	ldrb	r0, [r2, #0]
    79f0:	791a      	ldrb	r2, [r3, #4]
    79f2:	2100      	movs	r1, #0
    79f4:	400a      	ands	r2, r1
    79f6:	1c11      	adds	r1, r2, #0
    79f8:	1c02      	adds	r2, r0, #0
    79fa:	430a      	orrs	r2, r1
    79fc:	711a      	strb	r2, [r3, #4]
    79fe:	1d7a      	adds	r2, r7, #5
    7a00:	7810      	ldrb	r0, [r2, #0]
    7a02:	795a      	ldrb	r2, [r3, #5]
    7a04:	2100      	movs	r1, #0
    7a06:	400a      	ands	r2, r1
    7a08:	1c11      	adds	r1, r2, #0
    7a0a:	1c02      	adds	r2, r0, #0
    7a0c:	430a      	orrs	r2, r1
    7a0e:	715a      	strb	r2, [r3, #5]
    7a10:	1dba      	adds	r2, r7, #6
    7a12:	7810      	ldrb	r0, [r2, #0]
    7a14:	799a      	ldrb	r2, [r3, #6]
    7a16:	2100      	movs	r1, #0
    7a18:	400a      	ands	r2, r1
    7a1a:	1c11      	adds	r1, r2, #0
    7a1c:	1c02      	adds	r2, r0, #0
    7a1e:	430a      	orrs	r2, r1
    7a20:	719a      	strb	r2, [r3, #6]
    7a22:	1dfa      	adds	r2, r7, #7
    7a24:	7810      	ldrb	r0, [r2, #0]
    7a26:	79da      	ldrb	r2, [r3, #7]
    7a28:	2100      	movs	r1, #0
    7a2a:	400a      	ands	r2, r1
    7a2c:	1c11      	adds	r1, r2, #0
    7a2e:	1c02      	adds	r2, r0, #0
    7a30:	430a      	orrs	r2, r1
    7a32:	71da      	strb	r2, [r3, #7]
	build_state->cert_size     = cert_size;
    7a34:	68fb      	ldr	r3, [r7, #12]
    7a36:	003a      	movs	r2, r7
    7a38:	7810      	ldrb	r0, [r2, #0]
    7a3a:	7a1a      	ldrb	r2, [r3, #8]
    7a3c:	2100      	movs	r1, #0
    7a3e:	400a      	ands	r2, r1
    7a40:	1c11      	adds	r1, r2, #0
    7a42:	1c02      	adds	r2, r0, #0
    7a44:	430a      	orrs	r2, r1
    7a46:	721a      	strb	r2, [r3, #8]
    7a48:	1c7a      	adds	r2, r7, #1
    7a4a:	7810      	ldrb	r0, [r2, #0]
    7a4c:	7a5a      	ldrb	r2, [r3, #9]
    7a4e:	2100      	movs	r1, #0
    7a50:	400a      	ands	r2, r1
    7a52:	1c11      	adds	r1, r2, #0
    7a54:	1c02      	adds	r2, r0, #0
    7a56:	430a      	orrs	r2, r1
    7a58:	725a      	strb	r2, [r3, #9]
    7a5a:	1cba      	adds	r2, r7, #2
    7a5c:	7810      	ldrb	r0, [r2, #0]
    7a5e:	7a9a      	ldrb	r2, [r3, #10]
    7a60:	2100      	movs	r1, #0
    7a62:	400a      	ands	r2, r1
    7a64:	1c11      	adds	r1, r2, #0
    7a66:	1c02      	adds	r2, r0, #0
    7a68:	430a      	orrs	r2, r1
    7a6a:	729a      	strb	r2, [r3, #10]
    7a6c:	1cfa      	adds	r2, r7, #3
    7a6e:	7810      	ldrb	r0, [r2, #0]
    7a70:	7ada      	ldrb	r2, [r3, #11]
    7a72:	2100      	movs	r1, #0
    7a74:	400a      	ands	r2, r1
    7a76:	1c11      	adds	r1, r2, #0
    7a78:	1c02      	adds	r2, r0, #0
    7a7a:	430a      	orrs	r2, r1
    7a7c:	72da      	strb	r2, [r3, #11]
	build_state->max_cert_size = *cert_size;
    7a7e:	683b      	ldr	r3, [r7, #0]
    7a80:	681a      	ldr	r2, [r3, #0]
    7a82:	68fb      	ldr	r3, [r7, #12]
    7a84:	21ff      	movs	r1, #255	; 0xff
    7a86:	4011      	ands	r1, r2
    7a88:	000c      	movs	r4, r1
    7a8a:	7b19      	ldrb	r1, [r3, #12]
    7a8c:	2000      	movs	r0, #0
    7a8e:	4001      	ands	r1, r0
    7a90:	1c08      	adds	r0, r1, #0
    7a92:	1c21      	adds	r1, r4, #0
    7a94:	4301      	orrs	r1, r0
    7a96:	7319      	strb	r1, [r3, #12]
    7a98:	0a11      	lsrs	r1, r2, #8
    7a9a:	20ff      	movs	r0, #255	; 0xff
    7a9c:	4001      	ands	r1, r0
    7a9e:	000c      	movs	r4, r1
    7aa0:	7b59      	ldrb	r1, [r3, #13]
    7aa2:	2000      	movs	r0, #0
    7aa4:	4001      	ands	r1, r0
    7aa6:	1c08      	adds	r0, r1, #0
    7aa8:	1c21      	adds	r1, r4, #0
    7aaa:	4301      	orrs	r1, r0
    7aac:	7359      	strb	r1, [r3, #13]
    7aae:	0c11      	lsrs	r1, r2, #16
    7ab0:	20ff      	movs	r0, #255	; 0xff
    7ab2:	4001      	ands	r1, r0
    7ab4:	000c      	movs	r4, r1
    7ab6:	7b99      	ldrb	r1, [r3, #14]
    7ab8:	2000      	movs	r0, #0
    7aba:	4001      	ands	r1, r0
    7abc:	1c08      	adds	r0, r1, #0
    7abe:	1c21      	adds	r1, r4, #0
    7ac0:	4301      	orrs	r1, r0
    7ac2:	7399      	strb	r1, [r3, #14]
    7ac4:	0e10      	lsrs	r0, r2, #24
    7ac6:	7bda      	ldrb	r2, [r3, #15]
    7ac8:	2100      	movs	r1, #0
    7aca:	400a      	ands	r2, r1
    7acc:	1c11      	adds	r1, r2, #0
    7ace:	1c02      	adds	r2, r0, #0
    7ad0:	430a      	orrs	r2, r1
    7ad2:	73da      	strb	r2, [r3, #15]
	build_state->is_device_sn  = FALSE;
    7ad4:	68fb      	ldr	r3, [r7, #12]
    7ad6:	2200      	movs	r2, #0
    7ad8:	741a      	strb	r2, [r3, #16]

	if (build_state->max_cert_size < build_state->cert_def->cert_template_size) {
    7ada:	68fb      	ldr	r3, [r7, #12]
    7adc:	7b1a      	ldrb	r2, [r3, #12]
    7ade:	7b59      	ldrb	r1, [r3, #13]
    7ae0:	0209      	lsls	r1, r1, #8
    7ae2:	430a      	orrs	r2, r1
    7ae4:	7b99      	ldrb	r1, [r3, #14]
    7ae6:	0409      	lsls	r1, r1, #16
    7ae8:	430a      	orrs	r2, r1
    7aea:	7bdb      	ldrb	r3, [r3, #15]
    7aec:	061b      	lsls	r3, r3, #24
    7aee:	4313      	orrs	r3, r2
    7af0:	0018      	movs	r0, r3
    7af2:	68fb      	ldr	r3, [r7, #12]
    7af4:	781a      	ldrb	r2, [r3, #0]
    7af6:	7859      	ldrb	r1, [r3, #1]
    7af8:	0209      	lsls	r1, r1, #8
    7afa:	430a      	orrs	r2, r1
    7afc:	7899      	ldrb	r1, [r3, #2]
    7afe:	0409      	lsls	r1, r1, #16
    7b00:	430a      	orrs	r2, r1
    7b02:	78db      	ldrb	r3, [r3, #3]
    7b04:	061b      	lsls	r3, r3, #24
    7b06:	4313      	orrs	r3, r2
    7b08:	224a      	movs	r2, #74	; 0x4a
    7b0a:	5c9a      	ldrb	r2, [r3, r2]
    7b0c:	214b      	movs	r1, #75	; 0x4b
    7b0e:	5c5b      	ldrb	r3, [r3, r1]
    7b10:	021b      	lsls	r3, r3, #8
    7b12:	4313      	orrs	r3, r2
    7b14:	b29b      	uxth	r3, r3
    7b16:	4298      	cmp	r0, r3
    7b18:	d220      	bcs.n	7b5c <atcacert_cert_build_start+0x204>
		*build_state->cert_size = build_state->cert_def->cert_template_size;
    7b1a:	68fb      	ldr	r3, [r7, #12]
    7b1c:	7a1a      	ldrb	r2, [r3, #8]
    7b1e:	7a59      	ldrb	r1, [r3, #9]
    7b20:	0209      	lsls	r1, r1, #8
    7b22:	430a      	orrs	r2, r1
    7b24:	7a99      	ldrb	r1, [r3, #10]
    7b26:	0409      	lsls	r1, r1, #16
    7b28:	430a      	orrs	r2, r1
    7b2a:	7adb      	ldrb	r3, [r3, #11]
    7b2c:	061b      	lsls	r3, r3, #24
    7b2e:	4313      	orrs	r3, r2
    7b30:	001a      	movs	r2, r3
    7b32:	68fb      	ldr	r3, [r7, #12]
    7b34:	7819      	ldrb	r1, [r3, #0]
    7b36:	7858      	ldrb	r0, [r3, #1]
    7b38:	0200      	lsls	r0, r0, #8
    7b3a:	4301      	orrs	r1, r0
    7b3c:	7898      	ldrb	r0, [r3, #2]
    7b3e:	0400      	lsls	r0, r0, #16
    7b40:	4301      	orrs	r1, r0
    7b42:	78db      	ldrb	r3, [r3, #3]
    7b44:	061b      	lsls	r3, r3, #24
    7b46:	430b      	orrs	r3, r1
    7b48:	214a      	movs	r1, #74	; 0x4a
    7b4a:	5c59      	ldrb	r1, [r3, r1]
    7b4c:	204b      	movs	r0, #75	; 0x4b
    7b4e:	5c1b      	ldrb	r3, [r3, r0]
    7b50:	021b      	lsls	r3, r3, #8
    7b52:	430b      	orrs	r3, r1
    7b54:	b29b      	uxth	r3, r3
    7b56:	6013      	str	r3, [r2, #0]
		return ATCACERT_E_BUFFER_TOO_SMALL; // cert buffer is too small to contain the template
    7b58:	2303      	movs	r3, #3
    7b5a:	e0de      	b.n	7d1a <atcacert_cert_build_start+0x3c2>
	}

	// Initialize the cert buffer with the cert template
	*build_state->cert_size = build_state->cert_def->cert_template_size;
    7b5c:	68fb      	ldr	r3, [r7, #12]
    7b5e:	7a1a      	ldrb	r2, [r3, #8]
    7b60:	7a59      	ldrb	r1, [r3, #9]
    7b62:	0209      	lsls	r1, r1, #8
    7b64:	430a      	orrs	r2, r1
    7b66:	7a99      	ldrb	r1, [r3, #10]
    7b68:	0409      	lsls	r1, r1, #16
    7b6a:	430a      	orrs	r2, r1
    7b6c:	7adb      	ldrb	r3, [r3, #11]
    7b6e:	061b      	lsls	r3, r3, #24
    7b70:	4313      	orrs	r3, r2
    7b72:	001a      	movs	r2, r3
    7b74:	68fb      	ldr	r3, [r7, #12]
    7b76:	7819      	ldrb	r1, [r3, #0]
    7b78:	7858      	ldrb	r0, [r3, #1]
    7b7a:	0200      	lsls	r0, r0, #8
    7b7c:	4301      	orrs	r1, r0
    7b7e:	7898      	ldrb	r0, [r3, #2]
    7b80:	0400      	lsls	r0, r0, #16
    7b82:	4301      	orrs	r1, r0
    7b84:	78db      	ldrb	r3, [r3, #3]
    7b86:	061b      	lsls	r3, r3, #24
    7b88:	430b      	orrs	r3, r1
    7b8a:	214a      	movs	r1, #74	; 0x4a
    7b8c:	5c59      	ldrb	r1, [r3, r1]
    7b8e:	204b      	movs	r0, #75	; 0x4b
    7b90:	5c1b      	ldrb	r3, [r3, r0]
    7b92:	021b      	lsls	r3, r3, #8
    7b94:	430b      	orrs	r3, r1
    7b96:	b29b      	uxth	r3, r3
    7b98:	6013      	str	r3, [r2, #0]
	memcpy(build_state->cert, build_state->cert_def->cert_template, build_state->cert_def->cert_template_size);
    7b9a:	68fb      	ldr	r3, [r7, #12]
    7b9c:	791a      	ldrb	r2, [r3, #4]
    7b9e:	7959      	ldrb	r1, [r3, #5]
    7ba0:	0209      	lsls	r1, r1, #8
    7ba2:	430a      	orrs	r2, r1
    7ba4:	7999      	ldrb	r1, [r3, #6]
    7ba6:	0409      	lsls	r1, r1, #16
    7ba8:	430a      	orrs	r2, r1
    7baa:	79db      	ldrb	r3, [r3, #7]
    7bac:	061b      	lsls	r3, r3, #24
    7bae:	4313      	orrs	r3, r2
    7bb0:	0018      	movs	r0, r3
    7bb2:	68fb      	ldr	r3, [r7, #12]
    7bb4:	781a      	ldrb	r2, [r3, #0]
    7bb6:	7859      	ldrb	r1, [r3, #1]
    7bb8:	0209      	lsls	r1, r1, #8
    7bba:	430a      	orrs	r2, r1
    7bbc:	7899      	ldrb	r1, [r3, #2]
    7bbe:	0409      	lsls	r1, r1, #16
    7bc0:	430a      	orrs	r2, r1
    7bc2:	78db      	ldrb	r3, [r3, #3]
    7bc4:	061b      	lsls	r3, r3, #24
    7bc6:	4313      	orrs	r3, r2
    7bc8:	2246      	movs	r2, #70	; 0x46
    7bca:	5c9a      	ldrb	r2, [r3, r2]
    7bcc:	2147      	movs	r1, #71	; 0x47
    7bce:	5c59      	ldrb	r1, [r3, r1]
    7bd0:	0209      	lsls	r1, r1, #8
    7bd2:	430a      	orrs	r2, r1
    7bd4:	2148      	movs	r1, #72	; 0x48
    7bd6:	5c59      	ldrb	r1, [r3, r1]
    7bd8:	0409      	lsls	r1, r1, #16
    7bda:	430a      	orrs	r2, r1
    7bdc:	2149      	movs	r1, #73	; 0x49
    7bde:	5c5b      	ldrb	r3, [r3, r1]
    7be0:	061b      	lsls	r3, r3, #24
    7be2:	4313      	orrs	r3, r2
    7be4:	001c      	movs	r4, r3
    7be6:	68fb      	ldr	r3, [r7, #12]
    7be8:	781a      	ldrb	r2, [r3, #0]
    7bea:	7859      	ldrb	r1, [r3, #1]
    7bec:	0209      	lsls	r1, r1, #8
    7bee:	430a      	orrs	r2, r1
    7bf0:	7899      	ldrb	r1, [r3, #2]
    7bf2:	0409      	lsls	r1, r1, #16
    7bf4:	430a      	orrs	r2, r1
    7bf6:	78db      	ldrb	r3, [r3, #3]
    7bf8:	061b      	lsls	r3, r3, #24
    7bfa:	4313      	orrs	r3, r2
    7bfc:	224a      	movs	r2, #74	; 0x4a
    7bfe:	5c9a      	ldrb	r2, [r3, r2]
    7c00:	214b      	movs	r1, #75	; 0x4b
    7c02:	5c5b      	ldrb	r3, [r3, r1]
    7c04:	021b      	lsls	r3, r3, #8
    7c06:	4313      	orrs	r3, r2
    7c08:	b29b      	uxth	r3, r3
    7c0a:	001a      	movs	r2, r3
    7c0c:	0021      	movs	r1, r4
    7c0e:	4b46      	ldr	r3, [pc, #280]	; (7d28 <atcacert_cert_build_start+0x3d0>)
    7c10:	4798      	blx	r3

	if (build_state->cert_def->type == CERTTYPE_X509) {
    7c12:	68fb      	ldr	r3, [r7, #12]
    7c14:	781a      	ldrb	r2, [r3, #0]
    7c16:	7859      	ldrb	r1, [r3, #1]
    7c18:	0209      	lsls	r1, r1, #8
    7c1a:	430a      	orrs	r2, r1
    7c1c:	7899      	ldrb	r1, [r3, #2]
    7c1e:	0409      	lsls	r1, r1, #16
    7c20:	430a      	orrs	r2, r1
    7c22:	78db      	ldrb	r3, [r3, #3]
    7c24:	061b      	lsls	r3, r3, #24
    7c26:	4313      	orrs	r3, r2
    7c28:	781b      	ldrb	r3, [r3, #0]
    7c2a:	2b00      	cmp	r3, #0
    7c2c:	d145      	bne.n	7cba <atcacert_cert_build_start+0x362>
		// Set a fake signature that should result in the largest X.509 cert. This will ensure
		// the cert buffer is large enough early in the cert rebuilding process.
		uint8_t large_sig[64];
		memset(large_sig, 0xFF, sizeof(large_sig));
    7c2e:	2314      	movs	r3, #20
    7c30:	18fb      	adds	r3, r7, r3
    7c32:	2240      	movs	r2, #64	; 0x40
    7c34:	21ff      	movs	r1, #255	; 0xff
    7c36:	0018      	movs	r0, r3
    7c38:	4b3a      	ldr	r3, [pc, #232]	; (7d24 <atcacert_cert_build_start+0x3cc>)
    7c3a:	4798      	blx	r3
		ret = atcacert_set_signature(
    7c3c:	68fb      	ldr	r3, [r7, #12]
    7c3e:	781a      	ldrb	r2, [r3, #0]
    7c40:	7859      	ldrb	r1, [r3, #1]
    7c42:	0209      	lsls	r1, r1, #8
    7c44:	430a      	orrs	r2, r1
    7c46:	7899      	ldrb	r1, [r3, #2]
    7c48:	0409      	lsls	r1, r1, #16
    7c4a:	430a      	orrs	r2, r1
    7c4c:	78db      	ldrb	r3, [r3, #3]
    7c4e:	061b      	lsls	r3, r3, #24
    7c50:	4313      	orrs	r3, r2
    7c52:	0018      	movs	r0, r3
    7c54:	68fb      	ldr	r3, [r7, #12]
    7c56:	791a      	ldrb	r2, [r3, #4]
    7c58:	7959      	ldrb	r1, [r3, #5]
    7c5a:	0209      	lsls	r1, r1, #8
    7c5c:	430a      	orrs	r2, r1
    7c5e:	7999      	ldrb	r1, [r3, #6]
    7c60:	0409      	lsls	r1, r1, #16
    7c62:	430a      	orrs	r2, r1
    7c64:	79db      	ldrb	r3, [r3, #7]
    7c66:	061b      	lsls	r3, r3, #24
    7c68:	4313      	orrs	r3, r2
    7c6a:	001c      	movs	r4, r3
    7c6c:	68fb      	ldr	r3, [r7, #12]
    7c6e:	7a1a      	ldrb	r2, [r3, #8]
    7c70:	7a59      	ldrb	r1, [r3, #9]
    7c72:	0209      	lsls	r1, r1, #8
    7c74:	430a      	orrs	r2, r1
    7c76:	7a99      	ldrb	r1, [r3, #10]
    7c78:	0409      	lsls	r1, r1, #16
    7c7a:	430a      	orrs	r2, r1
    7c7c:	7adb      	ldrb	r3, [r3, #11]
    7c7e:	061b      	lsls	r3, r3, #24
    7c80:	4313      	orrs	r3, r2
    7c82:	001d      	movs	r5, r3
    7c84:	68fb      	ldr	r3, [r7, #12]
    7c86:	7b1a      	ldrb	r2, [r3, #12]
    7c88:	7b59      	ldrb	r1, [r3, #13]
    7c8a:	0209      	lsls	r1, r1, #8
    7c8c:	430a      	orrs	r2, r1
    7c8e:	7b99      	ldrb	r1, [r3, #14]
    7c90:	0409      	lsls	r1, r1, #16
    7c92:	430a      	orrs	r2, r1
    7c94:	7bdb      	ldrb	r3, [r3, #15]
    7c96:	061b      	lsls	r3, r3, #24
    7c98:	4313      	orrs	r3, r2
    7c9a:	001a      	movs	r2, r3
    7c9c:	2314      	movs	r3, #20
    7c9e:	18fb      	adds	r3, r7, r3
    7ca0:	9300      	str	r3, [sp, #0]
    7ca2:	0013      	movs	r3, r2
    7ca4:	002a      	movs	r2, r5
    7ca6:	0021      	movs	r1, r4
    7ca8:	4c20      	ldr	r4, [pc, #128]	; (7d2c <atcacert_cert_build_start+0x3d4>)
    7caa:	47a0      	blx	r4
    7cac:	0003      	movs	r3, r0
    7cae:	657b      	str	r3, [r7, #84]	; 0x54
		    build_state->cert_def,
		    build_state->cert,
		    build_state->cert_size,
		    build_state->max_cert_size,
		    large_sig);
		if (ret != ATCACERT_E_SUCCESS)
    7cb0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    7cb2:	2b00      	cmp	r3, #0
    7cb4:	d001      	beq.n	7cba <atcacert_cert_build_start+0x362>
			return ret;
    7cb6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    7cb8:	e02f      	b.n	7d1a <atcacert_cert_build_start+0x3c2>
	}

	// Set the authority key ID
	ret = atcacert_set_auth_key_id(
    7cba:	68fb      	ldr	r3, [r7, #12]
    7cbc:	781a      	ldrb	r2, [r3, #0]
    7cbe:	7859      	ldrb	r1, [r3, #1]
    7cc0:	0209      	lsls	r1, r1, #8
    7cc2:	430a      	orrs	r2, r1
    7cc4:	7899      	ldrb	r1, [r3, #2]
    7cc6:	0409      	lsls	r1, r1, #16
    7cc8:	430a      	orrs	r2, r1
    7cca:	78db      	ldrb	r3, [r3, #3]
    7ccc:	061b      	lsls	r3, r3, #24
    7cce:	4313      	orrs	r3, r2
    7cd0:	0018      	movs	r0, r3
    7cd2:	68fb      	ldr	r3, [r7, #12]
    7cd4:	791a      	ldrb	r2, [r3, #4]
    7cd6:	7959      	ldrb	r1, [r3, #5]
    7cd8:	0209      	lsls	r1, r1, #8
    7cda:	430a      	orrs	r2, r1
    7cdc:	7999      	ldrb	r1, [r3, #6]
    7cde:	0409      	lsls	r1, r1, #16
    7ce0:	430a      	orrs	r2, r1
    7ce2:	79db      	ldrb	r3, [r3, #7]
    7ce4:	061b      	lsls	r3, r3, #24
    7ce6:	4313      	orrs	r3, r2
    7ce8:	001c      	movs	r4, r3
	    build_state->cert_def,
	    build_state->cert,
	    *build_state->cert_size,
    7cea:	68fb      	ldr	r3, [r7, #12]
    7cec:	7a1a      	ldrb	r2, [r3, #8]
    7cee:	7a59      	ldrb	r1, [r3, #9]
    7cf0:	0209      	lsls	r1, r1, #8
    7cf2:	430a      	orrs	r2, r1
    7cf4:	7a99      	ldrb	r1, [r3, #10]
    7cf6:	0409      	lsls	r1, r1, #16
    7cf8:	430a      	orrs	r2, r1
    7cfa:	7adb      	ldrb	r3, [r3, #11]
    7cfc:	061b      	lsls	r3, r3, #24
    7cfe:	4313      	orrs	r3, r2
		if (ret != ATCACERT_E_SUCCESS)
			return ret;
	}

	// Set the authority key ID
	ret = atcacert_set_auth_key_id(
    7d00:	681a      	ldr	r2, [r3, #0]
    7d02:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    7d04:	0021      	movs	r1, r4
    7d06:	4c0a      	ldr	r4, [pc, #40]	; (7d30 <atcacert_cert_build_start+0x3d8>)
    7d08:	47a0      	blx	r4
    7d0a:	0003      	movs	r3, r0
    7d0c:	657b      	str	r3, [r7, #84]	; 0x54
	    build_state->cert_def,
	    build_state->cert,
	    *build_state->cert_size,
	    ca_public_key);
	if (ret != ATCACERT_E_SUCCESS)
    7d0e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    7d10:	2b00      	cmp	r3, #0
    7d12:	d001      	beq.n	7d18 <atcacert_cert_build_start+0x3c0>
		return ret;
    7d14:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    7d16:	e000      	b.n	7d1a <atcacert_cert_build_start+0x3c2>

	return ATCACERT_E_SUCCESS;
    7d18:	2300      	movs	r3, #0
}
    7d1a:	0018      	movs	r0, r3
    7d1c:	46bd      	mov	sp, r7
    7d1e:	b016      	add	sp, #88	; 0x58
    7d20:	bdb0      	pop	{r4, r5, r7, pc}
    7d22:	46c0      	nop			; (mov r8, r8)
    7d24:	00012823 	.word	0x00012823
    7d28:	000127e7 	.word	0x000127e7
    7d2c:	00008995 	.word	0x00008995
    7d30:	00009481 	.word	0x00009481

00007d34 <atcacert_cert_build_process>:

int atcacert_cert_build_process( atcacert_build_state_t*      build_state,
                                 const atcacert_device_loc_t* device_loc,
                                 const uint8_t*               device_data)
{
    7d34:	b5b0      	push	{r4, r5, r7, lr}
    7d36:	b09a      	sub	sp, #104	; 0x68
    7d38:	af02      	add	r7, sp, #8
    7d3a:	60f8      	str	r0, [r7, #12]
    7d3c:	60b9      	str	r1, [r7, #8]
    7d3e:	607a      	str	r2, [r7, #4]
	int ret = 0;
    7d40:	2300      	movs	r3, #0
    7d42:	65fb      	str	r3, [r7, #92]	; 0x5c
	size_t i = 0;
    7d44:	2300      	movs	r3, #0
    7d46:	65bb      	str	r3, [r7, #88]	; 0x58
	const uint8_t* data = NULL;
    7d48:	2300      	movs	r3, #0
    7d4a:	657b      	str	r3, [r7, #84]	; 0x54
		.is_genkey	= FALSE,
		.offset		= 0,
		.count		= 13
	};

	if (build_state == NULL || device_loc == NULL || device_data == NULL)
    7d4c:	68fb      	ldr	r3, [r7, #12]
    7d4e:	2b00      	cmp	r3, #0
    7d50:	d005      	beq.n	7d5e <atcacert_cert_build_process+0x2a>
    7d52:	68bb      	ldr	r3, [r7, #8]
    7d54:	2b00      	cmp	r3, #0
    7d56:	d002      	beq.n	7d5e <atcacert_cert_build_process+0x2a>
    7d58:	687b      	ldr	r3, [r7, #4]
    7d5a:	2b00      	cmp	r3, #0
    7d5c:	d101      	bne.n	7d62 <atcacert_cert_build_process+0x2e>
		return ATCACERT_E_BAD_PARAMS;
    7d5e:	2302      	movs	r3, #2
    7d60:	e2bb      	b.n	82da <atcacert_cert_build_process+0x5a6>

	data = atcacert_is_device_loc_match(&build_state->cert_def->cert_sn_dev_loc, device_loc, device_data);
    7d62:	68fb      	ldr	r3, [r7, #12]
    7d64:	781a      	ldrb	r2, [r3, #0]
    7d66:	7859      	ldrb	r1, [r3, #1]
    7d68:	0209      	lsls	r1, r1, #8
    7d6a:	430a      	orrs	r2, r1
    7d6c:	7899      	ldrb	r1, [r3, #2]
    7d6e:	0409      	lsls	r1, r1, #16
    7d70:	430a      	orrs	r2, r1
    7d72:	78db      	ldrb	r3, [r3, #3]
    7d74:	061b      	lsls	r3, r3, #24
    7d76:	4313      	orrs	r3, r2
    7d78:	3305      	adds	r3, #5
    7d7a:	687a      	ldr	r2, [r7, #4]
    7d7c:	68b9      	ldr	r1, [r7, #8]
    7d7e:	0018      	movs	r0, r3
    7d80:	4bc0      	ldr	r3, [pc, #768]	; (8084 <atcacert_cert_build_process+0x350>)
    7d82:	4798      	blx	r3
    7d84:	0003      	movs	r3, r0
    7d86:	657b      	str	r3, [r7, #84]	; 0x54
	if (data != NULL) {
    7d88:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    7d8a:	2b00      	cmp	r3, #0
    7d8c:	d042      	beq.n	7e14 <atcacert_cert_build_process+0xe0>
		ret = atcacert_set_cert_sn(
    7d8e:	68fb      	ldr	r3, [r7, #12]
    7d90:	781a      	ldrb	r2, [r3, #0]
    7d92:	7859      	ldrb	r1, [r3, #1]
    7d94:	0209      	lsls	r1, r1, #8
    7d96:	430a      	orrs	r2, r1
    7d98:	7899      	ldrb	r1, [r3, #2]
    7d9a:	0409      	lsls	r1, r1, #16
    7d9c:	430a      	orrs	r2, r1
    7d9e:	78db      	ldrb	r3, [r3, #3]
    7da0:	061b      	lsls	r3, r3, #24
    7da2:	4313      	orrs	r3, r2
    7da4:	001c      	movs	r4, r3
    7da6:	68fb      	ldr	r3, [r7, #12]
    7da8:	791a      	ldrb	r2, [r3, #4]
    7daa:	7959      	ldrb	r1, [r3, #5]
    7dac:	0209      	lsls	r1, r1, #8
    7dae:	430a      	orrs	r2, r1
    7db0:	7999      	ldrb	r1, [r3, #6]
    7db2:	0409      	lsls	r1, r1, #16
    7db4:	430a      	orrs	r2, r1
    7db6:	79db      	ldrb	r3, [r3, #7]
    7db8:	061b      	lsls	r3, r3, #24
    7dba:	4313      	orrs	r3, r2
    7dbc:	001d      	movs	r5, r3
		    build_state->cert_def,
		    build_state->cert,
		    *build_state->cert_size,
    7dbe:	68fb      	ldr	r3, [r7, #12]
    7dc0:	7a1a      	ldrb	r2, [r3, #8]
    7dc2:	7a59      	ldrb	r1, [r3, #9]
    7dc4:	0209      	lsls	r1, r1, #8
    7dc6:	430a      	orrs	r2, r1
    7dc8:	7a99      	ldrb	r1, [r3, #10]
    7dca:	0409      	lsls	r1, r1, #16
    7dcc:	430a      	orrs	r2, r1
    7dce:	7adb      	ldrb	r3, [r3, #11]
    7dd0:	061b      	lsls	r3, r3, #24
    7dd2:	4313      	orrs	r3, r2
	if (build_state == NULL || device_loc == NULL || device_data == NULL)
		return ATCACERT_E_BAD_PARAMS;

	data = atcacert_is_device_loc_match(&build_state->cert_def->cert_sn_dev_loc, device_loc, device_data);
	if (data != NULL) {
		ret = atcacert_set_cert_sn(
    7dd4:	6818      	ldr	r0, [r3, #0]
		    build_state->cert_def,
		    build_state->cert,
		    *build_state->cert_size,
		    data,
		    build_state->cert_def->cert_sn_dev_loc.count);
    7dd6:	68fb      	ldr	r3, [r7, #12]
    7dd8:	781a      	ldrb	r2, [r3, #0]
    7dda:	7859      	ldrb	r1, [r3, #1]
    7ddc:	0209      	lsls	r1, r1, #8
    7dde:	430a      	orrs	r2, r1
    7de0:	7899      	ldrb	r1, [r3, #2]
    7de2:	0409      	lsls	r1, r1, #16
    7de4:	430a      	orrs	r2, r1
    7de6:	78db      	ldrb	r3, [r3, #3]
    7de8:	061b      	lsls	r3, r3, #24
    7dea:	4313      	orrs	r3, r2
    7dec:	7a9a      	ldrb	r2, [r3, #10]
    7dee:	7adb      	ldrb	r3, [r3, #11]
    7df0:	021b      	lsls	r3, r3, #8
    7df2:	4313      	orrs	r3, r2
    7df4:	b29b      	uxth	r3, r3
	if (build_state == NULL || device_loc == NULL || device_data == NULL)
		return ATCACERT_E_BAD_PARAMS;

	data = atcacert_is_device_loc_match(&build_state->cert_def->cert_sn_dev_loc, device_loc, device_data);
	if (data != NULL) {
		ret = atcacert_set_cert_sn(
    7df6:	001a      	movs	r2, r3
    7df8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    7dfa:	9200      	str	r2, [sp, #0]
    7dfc:	0002      	movs	r2, r0
    7dfe:	0029      	movs	r1, r5
    7e00:	0020      	movs	r0, r4
    7e02:	4ca1      	ldr	r4, [pc, #644]	; (8088 <atcacert_cert_build_process+0x354>)
    7e04:	47a0      	blx	r4
    7e06:	0003      	movs	r3, r0
    7e08:	65fb      	str	r3, [r7, #92]	; 0x5c
		    build_state->cert_def,
		    build_state->cert,
		    *build_state->cert_size,
		    data,
		    build_state->cert_def->cert_sn_dev_loc.count);
		if (ret != ATCACERT_E_SUCCESS)
    7e0a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    7e0c:	2b00      	cmp	r3, #0
    7e0e:	d001      	beq.n	7e14 <atcacert_cert_build_process+0xe0>
			return ret;
    7e10:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    7e12:	e262      	b.n	82da <atcacert_cert_build_process+0x5a6>
	}

	data = atcacert_is_device_loc_match(&build_state->cert_def->public_key_dev_loc, device_loc, device_data);
    7e14:	68fb      	ldr	r3, [r7, #12]
    7e16:	781a      	ldrb	r2, [r3, #0]
    7e18:	7859      	ldrb	r1, [r3, #1]
    7e1a:	0209      	lsls	r1, r1, #8
    7e1c:	430a      	orrs	r2, r1
    7e1e:	7899      	ldrb	r1, [r3, #2]
    7e20:	0409      	lsls	r1, r1, #16
    7e22:	430a      	orrs	r2, r1
    7e24:	78db      	ldrb	r3, [r3, #3]
    7e26:	061b      	lsls	r3, r3, #24
    7e28:	4313      	orrs	r3, r2
    7e2a:	3313      	adds	r3, #19
    7e2c:	687a      	ldr	r2, [r7, #4]
    7e2e:	68b9      	ldr	r1, [r7, #8]
    7e30:	0018      	movs	r0, r3
    7e32:	4b94      	ldr	r3, [pc, #592]	; (8084 <atcacert_cert_build_process+0x350>)
    7e34:	4798      	blx	r3
    7e36:	0003      	movs	r3, r0
    7e38:	657b      	str	r3, [r7, #84]	; 0x54
	if (data != NULL) {
    7e3a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    7e3c:	2b00      	cmp	r3, #0
    7e3e:	d100      	bne.n	7e42 <atcacert_cert_build_process+0x10e>
    7e40:	e088      	b.n	7f54 <atcacert_cert_build_process+0x220>
		if (build_state->cert_def->public_key_dev_loc.count == 72) {
    7e42:	68fb      	ldr	r3, [r7, #12]
    7e44:	781a      	ldrb	r2, [r3, #0]
    7e46:	7859      	ldrb	r1, [r3, #1]
    7e48:	0209      	lsls	r1, r1, #8
    7e4a:	430a      	orrs	r2, r1
    7e4c:	7899      	ldrb	r1, [r3, #2]
    7e4e:	0409      	lsls	r1, r1, #16
    7e50:	430a      	orrs	r2, r1
    7e52:	78db      	ldrb	r3, [r3, #3]
    7e54:	061b      	lsls	r3, r3, #24
    7e56:	4313      	orrs	r3, r2
    7e58:	7e1a      	ldrb	r2, [r3, #24]
    7e5a:	7e5b      	ldrb	r3, [r3, #25]
    7e5c:	021b      	lsls	r3, r3, #8
    7e5e:	4313      	orrs	r3, r2
    7e60:	b29b      	uxth	r3, r3
    7e62:	2b48      	cmp	r3, #72	; 0x48
    7e64:	d132      	bne.n	7ecc <atcacert_cert_build_process+0x198>
			// Public key is formatted with padding bytes in front of the X and Y components
			atcacert_public_key_remove_padding(data, public_key);
    7e66:	2314      	movs	r3, #20
    7e68:	18fa      	adds	r2, r7, r3
    7e6a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    7e6c:	0011      	movs	r1, r2
    7e6e:	0018      	movs	r0, r3
    7e70:	4b86      	ldr	r3, [pc, #536]	; (808c <atcacert_cert_build_process+0x358>)
    7e72:	4798      	blx	r3
			ret = atcacert_set_subj_public_key(
    7e74:	68fb      	ldr	r3, [r7, #12]
    7e76:	781a      	ldrb	r2, [r3, #0]
    7e78:	7859      	ldrb	r1, [r3, #1]
    7e7a:	0209      	lsls	r1, r1, #8
    7e7c:	430a      	orrs	r2, r1
    7e7e:	7899      	ldrb	r1, [r3, #2]
    7e80:	0409      	lsls	r1, r1, #16
    7e82:	430a      	orrs	r2, r1
    7e84:	78db      	ldrb	r3, [r3, #3]
    7e86:	061b      	lsls	r3, r3, #24
    7e88:	4313      	orrs	r3, r2
    7e8a:	0018      	movs	r0, r3
    7e8c:	68fb      	ldr	r3, [r7, #12]
    7e8e:	791a      	ldrb	r2, [r3, #4]
    7e90:	7959      	ldrb	r1, [r3, #5]
    7e92:	0209      	lsls	r1, r1, #8
    7e94:	430a      	orrs	r2, r1
    7e96:	7999      	ldrb	r1, [r3, #6]
    7e98:	0409      	lsls	r1, r1, #16
    7e9a:	430a      	orrs	r2, r1
    7e9c:	79db      	ldrb	r3, [r3, #7]
    7e9e:	061b      	lsls	r3, r3, #24
    7ea0:	4313      	orrs	r3, r2
    7ea2:	001c      	movs	r4, r3
			    build_state->cert_def,
			    build_state->cert,
			    *build_state->cert_size,
    7ea4:	68fb      	ldr	r3, [r7, #12]
    7ea6:	7a1a      	ldrb	r2, [r3, #8]
    7ea8:	7a59      	ldrb	r1, [r3, #9]
    7eaa:	0209      	lsls	r1, r1, #8
    7eac:	430a      	orrs	r2, r1
    7eae:	7a99      	ldrb	r1, [r3, #10]
    7eb0:	0409      	lsls	r1, r1, #16
    7eb2:	430a      	orrs	r2, r1
    7eb4:	7adb      	ldrb	r3, [r3, #11]
    7eb6:	061b      	lsls	r3, r3, #24
    7eb8:	4313      	orrs	r3, r2
	data = atcacert_is_device_loc_match(&build_state->cert_def->public_key_dev_loc, device_loc, device_data);
	if (data != NULL) {
		if (build_state->cert_def->public_key_dev_loc.count == 72) {
			// Public key is formatted with padding bytes in front of the X and Y components
			atcacert_public_key_remove_padding(data, public_key);
			ret = atcacert_set_subj_public_key(
    7eba:	681a      	ldr	r2, [r3, #0]
    7ebc:	2314      	movs	r3, #20
    7ebe:	18fb      	adds	r3, r7, r3
    7ec0:	0021      	movs	r1, r4
    7ec2:	4c73      	ldr	r4, [pc, #460]	; (8090 <atcacert_cert_build_process+0x35c>)
    7ec4:	47a0      	blx	r4
    7ec6:	0003      	movs	r3, r0
    7ec8:	65fb      	str	r3, [r7, #92]	; 0x5c
    7eca:	e03e      	b.n	7f4a <atcacert_cert_build_process+0x216>
			    build_state->cert_def,
			    build_state->cert,
			    *build_state->cert_size,
			    public_key);
		}else if (build_state->cert_def->public_key_dev_loc.count == 64) {
    7ecc:	68fb      	ldr	r3, [r7, #12]
    7ece:	781a      	ldrb	r2, [r3, #0]
    7ed0:	7859      	ldrb	r1, [r3, #1]
    7ed2:	0209      	lsls	r1, r1, #8
    7ed4:	430a      	orrs	r2, r1
    7ed6:	7899      	ldrb	r1, [r3, #2]
    7ed8:	0409      	lsls	r1, r1, #16
    7eda:	430a      	orrs	r2, r1
    7edc:	78db      	ldrb	r3, [r3, #3]
    7ede:	061b      	lsls	r3, r3, #24
    7ee0:	4313      	orrs	r3, r2
    7ee2:	7e1a      	ldrb	r2, [r3, #24]
    7ee4:	7e5b      	ldrb	r3, [r3, #25]
    7ee6:	021b      	lsls	r3, r3, #8
    7ee8:	4313      	orrs	r3, r2
    7eea:	b29b      	uxth	r3, r3
    7eec:	2b40      	cmp	r3, #64	; 0x40
    7eee:	d12a      	bne.n	7f46 <atcacert_cert_build_process+0x212>
			ret = atcacert_set_subj_public_key(
    7ef0:	68fb      	ldr	r3, [r7, #12]
    7ef2:	781a      	ldrb	r2, [r3, #0]
    7ef4:	7859      	ldrb	r1, [r3, #1]
    7ef6:	0209      	lsls	r1, r1, #8
    7ef8:	430a      	orrs	r2, r1
    7efa:	7899      	ldrb	r1, [r3, #2]
    7efc:	0409      	lsls	r1, r1, #16
    7efe:	430a      	orrs	r2, r1
    7f00:	78db      	ldrb	r3, [r3, #3]
    7f02:	061b      	lsls	r3, r3, #24
    7f04:	4313      	orrs	r3, r2
    7f06:	0018      	movs	r0, r3
    7f08:	68fb      	ldr	r3, [r7, #12]
    7f0a:	791a      	ldrb	r2, [r3, #4]
    7f0c:	7959      	ldrb	r1, [r3, #5]
    7f0e:	0209      	lsls	r1, r1, #8
    7f10:	430a      	orrs	r2, r1
    7f12:	7999      	ldrb	r1, [r3, #6]
    7f14:	0409      	lsls	r1, r1, #16
    7f16:	430a      	orrs	r2, r1
    7f18:	79db      	ldrb	r3, [r3, #7]
    7f1a:	061b      	lsls	r3, r3, #24
    7f1c:	4313      	orrs	r3, r2
    7f1e:	001c      	movs	r4, r3
			    build_state->cert_def,
			    build_state->cert,
			    *build_state->cert_size,
    7f20:	68fb      	ldr	r3, [r7, #12]
    7f22:	7a1a      	ldrb	r2, [r3, #8]
    7f24:	7a59      	ldrb	r1, [r3, #9]
    7f26:	0209      	lsls	r1, r1, #8
    7f28:	430a      	orrs	r2, r1
    7f2a:	7a99      	ldrb	r1, [r3, #10]
    7f2c:	0409      	lsls	r1, r1, #16
    7f2e:	430a      	orrs	r2, r1
    7f30:	7adb      	ldrb	r3, [r3, #11]
    7f32:	061b      	lsls	r3, r3, #24
    7f34:	4313      	orrs	r3, r2
			    build_state->cert_def,
			    build_state->cert,
			    *build_state->cert_size,
			    public_key);
		}else if (build_state->cert_def->public_key_dev_loc.count == 64) {
			ret = atcacert_set_subj_public_key(
    7f36:	681a      	ldr	r2, [r3, #0]
    7f38:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    7f3a:	0021      	movs	r1, r4
    7f3c:	4c54      	ldr	r4, [pc, #336]	; (8090 <atcacert_cert_build_process+0x35c>)
    7f3e:	47a0      	blx	r4
    7f40:	0003      	movs	r3, r0
    7f42:	65fb      	str	r3, [r7, #92]	; 0x5c
    7f44:	e001      	b.n	7f4a <atcacert_cert_build_process+0x216>
			    build_state->cert_def,
			    build_state->cert,
			    *build_state->cert_size,
			    data);
		}else
			return ATCACERT_E_BAD_CERT; // Unexpected public key size
    7f46:	230a      	movs	r3, #10
    7f48:	e1c7      	b.n	82da <atcacert_cert_build_process+0x5a6>

		if (ret != ATCACERT_E_SUCCESS)
    7f4a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    7f4c:	2b00      	cmp	r3, #0
    7f4e:	d001      	beq.n	7f54 <atcacert_cert_build_process+0x220>
			return ret;
    7f50:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    7f52:	e1c2      	b.n	82da <atcacert_cert_build_process+0x5a6>
	}

	data = atcacert_is_device_loc_match(&build_state->cert_def->comp_cert_dev_loc, device_loc, device_data);
    7f54:	68fb      	ldr	r3, [r7, #12]
    7f56:	781a      	ldrb	r2, [r3, #0]
    7f58:	7859      	ldrb	r1, [r3, #1]
    7f5a:	0209      	lsls	r1, r1, #8
    7f5c:	430a      	orrs	r2, r1
    7f5e:	7899      	ldrb	r1, [r3, #2]
    7f60:	0409      	lsls	r1, r1, #16
    7f62:	430a      	orrs	r2, r1
    7f64:	78db      	ldrb	r3, [r3, #3]
    7f66:	061b      	lsls	r3, r3, #24
    7f68:	4313      	orrs	r3, r2
    7f6a:	331a      	adds	r3, #26
    7f6c:	687a      	ldr	r2, [r7, #4]
    7f6e:	68b9      	ldr	r1, [r7, #8]
    7f70:	0018      	movs	r0, r3
    7f72:	4b44      	ldr	r3, [pc, #272]	; (8084 <atcacert_cert_build_process+0x350>)
    7f74:	4798      	blx	r3
    7f76:	0003      	movs	r3, r0
    7f78:	657b      	str	r3, [r7, #84]	; 0x54
	if (data != NULL) {
    7f7a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    7f7c:	2b00      	cmp	r3, #0
    7f7e:	d052      	beq.n	8026 <atcacert_cert_build_process+0x2f2>
		if (build_state->cert_def->comp_cert_dev_loc.count != 72)
    7f80:	68fb      	ldr	r3, [r7, #12]
    7f82:	781a      	ldrb	r2, [r3, #0]
    7f84:	7859      	ldrb	r1, [r3, #1]
    7f86:	0209      	lsls	r1, r1, #8
    7f88:	430a      	orrs	r2, r1
    7f8a:	7899      	ldrb	r1, [r3, #2]
    7f8c:	0409      	lsls	r1, r1, #16
    7f8e:	430a      	orrs	r2, r1
    7f90:	78db      	ldrb	r3, [r3, #3]
    7f92:	061b      	lsls	r3, r3, #24
    7f94:	4313      	orrs	r3, r2
    7f96:	7fda      	ldrb	r2, [r3, #31]
    7f98:	2120      	movs	r1, #32
    7f9a:	5c5b      	ldrb	r3, [r3, r1]
    7f9c:	021b      	lsls	r3, r3, #8
    7f9e:	4313      	orrs	r3, r2
    7fa0:	b29b      	uxth	r3, r3
    7fa2:	2b48      	cmp	r3, #72	; 0x48
    7fa4:	d001      	beq.n	7faa <atcacert_cert_build_process+0x276>
			return ATCACERT_E_BAD_CERT; // Unexpected compressed certificate size
    7fa6:	230a      	movs	r3, #10
    7fa8:	e197      	b.n	82da <atcacert_cert_build_process+0x5a6>

		ret = atcacert_set_comp_cert(
    7faa:	68fb      	ldr	r3, [r7, #12]
    7fac:	781a      	ldrb	r2, [r3, #0]
    7fae:	7859      	ldrb	r1, [r3, #1]
    7fb0:	0209      	lsls	r1, r1, #8
    7fb2:	430a      	orrs	r2, r1
    7fb4:	7899      	ldrb	r1, [r3, #2]
    7fb6:	0409      	lsls	r1, r1, #16
    7fb8:	430a      	orrs	r2, r1
    7fba:	78db      	ldrb	r3, [r3, #3]
    7fbc:	061b      	lsls	r3, r3, #24
    7fbe:	4313      	orrs	r3, r2
    7fc0:	0018      	movs	r0, r3
    7fc2:	68fb      	ldr	r3, [r7, #12]
    7fc4:	791a      	ldrb	r2, [r3, #4]
    7fc6:	7959      	ldrb	r1, [r3, #5]
    7fc8:	0209      	lsls	r1, r1, #8
    7fca:	430a      	orrs	r2, r1
    7fcc:	7999      	ldrb	r1, [r3, #6]
    7fce:	0409      	lsls	r1, r1, #16
    7fd0:	430a      	orrs	r2, r1
    7fd2:	79db      	ldrb	r3, [r3, #7]
    7fd4:	061b      	lsls	r3, r3, #24
    7fd6:	4313      	orrs	r3, r2
    7fd8:	001c      	movs	r4, r3
    7fda:	68fb      	ldr	r3, [r7, #12]
    7fdc:	7a1a      	ldrb	r2, [r3, #8]
    7fde:	7a59      	ldrb	r1, [r3, #9]
    7fe0:	0209      	lsls	r1, r1, #8
    7fe2:	430a      	orrs	r2, r1
    7fe4:	7a99      	ldrb	r1, [r3, #10]
    7fe6:	0409      	lsls	r1, r1, #16
    7fe8:	430a      	orrs	r2, r1
    7fea:	7adb      	ldrb	r3, [r3, #11]
    7fec:	061b      	lsls	r3, r3, #24
    7fee:	4313      	orrs	r3, r2
    7ff0:	001d      	movs	r5, r3
    7ff2:	68fb      	ldr	r3, [r7, #12]
    7ff4:	7b1a      	ldrb	r2, [r3, #12]
    7ff6:	7b59      	ldrb	r1, [r3, #13]
    7ff8:	0209      	lsls	r1, r1, #8
    7ffa:	430a      	orrs	r2, r1
    7ffc:	7b99      	ldrb	r1, [r3, #14]
    7ffe:	0409      	lsls	r1, r1, #16
    8000:	430a      	orrs	r2, r1
    8002:	7bdb      	ldrb	r3, [r3, #15]
    8004:	061b      	lsls	r3, r3, #24
    8006:	4313      	orrs	r3, r2
    8008:	001a      	movs	r2, r3
    800a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    800c:	9300      	str	r3, [sp, #0]
    800e:	0013      	movs	r3, r2
    8010:	002a      	movs	r2, r5
    8012:	0021      	movs	r1, r4
    8014:	4c1f      	ldr	r4, [pc, #124]	; (8094 <atcacert_cert_build_process+0x360>)
    8016:	47a0      	blx	r4
    8018:	0003      	movs	r3, r0
    801a:	65fb      	str	r3, [r7, #92]	; 0x5c
		    build_state->cert_def,
		    build_state->cert,
		    build_state->cert_size,
		    build_state->max_cert_size,
		    data);
		if (ret != ATCACERT_E_SUCCESS)
    801c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    801e:	2b00      	cmp	r3, #0
    8020:	d001      	beq.n	8026 <atcacert_cert_build_process+0x2f2>
			return ret;
    8022:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    8024:	e159      	b.n	82da <atcacert_cert_build_process+0x5a6>
	}

	if (build_state->cert_def->cert_elements_count > 0 && build_state->cert_def->cert_elements == NULL)
    8026:	68fb      	ldr	r3, [r7, #12]
    8028:	781a      	ldrb	r2, [r3, #0]
    802a:	7859      	ldrb	r1, [r3, #1]
    802c:	0209      	lsls	r1, r1, #8
    802e:	430a      	orrs	r2, r1
    8030:	7899      	ldrb	r1, [r3, #2]
    8032:	0409      	lsls	r1, r1, #16
    8034:	430a      	orrs	r2, r1
    8036:	78db      	ldrb	r3, [r3, #3]
    8038:	061b      	lsls	r3, r3, #24
    803a:	4313      	orrs	r3, r2
    803c:	001a      	movs	r2, r3
    803e:	2345      	movs	r3, #69	; 0x45
    8040:	5cd3      	ldrb	r3, [r2, r3]
    8042:	2b00      	cmp	r3, #0
    8044:	d01b      	beq.n	807e <atcacert_cert_build_process+0x34a>
    8046:	68fb      	ldr	r3, [r7, #12]
    8048:	781a      	ldrb	r2, [r3, #0]
    804a:	7859      	ldrb	r1, [r3, #1]
    804c:	0209      	lsls	r1, r1, #8
    804e:	430a      	orrs	r2, r1
    8050:	7899      	ldrb	r1, [r3, #2]
    8052:	0409      	lsls	r1, r1, #16
    8054:	430a      	orrs	r2, r1
    8056:	78db      	ldrb	r3, [r3, #3]
    8058:	061b      	lsls	r3, r3, #24
    805a:	4313      	orrs	r3, r2
    805c:	2241      	movs	r2, #65	; 0x41
    805e:	5c9a      	ldrb	r2, [r3, r2]
    8060:	2142      	movs	r1, #66	; 0x42
    8062:	5c59      	ldrb	r1, [r3, r1]
    8064:	0209      	lsls	r1, r1, #8
    8066:	430a      	orrs	r2, r1
    8068:	2143      	movs	r1, #67	; 0x43
    806a:	5c59      	ldrb	r1, [r3, r1]
    806c:	0409      	lsls	r1, r1, #16
    806e:	430a      	orrs	r2, r1
    8070:	2144      	movs	r1, #68	; 0x44
    8072:	5c5b      	ldrb	r3, [r3, r1]
    8074:	061b      	lsls	r3, r3, #24
    8076:	4313      	orrs	r3, r2
    8078:	d101      	bne.n	807e <atcacert_cert_build_process+0x34a>
		return ATCACERT_E_BAD_CERT;
    807a:	230a      	movs	r3, #10
    807c:	e12d      	b.n	82da <atcacert_cert_build_process+0x5a6>
	for (i = 0; i < build_state->cert_def->cert_elements_count; i++) {
    807e:	2300      	movs	r3, #0
    8080:	65bb      	str	r3, [r7, #88]	; 0x58
    8082:	e0f8      	b.n	8276 <atcacert_cert_build_process+0x542>
    8084:	00007845 	.word	0x00007845
    8088:	00009061 	.word	0x00009061
    808c:	00009a65 	.word	0x00009a65
    8090:	000088ad 	.word	0x000088ad
    8094:	000094fd 	.word	0x000094fd
		data = atcacert_is_device_loc_match(&build_state->cert_def->cert_elements[i].device_loc, device_loc, device_data);
    8098:	68fb      	ldr	r3, [r7, #12]
    809a:	781a      	ldrb	r2, [r3, #0]
    809c:	7859      	ldrb	r1, [r3, #1]
    809e:	0209      	lsls	r1, r1, #8
    80a0:	430a      	orrs	r2, r1
    80a2:	7899      	ldrb	r1, [r3, #2]
    80a4:	0409      	lsls	r1, r1, #16
    80a6:	430a      	orrs	r2, r1
    80a8:	78db      	ldrb	r3, [r3, #3]
    80aa:	061b      	lsls	r3, r3, #24
    80ac:	4313      	orrs	r3, r2
    80ae:	2241      	movs	r2, #65	; 0x41
    80b0:	5c9a      	ldrb	r2, [r3, r2]
    80b2:	2142      	movs	r1, #66	; 0x42
    80b4:	5c59      	ldrb	r1, [r3, r1]
    80b6:	0209      	lsls	r1, r1, #8
    80b8:	430a      	orrs	r2, r1
    80ba:	2143      	movs	r1, #67	; 0x43
    80bc:	5c59      	ldrb	r1, [r3, r1]
    80be:	0409      	lsls	r1, r1, #16
    80c0:	430a      	orrs	r2, r1
    80c2:	2144      	movs	r1, #68	; 0x44
    80c4:	5c5b      	ldrb	r3, [r3, r1]
    80c6:	061b      	lsls	r3, r3, #24
    80c8:	4313      	orrs	r3, r2
    80ca:	0019      	movs	r1, r3
    80cc:	6dba      	ldr	r2, [r7, #88]	; 0x58
    80ce:	0013      	movs	r3, r2
    80d0:	005b      	lsls	r3, r3, #1
    80d2:	189b      	adds	r3, r3, r2
    80d4:	00da      	lsls	r2, r3, #3
    80d6:	189b      	adds	r3, r3, r2
    80d8:	18cb      	adds	r3, r1, r3
    80da:	3310      	adds	r3, #16
    80dc:	687a      	ldr	r2, [r7, #4]
    80de:	68b9      	ldr	r1, [r7, #8]
    80e0:	0018      	movs	r0, r3
    80e2:	4b80      	ldr	r3, [pc, #512]	; (82e4 <atcacert_cert_build_process+0x5b0>)
    80e4:	4798      	blx	r3
    80e6:	0003      	movs	r3, r0
    80e8:	657b      	str	r3, [r7, #84]	; 0x54
		if (data != NULL) {
    80ea:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    80ec:	2b00      	cmp	r3, #0
    80ee:	d100      	bne.n	80f2 <atcacert_cert_build_process+0x3be>
    80f0:	e0be      	b.n	8270 <atcacert_cert_build_process+0x53c>
			if (build_state->cert_def->cert_elements[i].device_loc.count != build_state->cert_def->cert_elements[i].cert_loc.count)
    80f2:	68fb      	ldr	r3, [r7, #12]
    80f4:	781a      	ldrb	r2, [r3, #0]
    80f6:	7859      	ldrb	r1, [r3, #1]
    80f8:	0209      	lsls	r1, r1, #8
    80fa:	430a      	orrs	r2, r1
    80fc:	7899      	ldrb	r1, [r3, #2]
    80fe:	0409      	lsls	r1, r1, #16
    8100:	430a      	orrs	r2, r1
    8102:	78db      	ldrb	r3, [r3, #3]
    8104:	061b      	lsls	r3, r3, #24
    8106:	4313      	orrs	r3, r2
    8108:	2241      	movs	r2, #65	; 0x41
    810a:	5c9a      	ldrb	r2, [r3, r2]
    810c:	2142      	movs	r1, #66	; 0x42
    810e:	5c59      	ldrb	r1, [r3, r1]
    8110:	0209      	lsls	r1, r1, #8
    8112:	430a      	orrs	r2, r1
    8114:	2143      	movs	r1, #67	; 0x43
    8116:	5c59      	ldrb	r1, [r3, r1]
    8118:	0409      	lsls	r1, r1, #16
    811a:	430a      	orrs	r2, r1
    811c:	2144      	movs	r1, #68	; 0x44
    811e:	5c5b      	ldrb	r3, [r3, r1]
    8120:	061b      	lsls	r3, r3, #24
    8122:	4313      	orrs	r3, r2
    8124:	0019      	movs	r1, r3
    8126:	6dba      	ldr	r2, [r7, #88]	; 0x58
    8128:	0013      	movs	r3, r2
    812a:	005b      	lsls	r3, r3, #1
    812c:	189b      	adds	r3, r3, r2
    812e:	00da      	lsls	r2, r3, #3
    8130:	189b      	adds	r3, r3, r2
    8132:	18cb      	adds	r3, r1, r3
    8134:	7d5a      	ldrb	r2, [r3, #21]
    8136:	7d9b      	ldrb	r3, [r3, #22]
    8138:	021b      	lsls	r3, r3, #8
    813a:	4313      	orrs	r3, r2
    813c:	b299      	uxth	r1, r3
    813e:	68fb      	ldr	r3, [r7, #12]
    8140:	781a      	ldrb	r2, [r3, #0]
    8142:	7858      	ldrb	r0, [r3, #1]
    8144:	0200      	lsls	r0, r0, #8
    8146:	4302      	orrs	r2, r0
    8148:	7898      	ldrb	r0, [r3, #2]
    814a:	0400      	lsls	r0, r0, #16
    814c:	4302      	orrs	r2, r0
    814e:	78db      	ldrb	r3, [r3, #3]
    8150:	061b      	lsls	r3, r3, #24
    8152:	4313      	orrs	r3, r2
    8154:	2241      	movs	r2, #65	; 0x41
    8156:	5c9a      	ldrb	r2, [r3, r2]
    8158:	2042      	movs	r0, #66	; 0x42
    815a:	5c18      	ldrb	r0, [r3, r0]
    815c:	0200      	lsls	r0, r0, #8
    815e:	4302      	orrs	r2, r0
    8160:	2043      	movs	r0, #67	; 0x43
    8162:	5c18      	ldrb	r0, [r3, r0]
    8164:	0400      	lsls	r0, r0, #16
    8166:	4302      	orrs	r2, r0
    8168:	2044      	movs	r0, #68	; 0x44
    816a:	5c1b      	ldrb	r3, [r3, r0]
    816c:	061b      	lsls	r3, r3, #24
    816e:	4313      	orrs	r3, r2
    8170:	0018      	movs	r0, r3
    8172:	6dba      	ldr	r2, [r7, #88]	; 0x58
    8174:	0013      	movs	r3, r2
    8176:	005b      	lsls	r3, r3, #1
    8178:	189b      	adds	r3, r3, r2
    817a:	00da      	lsls	r2, r3, #3
    817c:	189b      	adds	r3, r3, r2
    817e:	18c3      	adds	r3, r0, r3
    8180:	7e5a      	ldrb	r2, [r3, #25]
    8182:	7e9b      	ldrb	r3, [r3, #26]
    8184:	021b      	lsls	r3, r3, #8
    8186:	4313      	orrs	r3, r2
    8188:	b29b      	uxth	r3, r3
    818a:	4299      	cmp	r1, r3
    818c:	d001      	beq.n	8192 <atcacert_cert_build_process+0x45e>
				return ATCACERT_E_BAD_CERT;
    818e:	230a      	movs	r3, #10
    8190:	e0a3      	b.n	82da <atcacert_cert_build_process+0x5a6>
			ret = atcacert_set_cert_element(
			    &build_state->cert_def->cert_elements[i].cert_loc,
    8192:	68fb      	ldr	r3, [r7, #12]
    8194:	781a      	ldrb	r2, [r3, #0]
    8196:	7859      	ldrb	r1, [r3, #1]
    8198:	0209      	lsls	r1, r1, #8
    819a:	430a      	orrs	r2, r1
    819c:	7899      	ldrb	r1, [r3, #2]
    819e:	0409      	lsls	r1, r1, #16
    81a0:	430a      	orrs	r2, r1
    81a2:	78db      	ldrb	r3, [r3, #3]
    81a4:	061b      	lsls	r3, r3, #24
    81a6:	4313      	orrs	r3, r2
    81a8:	2241      	movs	r2, #65	; 0x41
    81aa:	5c9a      	ldrb	r2, [r3, r2]
    81ac:	2142      	movs	r1, #66	; 0x42
    81ae:	5c59      	ldrb	r1, [r3, r1]
    81b0:	0209      	lsls	r1, r1, #8
    81b2:	430a      	orrs	r2, r1
    81b4:	2143      	movs	r1, #67	; 0x43
    81b6:	5c59      	ldrb	r1, [r3, r1]
    81b8:	0409      	lsls	r1, r1, #16
    81ba:	430a      	orrs	r2, r1
    81bc:	2144      	movs	r1, #68	; 0x44
    81be:	5c5b      	ldrb	r3, [r3, r1]
    81c0:	061b      	lsls	r3, r3, #24
    81c2:	4313      	orrs	r3, r2
    81c4:	0019      	movs	r1, r3
    81c6:	6dba      	ldr	r2, [r7, #88]	; 0x58
    81c8:	0013      	movs	r3, r2
    81ca:	005b      	lsls	r3, r3, #1
    81cc:	189b      	adds	r3, r3, r2
    81ce:	00da      	lsls	r2, r3, #3
    81d0:	189b      	adds	r3, r3, r2
    81d2:	18cb      	adds	r3, r1, r3
	for (i = 0; i < build_state->cert_def->cert_elements_count; i++) {
		data = atcacert_is_device_loc_match(&build_state->cert_def->cert_elements[i].device_loc, device_loc, device_data);
		if (data != NULL) {
			if (build_state->cert_def->cert_elements[i].device_loc.count != build_state->cert_def->cert_elements[i].cert_loc.count)
				return ATCACERT_E_BAD_CERT;
			ret = atcacert_set_cert_element(
    81d4:	3317      	adds	r3, #23
    81d6:	0018      	movs	r0, r3
    81d8:	68fb      	ldr	r3, [r7, #12]
    81da:	791a      	ldrb	r2, [r3, #4]
    81dc:	7959      	ldrb	r1, [r3, #5]
    81de:	0209      	lsls	r1, r1, #8
    81e0:	430a      	orrs	r2, r1
    81e2:	7999      	ldrb	r1, [r3, #6]
    81e4:	0409      	lsls	r1, r1, #16
    81e6:	430a      	orrs	r2, r1
    81e8:	79db      	ldrb	r3, [r3, #7]
    81ea:	061b      	lsls	r3, r3, #24
    81ec:	4313      	orrs	r3, r2
    81ee:	001d      	movs	r5, r3
			    &build_state->cert_def->cert_elements[i].cert_loc,
			    build_state->cert,
			    *build_state->cert_size,
    81f0:	68fb      	ldr	r3, [r7, #12]
    81f2:	7a1a      	ldrb	r2, [r3, #8]
    81f4:	7a59      	ldrb	r1, [r3, #9]
    81f6:	0209      	lsls	r1, r1, #8
    81f8:	430a      	orrs	r2, r1
    81fa:	7a99      	ldrb	r1, [r3, #10]
    81fc:	0409      	lsls	r1, r1, #16
    81fe:	430a      	orrs	r2, r1
    8200:	7adb      	ldrb	r3, [r3, #11]
    8202:	061b      	lsls	r3, r3, #24
    8204:	4313      	orrs	r3, r2
	for (i = 0; i < build_state->cert_def->cert_elements_count; i++) {
		data = atcacert_is_device_loc_match(&build_state->cert_def->cert_elements[i].device_loc, device_loc, device_data);
		if (data != NULL) {
			if (build_state->cert_def->cert_elements[i].device_loc.count != build_state->cert_def->cert_elements[i].cert_loc.count)
				return ATCACERT_E_BAD_CERT;
			ret = atcacert_set_cert_element(
    8206:	681c      	ldr	r4, [r3, #0]
			    &build_state->cert_def->cert_elements[i].cert_loc,
			    build_state->cert,
			    *build_state->cert_size,
			    data,
			    build_state->cert_def->cert_elements[i].cert_loc.count);
    8208:	68fb      	ldr	r3, [r7, #12]
    820a:	781a      	ldrb	r2, [r3, #0]
    820c:	7859      	ldrb	r1, [r3, #1]
    820e:	0209      	lsls	r1, r1, #8
    8210:	430a      	orrs	r2, r1
    8212:	7899      	ldrb	r1, [r3, #2]
    8214:	0409      	lsls	r1, r1, #16
    8216:	430a      	orrs	r2, r1
    8218:	78db      	ldrb	r3, [r3, #3]
    821a:	061b      	lsls	r3, r3, #24
    821c:	4313      	orrs	r3, r2
    821e:	2241      	movs	r2, #65	; 0x41
    8220:	5c9a      	ldrb	r2, [r3, r2]
    8222:	2142      	movs	r1, #66	; 0x42
    8224:	5c59      	ldrb	r1, [r3, r1]
    8226:	0209      	lsls	r1, r1, #8
    8228:	430a      	orrs	r2, r1
    822a:	2143      	movs	r1, #67	; 0x43
    822c:	5c59      	ldrb	r1, [r3, r1]
    822e:	0409      	lsls	r1, r1, #16
    8230:	430a      	orrs	r2, r1
    8232:	2144      	movs	r1, #68	; 0x44
    8234:	5c5b      	ldrb	r3, [r3, r1]
    8236:	061b      	lsls	r3, r3, #24
    8238:	4313      	orrs	r3, r2
    823a:	0019      	movs	r1, r3
    823c:	6dba      	ldr	r2, [r7, #88]	; 0x58
    823e:	0013      	movs	r3, r2
    8240:	005b      	lsls	r3, r3, #1
    8242:	189b      	adds	r3, r3, r2
    8244:	00da      	lsls	r2, r3, #3
    8246:	189b      	adds	r3, r3, r2
    8248:	18cb      	adds	r3, r1, r3
    824a:	7e5a      	ldrb	r2, [r3, #25]
    824c:	7e9b      	ldrb	r3, [r3, #26]
    824e:	021b      	lsls	r3, r3, #8
    8250:	4313      	orrs	r3, r2
    8252:	b29b      	uxth	r3, r3
	for (i = 0; i < build_state->cert_def->cert_elements_count; i++) {
		data = atcacert_is_device_loc_match(&build_state->cert_def->cert_elements[i].device_loc, device_loc, device_data);
		if (data != NULL) {
			if (build_state->cert_def->cert_elements[i].device_loc.count != build_state->cert_def->cert_elements[i].cert_loc.count)
				return ATCACERT_E_BAD_CERT;
			ret = atcacert_set_cert_element(
    8254:	001a      	movs	r2, r3
    8256:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    8258:	9200      	str	r2, [sp, #0]
    825a:	0022      	movs	r2, r4
    825c:	0029      	movs	r1, r5
    825e:	4c22      	ldr	r4, [pc, #136]	; (82e8 <atcacert_cert_build_process+0x5b4>)
    8260:	47a0      	blx	r4
    8262:	0003      	movs	r3, r0
    8264:	65fb      	str	r3, [r7, #92]	; 0x5c
			    &build_state->cert_def->cert_elements[i].cert_loc,
			    build_state->cert,
			    *build_state->cert_size,
			    data,
			    build_state->cert_def->cert_elements[i].cert_loc.count);
			if (ret != ATCACERT_E_SUCCESS)
    8266:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    8268:	2b00      	cmp	r3, #0
    826a:	d001      	beq.n	8270 <atcacert_cert_build_process+0x53c>
				return ret;
    826c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    826e:	e034      	b.n	82da <atcacert_cert_build_process+0x5a6>
			return ret;
	}

	if (build_state->cert_def->cert_elements_count > 0 && build_state->cert_def->cert_elements == NULL)
		return ATCACERT_E_BAD_CERT;
	for (i = 0; i < build_state->cert_def->cert_elements_count; i++) {
    8270:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    8272:	3301      	adds	r3, #1
    8274:	65bb      	str	r3, [r7, #88]	; 0x58
    8276:	68fb      	ldr	r3, [r7, #12]
    8278:	781a      	ldrb	r2, [r3, #0]
    827a:	7859      	ldrb	r1, [r3, #1]
    827c:	0209      	lsls	r1, r1, #8
    827e:	430a      	orrs	r2, r1
    8280:	7899      	ldrb	r1, [r3, #2]
    8282:	0409      	lsls	r1, r1, #16
    8284:	430a      	orrs	r2, r1
    8286:	78db      	ldrb	r3, [r3, #3]
    8288:	061b      	lsls	r3, r3, #24
    828a:	4313      	orrs	r3, r2
    828c:	001a      	movs	r2, r3
    828e:	2345      	movs	r3, #69	; 0x45
    8290:	5cd3      	ldrb	r3, [r2, r3]
    8292:	1e1a      	subs	r2, r3, #0
    8294:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    8296:	429a      	cmp	r2, r3
    8298:	d900      	bls.n	829c <atcacert_cert_build_process+0x568>
    829a:	e6fd      	b.n	8098 <atcacert_cert_build_process+0x364>
			if (ret != ATCACERT_E_SUCCESS)
				return ret;
		}
	}

	data = atcacert_is_device_loc_match(&device_sn_dev_loc, device_loc, device_data);
    829c:	687a      	ldr	r2, [r7, #4]
    829e:	68b9      	ldr	r1, [r7, #8]
    82a0:	4b12      	ldr	r3, [pc, #72]	; (82ec <atcacert_cert_build_process+0x5b8>)
    82a2:	0018      	movs	r0, r3
    82a4:	4b0f      	ldr	r3, [pc, #60]	; (82e4 <atcacert_cert_build_process+0x5b0>)
    82a6:	4798      	blx	r3
    82a8:	0003      	movs	r3, r0
    82aa:	657b      	str	r3, [r7, #84]	; 0x54
	if (data != NULL) {
    82ac:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    82ae:	2b00      	cmp	r3, #0
    82b0:	d012      	beq.n	82d8 <atcacert_cert_build_process+0x5a4>
		// Get the device SN
		build_state->is_device_sn = TRUE;
    82b2:	68fb      	ldr	r3, [r7, #12]
    82b4:	2201      	movs	r2, #1
    82b6:	741a      	strb	r2, [r3, #16]
		memcpy(&build_state->device_sn[0], &data[0], 4);
    82b8:	68fb      	ldr	r3, [r7, #12]
    82ba:	3311      	adds	r3, #17
    82bc:	6d79      	ldr	r1, [r7, #84]	; 0x54
    82be:	2204      	movs	r2, #4
    82c0:	0018      	movs	r0, r3
    82c2:	4b0b      	ldr	r3, [pc, #44]	; (82f0 <atcacert_cert_build_process+0x5bc>)
    82c4:	4798      	blx	r3
		memcpy(&build_state->device_sn[4], &data[8], 5);
    82c6:	68fb      	ldr	r3, [r7, #12]
    82c8:	3315      	adds	r3, #21
    82ca:	0018      	movs	r0, r3
    82cc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    82ce:	3308      	adds	r3, #8
    82d0:	2205      	movs	r2, #5
    82d2:	0019      	movs	r1, r3
    82d4:	4b06      	ldr	r3, [pc, #24]	; (82f0 <atcacert_cert_build_process+0x5bc>)
    82d6:	4798      	blx	r3
	}

	return ATCACERT_E_SUCCESS;
    82d8:	2300      	movs	r3, #0
}
    82da:	0018      	movs	r0, r3
    82dc:	46bd      	mov	sp, r7
    82de:	b018      	add	sp, #96	; 0x60
    82e0:	bdb0      	pop	{r4, r5, r7, pc}
    82e2:	46c0      	nop			; (mov r8, r8)
    82e4:	00007845 	.word	0x00007845
    82e8:	00009879 	.word	0x00009879
    82ec:	000152ac 	.word	0x000152ac
    82f0:	000127e7 	.word	0x000127e7

000082f4 <atcacert_cert_build_finish>:

int atcacert_cert_build_finish( atcacert_build_state_t* build_state )
{
    82f4:	b590      	push	{r4, r7, lr}
    82f6:	b085      	sub	sp, #20
    82f8:	af00      	add	r7, sp, #0
    82fa:	6078      	str	r0, [r7, #4]
	int ret = 0;
    82fc:	2300      	movs	r3, #0
    82fe:	60bb      	str	r3, [r7, #8]
	const uint8_t* device_sn = NULL;
    8300:	2300      	movs	r3, #0
    8302:	60fb      	str	r3, [r7, #12]

	if (build_state == NULL)
    8304:	687b      	ldr	r3, [r7, #4]
    8306:	2b00      	cmp	r3, #0
    8308:	d101      	bne.n	830e <atcacert_cert_build_finish+0x1a>
		return ATCACERT_E_BAD_PARAMS;
    830a:	2302      	movs	r3, #2
    830c:	e036      	b.n	837c <atcacert_cert_build_finish+0x88>

	if (build_state->is_device_sn)
    830e:	687b      	ldr	r3, [r7, #4]
    8310:	7c1b      	ldrb	r3, [r3, #16]
    8312:	2b00      	cmp	r3, #0
    8314:	d002      	beq.n	831c <atcacert_cert_build_finish+0x28>
		device_sn = build_state->device_sn;
    8316:	687b      	ldr	r3, [r7, #4]
    8318:	3311      	adds	r3, #17
    831a:	60fb      	str	r3, [r7, #12]

	ret = atcacert_gen_cert_sn(build_state->cert_def, build_state->cert, *build_state->cert_size, device_sn);
    831c:	687b      	ldr	r3, [r7, #4]
    831e:	781a      	ldrb	r2, [r3, #0]
    8320:	7859      	ldrb	r1, [r3, #1]
    8322:	0209      	lsls	r1, r1, #8
    8324:	430a      	orrs	r2, r1
    8326:	7899      	ldrb	r1, [r3, #2]
    8328:	0409      	lsls	r1, r1, #16
    832a:	430a      	orrs	r2, r1
    832c:	78db      	ldrb	r3, [r3, #3]
    832e:	061b      	lsls	r3, r3, #24
    8330:	4313      	orrs	r3, r2
    8332:	0018      	movs	r0, r3
    8334:	687b      	ldr	r3, [r7, #4]
    8336:	791a      	ldrb	r2, [r3, #4]
    8338:	7959      	ldrb	r1, [r3, #5]
    833a:	0209      	lsls	r1, r1, #8
    833c:	430a      	orrs	r2, r1
    833e:	7999      	ldrb	r1, [r3, #6]
    8340:	0409      	lsls	r1, r1, #16
    8342:	430a      	orrs	r2, r1
    8344:	79db      	ldrb	r3, [r3, #7]
    8346:	061b      	lsls	r3, r3, #24
    8348:	4313      	orrs	r3, r2
    834a:	001c      	movs	r4, r3
    834c:	687b      	ldr	r3, [r7, #4]
    834e:	7a1a      	ldrb	r2, [r3, #8]
    8350:	7a59      	ldrb	r1, [r3, #9]
    8352:	0209      	lsls	r1, r1, #8
    8354:	430a      	orrs	r2, r1
    8356:	7a99      	ldrb	r1, [r3, #10]
    8358:	0409      	lsls	r1, r1, #16
    835a:	430a      	orrs	r2, r1
    835c:	7adb      	ldrb	r3, [r3, #11]
    835e:	061b      	lsls	r3, r3, #24
    8360:	4313      	orrs	r3, r2
    8362:	681a      	ldr	r2, [r3, #0]
    8364:	68fb      	ldr	r3, [r7, #12]
    8366:	0021      	movs	r1, r4
    8368:	4c06      	ldr	r4, [pc, #24]	; (8384 <atcacert_cert_build_finish+0x90>)
    836a:	47a0      	blx	r4
    836c:	0003      	movs	r3, r0
    836e:	60bb      	str	r3, [r7, #8]
	if (ret != ATCACERT_E_SUCCESS)
    8370:	68bb      	ldr	r3, [r7, #8]
    8372:	2b00      	cmp	r3, #0
    8374:	d001      	beq.n	837a <atcacert_cert_build_finish+0x86>
		return ret;
    8376:	68bb      	ldr	r3, [r7, #8]
    8378:	e000      	b.n	837c <atcacert_cert_build_finish+0x88>

	return ret;
    837a:	68bb      	ldr	r3, [r7, #8]
}
    837c:	0018      	movs	r0, r3
    837e:	46bd      	mov	sp, r7
    8380:	b005      	add	sp, #20
    8382:	bd90      	pop	{r4, r7, pc}
    8384:	000090a9 	.word	0x000090a9

00008388 <atcacert_is_device_loc_overlap>:

int atcacert_is_device_loc_overlap( const atcacert_device_loc_t* device_loc1,
                                    const atcacert_device_loc_t* device_loc2)
{
    8388:	b580      	push	{r7, lr}
    838a:	b082      	sub	sp, #8
    838c:	af00      	add	r7, sp, #0
    838e:	6078      	str	r0, [r7, #4]
    8390:	6039      	str	r1, [r7, #0]
	if (device_loc1->zone != device_loc2->zone)
    8392:	687b      	ldr	r3, [r7, #4]
    8394:	781a      	ldrb	r2, [r3, #0]
    8396:	683b      	ldr	r3, [r7, #0]
    8398:	781b      	ldrb	r3, [r3, #0]
    839a:	429a      	cmp	r2, r3
    839c:	d001      	beq.n	83a2 <atcacert_is_device_loc_overlap+0x1a>
		return FALSE;   // Zones don't match, can't overlap
    839e:	2300      	movs	r3, #0
    83a0:	e047      	b.n	8432 <atcacert_is_device_loc_overlap+0xaa>
	if (device_loc1->zone == DEVZONE_DATA && device_loc1->slot != device_loc2->slot)
    83a2:	687b      	ldr	r3, [r7, #4]
    83a4:	781b      	ldrb	r3, [r3, #0]
    83a6:	2b02      	cmp	r3, #2
    83a8:	d107      	bne.n	83ba <atcacert_is_device_loc_overlap+0x32>
    83aa:	687b      	ldr	r3, [r7, #4]
    83ac:	785a      	ldrb	r2, [r3, #1]
    83ae:	683b      	ldr	r3, [r7, #0]
    83b0:	785b      	ldrb	r3, [r3, #1]
    83b2:	429a      	cmp	r2, r3
    83b4:	d001      	beq.n	83ba <atcacert_is_device_loc_overlap+0x32>
		return FALSE;   // Data zone, slots don't match, can't overlap
    83b6:	2300      	movs	r3, #0
    83b8:	e03b      	b.n	8432 <atcacert_is_device_loc_overlap+0xaa>
	if (device_loc1->zone == DEVZONE_DATA && device_loc1->is_genkey != device_loc2->is_genkey)
    83ba:	687b      	ldr	r3, [r7, #4]
    83bc:	781b      	ldrb	r3, [r3, #0]
    83be:	2b02      	cmp	r3, #2
    83c0:	d107      	bne.n	83d2 <atcacert_is_device_loc_overlap+0x4a>
    83c2:	687b      	ldr	r3, [r7, #4]
    83c4:	789a      	ldrb	r2, [r3, #2]
    83c6:	683b      	ldr	r3, [r7, #0]
    83c8:	789b      	ldrb	r3, [r3, #2]
    83ca:	429a      	cmp	r2, r3
    83cc:	d001      	beq.n	83d2 <atcacert_is_device_loc_overlap+0x4a>
		return FALSE;   // Data zone, same slot, but read method doesn't match, can't overlap
    83ce:	2300      	movs	r3, #0
    83d0:	e02f      	b.n	8432 <atcacert_is_device_loc_overlap+0xaa>

	return !(   device_loc1->offset + device_loc1->count <= device_loc2->offset
    83d2:	687b      	ldr	r3, [r7, #4]
    83d4:	78da      	ldrb	r2, [r3, #3]
    83d6:	791b      	ldrb	r3, [r3, #4]
    83d8:	021b      	lsls	r3, r3, #8
    83da:	4313      	orrs	r3, r2
    83dc:	b29b      	uxth	r3, r3
    83de:	0019      	movs	r1, r3
    83e0:	687b      	ldr	r3, [r7, #4]
    83e2:	795a      	ldrb	r2, [r3, #5]
    83e4:	799b      	ldrb	r3, [r3, #6]
    83e6:	021b      	lsls	r3, r3, #8
    83e8:	4313      	orrs	r3, r2
    83ea:	b29b      	uxth	r3, r3
    83ec:	18ca      	adds	r2, r1, r3
    83ee:	683b      	ldr	r3, [r7, #0]
    83f0:	78d9      	ldrb	r1, [r3, #3]
    83f2:	791b      	ldrb	r3, [r3, #4]
    83f4:	021b      	lsls	r3, r3, #8
    83f6:	430b      	orrs	r3, r1
    83f8:	b29b      	uxth	r3, r3
    83fa:	429a      	cmp	r2, r3
    83fc:	dd18      	ble.n	8430 <atcacert_is_device_loc_overlap+0xa8>
	            || device_loc1->offset >= device_loc2->offset + device_loc2->count);
    83fe:	687b      	ldr	r3, [r7, #4]
    8400:	78da      	ldrb	r2, [r3, #3]
    8402:	791b      	ldrb	r3, [r3, #4]
    8404:	021b      	lsls	r3, r3, #8
    8406:	4313      	orrs	r3, r2
    8408:	b29b      	uxth	r3, r3
    840a:	0019      	movs	r1, r3
    840c:	683b      	ldr	r3, [r7, #0]
    840e:	78da      	ldrb	r2, [r3, #3]
    8410:	791b      	ldrb	r3, [r3, #4]
    8412:	021b      	lsls	r3, r3, #8
    8414:	4313      	orrs	r3, r2
    8416:	b29b      	uxth	r3, r3
    8418:	0018      	movs	r0, r3
    841a:	683b      	ldr	r3, [r7, #0]
    841c:	795a      	ldrb	r2, [r3, #5]
    841e:	799b      	ldrb	r3, [r3, #6]
    8420:	021b      	lsls	r3, r3, #8
    8422:	4313      	orrs	r3, r2
    8424:	b29b      	uxth	r3, r3
    8426:	18c3      	adds	r3, r0, r3
	if (device_loc1->zone == DEVZONE_DATA && device_loc1->slot != device_loc2->slot)
		return FALSE;   // Data zone, slots don't match, can't overlap
	if (device_loc1->zone == DEVZONE_DATA && device_loc1->is_genkey != device_loc2->is_genkey)
		return FALSE;   // Data zone, same slot, but read method doesn't match, can't overlap

	return !(   device_loc1->offset + device_loc1->count <= device_loc2->offset
    8428:	4299      	cmp	r1, r3
    842a:	da01      	bge.n	8430 <atcacert_is_device_loc_overlap+0xa8>
    842c:	2301      	movs	r3, #1
    842e:	e000      	b.n	8432 <atcacert_is_device_loc_overlap+0xaa>
    8430:	2300      	movs	r3, #0
	            || device_loc1->offset >= device_loc2->offset + device_loc2->count);
}
    8432:	0018      	movs	r0, r3
    8434:	46bd      	mov	sp, r7
    8436:	b002      	add	sp, #8
    8438:	bd80      	pop	{r7, pc}
    843a:	46c0      	nop			; (mov r8, r8)

0000843c <atcacert_copy_device_loc_data>:

static void atcacert_copy_device_loc_data( const atcacert_device_loc_t* device_loc_src,
                                           const uint8_t*               data_src,
                                           const atcacert_device_loc_t* device_loc_dest,
                                           uint8_t*                     data_dest)
{
    843c:	b580      	push	{r7, lr}
    843e:	b086      	sub	sp, #24
    8440:	af00      	add	r7, sp, #0
    8442:	60f8      	str	r0, [r7, #12]
    8444:	60b9      	str	r1, [r7, #8]
    8446:	607a      	str	r2, [r7, #4]
    8448:	603b      	str	r3, [r7, #0]
	size_t offset = ATCACERT_MAX(device_loc_src->offset, device_loc_dest->offset);
    844a:	68fb      	ldr	r3, [r7, #12]
    844c:	78da      	ldrb	r2, [r3, #3]
    844e:	791b      	ldrb	r3, [r3, #4]
    8450:	021b      	lsls	r3, r3, #8
    8452:	4313      	orrs	r3, r2
    8454:	b299      	uxth	r1, r3
    8456:	687b      	ldr	r3, [r7, #4]
    8458:	78da      	ldrb	r2, [r3, #3]
    845a:	791b      	ldrb	r3, [r3, #4]
    845c:	021b      	lsls	r3, r3, #8
    845e:	4313      	orrs	r3, r2
    8460:	b29b      	uxth	r3, r3
    8462:	1c18      	adds	r0, r3, #0
    8464:	b28a      	uxth	r2, r1
    8466:	b283      	uxth	r3, r0
    8468:	429a      	cmp	r2, r3
    846a:	d200      	bcs.n	846e <atcacert_copy_device_loc_data+0x32>
    846c:	1c01      	adds	r1, r0, #0
    846e:	b28b      	uxth	r3, r1
    8470:	617b      	str	r3, [r7, #20]
	size_t end    = ATCACERT_MIN(device_loc_src->offset + device_loc_src->count, device_loc_dest->offset + device_loc_dest->count);
    8472:	687b      	ldr	r3, [r7, #4]
    8474:	78da      	ldrb	r2, [r3, #3]
    8476:	791b      	ldrb	r3, [r3, #4]
    8478:	021b      	lsls	r3, r3, #8
    847a:	4313      	orrs	r3, r2
    847c:	b29b      	uxth	r3, r3
    847e:	0019      	movs	r1, r3
    8480:	687b      	ldr	r3, [r7, #4]
    8482:	795a      	ldrb	r2, [r3, #5]
    8484:	799b      	ldrb	r3, [r3, #6]
    8486:	021b      	lsls	r3, r3, #8
    8488:	4313      	orrs	r3, r2
    848a:	b29b      	uxth	r3, r3
    848c:	18c9      	adds	r1, r1, r3
    848e:	68fb      	ldr	r3, [r7, #12]
    8490:	78da      	ldrb	r2, [r3, #3]
    8492:	791b      	ldrb	r3, [r3, #4]
    8494:	021b      	lsls	r3, r3, #8
    8496:	4313      	orrs	r3, r2
    8498:	b29b      	uxth	r3, r3
    849a:	0018      	movs	r0, r3
    849c:	68fb      	ldr	r3, [r7, #12]
    849e:	795a      	ldrb	r2, [r3, #5]
    84a0:	799b      	ldrb	r3, [r3, #6]
    84a2:	021b      	lsls	r3, r3, #8
    84a4:	4313      	orrs	r3, r2
    84a6:	b29b      	uxth	r3, r3
    84a8:	18c2      	adds	r2, r0, r3
    84aa:	1e0b      	subs	r3, r1, #0
    84ac:	4293      	cmp	r3, r2
    84ae:	dd00      	ble.n	84b2 <atcacert_copy_device_loc_data+0x76>
    84b0:	0013      	movs	r3, r2
    84b2:	613b      	str	r3, [r7, #16]

	memcpy(&data_dest[offset - device_loc_dest->offset], &data_src[offset - device_loc_src->offset], end - offset);
    84b4:	687b      	ldr	r3, [r7, #4]
    84b6:	78da      	ldrb	r2, [r3, #3]
    84b8:	791b      	ldrb	r3, [r3, #4]
    84ba:	021b      	lsls	r3, r3, #8
    84bc:	4313      	orrs	r3, r2
    84be:	b29b      	uxth	r3, r3
    84c0:	001a      	movs	r2, r3
    84c2:	697b      	ldr	r3, [r7, #20]
    84c4:	1a9b      	subs	r3, r3, r2
    84c6:	683a      	ldr	r2, [r7, #0]
    84c8:	18d0      	adds	r0, r2, r3
    84ca:	68fb      	ldr	r3, [r7, #12]
    84cc:	78da      	ldrb	r2, [r3, #3]
    84ce:	791b      	ldrb	r3, [r3, #4]
    84d0:	021b      	lsls	r3, r3, #8
    84d2:	4313      	orrs	r3, r2
    84d4:	b29b      	uxth	r3, r3
    84d6:	001a      	movs	r2, r3
    84d8:	697b      	ldr	r3, [r7, #20]
    84da:	1a9b      	subs	r3, r3, r2
    84dc:	68ba      	ldr	r2, [r7, #8]
    84de:	18d1      	adds	r1, r2, r3
    84e0:	693a      	ldr	r2, [r7, #16]
    84e2:	697b      	ldr	r3, [r7, #20]
    84e4:	1ad3      	subs	r3, r2, r3
    84e6:	001a      	movs	r2, r3
    84e8:	4b02      	ldr	r3, [pc, #8]	; (84f4 <atcacert_copy_device_loc_data+0xb8>)
    84ea:	4798      	blx	r3
}
    84ec:	46c0      	nop			; (mov r8, r8)
    84ee:	46bd      	mov	sp, r7
    84f0:	b006      	add	sp, #24
    84f2:	bd80      	pop	{r7, pc}
    84f4:	000127e7 	.word	0x000127e7

000084f8 <atcacert_get_device_data>:
int atcacert_get_device_data( const atcacert_def_t*        cert_def,
                              const uint8_t*               cert,
                              size_t cert_size,
                              const atcacert_device_loc_t* device_loc,
                              uint8_t*                     device_data)
{
    84f8:	b590      	push	{r4, r7, lr}
    84fa:	b0cb      	sub	sp, #300	; 0x12c
    84fc:	af02      	add	r7, sp, #8
    84fe:	60f8      	str	r0, [r7, #12]
    8500:	60b9      	str	r1, [r7, #8]
    8502:	607a      	str	r2, [r7, #4]
    8504:	603b      	str	r3, [r7, #0]
	int ret = 0;
    8506:	2300      	movs	r3, #0
    8508:	228c      	movs	r2, #140	; 0x8c
    850a:	0052      	lsls	r2, r2, #1
    850c:	18ba      	adds	r2, r7, r2
    850e:	6013      	str	r3, [r2, #0]
	int i = 0;
    8510:	2300      	movs	r3, #0
    8512:	228e      	movs	r2, #142	; 0x8e
    8514:	0052      	lsls	r2, r2, #1
    8516:	18ba      	adds	r2, r7, r2
    8518:	6013      	str	r3, [r2, #0]
	uint8_t temp_buf[256]; // Must be at least 72 bytes
	size_t temp_buf_size = sizeof(temp_buf);
    851a:	2380      	movs	r3, #128	; 0x80
    851c:	005b      	lsls	r3, r3, #1
    851e:	617b      	str	r3, [r7, #20]

	if (cert_def == NULL || cert == NULL || device_loc == NULL || device_data == NULL)
    8520:	68fb      	ldr	r3, [r7, #12]
    8522:	2b00      	cmp	r3, #0
    8524:	d00b      	beq.n	853e <atcacert_get_device_data+0x46>
    8526:	68bb      	ldr	r3, [r7, #8]
    8528:	2b00      	cmp	r3, #0
    852a:	d008      	beq.n	853e <atcacert_get_device_data+0x46>
    852c:	683b      	ldr	r3, [r7, #0]
    852e:	2b00      	cmp	r3, #0
    8530:	d005      	beq.n	853e <atcacert_get_device_data+0x46>
    8532:	2398      	movs	r3, #152	; 0x98
    8534:	005b      	lsls	r3, r3, #1
    8536:	18fb      	adds	r3, r7, r3
    8538:	681b      	ldr	r3, [r3, #0]
    853a:	2b00      	cmp	r3, #0
    853c:	d101      	bne.n	8542 <atcacert_get_device_data+0x4a>
		return ATCACERT_E_BAD_PARAMS;
    853e:	2302      	movs	r3, #2
    8540:	e1a1      	b.n	8886 <atcacert_get_device_data+0x38e>

	// Certificate serial number
	if (atcacert_is_device_loc_overlap(&cert_def->cert_sn_dev_loc, device_loc)) {
    8542:	68fb      	ldr	r3, [r7, #12]
    8544:	3305      	adds	r3, #5
    8546:	683a      	ldr	r2, [r7, #0]
    8548:	0011      	movs	r1, r2
    854a:	0018      	movs	r0, r3
    854c:	4bd0      	ldr	r3, [pc, #832]	; (8890 <atcacert_get_device_data+0x398>)
    854e:	4798      	blx	r3
    8550:	1e03      	subs	r3, r0, #0
    8552:	d028      	beq.n	85a6 <atcacert_get_device_data+0xae>
		temp_buf_size = sizeof(temp_buf);
    8554:	2380      	movs	r3, #128	; 0x80
    8556:	005b      	lsls	r3, r3, #1
    8558:	617b      	str	r3, [r7, #20]
		ret = atcacert_get_cert_sn(cert_def, cert, cert_size, temp_buf, &temp_buf_size);
    855a:	2318      	movs	r3, #24
    855c:	18fc      	adds	r4, r7, r3
    855e:	687a      	ldr	r2, [r7, #4]
    8560:	68b9      	ldr	r1, [r7, #8]
    8562:	68f8      	ldr	r0, [r7, #12]
    8564:	2314      	movs	r3, #20
    8566:	18fb      	adds	r3, r7, r3
    8568:	9300      	str	r3, [sp, #0]
    856a:	0023      	movs	r3, r4
    856c:	4cc9      	ldr	r4, [pc, #804]	; (8894 <atcacert_get_device_data+0x39c>)
    856e:	47a0      	blx	r4
    8570:	0003      	movs	r3, r0
    8572:	228c      	movs	r2, #140	; 0x8c
    8574:	0052      	lsls	r2, r2, #1
    8576:	18ba      	adds	r2, r7, r2
    8578:	6013      	str	r3, [r2, #0]
		if (ret != ATCACERT_E_SUCCESS)
    857a:	238c      	movs	r3, #140	; 0x8c
    857c:	005b      	lsls	r3, r3, #1
    857e:	18fb      	adds	r3, r7, r3
    8580:	681b      	ldr	r3, [r3, #0]
    8582:	2b00      	cmp	r3, #0
    8584:	d004      	beq.n	8590 <atcacert_get_device_data+0x98>
			return ret;
    8586:	238c      	movs	r3, #140	; 0x8c
    8588:	005b      	lsls	r3, r3, #1
    858a:	18fb      	adds	r3, r7, r3
    858c:	681b      	ldr	r3, [r3, #0]
    858e:	e17a      	b.n	8886 <atcacert_get_device_data+0x38e>
		atcacert_copy_device_loc_data(&cert_def->cert_sn_dev_loc, temp_buf, device_loc, device_data);
    8590:	68fb      	ldr	r3, [r7, #12]
    8592:	1d58      	adds	r0, r3, #5
    8594:	2398      	movs	r3, #152	; 0x98
    8596:	005b      	lsls	r3, r3, #1
    8598:	18fb      	adds	r3, r7, r3
    859a:	681b      	ldr	r3, [r3, #0]
    859c:	683a      	ldr	r2, [r7, #0]
    859e:	2118      	movs	r1, #24
    85a0:	1879      	adds	r1, r7, r1
    85a2:	4cbd      	ldr	r4, [pc, #756]	; (8898 <atcacert_get_device_data+0x3a0>)
    85a4:	47a0      	blx	r4
	}

	// Subject public key
	if (atcacert_is_device_loc_overlap(&cert_def->public_key_dev_loc, device_loc)) {
    85a6:	68fb      	ldr	r3, [r7, #12]
    85a8:	3313      	adds	r3, #19
    85aa:	683a      	ldr	r2, [r7, #0]
    85ac:	0011      	movs	r1, r2
    85ae:	0018      	movs	r0, r3
    85b0:	4bb7      	ldr	r3, [pc, #732]	; (8890 <atcacert_get_device_data+0x398>)
    85b2:	4798      	blx	r3
    85b4:	1e03      	subs	r3, r0, #0
    85b6:	d03d      	beq.n	8634 <atcacert_get_device_data+0x13c>
		ret = atcacert_get_subj_public_key(cert_def, cert, cert_size, temp_buf);
    85b8:	2318      	movs	r3, #24
    85ba:	18fb      	adds	r3, r7, r3
    85bc:	687a      	ldr	r2, [r7, #4]
    85be:	68b9      	ldr	r1, [r7, #8]
    85c0:	68f8      	ldr	r0, [r7, #12]
    85c2:	4cb6      	ldr	r4, [pc, #728]	; (889c <atcacert_get_device_data+0x3a4>)
    85c4:	47a0      	blx	r4
    85c6:	0003      	movs	r3, r0
    85c8:	228c      	movs	r2, #140	; 0x8c
    85ca:	0052      	lsls	r2, r2, #1
    85cc:	18ba      	adds	r2, r7, r2
    85ce:	6013      	str	r3, [r2, #0]
		if (ret != ATCACERT_E_SUCCESS)
    85d0:	238c      	movs	r3, #140	; 0x8c
    85d2:	005b      	lsls	r3, r3, #1
    85d4:	18fb      	adds	r3, r7, r3
    85d6:	681b      	ldr	r3, [r3, #0]
    85d8:	2b00      	cmp	r3, #0
    85da:	d004      	beq.n	85e6 <atcacert_get_device_data+0xee>
			return ret;
    85dc:	238c      	movs	r3, #140	; 0x8c
    85de:	005b      	lsls	r3, r3, #1
    85e0:	18fb      	adds	r3, r7, r3
    85e2:	681b      	ldr	r3, [r3, #0]
    85e4:	e14f      	b.n	8886 <atcacert_get_device_data+0x38e>
		if (cert_def->public_key_dev_loc.count == 72)
    85e6:	68fb      	ldr	r3, [r7, #12]
    85e8:	7e1a      	ldrb	r2, [r3, #24]
    85ea:	7e5b      	ldrb	r3, [r3, #25]
    85ec:	021b      	lsls	r3, r3, #8
    85ee:	4313      	orrs	r3, r2
    85f0:	b29b      	uxth	r3, r3
    85f2:	2b48      	cmp	r3, #72	; 0x48
    85f4:	d108      	bne.n	8608 <atcacert_get_device_data+0x110>
			// Public key is formatted with padding bytes in front of the X and Y components
			atcacert_public_key_add_padding(temp_buf, temp_buf);
    85f6:	2318      	movs	r3, #24
    85f8:	18fa      	adds	r2, r7, r3
    85fa:	2318      	movs	r3, #24
    85fc:	18fb      	adds	r3, r7, r3
    85fe:	0011      	movs	r1, r2
    8600:	0018      	movs	r0, r3
    8602:	4ba7      	ldr	r3, [pc, #668]	; (88a0 <atcacert_get_device_data+0x3a8>)
    8604:	4798      	blx	r3
    8606:	e009      	b.n	861c <atcacert_get_device_data+0x124>
		else if (cert_def->public_key_dev_loc.count != 64)
    8608:	68fb      	ldr	r3, [r7, #12]
    860a:	7e1a      	ldrb	r2, [r3, #24]
    860c:	7e5b      	ldrb	r3, [r3, #25]
    860e:	021b      	lsls	r3, r3, #8
    8610:	4313      	orrs	r3, r2
    8612:	b29b      	uxth	r3, r3
    8614:	2b40      	cmp	r3, #64	; 0x40
    8616:	d001      	beq.n	861c <atcacert_get_device_data+0x124>
			return ATCACERT_E_BAD_CERT; // Unexpected public key size
    8618:	230a      	movs	r3, #10
    861a:	e134      	b.n	8886 <atcacert_get_device_data+0x38e>
		atcacert_copy_device_loc_data(&cert_def->public_key_dev_loc, temp_buf, device_loc, device_data);
    861c:	68fb      	ldr	r3, [r7, #12]
    861e:	3313      	adds	r3, #19
    8620:	0018      	movs	r0, r3
    8622:	2398      	movs	r3, #152	; 0x98
    8624:	005b      	lsls	r3, r3, #1
    8626:	18fb      	adds	r3, r7, r3
    8628:	681b      	ldr	r3, [r3, #0]
    862a:	683a      	ldr	r2, [r7, #0]
    862c:	2118      	movs	r1, #24
    862e:	1879      	adds	r1, r7, r1
    8630:	4c99      	ldr	r4, [pc, #612]	; (8898 <atcacert_get_device_data+0x3a0>)
    8632:	47a0      	blx	r4
	}

	// Compressed certificate
	if (atcacert_is_device_loc_overlap(&cert_def->comp_cert_dev_loc, device_loc)) {
    8634:	68fb      	ldr	r3, [r7, #12]
    8636:	331a      	adds	r3, #26
    8638:	683a      	ldr	r2, [r7, #0]
    863a:	0011      	movs	r1, r2
    863c:	0018      	movs	r0, r3
    863e:	4b94      	ldr	r3, [pc, #592]	; (8890 <atcacert_get_device_data+0x398>)
    8640:	4798      	blx	r3
    8642:	1e03      	subs	r3, r0, #0
    8644:	d02d      	beq.n	86a2 <atcacert_get_device_data+0x1aa>
		ret = atcacert_get_comp_cert(cert_def, cert, cert_size, temp_buf);
    8646:	2318      	movs	r3, #24
    8648:	18fb      	adds	r3, r7, r3
    864a:	687a      	ldr	r2, [r7, #4]
    864c:	68b9      	ldr	r1, [r7, #8]
    864e:	68f8      	ldr	r0, [r7, #12]
    8650:	4c94      	ldr	r4, [pc, #592]	; (88a4 <atcacert_get_device_data+0x3ac>)
    8652:	47a0      	blx	r4
    8654:	0003      	movs	r3, r0
    8656:	228c      	movs	r2, #140	; 0x8c
    8658:	0052      	lsls	r2, r2, #1
    865a:	18ba      	adds	r2, r7, r2
    865c:	6013      	str	r3, [r2, #0]
		if (ret != ATCACERT_E_SUCCESS)
    865e:	238c      	movs	r3, #140	; 0x8c
    8660:	005b      	lsls	r3, r3, #1
    8662:	18fb      	adds	r3, r7, r3
    8664:	681b      	ldr	r3, [r3, #0]
    8666:	2b00      	cmp	r3, #0
    8668:	d004      	beq.n	8674 <atcacert_get_device_data+0x17c>
			return ret;
    866a:	238c      	movs	r3, #140	; 0x8c
    866c:	005b      	lsls	r3, r3, #1
    866e:	18fb      	adds	r3, r7, r3
    8670:	681b      	ldr	r3, [r3, #0]
    8672:	e108      	b.n	8886 <atcacert_get_device_data+0x38e>
		if (cert_def->comp_cert_dev_loc.count != 72)
    8674:	68fb      	ldr	r3, [r7, #12]
    8676:	7fda      	ldrb	r2, [r3, #31]
    8678:	2120      	movs	r1, #32
    867a:	5c5b      	ldrb	r3, [r3, r1]
    867c:	021b      	lsls	r3, r3, #8
    867e:	4313      	orrs	r3, r2
    8680:	b29b      	uxth	r3, r3
    8682:	2b48      	cmp	r3, #72	; 0x48
    8684:	d001      	beq.n	868a <atcacert_get_device_data+0x192>
			return ATCACERT_E_BAD_CERT; // Unexpected compressed certificate size
    8686:	230a      	movs	r3, #10
    8688:	e0fd      	b.n	8886 <atcacert_get_device_data+0x38e>
		atcacert_copy_device_loc_data(&cert_def->comp_cert_dev_loc, temp_buf, device_loc, device_data);
    868a:	68fb      	ldr	r3, [r7, #12]
    868c:	331a      	adds	r3, #26
    868e:	0018      	movs	r0, r3
    8690:	2398      	movs	r3, #152	; 0x98
    8692:	005b      	lsls	r3, r3, #1
    8694:	18fb      	adds	r3, r7, r3
    8696:	681b      	ldr	r3, [r3, #0]
    8698:	683a      	ldr	r2, [r7, #0]
    869a:	2118      	movs	r1, #24
    869c:	1879      	adds	r1, r7, r1
    869e:	4c7e      	ldr	r4, [pc, #504]	; (8898 <atcacert_get_device_data+0x3a0>)
    86a0:	47a0      	blx	r4
	}

	// Additional custom certificate elements
	if (cert_def->cert_elements_count > 0 && cert_def->cert_elements == NULL)
    86a2:	68fb      	ldr	r3, [r7, #12]
    86a4:	2245      	movs	r2, #69	; 0x45
    86a6:	5c9b      	ldrb	r3, [r3, r2]
    86a8:	2b00      	cmp	r3, #0
    86aa:	d011      	beq.n	86d0 <atcacert_get_device_data+0x1d8>
    86ac:	68fb      	ldr	r3, [r7, #12]
    86ae:	2241      	movs	r2, #65	; 0x41
    86b0:	5c9a      	ldrb	r2, [r3, r2]
    86b2:	2142      	movs	r1, #66	; 0x42
    86b4:	5c59      	ldrb	r1, [r3, r1]
    86b6:	0209      	lsls	r1, r1, #8
    86b8:	430a      	orrs	r2, r1
    86ba:	2143      	movs	r1, #67	; 0x43
    86bc:	5c59      	ldrb	r1, [r3, r1]
    86be:	0409      	lsls	r1, r1, #16
    86c0:	430a      	orrs	r2, r1
    86c2:	2144      	movs	r1, #68	; 0x44
    86c4:	5c5b      	ldrb	r3, [r3, r1]
    86c6:	061b      	lsls	r3, r3, #24
    86c8:	4313      	orrs	r3, r2
    86ca:	d101      	bne.n	86d0 <atcacert_get_device_data+0x1d8>
		return ATCACERT_E_BAD_CERT;
    86cc:	230a      	movs	r3, #10
    86ce:	e0da      	b.n	8886 <atcacert_get_device_data+0x38e>
	for (i = 0; i < cert_def->cert_elements_count; i++) {
    86d0:	2300      	movs	r3, #0
    86d2:	228e      	movs	r2, #142	; 0x8e
    86d4:	0052      	lsls	r2, r2, #1
    86d6:	18ba      	adds	r2, r7, r2
    86d8:	6013      	str	r3, [r2, #0]
    86da:	e0c8      	b.n	886e <atcacert_get_device_data+0x376>
		if (atcacert_is_device_loc_overlap(&cert_def->cert_elements[i].device_loc, device_loc)) {
    86dc:	68fb      	ldr	r3, [r7, #12]
    86de:	2241      	movs	r2, #65	; 0x41
    86e0:	5c9a      	ldrb	r2, [r3, r2]
    86e2:	2142      	movs	r1, #66	; 0x42
    86e4:	5c59      	ldrb	r1, [r3, r1]
    86e6:	0209      	lsls	r1, r1, #8
    86e8:	430a      	orrs	r2, r1
    86ea:	2143      	movs	r1, #67	; 0x43
    86ec:	5c59      	ldrb	r1, [r3, r1]
    86ee:	0409      	lsls	r1, r1, #16
    86f0:	430a      	orrs	r2, r1
    86f2:	2144      	movs	r1, #68	; 0x44
    86f4:	5c5b      	ldrb	r3, [r3, r1]
    86f6:	061b      	lsls	r3, r3, #24
    86f8:	4313      	orrs	r3, r2
    86fa:	0019      	movs	r1, r3
    86fc:	238e      	movs	r3, #142	; 0x8e
    86fe:	005b      	lsls	r3, r3, #1
    8700:	18fb      	adds	r3, r7, r3
    8702:	681a      	ldr	r2, [r3, #0]
    8704:	0013      	movs	r3, r2
    8706:	005b      	lsls	r3, r3, #1
    8708:	189b      	adds	r3, r3, r2
    870a:	00da      	lsls	r2, r3, #3
    870c:	189b      	adds	r3, r3, r2
    870e:	18cb      	adds	r3, r1, r3
    8710:	3310      	adds	r3, #16
    8712:	683a      	ldr	r2, [r7, #0]
    8714:	0011      	movs	r1, r2
    8716:	0018      	movs	r0, r3
    8718:	4b5d      	ldr	r3, [pc, #372]	; (8890 <atcacert_get_device_data+0x398>)
    871a:	4798      	blx	r3
    871c:	1e03      	subs	r3, r0, #0
    871e:	d100      	bne.n	8722 <atcacert_get_device_data+0x22a>
    8720:	e09c      	b.n	885c <atcacert_get_device_data+0x364>
			if (sizeof(temp_buf) < cert_def->cert_elements[i].device_loc.count)
    8722:	68fb      	ldr	r3, [r7, #12]
    8724:	2241      	movs	r2, #65	; 0x41
    8726:	5c9a      	ldrb	r2, [r3, r2]
    8728:	2142      	movs	r1, #66	; 0x42
    872a:	5c59      	ldrb	r1, [r3, r1]
    872c:	0209      	lsls	r1, r1, #8
    872e:	430a      	orrs	r2, r1
    8730:	2143      	movs	r1, #67	; 0x43
    8732:	5c59      	ldrb	r1, [r3, r1]
    8734:	0409      	lsls	r1, r1, #16
    8736:	430a      	orrs	r2, r1
    8738:	2144      	movs	r1, #68	; 0x44
    873a:	5c5b      	ldrb	r3, [r3, r1]
    873c:	061b      	lsls	r3, r3, #24
    873e:	4313      	orrs	r3, r2
    8740:	0019      	movs	r1, r3
    8742:	238e      	movs	r3, #142	; 0x8e
    8744:	005b      	lsls	r3, r3, #1
    8746:	18fb      	adds	r3, r7, r3
    8748:	681a      	ldr	r2, [r3, #0]
    874a:	0013      	movs	r3, r2
    874c:	005b      	lsls	r3, r3, #1
    874e:	189b      	adds	r3, r3, r2
    8750:	00da      	lsls	r2, r3, #3
    8752:	189b      	adds	r3, r3, r2
    8754:	18cb      	adds	r3, r1, r3
    8756:	7d5a      	ldrb	r2, [r3, #21]
    8758:	7d9b      	ldrb	r3, [r3, #22]
    875a:	021b      	lsls	r3, r3, #8
    875c:	4313      	orrs	r3, r2
    875e:	b29a      	uxth	r2, r3
    8760:	2380      	movs	r3, #128	; 0x80
    8762:	005b      	lsls	r3, r3, #1
    8764:	429a      	cmp	r2, r3
    8766:	d901      	bls.n	876c <atcacert_get_device_data+0x274>
				return ATCACERT_E_BUFFER_TOO_SMALL;
    8768:	2303      	movs	r3, #3
    876a:	e08c      	b.n	8886 <atcacert_get_device_data+0x38e>
			ret = atcacert_get_cert_element(
			    &cert_def->cert_elements[i].cert_loc,
    876c:	68fb      	ldr	r3, [r7, #12]
    876e:	2241      	movs	r2, #65	; 0x41
    8770:	5c9a      	ldrb	r2, [r3, r2]
    8772:	2142      	movs	r1, #66	; 0x42
    8774:	5c59      	ldrb	r1, [r3, r1]
    8776:	0209      	lsls	r1, r1, #8
    8778:	430a      	orrs	r2, r1
    877a:	2143      	movs	r1, #67	; 0x43
    877c:	5c59      	ldrb	r1, [r3, r1]
    877e:	0409      	lsls	r1, r1, #16
    8780:	430a      	orrs	r2, r1
    8782:	2144      	movs	r1, #68	; 0x44
    8784:	5c5b      	ldrb	r3, [r3, r1]
    8786:	061b      	lsls	r3, r3, #24
    8788:	4313      	orrs	r3, r2
    878a:	0019      	movs	r1, r3
    878c:	238e      	movs	r3, #142	; 0x8e
    878e:	005b      	lsls	r3, r3, #1
    8790:	18fb      	adds	r3, r7, r3
    8792:	681a      	ldr	r2, [r3, #0]
    8794:	0013      	movs	r3, r2
    8796:	005b      	lsls	r3, r3, #1
    8798:	189b      	adds	r3, r3, r2
    879a:	00da      	lsls	r2, r3, #3
    879c:	189b      	adds	r3, r3, r2
    879e:	18cb      	adds	r3, r1, r3
		return ATCACERT_E_BAD_CERT;
	for (i = 0; i < cert_def->cert_elements_count; i++) {
		if (atcacert_is_device_loc_overlap(&cert_def->cert_elements[i].device_loc, device_loc)) {
			if (sizeof(temp_buf) < cert_def->cert_elements[i].device_loc.count)
				return ATCACERT_E_BUFFER_TOO_SMALL;
			ret = atcacert_get_cert_element(
    87a0:	3317      	adds	r3, #23
    87a2:	0018      	movs	r0, r3
			    &cert_def->cert_elements[i].cert_loc,
			    cert,
			    cert_size,
			    temp_buf,
			    cert_def->cert_elements[i].device_loc.count);
    87a4:	68fb      	ldr	r3, [r7, #12]
    87a6:	2241      	movs	r2, #65	; 0x41
    87a8:	5c9a      	ldrb	r2, [r3, r2]
    87aa:	2142      	movs	r1, #66	; 0x42
    87ac:	5c59      	ldrb	r1, [r3, r1]
    87ae:	0209      	lsls	r1, r1, #8
    87b0:	430a      	orrs	r2, r1
    87b2:	2143      	movs	r1, #67	; 0x43
    87b4:	5c59      	ldrb	r1, [r3, r1]
    87b6:	0409      	lsls	r1, r1, #16
    87b8:	430a      	orrs	r2, r1
    87ba:	2144      	movs	r1, #68	; 0x44
    87bc:	5c5b      	ldrb	r3, [r3, r1]
    87be:	061b      	lsls	r3, r3, #24
    87c0:	4313      	orrs	r3, r2
    87c2:	0019      	movs	r1, r3
    87c4:	238e      	movs	r3, #142	; 0x8e
    87c6:	005b      	lsls	r3, r3, #1
    87c8:	18fb      	adds	r3, r7, r3
    87ca:	681a      	ldr	r2, [r3, #0]
    87cc:	0013      	movs	r3, r2
    87ce:	005b      	lsls	r3, r3, #1
    87d0:	189b      	adds	r3, r3, r2
    87d2:	00da      	lsls	r2, r3, #3
    87d4:	189b      	adds	r3, r3, r2
    87d6:	18cb      	adds	r3, r1, r3
    87d8:	7d5a      	ldrb	r2, [r3, #21]
    87da:	7d9b      	ldrb	r3, [r3, #22]
    87dc:	021b      	lsls	r3, r3, #8
    87de:	4313      	orrs	r3, r2
    87e0:	b29b      	uxth	r3, r3
		return ATCACERT_E_BAD_CERT;
	for (i = 0; i < cert_def->cert_elements_count; i++) {
		if (atcacert_is_device_loc_overlap(&cert_def->cert_elements[i].device_loc, device_loc)) {
			if (sizeof(temp_buf) < cert_def->cert_elements[i].device_loc.count)
				return ATCACERT_E_BUFFER_TOO_SMALL;
			ret = atcacert_get_cert_element(
    87e2:	001c      	movs	r4, r3
    87e4:	2318      	movs	r3, #24
    87e6:	18fb      	adds	r3, r7, r3
    87e8:	687a      	ldr	r2, [r7, #4]
    87ea:	68b9      	ldr	r1, [r7, #8]
    87ec:	9400      	str	r4, [sp, #0]
    87ee:	4c2e      	ldr	r4, [pc, #184]	; (88a8 <atcacert_get_device_data+0x3b0>)
    87f0:	47a0      	blx	r4
    87f2:	0003      	movs	r3, r0
    87f4:	228c      	movs	r2, #140	; 0x8c
    87f6:	0052      	lsls	r2, r2, #1
    87f8:	18ba      	adds	r2, r7, r2
    87fa:	6013      	str	r3, [r2, #0]
			    &cert_def->cert_elements[i].cert_loc,
			    cert,
			    cert_size,
			    temp_buf,
			    cert_def->cert_elements[i].device_loc.count);
			if (ret != ATCACERT_E_SUCCESS)
    87fc:	238c      	movs	r3, #140	; 0x8c
    87fe:	005b      	lsls	r3, r3, #1
    8800:	18fb      	adds	r3, r7, r3
    8802:	681b      	ldr	r3, [r3, #0]
    8804:	2b00      	cmp	r3, #0
    8806:	d004      	beq.n	8812 <atcacert_get_device_data+0x31a>
				return ret;
    8808:	238c      	movs	r3, #140	; 0x8c
    880a:	005b      	lsls	r3, r3, #1
    880c:	18fb      	adds	r3, r7, r3
    880e:	681b      	ldr	r3, [r3, #0]
    8810:	e039      	b.n	8886 <atcacert_get_device_data+0x38e>
			atcacert_copy_device_loc_data(&cert_def->cert_elements[i].device_loc, temp_buf, device_loc, device_data);
    8812:	68fb      	ldr	r3, [r7, #12]
    8814:	2241      	movs	r2, #65	; 0x41
    8816:	5c9a      	ldrb	r2, [r3, r2]
    8818:	2142      	movs	r1, #66	; 0x42
    881a:	5c59      	ldrb	r1, [r3, r1]
    881c:	0209      	lsls	r1, r1, #8
    881e:	430a      	orrs	r2, r1
    8820:	2143      	movs	r1, #67	; 0x43
    8822:	5c59      	ldrb	r1, [r3, r1]
    8824:	0409      	lsls	r1, r1, #16
    8826:	430a      	orrs	r2, r1
    8828:	2144      	movs	r1, #68	; 0x44
    882a:	5c5b      	ldrb	r3, [r3, r1]
    882c:	061b      	lsls	r3, r3, #24
    882e:	4313      	orrs	r3, r2
    8830:	0019      	movs	r1, r3
    8832:	238e      	movs	r3, #142	; 0x8e
    8834:	005b      	lsls	r3, r3, #1
    8836:	18fb      	adds	r3, r7, r3
    8838:	681a      	ldr	r2, [r3, #0]
    883a:	0013      	movs	r3, r2
    883c:	005b      	lsls	r3, r3, #1
    883e:	189b      	adds	r3, r3, r2
    8840:	00da      	lsls	r2, r3, #3
    8842:	189b      	adds	r3, r3, r2
    8844:	18cb      	adds	r3, r1, r3
    8846:	3310      	adds	r3, #16
    8848:	0018      	movs	r0, r3
    884a:	2398      	movs	r3, #152	; 0x98
    884c:	005b      	lsls	r3, r3, #1
    884e:	18fb      	adds	r3, r7, r3
    8850:	681b      	ldr	r3, [r3, #0]
    8852:	683a      	ldr	r2, [r7, #0]
    8854:	2118      	movs	r1, #24
    8856:	1879      	adds	r1, r7, r1
    8858:	4c0f      	ldr	r4, [pc, #60]	; (8898 <atcacert_get_device_data+0x3a0>)
    885a:	47a0      	blx	r4
	}

	// Additional custom certificate elements
	if (cert_def->cert_elements_count > 0 && cert_def->cert_elements == NULL)
		return ATCACERT_E_BAD_CERT;
	for (i = 0; i < cert_def->cert_elements_count; i++) {
    885c:	238e      	movs	r3, #142	; 0x8e
    885e:	005b      	lsls	r3, r3, #1
    8860:	18fb      	adds	r3, r7, r3
    8862:	681b      	ldr	r3, [r3, #0]
    8864:	3301      	adds	r3, #1
    8866:	228e      	movs	r2, #142	; 0x8e
    8868:	0052      	lsls	r2, r2, #1
    886a:	18ba      	adds	r2, r7, r2
    886c:	6013      	str	r3, [r2, #0]
    886e:	68fb      	ldr	r3, [r7, #12]
    8870:	2245      	movs	r2, #69	; 0x45
    8872:	5c9b      	ldrb	r3, [r3, r2]
    8874:	001a      	movs	r2, r3
    8876:	238e      	movs	r3, #142	; 0x8e
    8878:	005b      	lsls	r3, r3, #1
    887a:	18fb      	adds	r3, r7, r3
    887c:	681b      	ldr	r3, [r3, #0]
    887e:	429a      	cmp	r2, r3
    8880:	dd00      	ble.n	8884 <atcacert_get_device_data+0x38c>
    8882:	e72b      	b.n	86dc <atcacert_get_device_data+0x1e4>
				return ret;
			atcacert_copy_device_loc_data(&cert_def->cert_elements[i].device_loc, temp_buf, device_loc, device_data);
		}
	}

	return ATCACERT_E_SUCCESS;
    8884:	2300      	movs	r3, #0
}
    8886:	0018      	movs	r0, r3
    8888:	46bd      	mov	sp, r7
    888a:	b049      	add	sp, #292	; 0x124
    888c:	bd90      	pop	{r4, r7, pc}
    888e:	46c0      	nop			; (mov r8, r8)
    8890:	00008389 	.word	0x00008389
    8894:	000093e9 	.word	0x000093e9
    8898:	0000843d 	.word	0x0000843d
    889c:	0000894d 	.word	0x0000894d
    88a0:	00009a11 	.word	0x00009a11
    88a4:	00009689 	.word	0x00009689
    88a8:	0000991d 	.word	0x0000991d

000088ac <atcacert_set_subj_public_key>:

int atcacert_set_subj_public_key( const atcacert_def_t* cert_def,
                                  uint8_t*              cert,
                                  size_t cert_size,
                                  const uint8_t subj_public_key[64])
{
    88ac:	b590      	push	{r4, r7, lr}
    88ae:	b08d      	sub	sp, #52	; 0x34
    88b0:	af02      	add	r7, sp, #8
    88b2:	60f8      	str	r0, [r7, #12]
    88b4:	60b9      	str	r1, [r7, #8]
    88b6:	607a      	str	r2, [r7, #4]
    88b8:	603b      	str	r3, [r7, #0]
	int ret = 0;
    88ba:	2300      	movs	r3, #0
    88bc:	627b      	str	r3, [r7, #36]	; 0x24
	uint8_t key_id[20];

	if (cert_def == NULL || cert == NULL || subj_public_key == NULL)
    88be:	68fb      	ldr	r3, [r7, #12]
    88c0:	2b00      	cmp	r3, #0
    88c2:	d005      	beq.n	88d0 <atcacert_set_subj_public_key+0x24>
    88c4:	68bb      	ldr	r3, [r7, #8]
    88c6:	2b00      	cmp	r3, #0
    88c8:	d002      	beq.n	88d0 <atcacert_set_subj_public_key+0x24>
    88ca:	683b      	ldr	r3, [r7, #0]
    88cc:	2b00      	cmp	r3, #0
    88ce:	d101      	bne.n	88d4 <atcacert_set_subj_public_key+0x28>
		return ATCACERT_E_BAD_PARAMS;
    88d0:	2302      	movs	r3, #2
    88d2:	e033      	b.n	893c <atcacert_set_subj_public_key+0x90>

	ret = atcacert_set_cert_element(&cert_def->std_cert_elements[STDCERT_PUBLIC_KEY], cert, cert_size, subj_public_key, 64);
    88d4:	68fb      	ldr	r3, [r7, #12]
    88d6:	3321      	adds	r3, #33	; 0x21
    88d8:	0018      	movs	r0, r3
    88da:	683c      	ldr	r4, [r7, #0]
    88dc:	687a      	ldr	r2, [r7, #4]
    88de:	68b9      	ldr	r1, [r7, #8]
    88e0:	2340      	movs	r3, #64	; 0x40
    88e2:	9300      	str	r3, [sp, #0]
    88e4:	0023      	movs	r3, r4
    88e6:	4c17      	ldr	r4, [pc, #92]	; (8944 <atcacert_set_subj_public_key+0x98>)
    88e8:	47a0      	blx	r4
    88ea:	0003      	movs	r3, r0
    88ec:	627b      	str	r3, [r7, #36]	; 0x24
	if (ret != ATCACERT_E_SUCCESS)
    88ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    88f0:	2b00      	cmp	r3, #0
    88f2:	d001      	beq.n	88f8 <atcacert_set_subj_public_key+0x4c>
		return ret;
    88f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    88f6:	e021      	b.n	893c <atcacert_set_subj_public_key+0x90>

	ret = atcacert_get_key_id(subj_public_key, key_id);
    88f8:	2310      	movs	r3, #16
    88fa:	18fa      	adds	r2, r7, r3
    88fc:	683b      	ldr	r3, [r7, #0]
    88fe:	0011      	movs	r1, r2
    8900:	0018      	movs	r0, r3
    8902:	4b11      	ldr	r3, [pc, #68]	; (8948 <atcacert_set_subj_public_key+0x9c>)
    8904:	4798      	blx	r3
    8906:	0003      	movs	r3, r0
    8908:	627b      	str	r3, [r7, #36]	; 0x24
	if (ret != ATCACERT_E_SUCCESS)
    890a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    890c:	2b00      	cmp	r3, #0
    890e:	d001      	beq.n	8914 <atcacert_set_subj_public_key+0x68>
		return ret;
    8910:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8912:	e013      	b.n	893c <atcacert_set_subj_public_key+0x90>

	ret = atcacert_set_cert_element(&cert_def->std_cert_elements[STDCERT_SUBJ_KEY_ID], cert, cert_size, key_id, 20);
    8914:	68fb      	ldr	r3, [r7, #12]
    8916:	333d      	adds	r3, #61	; 0x3d
    8918:	0018      	movs	r0, r3
    891a:	2310      	movs	r3, #16
    891c:	18fc      	adds	r4, r7, r3
    891e:	687a      	ldr	r2, [r7, #4]
    8920:	68b9      	ldr	r1, [r7, #8]
    8922:	2314      	movs	r3, #20
    8924:	9300      	str	r3, [sp, #0]
    8926:	0023      	movs	r3, r4
    8928:	4c06      	ldr	r4, [pc, #24]	; (8944 <atcacert_set_subj_public_key+0x98>)
    892a:	47a0      	blx	r4
    892c:	0003      	movs	r3, r0
    892e:	627b      	str	r3, [r7, #36]	; 0x24
	if (ret != ATCACERT_E_SUCCESS)
    8930:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8932:	2b00      	cmp	r3, #0
    8934:	d001      	beq.n	893a <atcacert_set_subj_public_key+0x8e>
		return ret;
    8936:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8938:	e000      	b.n	893c <atcacert_set_subj_public_key+0x90>

	return ATCACERT_E_SUCCESS;
    893a:	2300      	movs	r3, #0
}
    893c:	0018      	movs	r0, r3
    893e:	46bd      	mov	sp, r7
    8940:	b00b      	add	sp, #44	; 0x2c
    8942:	bd90      	pop	{r4, r7, pc}
    8944:	00009879 	.word	0x00009879
    8948:	000099bd 	.word	0x000099bd

0000894c <atcacert_get_subj_public_key>:

int atcacert_get_subj_public_key( const atcacert_def_t* cert_def,
                                  const uint8_t*        cert,
                                  size_t cert_size,
                                  uint8_t subj_public_key[64])
{
    894c:	b590      	push	{r4, r7, lr}
    894e:	b087      	sub	sp, #28
    8950:	af02      	add	r7, sp, #8
    8952:	60f8      	str	r0, [r7, #12]
    8954:	60b9      	str	r1, [r7, #8]
    8956:	607a      	str	r2, [r7, #4]
    8958:	603b      	str	r3, [r7, #0]
	if (cert_def == NULL || cert == NULL || subj_public_key == NULL)
    895a:	68fb      	ldr	r3, [r7, #12]
    895c:	2b00      	cmp	r3, #0
    895e:	d005      	beq.n	896c <atcacert_get_subj_public_key+0x20>
    8960:	68bb      	ldr	r3, [r7, #8]
    8962:	2b00      	cmp	r3, #0
    8964:	d002      	beq.n	896c <atcacert_get_subj_public_key+0x20>
    8966:	683b      	ldr	r3, [r7, #0]
    8968:	2b00      	cmp	r3, #0
    896a:	d101      	bne.n	8970 <atcacert_get_subj_public_key+0x24>
		return ATCACERT_E_BAD_PARAMS;
    896c:	2302      	movs	r3, #2
    896e:	e00b      	b.n	8988 <atcacert_get_subj_public_key+0x3c>

	return atcacert_get_cert_element(&cert_def->std_cert_elements[STDCERT_PUBLIC_KEY], cert, cert_size, subj_public_key, 64);
    8970:	68fb      	ldr	r3, [r7, #12]
    8972:	3321      	adds	r3, #33	; 0x21
    8974:	0018      	movs	r0, r3
    8976:	683c      	ldr	r4, [r7, #0]
    8978:	687a      	ldr	r2, [r7, #4]
    897a:	68b9      	ldr	r1, [r7, #8]
    897c:	2340      	movs	r3, #64	; 0x40
    897e:	9300      	str	r3, [sp, #0]
    8980:	0023      	movs	r3, r4
    8982:	4c03      	ldr	r4, [pc, #12]	; (8990 <atcacert_get_subj_public_key+0x44>)
    8984:	47a0      	blx	r4
    8986:	0003      	movs	r3, r0
}
    8988:	0018      	movs	r0, r3
    898a:	46bd      	mov	sp, r7
    898c:	b005      	add	sp, #20
    898e:	bd90      	pop	{r4, r7, pc}
    8990:	0000991d 	.word	0x0000991d

00008994 <atcacert_set_signature>:
int atcacert_set_signature( const atcacert_def_t* cert_def,
                            uint8_t*              cert,
                            size_t*               cert_size,
                            size_t max_cert_size,
                            const uint8_t signature[64])
{
    8994:	b590      	push	{r4, r7, lr}
    8996:	b091      	sub	sp, #68	; 0x44
    8998:	af02      	add	r7, sp, #8
    899a:	60f8      	str	r0, [r7, #12]
    899c:	60b9      	str	r1, [r7, #8]
    899e:	607a      	str	r2, [r7, #4]
    89a0:	603b      	str	r3, [r7, #0]
	int ret = 0;
    89a2:	2300      	movs	r3, #0
    89a4:	637b      	str	r3, [r7, #52]	; 0x34
	size_t old_cert_der_length_size;
	size_t new_cert_der_length_size;
	size_t new_cert_length;
	uint8_t new_cert_der_length[5];

	if (cert_def == NULL || cert == NULL || cert_size == NULL || signature == NULL)
    89a6:	68fb      	ldr	r3, [r7, #12]
    89a8:	2b00      	cmp	r3, #0
    89aa:	d008      	beq.n	89be <atcacert_set_signature+0x2a>
    89ac:	68bb      	ldr	r3, [r7, #8]
    89ae:	2b00      	cmp	r3, #0
    89b0:	d005      	beq.n	89be <atcacert_set_signature+0x2a>
    89b2:	687b      	ldr	r3, [r7, #4]
    89b4:	2b00      	cmp	r3, #0
    89b6:	d002      	beq.n	89be <atcacert_set_signature+0x2a>
    89b8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    89ba:	2b00      	cmp	r3, #0
    89bc:	d101      	bne.n	89c2 <atcacert_set_signature+0x2e>
		return ATCACERT_E_BAD_PARAMS;
    89be:	2302      	movs	r3, #2
    89c0:	e099      	b.n	8af6 <atcacert_set_signature+0x162>

	sig_offset = cert_def->std_cert_elements[STDCERT_SIGNATURE].offset;
    89c2:	2332      	movs	r3, #50	; 0x32
    89c4:	18fa      	adds	r2, r7, r3
    89c6:	68fb      	ldr	r3, [r7, #12]
    89c8:	2125      	movs	r1, #37	; 0x25
    89ca:	5c59      	ldrb	r1, [r3, r1]
    89cc:	2026      	movs	r0, #38	; 0x26
    89ce:	5c1b      	ldrb	r3, [r3, r0]
    89d0:	021b      	lsls	r3, r3, #8
    89d2:	430b      	orrs	r3, r1
    89d4:	8013      	strh	r3, [r2, #0]

	// Non X.509 signatures are treated like normal certificate elements
	if (cert_def->type != CERTTYPE_X509)
    89d6:	68fb      	ldr	r3, [r7, #12]
    89d8:	781b      	ldrb	r3, [r3, #0]
    89da:	2b00      	cmp	r3, #0
    89dc:	d00d      	beq.n	89fa <atcacert_set_signature+0x66>
		return atcacert_set_cert_element(&cert_def->std_cert_elements[STDCERT_SIGNATURE], cert, *cert_size, signature, 64);
    89de:	68fb      	ldr	r3, [r7, #12]
    89e0:	3325      	adds	r3, #37	; 0x25
    89e2:	0018      	movs	r0, r3
    89e4:	687b      	ldr	r3, [r7, #4]
    89e6:	681a      	ldr	r2, [r3, #0]
    89e8:	6cbc      	ldr	r4, [r7, #72]	; 0x48
    89ea:	68b9      	ldr	r1, [r7, #8]
    89ec:	2340      	movs	r3, #64	; 0x40
    89ee:	9300      	str	r3, [sp, #0]
    89f0:	0023      	movs	r3, r4
    89f2:	4c43      	ldr	r4, [pc, #268]	; (8b00 <atcacert_set_signature+0x16c>)
    89f4:	47a0      	blx	r4
    89f6:	0003      	movs	r3, r0
    89f8:	e07d      	b.n	8af6 <atcacert_set_signature+0x162>

	if (sig_offset >= *cert_size)
    89fa:	2332      	movs	r3, #50	; 0x32
    89fc:	18fb      	adds	r3, r7, r3
    89fe:	881a      	ldrh	r2, [r3, #0]
    8a00:	687b      	ldr	r3, [r7, #4]
    8a02:	681b      	ldr	r3, [r3, #0]
    8a04:	429a      	cmp	r2, r3
    8a06:	d301      	bcc.n	8a0c <atcacert_set_signature+0x78>
		return ATCACERT_E_ELEM_OUT_OF_BOUNDS; // Signature element is shown as past the end of the certificate
    8a08:	2309      	movs	r3, #9
    8a0a:	e074      	b.n	8af6 <atcacert_set_signature+0x162>

	// Current size of the signature is from its offset to the end of the cert
	cur_der_sig_size = *cert_size - sig_offset;
    8a0c:	687b      	ldr	r3, [r7, #4]
    8a0e:	681a      	ldr	r2, [r3, #0]
    8a10:	2332      	movs	r3, #50	; 0x32
    8a12:	18fb      	adds	r3, r7, r3
    8a14:	881b      	ldrh	r3, [r3, #0]
    8a16:	1ad3      	subs	r3, r2, r3
    8a18:	62fb      	str	r3, [r7, #44]	; 0x2c

	// Find the size of buffer available for the new DER signature
	new_der_sig_size = max_cert_size - sig_offset;
    8a1a:	2332      	movs	r3, #50	; 0x32
    8a1c:	18fb      	adds	r3, r7, r3
    8a1e:	881b      	ldrh	r3, [r3, #0]
    8a20:	683a      	ldr	r2, [r7, #0]
    8a22:	1ad3      	subs	r3, r2, r3
    8a24:	627b      	str	r3, [r7, #36]	; 0x24

	// Set the new signature
	ret = atcacert_der_enc_ecdsa_sig_value(signature, &cert[sig_offset], &new_der_sig_size);
    8a26:	2332      	movs	r3, #50	; 0x32
    8a28:	18fb      	adds	r3, r7, r3
    8a2a:	881b      	ldrh	r3, [r3, #0]
    8a2c:	68ba      	ldr	r2, [r7, #8]
    8a2e:	18d1      	adds	r1, r2, r3
    8a30:	2324      	movs	r3, #36	; 0x24
    8a32:	18fa      	adds	r2, r7, r3
    8a34:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    8a36:	0018      	movs	r0, r3
    8a38:	4b32      	ldr	r3, [pc, #200]	; (8b04 <atcacert_set_signature+0x170>)
    8a3a:	4798      	blx	r3
    8a3c:	0003      	movs	r3, r0
    8a3e:	637b      	str	r3, [r7, #52]	; 0x34
	if (ret != ATCACERT_E_SUCCESS) {
    8a40:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8a42:	2b00      	cmp	r3, #0
    8a44:	d00d      	beq.n	8a62 <atcacert_set_signature+0xce>
		if (ret == ATCACERT_E_BUFFER_TOO_SMALL)
    8a46:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8a48:	2b03      	cmp	r3, #3
    8a4a:	d108      	bne.n	8a5e <atcacert_set_signature+0xca>
			*cert_size += (int)new_der_sig_size - (int)cur_der_sig_size; // Report the size needed
    8a4c:	687b      	ldr	r3, [r7, #4]
    8a4e:	681b      	ldr	r3, [r3, #0]
    8a50:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    8a52:	0011      	movs	r1, r2
    8a54:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    8a56:	1a8a      	subs	r2, r1, r2
    8a58:	189a      	adds	r2, r3, r2
    8a5a:	687b      	ldr	r3, [r7, #4]
    8a5c:	601a      	str	r2, [r3, #0]
		return ret;
    8a5e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8a60:	e049      	b.n	8af6 <atcacert_set_signature+0x162>
	}

	*cert_size += (int)new_der_sig_size - (int)cur_der_sig_size;
    8a62:	687b      	ldr	r3, [r7, #4]
    8a64:	681b      	ldr	r3, [r3, #0]
    8a66:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    8a68:	0011      	movs	r1, r2
    8a6a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    8a6c:	1a8a      	subs	r2, r1, r2
    8a6e:	189a      	adds	r2, r3, r2
    8a70:	687b      	ldr	r3, [r7, #4]
    8a72:	601a      	str	r2, [r3, #0]

	old_cert_der_length_size = *cert_size - 1;
    8a74:	687b      	ldr	r3, [r7, #4]
    8a76:	681b      	ldr	r3, [r3, #0]
    8a78:	3b01      	subs	r3, #1
    8a7a:	623b      	str	r3, [r7, #32]
	ret = atcacert_der_dec_length(&cert[1], &old_cert_der_length_size, NULL);
    8a7c:	68bb      	ldr	r3, [r7, #8]
    8a7e:	3301      	adds	r3, #1
    8a80:	2220      	movs	r2, #32
    8a82:	18b9      	adds	r1, r7, r2
    8a84:	2200      	movs	r2, #0
    8a86:	0018      	movs	r0, r3
    8a88:	4b1f      	ldr	r3, [pc, #124]	; (8b08 <atcacert_set_signature+0x174>)
    8a8a:	4798      	blx	r3
    8a8c:	0003      	movs	r3, r0
    8a8e:	637b      	str	r3, [r7, #52]	; 0x34
	if (ret != ATCACERT_E_SUCCESS)
    8a90:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8a92:	2b00      	cmp	r3, #0
    8a94:	d001      	beq.n	8a9a <atcacert_set_signature+0x106>
		return ret;
    8a96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8a98:	e02d      	b.n	8af6 <atcacert_set_signature+0x162>

	if ((1 + old_cert_der_length_size) > *cert_size)
    8a9a:	6a3b      	ldr	r3, [r7, #32]
    8a9c:	1c5a      	adds	r2, r3, #1
    8a9e:	687b      	ldr	r3, [r7, #4]
    8aa0:	681b      	ldr	r3, [r3, #0]
    8aa2:	429a      	cmp	r2, r3
    8aa4:	d901      	bls.n	8aaa <atcacert_set_signature+0x116>
		return ATCACERT_E_BAD_CERT;
    8aa6:	230a      	movs	r3, #10
    8aa8:	e025      	b.n	8af6 <atcacert_set_signature+0x162>
	new_cert_length = *cert_size - (1 + old_cert_der_length_size);
    8aaa:	687b      	ldr	r3, [r7, #4]
    8aac:	681a      	ldr	r2, [r3, #0]
    8aae:	6a3b      	ldr	r3, [r7, #32]
    8ab0:	1ad3      	subs	r3, r2, r3
    8ab2:	3b01      	subs	r3, #1
    8ab4:	62bb      	str	r3, [r7, #40]	; 0x28

	new_cert_der_length_size = sizeof(new_cert_der_length);
    8ab6:	2305      	movs	r3, #5
    8ab8:	61fb      	str	r3, [r7, #28]
	ret = atcacert_der_enc_length(new_cert_length, new_cert_der_length, &new_cert_der_length_size);
    8aba:	231c      	movs	r3, #28
    8abc:	18fa      	adds	r2, r7, r3
    8abe:	2314      	movs	r3, #20
    8ac0:	18f9      	adds	r1, r7, r3
    8ac2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8ac4:	0018      	movs	r0, r3
    8ac6:	4b11      	ldr	r3, [pc, #68]	; (8b0c <atcacert_set_signature+0x178>)
    8ac8:	4798      	blx	r3
    8aca:	0003      	movs	r3, r0
    8acc:	637b      	str	r3, [r7, #52]	; 0x34
	if (ret != ATCACERT_E_SUCCESS)
    8ace:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8ad0:	2b00      	cmp	r3, #0
    8ad2:	d001      	beq.n	8ad8 <atcacert_set_signature+0x144>
		return ret;
    8ad4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8ad6:	e00e      	b.n	8af6 <atcacert_set_signature+0x162>

	if (old_cert_der_length_size != new_cert_der_length_size)
    8ad8:	6a3a      	ldr	r2, [r7, #32]
    8ada:	69fb      	ldr	r3, [r7, #28]
    8adc:	429a      	cmp	r2, r3
    8ade:	d001      	beq.n	8ae4 <atcacert_set_signature+0x150>
		return ATCACERT_E_BAD_CERT;
    8ae0:	230a      	movs	r3, #10
    8ae2:	e008      	b.n	8af6 <atcacert_set_signature+0x162>

	memcpy(&cert[1], new_cert_der_length, new_cert_der_length_size);
    8ae4:	68bb      	ldr	r3, [r7, #8]
    8ae6:	3301      	adds	r3, #1
    8ae8:	69fa      	ldr	r2, [r7, #28]
    8aea:	2114      	movs	r1, #20
    8aec:	1879      	adds	r1, r7, r1
    8aee:	0018      	movs	r0, r3
    8af0:	4b07      	ldr	r3, [pc, #28]	; (8b10 <atcacert_set_signature+0x17c>)
    8af2:	4798      	blx	r3

	return ATCACERT_E_SUCCESS;
    8af4:	2300      	movs	r3, #0
}
    8af6:	0018      	movs	r0, r3
    8af8:	46bd      	mov	sp, r7
    8afa:	b00f      	add	sp, #60	; 0x3c
    8afc:	bd90      	pop	{r4, r7, pc}
    8afe:	46c0      	nop			; (mov r8, r8)
    8b00:	00009879 	.word	0x00009879
    8b04:	00009e71 	.word	0x00009e71
    8b08:	00009b59 	.word	0x00009b59
    8b0c:	00009a9d 	.word	0x00009a9d
    8b10:	000127e7 	.word	0x000127e7

00008b14 <atcacert_get_signature>:

int atcacert_get_signature( const atcacert_def_t* cert_def,
                            const uint8_t*        cert,
                            size_t cert_size,
                            uint8_t signature[64])
{
    8b14:	b590      	push	{r4, r7, lr}
    8b16:	b089      	sub	sp, #36	; 0x24
    8b18:	af02      	add	r7, sp, #8
    8b1a:	60f8      	str	r0, [r7, #12]
    8b1c:	60b9      	str	r1, [r7, #8]
    8b1e:	607a      	str	r2, [r7, #4]
    8b20:	603b      	str	r3, [r7, #0]
	uint16_t sig_offset;
	size_t der_sig_size = 0;
    8b22:	2300      	movs	r3, #0
    8b24:	613b      	str	r3, [r7, #16]

	if (cert_def == NULL || cert == NULL || signature == NULL)
    8b26:	68fb      	ldr	r3, [r7, #12]
    8b28:	2b00      	cmp	r3, #0
    8b2a:	d005      	beq.n	8b38 <atcacert_get_signature+0x24>
    8b2c:	68bb      	ldr	r3, [r7, #8]
    8b2e:	2b00      	cmp	r3, #0
    8b30:	d002      	beq.n	8b38 <atcacert_get_signature+0x24>
    8b32:	683b      	ldr	r3, [r7, #0]
    8b34:	2b00      	cmp	r3, #0
    8b36:	d101      	bne.n	8b3c <atcacert_get_signature+0x28>
		return ATCACERT_E_BAD_PARAMS;
    8b38:	2302      	movs	r3, #2
    8b3a:	e034      	b.n	8ba6 <atcacert_get_signature+0x92>

	sig_offset = cert_def->std_cert_elements[STDCERT_SIGNATURE].offset;
    8b3c:	2316      	movs	r3, #22
    8b3e:	18fa      	adds	r2, r7, r3
    8b40:	68fb      	ldr	r3, [r7, #12]
    8b42:	2125      	movs	r1, #37	; 0x25
    8b44:	5c59      	ldrb	r1, [r3, r1]
    8b46:	2026      	movs	r0, #38	; 0x26
    8b48:	5c1b      	ldrb	r3, [r3, r0]
    8b4a:	021b      	lsls	r3, r3, #8
    8b4c:	430b      	orrs	r3, r1
    8b4e:	8013      	strh	r3, [r2, #0]

	// Non X.509 signatures are treated like normal certificate elements
	if (cert_def->type != CERTTYPE_X509)
    8b50:	68fb      	ldr	r3, [r7, #12]
    8b52:	781b      	ldrb	r3, [r3, #0]
    8b54:	2b00      	cmp	r3, #0
    8b56:	d00c      	beq.n	8b72 <atcacert_get_signature+0x5e>
		return atcacert_get_cert_element(&cert_def->std_cert_elements[STDCERT_SIGNATURE], cert, cert_size, signature, 64);
    8b58:	68fb      	ldr	r3, [r7, #12]
    8b5a:	3325      	adds	r3, #37	; 0x25
    8b5c:	0018      	movs	r0, r3
    8b5e:	683c      	ldr	r4, [r7, #0]
    8b60:	687a      	ldr	r2, [r7, #4]
    8b62:	68b9      	ldr	r1, [r7, #8]
    8b64:	2340      	movs	r3, #64	; 0x40
    8b66:	9300      	str	r3, [sp, #0]
    8b68:	0023      	movs	r3, r4
    8b6a:	4c11      	ldr	r4, [pc, #68]	; (8bb0 <atcacert_get_signature+0x9c>)
    8b6c:	47a0      	blx	r4
    8b6e:	0003      	movs	r3, r0
    8b70:	e019      	b.n	8ba6 <atcacert_get_signature+0x92>

	if (sig_offset >= cert_size)
    8b72:	2316      	movs	r3, #22
    8b74:	18fb      	adds	r3, r7, r3
    8b76:	881a      	ldrh	r2, [r3, #0]
    8b78:	687b      	ldr	r3, [r7, #4]
    8b7a:	429a      	cmp	r2, r3
    8b7c:	d301      	bcc.n	8b82 <atcacert_get_signature+0x6e>
		return ATCACERT_E_ELEM_OUT_OF_BOUNDS; // Signature element is shown as past the end of the certificate
    8b7e:	2309      	movs	r3, #9
    8b80:	e011      	b.n	8ba6 <atcacert_get_signature+0x92>

	der_sig_size = cert_size - sig_offset;
    8b82:	2316      	movs	r3, #22
    8b84:	18fb      	adds	r3, r7, r3
    8b86:	881b      	ldrh	r3, [r3, #0]
    8b88:	687a      	ldr	r2, [r7, #4]
    8b8a:	1ad3      	subs	r3, r2, r3
    8b8c:	613b      	str	r3, [r7, #16]
	return atcacert_der_dec_ecdsa_sig_value(&cert[sig_offset], &der_sig_size, signature);
    8b8e:	2316      	movs	r3, #22
    8b90:	18fb      	adds	r3, r7, r3
    8b92:	881b      	ldrh	r3, [r3, #0]
    8b94:	68ba      	ldr	r2, [r7, #8]
    8b96:	18d3      	adds	r3, r2, r3
    8b98:	683a      	ldr	r2, [r7, #0]
    8b9a:	2110      	movs	r1, #16
    8b9c:	1879      	adds	r1, r7, r1
    8b9e:	0018      	movs	r0, r3
    8ba0:	4b04      	ldr	r3, [pc, #16]	; (8bb4 <atcacert_get_signature+0xa0>)
    8ba2:	4798      	blx	r3
    8ba4:	0003      	movs	r3, r0
}
    8ba6:	0018      	movs	r0, r3
    8ba8:	46bd      	mov	sp, r7
    8baa:	b007      	add	sp, #28
    8bac:	bd90      	pop	{r4, r7, pc}
    8bae:	46c0      	nop			; (mov r8, r8)
    8bb0:	0000991d 	.word	0x0000991d
    8bb4:	00009fa5 	.word	0x00009fa5

00008bb8 <atcacert_set_issue_date>:

int atcacert_set_issue_date( const atcacert_def_t*     cert_def,
                             uint8_t*                  cert,
                             size_t cert_size,
                             const atcacert_tm_utc_t*  timestamp)
{
    8bb8:	b590      	push	{r4, r7, lr}
    8bba:	b08f      	sub	sp, #60	; 0x3c
    8bbc:	af02      	add	r7, sp, #8
    8bbe:	60f8      	str	r0, [r7, #12]
    8bc0:	60b9      	str	r1, [r7, #8]
    8bc2:	607a      	str	r2, [r7, #4]
    8bc4:	603b      	str	r3, [r7, #0]
	int ret = 0;
    8bc6:	2300      	movs	r3, #0
    8bc8:	62fb      	str	r3, [r7, #44]	; 0x2c
	uint8_t formatted_date[DATEFMT_MAX_SIZE];
	size_t formatted_date_size = sizeof(formatted_date);
    8bca:	2314      	movs	r3, #20
    8bcc:	617b      	str	r3, [r7, #20]

	if (cert_def == NULL || cert == NULL || timestamp == NULL)
    8bce:	68fb      	ldr	r3, [r7, #12]
    8bd0:	2b00      	cmp	r3, #0
    8bd2:	d005      	beq.n	8be0 <atcacert_set_issue_date+0x28>
    8bd4:	68bb      	ldr	r3, [r7, #8]
    8bd6:	2b00      	cmp	r3, #0
    8bd8:	d002      	beq.n	8be0 <atcacert_set_issue_date+0x28>
    8bda:	683b      	ldr	r3, [r7, #0]
    8bdc:	2b00      	cmp	r3, #0
    8bde:	d101      	bne.n	8be4 <atcacert_set_issue_date+0x2c>
		return ATCACERT_E_BAD_PARAMS;
    8be0:	2302      	movs	r3, #2
    8be2:	e02f      	b.n	8c44 <atcacert_set_issue_date+0x8c>

	if (cert_def->std_cert_elements[STDCERT_ISSUE_DATE].count == 0)
    8be4:	68fb      	ldr	r3, [r7, #12]
    8be6:	222b      	movs	r2, #43	; 0x2b
    8be8:	5c9a      	ldrb	r2, [r3, r2]
    8bea:	212c      	movs	r1, #44	; 0x2c
    8bec:	5c5b      	ldrb	r3, [r3, r1]
    8bee:	021b      	lsls	r3, r3, #8
    8bf0:	4313      	orrs	r3, r2
    8bf2:	b29b      	uxth	r3, r3
    8bf4:	2b00      	cmp	r3, #0
    8bf6:	d101      	bne.n	8bfc <atcacert_set_issue_date+0x44>
		return ATCACERT_E_SUCCESS; // No issue date to be set
    8bf8:	2300      	movs	r3, #0
    8bfa:	e023      	b.n	8c44 <atcacert_set_issue_date+0x8c>

	ret = atcacert_date_enc(cert_def->issue_date_format, timestamp, formatted_date, &formatted_date_size);
    8bfc:	68fb      	ldr	r3, [r7, #12]
    8bfe:	7b18      	ldrb	r0, [r3, #12]
    8c00:	2314      	movs	r3, #20
    8c02:	18fb      	adds	r3, r7, r3
    8c04:	2218      	movs	r2, #24
    8c06:	18ba      	adds	r2, r7, r2
    8c08:	6839      	ldr	r1, [r7, #0]
    8c0a:	4c10      	ldr	r4, [pc, #64]	; (8c4c <atcacert_set_issue_date+0x94>)
    8c0c:	47a0      	blx	r4
    8c0e:	0003      	movs	r3, r0
    8c10:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (ret != ATCACERT_E_SUCCESS)
    8c12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8c14:	2b00      	cmp	r3, #0
    8c16:	d001      	beq.n	8c1c <atcacert_set_issue_date+0x64>
		return ret;
    8c18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8c1a:	e013      	b.n	8c44 <atcacert_set_issue_date+0x8c>

	ret = atcacert_set_cert_element(&cert_def->std_cert_elements[STDCERT_ISSUE_DATE], cert, cert_size, formatted_date, formatted_date_size);
    8c1c:	68fb      	ldr	r3, [r7, #12]
    8c1e:	3329      	adds	r3, #41	; 0x29
    8c20:	0018      	movs	r0, r3
    8c22:	697b      	ldr	r3, [r7, #20]
    8c24:	2218      	movs	r2, #24
    8c26:	18bc      	adds	r4, r7, r2
    8c28:	687a      	ldr	r2, [r7, #4]
    8c2a:	68b9      	ldr	r1, [r7, #8]
    8c2c:	9300      	str	r3, [sp, #0]
    8c2e:	0023      	movs	r3, r4
    8c30:	4c07      	ldr	r4, [pc, #28]	; (8c50 <atcacert_set_issue_date+0x98>)
    8c32:	47a0      	blx	r4
    8c34:	0003      	movs	r3, r0
    8c36:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (ret != ATCACERT_E_SUCCESS)
    8c38:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8c3a:	2b00      	cmp	r3, #0
    8c3c:	d001      	beq.n	8c42 <atcacert_set_issue_date+0x8a>
		return ret;
    8c3e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8c40:	e000      	b.n	8c44 <atcacert_set_issue_date+0x8c>

	return ATCACERT_E_SUCCESS;
    8c42:	2300      	movs	r3, #0
}
    8c44:	0018      	movs	r0, r3
    8c46:	46bd      	mov	sp, r7
    8c48:	b00d      	add	sp, #52	; 0x34
    8c4a:	bd90      	pop	{r4, r7, pc}
    8c4c:	00005df1 	.word	0x00005df1
    8c50:	00009879 	.word	0x00009879

00008c54 <atcacert_get_issue_date>:

int atcacert_get_issue_date( const atcacert_def_t*  cert_def,
                             const uint8_t*         cert,
                             size_t cert_size,
                             atcacert_tm_utc_t*     timestamp)
{
    8c54:	b590      	push	{r4, r7, lr}
    8c56:	b08f      	sub	sp, #60	; 0x3c
    8c58:	af02      	add	r7, sp, #8
    8c5a:	60f8      	str	r0, [r7, #12]
    8c5c:	60b9      	str	r1, [r7, #8]
    8c5e:	607a      	str	r2, [r7, #4]
    8c60:	603b      	str	r3, [r7, #0]
	int ret = 0;
    8c62:	2300      	movs	r3, #0
    8c64:	62fb      	str	r3, [r7, #44]	; 0x2c
	uint8_t formatted_date[DATEFMT_MAX_SIZE];
	size_t formatted_date_size = sizeof(formatted_date);
    8c66:	2314      	movs	r3, #20
    8c68:	62bb      	str	r3, [r7, #40]	; 0x28

	if (cert_def == NULL || cert == NULL || timestamp == NULL)
    8c6a:	68fb      	ldr	r3, [r7, #12]
    8c6c:	2b00      	cmp	r3, #0
    8c6e:	d005      	beq.n	8c7c <atcacert_get_issue_date+0x28>
    8c70:	68bb      	ldr	r3, [r7, #8]
    8c72:	2b00      	cmp	r3, #0
    8c74:	d002      	beq.n	8c7c <atcacert_get_issue_date+0x28>
    8c76:	683b      	ldr	r3, [r7, #0]
    8c78:	2b00      	cmp	r3, #0
    8c7a:	d101      	bne.n	8c80 <atcacert_get_issue_date+0x2c>
		return ATCACERT_E_BAD_PARAMS;
    8c7c:	2302      	movs	r3, #2
    8c7e:	e034      	b.n	8cea <atcacert_get_issue_date+0x96>

	if (cert_def->issue_date_format > sizeof(ATCACERT_DATE_FORMAT_SIZES) / sizeof(ATCACERT_DATE_FORMAT_SIZES[0]))
    8c80:	68fb      	ldr	r3, [r7, #12]
    8c82:	7b1b      	ldrb	r3, [r3, #12]
    8c84:	2b05      	cmp	r3, #5
    8c86:	d901      	bls.n	8c8c <atcacert_get_issue_date+0x38>
		return ATCACERT_E_ERROR; // Format is out of range
    8c88:	2301      	movs	r3, #1
    8c8a:	e02e      	b.n	8cea <atcacert_get_issue_date+0x96>

	formatted_date_size = ATCACERT_DATE_FORMAT_SIZES[cert_def->issue_date_format];
    8c8c:	68fb      	ldr	r3, [r7, #12]
    8c8e:	7b1b      	ldrb	r3, [r3, #12]
    8c90:	001a      	movs	r2, r3
    8c92:	4b18      	ldr	r3, [pc, #96]	; (8cf4 <atcacert_get_issue_date+0xa0>)
    8c94:	0092      	lsls	r2, r2, #2
    8c96:	58d3      	ldr	r3, [r2, r3]
    8c98:	62bb      	str	r3, [r7, #40]	; 0x28
	if (formatted_date_size > sizeof(formatted_date))
    8c9a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8c9c:	2b14      	cmp	r3, #20
    8c9e:	d901      	bls.n	8ca4 <atcacert_get_issue_date+0x50>
		return ATCACERT_E_ERROR; // DATEFMT_MAX_SIZE is wrong
    8ca0:	2301      	movs	r3, #1
    8ca2:	e022      	b.n	8cea <atcacert_get_issue_date+0x96>

	ret = atcacert_get_cert_element(&cert_def->std_cert_elements[STDCERT_ISSUE_DATE], cert, cert_size, formatted_date, formatted_date_size);
    8ca4:	68fb      	ldr	r3, [r7, #12]
    8ca6:	3329      	adds	r3, #41	; 0x29
    8ca8:	0018      	movs	r0, r3
    8caa:	2314      	movs	r3, #20
    8cac:	18fc      	adds	r4, r7, r3
    8cae:	687a      	ldr	r2, [r7, #4]
    8cb0:	68b9      	ldr	r1, [r7, #8]
    8cb2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8cb4:	9300      	str	r3, [sp, #0]
    8cb6:	0023      	movs	r3, r4
    8cb8:	4c0f      	ldr	r4, [pc, #60]	; (8cf8 <atcacert_get_issue_date+0xa4>)
    8cba:	47a0      	blx	r4
    8cbc:	0003      	movs	r3, r0
    8cbe:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (ret != ATCACERT_E_SUCCESS)
    8cc0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8cc2:	2b00      	cmp	r3, #0
    8cc4:	d001      	beq.n	8cca <atcacert_get_issue_date+0x76>
		return ret;
    8cc6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8cc8:	e00f      	b.n	8cea <atcacert_get_issue_date+0x96>

	ret = atcacert_date_dec(cert_def->issue_date_format, formatted_date, formatted_date_size, timestamp);
    8cca:	68fb      	ldr	r3, [r7, #12]
    8ccc:	7b18      	ldrb	r0, [r3, #12]
    8cce:	683b      	ldr	r3, [r7, #0]
    8cd0:	6aba      	ldr	r2, [r7, #40]	; 0x28
    8cd2:	2114      	movs	r1, #20
    8cd4:	1879      	adds	r1, r7, r1
    8cd6:	4c09      	ldr	r4, [pc, #36]	; (8cfc <atcacert_get_issue_date+0xa8>)
    8cd8:	47a0      	blx	r4
    8cda:	0003      	movs	r3, r0
    8cdc:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (ret != ATCACERT_E_SUCCESS)
    8cde:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8ce0:	2b00      	cmp	r3, #0
    8ce2:	d001      	beq.n	8ce8 <atcacert_get_issue_date+0x94>
		return ret;
    8ce4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8ce6:	e000      	b.n	8cea <atcacert_get_issue_date+0x96>

	return ATCACERT_E_SUCCESS;
    8ce8:	2300      	movs	r3, #0
}
    8cea:	0018      	movs	r0, r3
    8cec:	46bd      	mov	sp, r7
    8cee:	b00d      	add	sp, #52	; 0x34
    8cf0:	bd90      	pop	{r4, r7, pc}
    8cf2:	46c0      	nop			; (mov r8, r8)
    8cf4:	00015278 	.word	0x00015278
    8cf8:	0000991d 	.word	0x0000991d
    8cfc:	00005ef1 	.word	0x00005ef1

00008d00 <atcacert_set_expire_date>:

int atcacert_set_expire_date( const atcacert_def_t*     cert_def,
                              uint8_t*                  cert,
                              size_t cert_size,
                              const atcacert_tm_utc_t*  timestamp)
{
    8d00:	b590      	push	{r4, r7, lr}
    8d02:	b08f      	sub	sp, #60	; 0x3c
    8d04:	af02      	add	r7, sp, #8
    8d06:	60f8      	str	r0, [r7, #12]
    8d08:	60b9      	str	r1, [r7, #8]
    8d0a:	607a      	str	r2, [r7, #4]
    8d0c:	603b      	str	r3, [r7, #0]
	int ret = 0;
    8d0e:	2300      	movs	r3, #0
    8d10:	62fb      	str	r3, [r7, #44]	; 0x2c
	uint8_t formatted_date[DATEFMT_MAX_SIZE];
	size_t formatted_date_size = sizeof(formatted_date);
    8d12:	2314      	movs	r3, #20
    8d14:	617b      	str	r3, [r7, #20]

	if (cert_def == NULL || cert == NULL || timestamp == NULL)
    8d16:	68fb      	ldr	r3, [r7, #12]
    8d18:	2b00      	cmp	r3, #0
    8d1a:	d005      	beq.n	8d28 <atcacert_set_expire_date+0x28>
    8d1c:	68bb      	ldr	r3, [r7, #8]
    8d1e:	2b00      	cmp	r3, #0
    8d20:	d002      	beq.n	8d28 <atcacert_set_expire_date+0x28>
    8d22:	683b      	ldr	r3, [r7, #0]
    8d24:	2b00      	cmp	r3, #0
    8d26:	d101      	bne.n	8d2c <atcacert_set_expire_date+0x2c>
		return ATCACERT_E_BAD_PARAMS;
    8d28:	2302      	movs	r3, #2
    8d2a:	e02f      	b.n	8d8c <atcacert_set_expire_date+0x8c>

	if (cert_def->std_cert_elements[STDCERT_EXPIRE_DATE].count == 0)
    8d2c:	68fb      	ldr	r3, [r7, #12]
    8d2e:	222f      	movs	r2, #47	; 0x2f
    8d30:	5c9a      	ldrb	r2, [r3, r2]
    8d32:	2130      	movs	r1, #48	; 0x30
    8d34:	5c5b      	ldrb	r3, [r3, r1]
    8d36:	021b      	lsls	r3, r3, #8
    8d38:	4313      	orrs	r3, r2
    8d3a:	b29b      	uxth	r3, r3
    8d3c:	2b00      	cmp	r3, #0
    8d3e:	d101      	bne.n	8d44 <atcacert_set_expire_date+0x44>
		return ATCACERT_E_SUCCESS; // No expire date to be set
    8d40:	2300      	movs	r3, #0
    8d42:	e023      	b.n	8d8c <atcacert_set_expire_date+0x8c>

	ret = atcacert_date_enc(cert_def->expire_date_format, timestamp, formatted_date, &formatted_date_size);
    8d44:	68fb      	ldr	r3, [r7, #12]
    8d46:	7b58      	ldrb	r0, [r3, #13]
    8d48:	2314      	movs	r3, #20
    8d4a:	18fb      	adds	r3, r7, r3
    8d4c:	2218      	movs	r2, #24
    8d4e:	18ba      	adds	r2, r7, r2
    8d50:	6839      	ldr	r1, [r7, #0]
    8d52:	4c10      	ldr	r4, [pc, #64]	; (8d94 <atcacert_set_expire_date+0x94>)
    8d54:	47a0      	blx	r4
    8d56:	0003      	movs	r3, r0
    8d58:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (ret != ATCACERT_E_SUCCESS)
    8d5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8d5c:	2b00      	cmp	r3, #0
    8d5e:	d001      	beq.n	8d64 <atcacert_set_expire_date+0x64>
		return ret;
    8d60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8d62:	e013      	b.n	8d8c <atcacert_set_expire_date+0x8c>

	ret = atcacert_set_cert_element(&cert_def->std_cert_elements[STDCERT_EXPIRE_DATE], cert, cert_size, formatted_date, formatted_date_size);
    8d64:	68fb      	ldr	r3, [r7, #12]
    8d66:	332d      	adds	r3, #45	; 0x2d
    8d68:	0018      	movs	r0, r3
    8d6a:	697b      	ldr	r3, [r7, #20]
    8d6c:	2218      	movs	r2, #24
    8d6e:	18bc      	adds	r4, r7, r2
    8d70:	687a      	ldr	r2, [r7, #4]
    8d72:	68b9      	ldr	r1, [r7, #8]
    8d74:	9300      	str	r3, [sp, #0]
    8d76:	0023      	movs	r3, r4
    8d78:	4c07      	ldr	r4, [pc, #28]	; (8d98 <atcacert_set_expire_date+0x98>)
    8d7a:	47a0      	blx	r4
    8d7c:	0003      	movs	r3, r0
    8d7e:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (ret != ATCACERT_E_SUCCESS)
    8d80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8d82:	2b00      	cmp	r3, #0
    8d84:	d001      	beq.n	8d8a <atcacert_set_expire_date+0x8a>
		return ret;
    8d86:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8d88:	e000      	b.n	8d8c <atcacert_set_expire_date+0x8c>

	return ATCACERT_E_SUCCESS;
    8d8a:	2300      	movs	r3, #0
}
    8d8c:	0018      	movs	r0, r3
    8d8e:	46bd      	mov	sp, r7
    8d90:	b00d      	add	sp, #52	; 0x34
    8d92:	bd90      	pop	{r4, r7, pc}
    8d94:	00005df1 	.word	0x00005df1
    8d98:	00009879 	.word	0x00009879

00008d9c <uint8_to_hex>:

	return ATCACERT_E_SUCCESS;
}

static void uint8_to_hex(uint8_t num, uint8_t* hex_str)
{
    8d9c:	b580      	push	{r7, lr}
    8d9e:	b084      	sub	sp, #16
    8da0:	af00      	add	r7, sp, #0
    8da2:	0002      	movs	r2, r0
    8da4:	6039      	str	r1, [r7, #0]
    8da6:	1dfb      	adds	r3, r7, #7
    8da8:	701a      	strb	r2, [r3, #0]
	uint8_t nibble = (num >> 4) & 0x0F;
    8daa:	230f      	movs	r3, #15
    8dac:	18fb      	adds	r3, r7, r3
    8dae:	1dfa      	adds	r2, r7, #7
    8db0:	7812      	ldrb	r2, [r2, #0]
    8db2:	0912      	lsrs	r2, r2, #4
    8db4:	701a      	strb	r2, [r3, #0]

	if (nibble < 10)
    8db6:	230f      	movs	r3, #15
    8db8:	18fb      	adds	r3, r7, r3
    8dba:	781b      	ldrb	r3, [r3, #0]
    8dbc:	2b09      	cmp	r3, #9
    8dbe:	d809      	bhi.n	8dd4 <uint8_to_hex+0x38>
		*(hex_str++) = '0' + nibble;
    8dc0:	683b      	ldr	r3, [r7, #0]
    8dc2:	1c5a      	adds	r2, r3, #1
    8dc4:	603a      	str	r2, [r7, #0]
    8dc6:	220f      	movs	r2, #15
    8dc8:	18ba      	adds	r2, r7, r2
    8dca:	7812      	ldrb	r2, [r2, #0]
    8dcc:	3230      	adds	r2, #48	; 0x30
    8dce:	b2d2      	uxtb	r2, r2
    8dd0:	701a      	strb	r2, [r3, #0]
    8dd2:	e008      	b.n	8de6 <uint8_to_hex+0x4a>
	else
		*(hex_str++) = 'A' + (nibble - 10);
    8dd4:	683b      	ldr	r3, [r7, #0]
    8dd6:	1c5a      	adds	r2, r3, #1
    8dd8:	603a      	str	r2, [r7, #0]
    8dda:	220f      	movs	r2, #15
    8ddc:	18ba      	adds	r2, r7, r2
    8dde:	7812      	ldrb	r2, [r2, #0]
    8de0:	3237      	adds	r2, #55	; 0x37
    8de2:	b2d2      	uxtb	r2, r2
    8de4:	701a      	strb	r2, [r3, #0]
	nibble = num & 0x0F;
    8de6:	230f      	movs	r3, #15
    8de8:	18fb      	adds	r3, r7, r3
    8dea:	1dfa      	adds	r2, r7, #7
    8dec:	7812      	ldrb	r2, [r2, #0]
    8dee:	210f      	movs	r1, #15
    8df0:	400a      	ands	r2, r1
    8df2:	701a      	strb	r2, [r3, #0]
	if (nibble < 10)
    8df4:	230f      	movs	r3, #15
    8df6:	18fb      	adds	r3, r7, r3
    8df8:	781b      	ldrb	r3, [r3, #0]
    8dfa:	2b09      	cmp	r3, #9
    8dfc:	d809      	bhi.n	8e12 <uint8_to_hex+0x76>
		*(hex_str++) = '0' + nibble;
    8dfe:	683b      	ldr	r3, [r7, #0]
    8e00:	1c5a      	adds	r2, r3, #1
    8e02:	603a      	str	r2, [r7, #0]
    8e04:	220f      	movs	r2, #15
    8e06:	18ba      	adds	r2, r7, r2
    8e08:	7812      	ldrb	r2, [r2, #0]
    8e0a:	3230      	adds	r2, #48	; 0x30
    8e0c:	b2d2      	uxtb	r2, r2
    8e0e:	701a      	strb	r2, [r3, #0]
	else
		*(hex_str++) = 'A' + (nibble - 10);
}
    8e10:	e008      	b.n	8e24 <uint8_to_hex+0x88>
		*(hex_str++) = 'A' + (nibble - 10);
	nibble = num & 0x0F;
	if (nibble < 10)
		*(hex_str++) = '0' + nibble;
	else
		*(hex_str++) = 'A' + (nibble - 10);
    8e12:	683b      	ldr	r3, [r7, #0]
    8e14:	1c5a      	adds	r2, r3, #1
    8e16:	603a      	str	r2, [r7, #0]
    8e18:	220f      	movs	r2, #15
    8e1a:	18ba      	adds	r2, r7, r2
    8e1c:	7812      	ldrb	r2, [r2, #0]
    8e1e:	3237      	adds	r2, #55	; 0x37
    8e20:	b2d2      	uxtb	r2, r2
    8e22:	701a      	strb	r2, [r3, #0]
}
    8e24:	46c0      	nop			; (mov r8, r8)
    8e26:	46bd      	mov	sp, r7
    8e28:	b004      	add	sp, #16
    8e2a:	bd80      	pop	{r7, pc}

00008e2c <atcacert_set_signer_id>:

int atcacert_set_signer_id( const atcacert_def_t* cert_def,
                            uint8_t*              cert,
                            size_t cert_size,
                            const uint8_t signer_id[2])
{
    8e2c:	b590      	push	{r4, r7, lr}
    8e2e:	b089      	sub	sp, #36	; 0x24
    8e30:	af02      	add	r7, sp, #8
    8e32:	60f8      	str	r0, [r7, #12]
    8e34:	60b9      	str	r1, [r7, #8]
    8e36:	607a      	str	r2, [r7, #4]
    8e38:	603b      	str	r3, [r7, #0]
	uint8_t hex_str[4];

	if (cert_def == NULL || cert == NULL || signer_id == NULL)
    8e3a:	68fb      	ldr	r3, [r7, #12]
    8e3c:	2b00      	cmp	r3, #0
    8e3e:	d005      	beq.n	8e4c <atcacert_set_signer_id+0x20>
    8e40:	68bb      	ldr	r3, [r7, #8]
    8e42:	2b00      	cmp	r3, #0
    8e44:	d002      	beq.n	8e4c <atcacert_set_signer_id+0x20>
    8e46:	683b      	ldr	r3, [r7, #0]
    8e48:	2b00      	cmp	r3, #0
    8e4a:	d101      	bne.n	8e50 <atcacert_set_signer_id+0x24>
		return ATCACERT_E_BAD_PARAMS;
    8e4c:	2302      	movs	r3, #2
    8e4e:	e01e      	b.n	8e8e <atcacert_set_signer_id+0x62>

	uint8_to_hex(signer_id[0], &hex_str[0]);
    8e50:	683b      	ldr	r3, [r7, #0]
    8e52:	781b      	ldrb	r3, [r3, #0]
    8e54:	2214      	movs	r2, #20
    8e56:	18ba      	adds	r2, r7, r2
    8e58:	0011      	movs	r1, r2
    8e5a:	0018      	movs	r0, r3
    8e5c:	4b0e      	ldr	r3, [pc, #56]	; (8e98 <atcacert_set_signer_id+0x6c>)
    8e5e:	4798      	blx	r3
	uint8_to_hex(signer_id[1], &hex_str[2]);
    8e60:	683b      	ldr	r3, [r7, #0]
    8e62:	3301      	adds	r3, #1
    8e64:	781a      	ldrb	r2, [r3, #0]
    8e66:	2314      	movs	r3, #20
    8e68:	18fb      	adds	r3, r7, r3
    8e6a:	3302      	adds	r3, #2
    8e6c:	0019      	movs	r1, r3
    8e6e:	0010      	movs	r0, r2
    8e70:	4b09      	ldr	r3, [pc, #36]	; (8e98 <atcacert_set_signer_id+0x6c>)
    8e72:	4798      	blx	r3

	return atcacert_set_cert_element(&cert_def->std_cert_elements[STDCERT_SIGNER_ID], cert, cert_size, hex_str, 4);
    8e74:	68fb      	ldr	r3, [r7, #12]
    8e76:	3331      	adds	r3, #49	; 0x31
    8e78:	0018      	movs	r0, r3
    8e7a:	2314      	movs	r3, #20
    8e7c:	18fc      	adds	r4, r7, r3
    8e7e:	687a      	ldr	r2, [r7, #4]
    8e80:	68b9      	ldr	r1, [r7, #8]
    8e82:	2304      	movs	r3, #4
    8e84:	9300      	str	r3, [sp, #0]
    8e86:	0023      	movs	r3, r4
    8e88:	4c04      	ldr	r4, [pc, #16]	; (8e9c <atcacert_set_signer_id+0x70>)
    8e8a:	47a0      	blx	r4
    8e8c:	0003      	movs	r3, r0
}
    8e8e:	0018      	movs	r0, r3
    8e90:	46bd      	mov	sp, r7
    8e92:	b007      	add	sp, #28
    8e94:	bd90      	pop	{r4, r7, pc}
    8e96:	46c0      	nop			; (mov r8, r8)
    8e98:	00008d9d 	.word	0x00008d9d
    8e9c:	00009879 	.word	0x00009879

00008ea0 <hex_to_uint8>:

static int hex_to_uint8(const uint8_t hex_str[2], uint8_t* num)
{
    8ea0:	b580      	push	{r7, lr}
    8ea2:	b082      	sub	sp, #8
    8ea4:	af00      	add	r7, sp, #0
    8ea6:	6078      	str	r0, [r7, #4]
    8ea8:	6039      	str	r1, [r7, #0]
	*num = 0;
    8eaa:	683b      	ldr	r3, [r7, #0]
    8eac:	2200      	movs	r2, #0
    8eae:	701a      	strb	r2, [r3, #0]

	if (hex_str[0] >= '0' && hex_str[0] <= '9')
    8eb0:	687b      	ldr	r3, [r7, #4]
    8eb2:	781b      	ldrb	r3, [r3, #0]
    8eb4:	2b2f      	cmp	r3, #47	; 0x2f
    8eb6:	d910      	bls.n	8eda <hex_to_uint8+0x3a>
    8eb8:	687b      	ldr	r3, [r7, #4]
    8eba:	781b      	ldrb	r3, [r3, #0]
    8ebc:	2b39      	cmp	r3, #57	; 0x39
    8ebe:	d80c      	bhi.n	8eda <hex_to_uint8+0x3a>
		*num += (hex_str[0] - '0') << 4;
    8ec0:	683b      	ldr	r3, [r7, #0]
    8ec2:	781a      	ldrb	r2, [r3, #0]
    8ec4:	687b      	ldr	r3, [r7, #4]
    8ec6:	781b      	ldrb	r3, [r3, #0]
    8ec8:	3b30      	subs	r3, #48	; 0x30
    8eca:	b2db      	uxtb	r3, r3
    8ecc:	011b      	lsls	r3, r3, #4
    8ece:	b2db      	uxtb	r3, r3
    8ed0:	18d3      	adds	r3, r2, r3
    8ed2:	b2da      	uxtb	r2, r3
    8ed4:	683b      	ldr	r3, [r7, #0]
    8ed6:	701a      	strb	r2, [r3, #0]
    8ed8:	e02b      	b.n	8f32 <hex_to_uint8+0x92>
	else if (hex_str[0] >= 'A' && hex_str[0] <= 'F')
    8eda:	687b      	ldr	r3, [r7, #4]
    8edc:	781b      	ldrb	r3, [r3, #0]
    8ede:	2b40      	cmp	r3, #64	; 0x40
    8ee0:	d910      	bls.n	8f04 <hex_to_uint8+0x64>
    8ee2:	687b      	ldr	r3, [r7, #4]
    8ee4:	781b      	ldrb	r3, [r3, #0]
    8ee6:	2b46      	cmp	r3, #70	; 0x46
    8ee8:	d80c      	bhi.n	8f04 <hex_to_uint8+0x64>
		*num += (hex_str[0] - 'A' + 10) << 4;
    8eea:	683b      	ldr	r3, [r7, #0]
    8eec:	781a      	ldrb	r2, [r3, #0]
    8eee:	687b      	ldr	r3, [r7, #4]
    8ef0:	781b      	ldrb	r3, [r3, #0]
    8ef2:	3b37      	subs	r3, #55	; 0x37
    8ef4:	b2db      	uxtb	r3, r3
    8ef6:	011b      	lsls	r3, r3, #4
    8ef8:	b2db      	uxtb	r3, r3
    8efa:	18d3      	adds	r3, r2, r3
    8efc:	b2da      	uxtb	r2, r3
    8efe:	683b      	ldr	r3, [r7, #0]
    8f00:	701a      	strb	r2, [r3, #0]
    8f02:	e016      	b.n	8f32 <hex_to_uint8+0x92>
	else if (hex_str[0] >= 'a' && hex_str[0] <= 'f')
    8f04:	687b      	ldr	r3, [r7, #4]
    8f06:	781b      	ldrb	r3, [r3, #0]
    8f08:	2b60      	cmp	r3, #96	; 0x60
    8f0a:	d910      	bls.n	8f2e <hex_to_uint8+0x8e>
    8f0c:	687b      	ldr	r3, [r7, #4]
    8f0e:	781b      	ldrb	r3, [r3, #0]
    8f10:	2b66      	cmp	r3, #102	; 0x66
    8f12:	d80c      	bhi.n	8f2e <hex_to_uint8+0x8e>
		*num += (hex_str[0] - 'a' + 10) << 4;
    8f14:	683b      	ldr	r3, [r7, #0]
    8f16:	781a      	ldrb	r2, [r3, #0]
    8f18:	687b      	ldr	r3, [r7, #4]
    8f1a:	781b      	ldrb	r3, [r3, #0]
    8f1c:	3b57      	subs	r3, #87	; 0x57
    8f1e:	b2db      	uxtb	r3, r3
    8f20:	011b      	lsls	r3, r3, #4
    8f22:	b2db      	uxtb	r3, r3
    8f24:	18d3      	adds	r3, r2, r3
    8f26:	b2da      	uxtb	r2, r3
    8f28:	683b      	ldr	r3, [r7, #0]
    8f2a:	701a      	strb	r2, [r3, #0]
    8f2c:	e001      	b.n	8f32 <hex_to_uint8+0x92>
	else
		return ATCACERT_E_DECODING_ERROR;
    8f2e:	2304      	movs	r3, #4
    8f30:	e044      	b.n	8fbc <hex_to_uint8+0x11c>

	if (hex_str[1] >= '0' && hex_str[1] <= '9')
    8f32:	687b      	ldr	r3, [r7, #4]
    8f34:	3301      	adds	r3, #1
    8f36:	781b      	ldrb	r3, [r3, #0]
    8f38:	2b2f      	cmp	r3, #47	; 0x2f
    8f3a:	d910      	bls.n	8f5e <hex_to_uint8+0xbe>
    8f3c:	687b      	ldr	r3, [r7, #4]
    8f3e:	3301      	adds	r3, #1
    8f40:	781b      	ldrb	r3, [r3, #0]
    8f42:	2b39      	cmp	r3, #57	; 0x39
    8f44:	d80b      	bhi.n	8f5e <hex_to_uint8+0xbe>
		*num += (hex_str[1] - '0');
    8f46:	683b      	ldr	r3, [r7, #0]
    8f48:	781a      	ldrb	r2, [r3, #0]
    8f4a:	687b      	ldr	r3, [r7, #4]
    8f4c:	3301      	adds	r3, #1
    8f4e:	781b      	ldrb	r3, [r3, #0]
    8f50:	18d3      	adds	r3, r2, r3
    8f52:	b2db      	uxtb	r3, r3
    8f54:	3b30      	subs	r3, #48	; 0x30
    8f56:	b2da      	uxtb	r2, r3
    8f58:	683b      	ldr	r3, [r7, #0]
    8f5a:	701a      	strb	r2, [r3, #0]
    8f5c:	e02d      	b.n	8fba <hex_to_uint8+0x11a>
	else if (hex_str[1] >= 'A' && hex_str[1] <= 'F')
    8f5e:	687b      	ldr	r3, [r7, #4]
    8f60:	3301      	adds	r3, #1
    8f62:	781b      	ldrb	r3, [r3, #0]
    8f64:	2b40      	cmp	r3, #64	; 0x40
    8f66:	d910      	bls.n	8f8a <hex_to_uint8+0xea>
    8f68:	687b      	ldr	r3, [r7, #4]
    8f6a:	3301      	adds	r3, #1
    8f6c:	781b      	ldrb	r3, [r3, #0]
    8f6e:	2b46      	cmp	r3, #70	; 0x46
    8f70:	d80b      	bhi.n	8f8a <hex_to_uint8+0xea>
		*num += (hex_str[1] - 'A' + 10);
    8f72:	683b      	ldr	r3, [r7, #0]
    8f74:	781a      	ldrb	r2, [r3, #0]
    8f76:	687b      	ldr	r3, [r7, #4]
    8f78:	3301      	adds	r3, #1
    8f7a:	781b      	ldrb	r3, [r3, #0]
    8f7c:	18d3      	adds	r3, r2, r3
    8f7e:	b2db      	uxtb	r3, r3
    8f80:	3b37      	subs	r3, #55	; 0x37
    8f82:	b2da      	uxtb	r2, r3
    8f84:	683b      	ldr	r3, [r7, #0]
    8f86:	701a      	strb	r2, [r3, #0]
    8f88:	e017      	b.n	8fba <hex_to_uint8+0x11a>
	else if (hex_str[1] >= 'a' && hex_str[1] <= 'f')
    8f8a:	687b      	ldr	r3, [r7, #4]
    8f8c:	3301      	adds	r3, #1
    8f8e:	781b      	ldrb	r3, [r3, #0]
    8f90:	2b60      	cmp	r3, #96	; 0x60
    8f92:	d910      	bls.n	8fb6 <hex_to_uint8+0x116>
    8f94:	687b      	ldr	r3, [r7, #4]
    8f96:	3301      	adds	r3, #1
    8f98:	781b      	ldrb	r3, [r3, #0]
    8f9a:	2b66      	cmp	r3, #102	; 0x66
    8f9c:	d80b      	bhi.n	8fb6 <hex_to_uint8+0x116>
		*num += (hex_str[1] - 'a' + 10);
    8f9e:	683b      	ldr	r3, [r7, #0]
    8fa0:	781a      	ldrb	r2, [r3, #0]
    8fa2:	687b      	ldr	r3, [r7, #4]
    8fa4:	3301      	adds	r3, #1
    8fa6:	781b      	ldrb	r3, [r3, #0]
    8fa8:	18d3      	adds	r3, r2, r3
    8faa:	b2db      	uxtb	r3, r3
    8fac:	3b57      	subs	r3, #87	; 0x57
    8fae:	b2da      	uxtb	r2, r3
    8fb0:	683b      	ldr	r3, [r7, #0]
    8fb2:	701a      	strb	r2, [r3, #0]
    8fb4:	e001      	b.n	8fba <hex_to_uint8+0x11a>
	else
		return ATCACERT_E_DECODING_ERROR;
    8fb6:	2304      	movs	r3, #4
    8fb8:	e000      	b.n	8fbc <hex_to_uint8+0x11c>

	return ATCACERT_E_SUCCESS;
    8fba:	2300      	movs	r3, #0
}
    8fbc:	0018      	movs	r0, r3
    8fbe:	46bd      	mov	sp, r7
    8fc0:	b002      	add	sp, #8
    8fc2:	bd80      	pop	{r7, pc}

00008fc4 <atcacert_get_signer_id>:

int atcacert_get_signer_id( const atcacert_def_t* cert_def,
                            const uint8_t*        cert,
                            size_t cert_size,
                            uint8_t signer_id[2])
{
    8fc4:	b590      	push	{r4, r7, lr}
    8fc6:	b089      	sub	sp, #36	; 0x24
    8fc8:	af02      	add	r7, sp, #8
    8fca:	60f8      	str	r0, [r7, #12]
    8fcc:	60b9      	str	r1, [r7, #8]
    8fce:	607a      	str	r2, [r7, #4]
    8fd0:	603b      	str	r3, [r7, #0]
	int ret = 0;
    8fd2:	2300      	movs	r3, #0
    8fd4:	617b      	str	r3, [r7, #20]
	uint8_t hex_str[4];

	if (cert_def == NULL || cert == NULL || signer_id == NULL)
    8fd6:	68fb      	ldr	r3, [r7, #12]
    8fd8:	2b00      	cmp	r3, #0
    8fda:	d005      	beq.n	8fe8 <atcacert_get_signer_id+0x24>
    8fdc:	68bb      	ldr	r3, [r7, #8]
    8fde:	2b00      	cmp	r3, #0
    8fe0:	d002      	beq.n	8fe8 <atcacert_get_signer_id+0x24>
    8fe2:	683b      	ldr	r3, [r7, #0]
    8fe4:	2b00      	cmp	r3, #0
    8fe6:	d101      	bne.n	8fec <atcacert_get_signer_id+0x28>
		return ATCACERT_E_BAD_PARAMS;
    8fe8:	2302      	movs	r3, #2
    8fea:	e031      	b.n	9050 <atcacert_get_signer_id+0x8c>

	ret = atcacert_get_cert_element(&cert_def->std_cert_elements[STDCERT_SIGNER_ID], cert, cert_size, hex_str, 4);
    8fec:	68fb      	ldr	r3, [r7, #12]
    8fee:	3331      	adds	r3, #49	; 0x31
    8ff0:	0018      	movs	r0, r3
    8ff2:	2310      	movs	r3, #16
    8ff4:	18fc      	adds	r4, r7, r3
    8ff6:	687a      	ldr	r2, [r7, #4]
    8ff8:	68b9      	ldr	r1, [r7, #8]
    8ffa:	2304      	movs	r3, #4
    8ffc:	9300      	str	r3, [sp, #0]
    8ffe:	0023      	movs	r3, r4
    9000:	4c15      	ldr	r4, [pc, #84]	; (9058 <atcacert_get_signer_id+0x94>)
    9002:	47a0      	blx	r4
    9004:	0003      	movs	r3, r0
    9006:	617b      	str	r3, [r7, #20]
	if (ret != ATCACERT_E_SUCCESS)
    9008:	697b      	ldr	r3, [r7, #20]
    900a:	2b00      	cmp	r3, #0
    900c:	d001      	beq.n	9012 <atcacert_get_signer_id+0x4e>
		return ret;
    900e:	697b      	ldr	r3, [r7, #20]
    9010:	e01e      	b.n	9050 <atcacert_get_signer_id+0x8c>

	ret = hex_to_uint8(&hex_str[0], &signer_id[0]);
    9012:	683a      	ldr	r2, [r7, #0]
    9014:	2310      	movs	r3, #16
    9016:	18fb      	adds	r3, r7, r3
    9018:	0011      	movs	r1, r2
    901a:	0018      	movs	r0, r3
    901c:	4b0f      	ldr	r3, [pc, #60]	; (905c <atcacert_get_signer_id+0x98>)
    901e:	4798      	blx	r3
    9020:	0003      	movs	r3, r0
    9022:	617b      	str	r3, [r7, #20]
	if (ret != ATCACERT_E_SUCCESS)
    9024:	697b      	ldr	r3, [r7, #20]
    9026:	2b00      	cmp	r3, #0
    9028:	d001      	beq.n	902e <atcacert_get_signer_id+0x6a>
		return ret;
    902a:	697b      	ldr	r3, [r7, #20]
    902c:	e010      	b.n	9050 <atcacert_get_signer_id+0x8c>

	ret = hex_to_uint8(&hex_str[2], &signer_id[1]);
    902e:	683b      	ldr	r3, [r7, #0]
    9030:	1c5a      	adds	r2, r3, #1
    9032:	2310      	movs	r3, #16
    9034:	18fb      	adds	r3, r7, r3
    9036:	3302      	adds	r3, #2
    9038:	0011      	movs	r1, r2
    903a:	0018      	movs	r0, r3
    903c:	4b07      	ldr	r3, [pc, #28]	; (905c <atcacert_get_signer_id+0x98>)
    903e:	4798      	blx	r3
    9040:	0003      	movs	r3, r0
    9042:	617b      	str	r3, [r7, #20]
	if (ret != ATCACERT_E_SUCCESS)
    9044:	697b      	ldr	r3, [r7, #20]
    9046:	2b00      	cmp	r3, #0
    9048:	d001      	beq.n	904e <atcacert_get_signer_id+0x8a>
		return ret;
    904a:	697b      	ldr	r3, [r7, #20]
    904c:	e000      	b.n	9050 <atcacert_get_signer_id+0x8c>

	return ATCACERT_E_SUCCESS;
    904e:	2300      	movs	r3, #0
}
    9050:	0018      	movs	r0, r3
    9052:	46bd      	mov	sp, r7
    9054:	b007      	add	sp, #28
    9056:	bd90      	pop	{r4, r7, pc}
    9058:	0000991d 	.word	0x0000991d
    905c:	00008ea1 	.word	0x00008ea1

00009060 <atcacert_set_cert_sn>:
int atcacert_set_cert_sn( const atcacert_def_t* cert_def,
                          uint8_t*              cert,
                          size_t cert_size,
                          const uint8_t*        cert_sn,
                          size_t cert_sn_size)
{
    9060:	b590      	push	{r4, r7, lr}
    9062:	b087      	sub	sp, #28
    9064:	af02      	add	r7, sp, #8
    9066:	60f8      	str	r0, [r7, #12]
    9068:	60b9      	str	r1, [r7, #8]
    906a:	607a      	str	r2, [r7, #4]
    906c:	603b      	str	r3, [r7, #0]
	if (cert_def == NULL || cert == NULL || cert_sn == NULL)
    906e:	68fb      	ldr	r3, [r7, #12]
    9070:	2b00      	cmp	r3, #0
    9072:	d005      	beq.n	9080 <atcacert_set_cert_sn+0x20>
    9074:	68bb      	ldr	r3, [r7, #8]
    9076:	2b00      	cmp	r3, #0
    9078:	d002      	beq.n	9080 <atcacert_set_cert_sn+0x20>
    907a:	683b      	ldr	r3, [r7, #0]
    907c:	2b00      	cmp	r3, #0
    907e:	d101      	bne.n	9084 <atcacert_set_cert_sn+0x24>
		return ATCACERT_E_BAD_PARAMS;
    9080:	2302      	movs	r3, #2
    9082:	e00b      	b.n	909c <atcacert_set_cert_sn+0x3c>

	return atcacert_set_cert_element(&cert_def->std_cert_elements[STDCERT_CERT_SN], cert, cert_size, cert_sn, cert_sn_size);
    9084:	68fb      	ldr	r3, [r7, #12]
    9086:	3335      	adds	r3, #53	; 0x35
    9088:	0018      	movs	r0, r3
    908a:	683c      	ldr	r4, [r7, #0]
    908c:	687a      	ldr	r2, [r7, #4]
    908e:	68b9      	ldr	r1, [r7, #8]
    9090:	6a3b      	ldr	r3, [r7, #32]
    9092:	9300      	str	r3, [sp, #0]
    9094:	0023      	movs	r3, r4
    9096:	4c03      	ldr	r4, [pc, #12]	; (90a4 <atcacert_set_cert_sn+0x44>)
    9098:	47a0      	blx	r4
    909a:	0003      	movs	r3, r0
}
    909c:	0018      	movs	r0, r3
    909e:	46bd      	mov	sp, r7
    90a0:	b005      	add	sp, #20
    90a2:	bd90      	pop	{r4, r7, pc}
    90a4:	00009879 	.word	0x00009879

000090a8 <atcacert_gen_cert_sn>:

int atcacert_gen_cert_sn( const atcacert_def_t* cert_def,
                          uint8_t*              cert,
                          size_t cert_size,
                          const uint8_t device_sn[9])
{
    90a8:	b590      	push	{r4, r7, lr}
    90aa:	b0a9      	sub	sp, #164	; 0xa4
    90ac:	af02      	add	r7, sp, #8
    90ae:	60f8      	str	r0, [r7, #12]
    90b0:	60b9      	str	r1, [r7, #8]
    90b2:	607a      	str	r2, [r7, #4]
    90b4:	603b      	str	r3, [r7, #0]
	int ret = 0;
    90b6:	2300      	movs	r3, #0
    90b8:	2290      	movs	r2, #144	; 0x90
    90ba:	18ba      	adds	r2, r7, r2
    90bc:	6013      	str	r3, [r2, #0]
	size_t sn_size = 0;
    90be:	2300      	movs	r3, #0
    90c0:	2294      	movs	r2, #148	; 0x94
    90c2:	18ba      	adds	r2, r7, r2
    90c4:	6013      	str	r3, [r2, #0]
	uint8_t msg[64 + 3];
	uint8_t sn[32];
	atcacert_tm_utc_t issue_date;

	if (cert_def == NULL || cert == NULL)
    90c6:	68fb      	ldr	r3, [r7, #12]
    90c8:	2b00      	cmp	r3, #0
    90ca:	d002      	beq.n	90d2 <atcacert_gen_cert_sn+0x2a>
    90cc:	68bb      	ldr	r3, [r7, #8]
    90ce:	2b00      	cmp	r3, #0
    90d0:	d101      	bne.n	90d6 <atcacert_gen_cert_sn+0x2e>
		return ATCACERT_E_BAD_PARAMS;
    90d2:	2302      	movs	r3, #2
    90d4:	e173      	b.n	93be <atcacert_gen_cert_sn+0x316>

	if (cert_def->sn_source == SNSRC_STORED || cert_def->std_cert_elements[STDCERT_CERT_SN].count == 0)
    90d6:	68fb      	ldr	r3, [r7, #12]
    90d8:	791b      	ldrb	r3, [r3, #4]
    90da:	2b00      	cmp	r3, #0
    90dc:	d009      	beq.n	90f2 <atcacert_gen_cert_sn+0x4a>
    90de:	68fb      	ldr	r3, [r7, #12]
    90e0:	2237      	movs	r2, #55	; 0x37
    90e2:	5c9a      	ldrb	r2, [r3, r2]
    90e4:	2138      	movs	r1, #56	; 0x38
    90e6:	5c5b      	ldrb	r3, [r3, r1]
    90e8:	021b      	lsls	r3, r3, #8
    90ea:	4313      	orrs	r3, r2
    90ec:	b29b      	uxth	r3, r3
    90ee:	2b00      	cmp	r3, #0
    90f0:	d101      	bne.n	90f6 <atcacert_gen_cert_sn+0x4e>
		return ATCACERT_E_SUCCESS; // Certificate serial number is not generated or not in the certificate
    90f2:	2300      	movs	r3, #0
    90f4:	e163      	b.n	93be <atcacert_gen_cert_sn+0x316>

	switch (cert_def->sn_source) {
    90f6:	68fb      	ldr	r3, [r7, #12]
    90f8:	791b      	ldrb	r3, [r3, #4]
    90fa:	3b08      	subs	r3, #8
    90fc:	2b07      	cmp	r3, #7
    90fe:	d900      	bls.n	9102 <atcacert_gen_cert_sn+0x5a>
    9100:	e147      	b.n	9392 <atcacert_gen_cert_sn+0x2ea>
    9102:	009a      	lsls	r2, r3, #2
    9104:	4bb0      	ldr	r3, [pc, #704]	; (93c8 <atcacert_gen_cert_sn+0x320>)
    9106:	18d3      	adds	r3, r2, r3
    9108:	681b      	ldr	r3, [r3, #0]
    910a:	469f      	mov	pc, r3
	case SNSRC_DEVICE_SN:     // Cert serial number is 0x40(MSB) + 9-byte device serial number. Only applies to device certificates.
		if (device_sn == NULL)
    910c:	683b      	ldr	r3, [r7, #0]
    910e:	2b00      	cmp	r3, #0
    9110:	d101      	bne.n	9116 <atcacert_gen_cert_sn+0x6e>
			return ATCACERT_E_BAD_PARAMS;
    9112:	2302      	movs	r3, #2
    9114:	e153      	b.n	93be <atcacert_gen_cert_sn+0x316>
		sn_size = 1 + 9;
    9116:	230a      	movs	r3, #10
    9118:	2294      	movs	r2, #148	; 0x94
    911a:	18ba      	adds	r2, r7, r2
    911c:	6013      	str	r3, [r2, #0]
		sn[0] = 0x40;
    911e:	232c      	movs	r3, #44	; 0x2c
    9120:	18fb      	adds	r3, r7, r3
    9122:	2240      	movs	r2, #64	; 0x40
    9124:	701a      	strb	r2, [r3, #0]
		memcpy(&sn[1], device_sn, 9);
    9126:	6839      	ldr	r1, [r7, #0]
    9128:	232c      	movs	r3, #44	; 0x2c
    912a:	18fb      	adds	r3, r7, r3
    912c:	3301      	adds	r3, #1
    912e:	2209      	movs	r2, #9
    9130:	0018      	movs	r0, r3
    9132:	4ba6      	ldr	r3, [pc, #664]	; (93cc <atcacert_gen_cert_sn+0x324>)
    9134:	4798      	blx	r3
		break;
    9136:	e133      	b.n	93a0 <atcacert_gen_cert_sn+0x2f8>

	case SNSRC_SIGNER_ID:     // Cert serial number is 0x40(MSB) + 2-byte signer ID. Only applies to signer certificates.
		sn_size = 1 + 2;
    9138:	2303      	movs	r3, #3
    913a:	2294      	movs	r2, #148	; 0x94
    913c:	18ba      	adds	r2, r7, r2
    913e:	6013      	str	r3, [r2, #0]
		sn[0] = 0x40;
    9140:	232c      	movs	r3, #44	; 0x2c
    9142:	18fb      	adds	r3, r7, r3
    9144:	2240      	movs	r2, #64	; 0x40
    9146:	701a      	strb	r2, [r3, #0]
		ret = atcacert_get_signer_id(cert_def, cert, cert_size, &sn[1]);
    9148:	232c      	movs	r3, #44	; 0x2c
    914a:	18fb      	adds	r3, r7, r3
    914c:	3301      	adds	r3, #1
    914e:	687a      	ldr	r2, [r7, #4]
    9150:	68b9      	ldr	r1, [r7, #8]
    9152:	68f8      	ldr	r0, [r7, #12]
    9154:	4c9e      	ldr	r4, [pc, #632]	; (93d0 <atcacert_gen_cert_sn+0x328>)
    9156:	47a0      	blx	r4
    9158:	0003      	movs	r3, r0
    915a:	2290      	movs	r2, #144	; 0x90
    915c:	18ba      	adds	r2, r7, r2
    915e:	6013      	str	r3, [r2, #0]
		if (ret != ATCACERT_E_SUCCESS)
    9160:	2390      	movs	r3, #144	; 0x90
    9162:	18fb      	adds	r3, r7, r3
    9164:	681b      	ldr	r3, [r3, #0]
    9166:	2b00      	cmp	r3, #0
    9168:	d100      	bne.n	916c <atcacert_gen_cert_sn+0xc4>
    916a:	e114      	b.n	9396 <atcacert_gen_cert_sn+0x2ee>
			return ret;
    916c:	2390      	movs	r3, #144	; 0x90
    916e:	18fb      	adds	r3, r7, r3
    9170:	681b      	ldr	r3, [r3, #0]
    9172:	e124      	b.n	93be <atcacert_gen_cert_sn+0x316>
		break;

	case SNSRC_PUB_KEY_HASH_RAW:     // Cert serial number is the SHA256(Subject public key + Encoded dates)
	case SNSRC_PUB_KEY_HASH_POS:
	case SNSRC_PUB_KEY_HASH:
		if (cert_def->std_cert_elements[STDCERT_CERT_SN].count > 32)
    9174:	68fb      	ldr	r3, [r7, #12]
    9176:	2237      	movs	r2, #55	; 0x37
    9178:	5c9a      	ldrb	r2, [r3, r2]
    917a:	2138      	movs	r1, #56	; 0x38
    917c:	5c5b      	ldrb	r3, [r3, r1]
    917e:	021b      	lsls	r3, r3, #8
    9180:	4313      	orrs	r3, r2
    9182:	b29b      	uxth	r3, r3
    9184:	2b20      	cmp	r3, #32
    9186:	d901      	bls.n	918c <atcacert_gen_cert_sn+0xe4>
			return ATCACERT_E_UNEXPECTED_ELEM_SIZE;
    9188:	2307      	movs	r3, #7
    918a:	e118      	b.n	93be <atcacert_gen_cert_sn+0x316>
		sn_size = cert_def->std_cert_elements[STDCERT_CERT_SN].count;
    918c:	68fb      	ldr	r3, [r7, #12]
    918e:	2237      	movs	r2, #55	; 0x37
    9190:	5c9a      	ldrb	r2, [r3, r2]
    9192:	2138      	movs	r1, #56	; 0x38
    9194:	5c5b      	ldrb	r3, [r3, r1]
    9196:	021b      	lsls	r3, r3, #8
    9198:	4313      	orrs	r3, r2
    919a:	b29b      	uxth	r3, r3
    919c:	2294      	movs	r2, #148	; 0x94
    919e:	18ba      	adds	r2, r7, r2
    91a0:	6013      	str	r3, [r2, #0]

		// Add public key to hash input
		ret = atcacert_get_subj_public_key(cert_def, cert, cert_size, &msg[0]);
    91a2:	234c      	movs	r3, #76	; 0x4c
    91a4:	18fb      	adds	r3, r7, r3
    91a6:	687a      	ldr	r2, [r7, #4]
    91a8:	68b9      	ldr	r1, [r7, #8]
    91aa:	68f8      	ldr	r0, [r7, #12]
    91ac:	4c89      	ldr	r4, [pc, #548]	; (93d4 <atcacert_gen_cert_sn+0x32c>)
    91ae:	47a0      	blx	r4
    91b0:	0003      	movs	r3, r0
    91b2:	2290      	movs	r2, #144	; 0x90
    91b4:	18ba      	adds	r2, r7, r2
    91b6:	6013      	str	r3, [r2, #0]
		if (ret != ATCACERT_E_SUCCESS)
    91b8:	2390      	movs	r3, #144	; 0x90
    91ba:	18fb      	adds	r3, r7, r3
    91bc:	681b      	ldr	r3, [r3, #0]
    91be:	2b00      	cmp	r3, #0
    91c0:	d003      	beq.n	91ca <atcacert_gen_cert_sn+0x122>
			return ret;
    91c2:	2390      	movs	r3, #144	; 0x90
    91c4:	18fb      	adds	r3, r7, r3
    91c6:	681b      	ldr	r3, [r3, #0]
    91c8:	e0f9      	b.n	93be <atcacert_gen_cert_sn+0x316>

		// Add compressed/encoded dates to hash input
		ret = atcacert_get_issue_date(cert_def, cert, cert_size, &issue_date);
    91ca:	2314      	movs	r3, #20
    91cc:	18fb      	adds	r3, r7, r3
    91ce:	687a      	ldr	r2, [r7, #4]
    91d0:	68b9      	ldr	r1, [r7, #8]
    91d2:	68f8      	ldr	r0, [r7, #12]
    91d4:	4c80      	ldr	r4, [pc, #512]	; (93d8 <atcacert_gen_cert_sn+0x330>)
    91d6:	47a0      	blx	r4
    91d8:	0003      	movs	r3, r0
    91da:	2290      	movs	r2, #144	; 0x90
    91dc:	18ba      	adds	r2, r7, r2
    91de:	6013      	str	r3, [r2, #0]
		if (ret != ATCACERT_E_SUCCESS)
    91e0:	2390      	movs	r3, #144	; 0x90
    91e2:	18fb      	adds	r3, r7, r3
    91e4:	681b      	ldr	r3, [r3, #0]
    91e6:	2b00      	cmp	r3, #0
    91e8:	d003      	beq.n	91f2 <atcacert_gen_cert_sn+0x14a>
			return ret;
    91ea:	2390      	movs	r3, #144	; 0x90
    91ec:	18fb      	adds	r3, r7, r3
    91ee:	681b      	ldr	r3, [r3, #0]
    91f0:	e0e5      	b.n	93be <atcacert_gen_cert_sn+0x316>
		ret = atcacert_date_enc_compcert(&issue_date, cert_def->expire_years, &msg[64]);
    91f2:	68fb      	ldr	r3, [r7, #12]
    91f4:	7c99      	ldrb	r1, [r3, #18]
    91f6:	234c      	movs	r3, #76	; 0x4c
    91f8:	18fb      	adds	r3, r7, r3
    91fa:	3340      	adds	r3, #64	; 0x40
    91fc:	001a      	movs	r2, r3
    91fe:	2314      	movs	r3, #20
    9200:	18fb      	adds	r3, r7, r3
    9202:	0018      	movs	r0, r3
    9204:	4b75      	ldr	r3, [pc, #468]	; (93dc <atcacert_gen_cert_sn+0x334>)
    9206:	4798      	blx	r3
    9208:	0003      	movs	r3, r0
    920a:	2290      	movs	r2, #144	; 0x90
    920c:	18ba      	adds	r2, r7, r2
    920e:	6013      	str	r3, [r2, #0]
		if (ret != ATCACERT_E_SUCCESS)
    9210:	2390      	movs	r3, #144	; 0x90
    9212:	18fb      	adds	r3, r7, r3
    9214:	681b      	ldr	r3, [r3, #0]
    9216:	2b00      	cmp	r3, #0
    9218:	d003      	beq.n	9222 <atcacert_gen_cert_sn+0x17a>
			return ret;
    921a:	2390      	movs	r3, #144	; 0x90
    921c:	18fb      	adds	r3, r7, r3
    921e:	681b      	ldr	r3, [r3, #0]
    9220:	e0cd      	b.n	93be <atcacert_gen_cert_sn+0x316>
		ret = atcac_sw_sha2_256(msg, 64 + 3, sn);
    9222:	232c      	movs	r3, #44	; 0x2c
    9224:	18fa      	adds	r2, r7, r3
    9226:	234c      	movs	r3, #76	; 0x4c
    9228:	18fb      	adds	r3, r7, r3
    922a:	2143      	movs	r1, #67	; 0x43
    922c:	0018      	movs	r0, r3
    922e:	4b6c      	ldr	r3, [pc, #432]	; (93e0 <atcacert_gen_cert_sn+0x338>)
    9230:	4798      	blx	r3
    9232:	0003      	movs	r3, r0
    9234:	2290      	movs	r2, #144	; 0x90
    9236:	18ba      	adds	r2, r7, r2
    9238:	6013      	str	r3, [r2, #0]
		if (ret != ATCACERT_E_SUCCESS)
    923a:	2390      	movs	r3, #144	; 0x90
    923c:	18fb      	adds	r3, r7, r3
    923e:	681b      	ldr	r3, [r3, #0]
    9240:	2b00      	cmp	r3, #0
    9242:	d003      	beq.n	924c <atcacert_gen_cert_sn+0x1a4>
			return ret;
    9244:	2390      	movs	r3, #144	; 0x90
    9246:	18fb      	adds	r3, r7, r3
    9248:	681b      	ldr	r3, [r3, #0]
    924a:	e0b8      	b.n	93be <atcacert_gen_cert_sn+0x316>

		if (cert_def->sn_source == SNSRC_PUB_KEY_HASH_POS || cert_def->sn_source == SNSRC_PUB_KEY_HASH)
    924c:	68fb      	ldr	r3, [r7, #12]
    924e:	791b      	ldrb	r3, [r3, #4]
    9250:	2b0c      	cmp	r3, #12
    9252:	d003      	beq.n	925c <atcacert_gen_cert_sn+0x1b4>
    9254:	68fb      	ldr	r3, [r7, #12]
    9256:	791b      	ldrb	r3, [r3, #4]
    9258:	2b0a      	cmp	r3, #10
    925a:	d108      	bne.n	926e <atcacert_gen_cert_sn+0x1c6>
			sn[0] &= 0x7F;      // Ensure the SN is positive
    925c:	232c      	movs	r3, #44	; 0x2c
    925e:	18fb      	adds	r3, r7, r3
    9260:	781b      	ldrb	r3, [r3, #0]
    9262:	227f      	movs	r2, #127	; 0x7f
    9264:	4013      	ands	r3, r2
    9266:	b2da      	uxtb	r2, r3
    9268:	232c      	movs	r3, #44	; 0x2c
    926a:	18fb      	adds	r3, r7, r3
    926c:	701a      	strb	r2, [r3, #0]
		if (cert_def->sn_source == SNSRC_PUB_KEY_HASH)
    926e:	68fb      	ldr	r3, [r7, #12]
    9270:	791b      	ldrb	r3, [r3, #4]
    9272:	2b0a      	cmp	r3, #10
    9274:	d000      	beq.n	9278 <atcacert_gen_cert_sn+0x1d0>
    9276:	e090      	b.n	939a <atcacert_gen_cert_sn+0x2f2>
			sn[0] |= 0x40;      // Ensure the SN doesn't have any trimmable bytes
    9278:	232c      	movs	r3, #44	; 0x2c
    927a:	18fb      	adds	r3, r7, r3
    927c:	781b      	ldrb	r3, [r3, #0]
    927e:	2240      	movs	r2, #64	; 0x40
    9280:	4313      	orrs	r3, r2
    9282:	b2da      	uxtb	r2, r3
    9284:	232c      	movs	r3, #44	; 0x2c
    9286:	18fb      	adds	r3, r7, r3
    9288:	701a      	strb	r2, [r3, #0]
		break;
    928a:	e086      	b.n	939a <atcacert_gen_cert_sn+0x2f2>

	case SNSRC_DEVICE_SN_HASH_RAW:     // Cert serial number is the SHA256(Device SN + Encoded dates). Only applies to device certificates.
	case SNSRC_DEVICE_SN_HASH_POS:
	case SNSRC_DEVICE_SN_HASH:
		if (device_sn == NULL)
    928c:	683b      	ldr	r3, [r7, #0]
    928e:	2b00      	cmp	r3, #0
    9290:	d101      	bne.n	9296 <atcacert_gen_cert_sn+0x1ee>
			return ATCACERT_E_BAD_PARAMS;
    9292:	2302      	movs	r3, #2
    9294:	e093      	b.n	93be <atcacert_gen_cert_sn+0x316>
		if (cert_def->std_cert_elements[STDCERT_CERT_SN].count > 32)
    9296:	68fb      	ldr	r3, [r7, #12]
    9298:	2237      	movs	r2, #55	; 0x37
    929a:	5c9a      	ldrb	r2, [r3, r2]
    929c:	2138      	movs	r1, #56	; 0x38
    929e:	5c5b      	ldrb	r3, [r3, r1]
    92a0:	021b      	lsls	r3, r3, #8
    92a2:	4313      	orrs	r3, r2
    92a4:	b29b      	uxth	r3, r3
    92a6:	2b20      	cmp	r3, #32
    92a8:	d901      	bls.n	92ae <atcacert_gen_cert_sn+0x206>
			return ATCACERT_E_UNEXPECTED_ELEM_SIZE;
    92aa:	2307      	movs	r3, #7
    92ac:	e087      	b.n	93be <atcacert_gen_cert_sn+0x316>
		sn_size = cert_def->std_cert_elements[STDCERT_CERT_SN].count;
    92ae:	68fb      	ldr	r3, [r7, #12]
    92b0:	2237      	movs	r2, #55	; 0x37
    92b2:	5c9a      	ldrb	r2, [r3, r2]
    92b4:	2138      	movs	r1, #56	; 0x38
    92b6:	5c5b      	ldrb	r3, [r3, r1]
    92b8:	021b      	lsls	r3, r3, #8
    92ba:	4313      	orrs	r3, r2
    92bc:	b29b      	uxth	r3, r3
    92be:	2294      	movs	r2, #148	; 0x94
    92c0:	18ba      	adds	r2, r7, r2
    92c2:	6013      	str	r3, [r2, #0]

		// Add device SN to the hash input
		memcpy(&msg[0], device_sn, 9);
    92c4:	6839      	ldr	r1, [r7, #0]
    92c6:	234c      	movs	r3, #76	; 0x4c
    92c8:	18fb      	adds	r3, r7, r3
    92ca:	2209      	movs	r2, #9
    92cc:	0018      	movs	r0, r3
    92ce:	4b3f      	ldr	r3, [pc, #252]	; (93cc <atcacert_gen_cert_sn+0x324>)
    92d0:	4798      	blx	r3

		// Add compressed/encoded dates to hash input
		ret = atcacert_get_issue_date(cert_def, cert, cert_size, &issue_date);
    92d2:	2314      	movs	r3, #20
    92d4:	18fb      	adds	r3, r7, r3
    92d6:	687a      	ldr	r2, [r7, #4]
    92d8:	68b9      	ldr	r1, [r7, #8]
    92da:	68f8      	ldr	r0, [r7, #12]
    92dc:	4c3e      	ldr	r4, [pc, #248]	; (93d8 <atcacert_gen_cert_sn+0x330>)
    92de:	47a0      	blx	r4
    92e0:	0003      	movs	r3, r0
    92e2:	2290      	movs	r2, #144	; 0x90
    92e4:	18ba      	adds	r2, r7, r2
    92e6:	6013      	str	r3, [r2, #0]
		if (ret != ATCACERT_E_SUCCESS)
    92e8:	2390      	movs	r3, #144	; 0x90
    92ea:	18fb      	adds	r3, r7, r3
    92ec:	681b      	ldr	r3, [r3, #0]
    92ee:	2b00      	cmp	r3, #0
    92f0:	d003      	beq.n	92fa <atcacert_gen_cert_sn+0x252>
			return ret;
    92f2:	2390      	movs	r3, #144	; 0x90
    92f4:	18fb      	adds	r3, r7, r3
    92f6:	681b      	ldr	r3, [r3, #0]
    92f8:	e061      	b.n	93be <atcacert_gen_cert_sn+0x316>
		ret = atcacert_date_enc_compcert(&issue_date, cert_def->expire_years, &msg[9]);
    92fa:	68fb      	ldr	r3, [r7, #12]
    92fc:	7c99      	ldrb	r1, [r3, #18]
    92fe:	234c      	movs	r3, #76	; 0x4c
    9300:	18fb      	adds	r3, r7, r3
    9302:	3309      	adds	r3, #9
    9304:	001a      	movs	r2, r3
    9306:	2314      	movs	r3, #20
    9308:	18fb      	adds	r3, r7, r3
    930a:	0018      	movs	r0, r3
    930c:	4b33      	ldr	r3, [pc, #204]	; (93dc <atcacert_gen_cert_sn+0x334>)
    930e:	4798      	blx	r3
    9310:	0003      	movs	r3, r0
    9312:	2290      	movs	r2, #144	; 0x90
    9314:	18ba      	adds	r2, r7, r2
    9316:	6013      	str	r3, [r2, #0]
		if (ret != ATCACERT_E_SUCCESS)
    9318:	2390      	movs	r3, #144	; 0x90
    931a:	18fb      	adds	r3, r7, r3
    931c:	681b      	ldr	r3, [r3, #0]
    931e:	2b00      	cmp	r3, #0
    9320:	d003      	beq.n	932a <atcacert_gen_cert_sn+0x282>
			return ret;
    9322:	2390      	movs	r3, #144	; 0x90
    9324:	18fb      	adds	r3, r7, r3
    9326:	681b      	ldr	r3, [r3, #0]
    9328:	e049      	b.n	93be <atcacert_gen_cert_sn+0x316>
		ret = atcac_sw_sha2_256(msg, 9 + 3, sn);
    932a:	232c      	movs	r3, #44	; 0x2c
    932c:	18fa      	adds	r2, r7, r3
    932e:	234c      	movs	r3, #76	; 0x4c
    9330:	18fb      	adds	r3, r7, r3
    9332:	210c      	movs	r1, #12
    9334:	0018      	movs	r0, r3
    9336:	4b2a      	ldr	r3, [pc, #168]	; (93e0 <atcacert_gen_cert_sn+0x338>)
    9338:	4798      	blx	r3
    933a:	0003      	movs	r3, r0
    933c:	2290      	movs	r2, #144	; 0x90
    933e:	18ba      	adds	r2, r7, r2
    9340:	6013      	str	r3, [r2, #0]
		if (ret != ATCACERT_E_SUCCESS)
    9342:	2390      	movs	r3, #144	; 0x90
    9344:	18fb      	adds	r3, r7, r3
    9346:	681b      	ldr	r3, [r3, #0]
    9348:	2b00      	cmp	r3, #0
    934a:	d003      	beq.n	9354 <atcacert_gen_cert_sn+0x2ac>
			return ret;
    934c:	2390      	movs	r3, #144	; 0x90
    934e:	18fb      	adds	r3, r7, r3
    9350:	681b      	ldr	r3, [r3, #0]
    9352:	e034      	b.n	93be <atcacert_gen_cert_sn+0x316>

		if (cert_def->sn_source == SNSRC_DEVICE_SN_HASH_POS || cert_def->sn_source == SNSRC_DEVICE_SN_HASH)
    9354:	68fb      	ldr	r3, [r7, #12]
    9356:	791b      	ldrb	r3, [r3, #4]
    9358:	2b0d      	cmp	r3, #13
    935a:	d003      	beq.n	9364 <atcacert_gen_cert_sn+0x2bc>
    935c:	68fb      	ldr	r3, [r7, #12]
    935e:	791b      	ldrb	r3, [r3, #4]
    9360:	2b0b      	cmp	r3, #11
    9362:	d108      	bne.n	9376 <atcacert_gen_cert_sn+0x2ce>
			sn[0] &= 0x7F;      // Ensure the SN is positive
    9364:	232c      	movs	r3, #44	; 0x2c
    9366:	18fb      	adds	r3, r7, r3
    9368:	781b      	ldrb	r3, [r3, #0]
    936a:	227f      	movs	r2, #127	; 0x7f
    936c:	4013      	ands	r3, r2
    936e:	b2da      	uxtb	r2, r3
    9370:	232c      	movs	r3, #44	; 0x2c
    9372:	18fb      	adds	r3, r7, r3
    9374:	701a      	strb	r2, [r3, #0]
		if (cert_def->sn_source == SNSRC_DEVICE_SN_HASH)
    9376:	68fb      	ldr	r3, [r7, #12]
    9378:	791b      	ldrb	r3, [r3, #4]
    937a:	2b0b      	cmp	r3, #11
    937c:	d10f      	bne.n	939e <atcacert_gen_cert_sn+0x2f6>
			sn[0] |= 0x40;      // Ensure the SN doesn't have any trimmable bytes
    937e:	232c      	movs	r3, #44	; 0x2c
    9380:	18fb      	adds	r3, r7, r3
    9382:	781b      	ldrb	r3, [r3, #0]
    9384:	2240      	movs	r2, #64	; 0x40
    9386:	4313      	orrs	r3, r2
    9388:	b2da      	uxtb	r2, r3
    938a:	232c      	movs	r3, #44	; 0x2c
    938c:	18fb      	adds	r3, r7, r3
    938e:	701a      	strb	r2, [r3, #0]
		break;
    9390:	e005      	b.n	939e <atcacert_gen_cert_sn+0x2f6>

	default:
		return ATCACERT_E_BAD_PARAMS;
    9392:	2302      	movs	r3, #2
    9394:	e013      	b.n	93be <atcacert_gen_cert_sn+0x316>
		sn_size = 1 + 2;
		sn[0] = 0x40;
		ret = atcacert_get_signer_id(cert_def, cert, cert_size, &sn[1]);
		if (ret != ATCACERT_E_SUCCESS)
			return ret;
		break;
    9396:	46c0      	nop			; (mov r8, r8)
    9398:	e002      	b.n	93a0 <atcacert_gen_cert_sn+0x2f8>

		if (cert_def->sn_source == SNSRC_PUB_KEY_HASH_POS || cert_def->sn_source == SNSRC_PUB_KEY_HASH)
			sn[0] &= 0x7F;      // Ensure the SN is positive
		if (cert_def->sn_source == SNSRC_PUB_KEY_HASH)
			sn[0] |= 0x40;      // Ensure the SN doesn't have any trimmable bytes
		break;
    939a:	46c0      	nop			; (mov r8, r8)
    939c:	e000      	b.n	93a0 <atcacert_gen_cert_sn+0x2f8>

		if (cert_def->sn_source == SNSRC_DEVICE_SN_HASH_POS || cert_def->sn_source == SNSRC_DEVICE_SN_HASH)
			sn[0] &= 0x7F;      // Ensure the SN is positive
		if (cert_def->sn_source == SNSRC_DEVICE_SN_HASH)
			sn[0] |= 0x40;      // Ensure the SN doesn't have any trimmable bytes
		break;
    939e:	46c0      	nop			; (mov r8, r8)

	default:
		return ATCACERT_E_BAD_PARAMS;
	}

	return atcacert_set_cert_element(&cert_def->std_cert_elements[STDCERT_CERT_SN], cert, cert_size, sn, sn_size);
    93a0:	68fb      	ldr	r3, [r7, #12]
    93a2:	3335      	adds	r3, #53	; 0x35
    93a4:	0018      	movs	r0, r3
    93a6:	232c      	movs	r3, #44	; 0x2c
    93a8:	18fc      	adds	r4, r7, r3
    93aa:	687a      	ldr	r2, [r7, #4]
    93ac:	68b9      	ldr	r1, [r7, #8]
    93ae:	2394      	movs	r3, #148	; 0x94
    93b0:	18fb      	adds	r3, r7, r3
    93b2:	681b      	ldr	r3, [r3, #0]
    93b4:	9300      	str	r3, [sp, #0]
    93b6:	0023      	movs	r3, r4
    93b8:	4c0a      	ldr	r4, [pc, #40]	; (93e4 <atcacert_gen_cert_sn+0x33c>)
    93ba:	47a0      	blx	r4
    93bc:	0003      	movs	r3, r0
}
    93be:	0018      	movs	r0, r3
    93c0:	46bd      	mov	sp, r7
    93c2:	b027      	add	sp, #156	; 0x9c
    93c4:	bd90      	pop	{r4, r7, pc}
    93c6:	46c0      	nop			; (mov r8, r8)
    93c8:	0001528c 	.word	0x0001528c
    93cc:	000127e7 	.word	0x000127e7
    93d0:	00008fc5 	.word	0x00008fc5
    93d4:	0000894d 	.word	0x0000894d
    93d8:	00008c55 	.word	0x00008c55
    93dc:	0000708d 	.word	0x0000708d
    93e0:	0000d389 	.word	0x0000d389
    93e4:	00009879 	.word	0x00009879

000093e8 <atcacert_get_cert_sn>:
int atcacert_get_cert_sn( const atcacert_def_t* cert_def,
                          const uint8_t*        cert,
                          size_t cert_size,
                          uint8_t*              cert_sn,
                          size_t*               cert_sn_size)
{
    93e8:	b590      	push	{r4, r7, lr}
    93ea:	b087      	sub	sp, #28
    93ec:	af02      	add	r7, sp, #8
    93ee:	60f8      	str	r0, [r7, #12]
    93f0:	60b9      	str	r1, [r7, #8]
    93f2:	607a      	str	r2, [r7, #4]
    93f4:	603b      	str	r3, [r7, #0]
	if (cert_def == NULL || cert == NULL || cert_sn == NULL || cert_sn_size == NULL)
    93f6:	68fb      	ldr	r3, [r7, #12]
    93f8:	2b00      	cmp	r3, #0
    93fa:	d008      	beq.n	940e <atcacert_get_cert_sn+0x26>
    93fc:	68bb      	ldr	r3, [r7, #8]
    93fe:	2b00      	cmp	r3, #0
    9400:	d005      	beq.n	940e <atcacert_get_cert_sn+0x26>
    9402:	683b      	ldr	r3, [r7, #0]
    9404:	2b00      	cmp	r3, #0
    9406:	d002      	beq.n	940e <atcacert_get_cert_sn+0x26>
    9408:	6a3b      	ldr	r3, [r7, #32]
    940a:	2b00      	cmp	r3, #0
    940c:	d101      	bne.n	9412 <atcacert_get_cert_sn+0x2a>
		return ATCACERT_E_BAD_PARAMS;
    940e:	2302      	movs	r3, #2
    9410:	e030      	b.n	9474 <atcacert_get_cert_sn+0x8c>

	if (*cert_sn_size < cert_def->std_cert_elements[STDCERT_CERT_SN].count) {
    9412:	6a3b      	ldr	r3, [r7, #32]
    9414:	681a      	ldr	r2, [r3, #0]
    9416:	68fb      	ldr	r3, [r7, #12]
    9418:	2137      	movs	r1, #55	; 0x37
    941a:	5c59      	ldrb	r1, [r3, r1]
    941c:	2038      	movs	r0, #56	; 0x38
    941e:	5c1b      	ldrb	r3, [r3, r0]
    9420:	021b      	lsls	r3, r3, #8
    9422:	430b      	orrs	r3, r1
    9424:	b29b      	uxth	r3, r3
    9426:	429a      	cmp	r2, r3
    9428:	d20c      	bcs.n	9444 <atcacert_get_cert_sn+0x5c>
		*cert_sn_size = cert_def->std_cert_elements[STDCERT_CERT_SN].count;
    942a:	68fb      	ldr	r3, [r7, #12]
    942c:	2237      	movs	r2, #55	; 0x37
    942e:	5c9a      	ldrb	r2, [r3, r2]
    9430:	2138      	movs	r1, #56	; 0x38
    9432:	5c5b      	ldrb	r3, [r3, r1]
    9434:	021b      	lsls	r3, r3, #8
    9436:	4313      	orrs	r3, r2
    9438:	b29b      	uxth	r3, r3
    943a:	001a      	movs	r2, r3
    943c:	6a3b      	ldr	r3, [r7, #32]
    943e:	601a      	str	r2, [r3, #0]
		return ATCACERT_E_BUFFER_TOO_SMALL;
    9440:	2303      	movs	r3, #3
    9442:	e017      	b.n	9474 <atcacert_get_cert_sn+0x8c>
	}

	*cert_sn_size = cert_def->std_cert_elements[STDCERT_CERT_SN].count;
    9444:	68fb      	ldr	r3, [r7, #12]
    9446:	2237      	movs	r2, #55	; 0x37
    9448:	5c9a      	ldrb	r2, [r3, r2]
    944a:	2138      	movs	r1, #56	; 0x38
    944c:	5c5b      	ldrb	r3, [r3, r1]
    944e:	021b      	lsls	r3, r3, #8
    9450:	4313      	orrs	r3, r2
    9452:	b29b      	uxth	r3, r3
    9454:	001a      	movs	r2, r3
    9456:	6a3b      	ldr	r3, [r7, #32]
    9458:	601a      	str	r2, [r3, #0]

	return atcacert_get_cert_element(&cert_def->std_cert_elements[STDCERT_CERT_SN], cert, cert_size, cert_sn, *cert_sn_size);
    945a:	68fb      	ldr	r3, [r7, #12]
    945c:	3335      	adds	r3, #53	; 0x35
    945e:	0018      	movs	r0, r3
    9460:	6a3b      	ldr	r3, [r7, #32]
    9462:	681b      	ldr	r3, [r3, #0]
    9464:	683c      	ldr	r4, [r7, #0]
    9466:	687a      	ldr	r2, [r7, #4]
    9468:	68b9      	ldr	r1, [r7, #8]
    946a:	9300      	str	r3, [sp, #0]
    946c:	0023      	movs	r3, r4
    946e:	4c03      	ldr	r4, [pc, #12]	; (947c <atcacert_get_cert_sn+0x94>)
    9470:	47a0      	blx	r4
    9472:	0003      	movs	r3, r0
}
    9474:	0018      	movs	r0, r3
    9476:	46bd      	mov	sp, r7
    9478:	b005      	add	sp, #20
    947a:	bd90      	pop	{r4, r7, pc}
    947c:	0000991d 	.word	0x0000991d

00009480 <atcacert_set_auth_key_id>:

int atcacert_set_auth_key_id( const atcacert_def_t* cert_def,
                              uint8_t*              cert,
                              size_t cert_size,
                              const uint8_t auth_public_key[64])
{
    9480:	b590      	push	{r4, r7, lr}
    9482:	b08d      	sub	sp, #52	; 0x34
    9484:	af02      	add	r7, sp, #8
    9486:	60f8      	str	r0, [r7, #12]
    9488:	60b9      	str	r1, [r7, #8]
    948a:	607a      	str	r2, [r7, #4]
    948c:	603b      	str	r3, [r7, #0]
	int ret = 0;
    948e:	2300      	movs	r3, #0
    9490:	627b      	str	r3, [r7, #36]	; 0x24
	uint8_t key_id[20];

	if (cert_def == NULL || cert == NULL || auth_public_key == NULL)
    9492:	68fb      	ldr	r3, [r7, #12]
    9494:	2b00      	cmp	r3, #0
    9496:	d005      	beq.n	94a4 <atcacert_set_auth_key_id+0x24>
    9498:	68bb      	ldr	r3, [r7, #8]
    949a:	2b00      	cmp	r3, #0
    949c:	d002      	beq.n	94a4 <atcacert_set_auth_key_id+0x24>
    949e:	683b      	ldr	r3, [r7, #0]
    94a0:	2b00      	cmp	r3, #0
    94a2:	d101      	bne.n	94a8 <atcacert_set_auth_key_id+0x28>
		return ATCACERT_E_BAD_PARAMS;
    94a4:	2302      	movs	r3, #2
    94a6:	e021      	b.n	94ec <atcacert_set_auth_key_id+0x6c>

	ret = atcacert_get_key_id(auth_public_key, key_id);
    94a8:	2310      	movs	r3, #16
    94aa:	18fa      	adds	r2, r7, r3
    94ac:	683b      	ldr	r3, [r7, #0]
    94ae:	0011      	movs	r1, r2
    94b0:	0018      	movs	r0, r3
    94b2:	4b10      	ldr	r3, [pc, #64]	; (94f4 <atcacert_set_auth_key_id+0x74>)
    94b4:	4798      	blx	r3
    94b6:	0003      	movs	r3, r0
    94b8:	627b      	str	r3, [r7, #36]	; 0x24
	if (ret != ATCACERT_E_SUCCESS)
    94ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    94bc:	2b00      	cmp	r3, #0
    94be:	d001      	beq.n	94c4 <atcacert_set_auth_key_id+0x44>
		return ret;
    94c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    94c2:	e013      	b.n	94ec <atcacert_set_auth_key_id+0x6c>

	ret = atcacert_set_cert_element(&cert_def->std_cert_elements[STDCERT_AUTH_KEY_ID], cert, cert_size, key_id, 20);
    94c4:	68fb      	ldr	r3, [r7, #12]
    94c6:	3339      	adds	r3, #57	; 0x39
    94c8:	0018      	movs	r0, r3
    94ca:	2310      	movs	r3, #16
    94cc:	18fc      	adds	r4, r7, r3
    94ce:	687a      	ldr	r2, [r7, #4]
    94d0:	68b9      	ldr	r1, [r7, #8]
    94d2:	2314      	movs	r3, #20
    94d4:	9300      	str	r3, [sp, #0]
    94d6:	0023      	movs	r3, r4
    94d8:	4c07      	ldr	r4, [pc, #28]	; (94f8 <atcacert_set_auth_key_id+0x78>)
    94da:	47a0      	blx	r4
    94dc:	0003      	movs	r3, r0
    94de:	627b      	str	r3, [r7, #36]	; 0x24
	if (ret != ATCACERT_E_SUCCESS)
    94e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    94e2:	2b00      	cmp	r3, #0
    94e4:	d001      	beq.n	94ea <atcacert_set_auth_key_id+0x6a>
		return ret;
    94e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    94e8:	e000      	b.n	94ec <atcacert_set_auth_key_id+0x6c>

	return ATCACERT_E_SUCCESS;
    94ea:	2300      	movs	r3, #0
}
    94ec:	0018      	movs	r0, r3
    94ee:	46bd      	mov	sp, r7
    94f0:	b00b      	add	sp, #44	; 0x2c
    94f2:	bd90      	pop	{r4, r7, pc}
    94f4:	000099bd 	.word	0x000099bd
    94f8:	00009879 	.word	0x00009879

000094fc <atcacert_set_comp_cert>:
int atcacert_set_comp_cert( const atcacert_def_t* cert_def,
                            uint8_t*              cert,
                            size_t*               cert_size,
                            size_t max_cert_size,
                            const uint8_t comp_cert[72])
{
    94fc:	b590      	push	{r4, r7, lr}
    94fe:	b097      	sub	sp, #92	; 0x5c
    9500:	af02      	add	r7, sp, #8
    9502:	60f8      	str	r0, [r7, #12]
    9504:	60b9      	str	r1, [r7, #8]
    9506:	607a      	str	r2, [r7, #4]
    9508:	603b      	str	r3, [r7, #0]
	int ret = 0;
    950a:	2300      	movs	r3, #0
    950c:	64fb      	str	r3, [r7, #76]	; 0x4c
	uint8_t sn_source;
	uint8_t format;
	atcacert_tm_utc_t issue_date;
	atcacert_tm_utc_t expire_date;

	if (cert_def == NULL || cert == NULL || cert_size == NULL || comp_cert == NULL)
    950e:	68fb      	ldr	r3, [r7, #12]
    9510:	2b00      	cmp	r3, #0
    9512:	d008      	beq.n	9526 <atcacert_set_comp_cert+0x2a>
    9514:	68bb      	ldr	r3, [r7, #8]
    9516:	2b00      	cmp	r3, #0
    9518:	d005      	beq.n	9526 <atcacert_set_comp_cert+0x2a>
    951a:	687b      	ldr	r3, [r7, #4]
    951c:	2b00      	cmp	r3, #0
    951e:	d002      	beq.n	9526 <atcacert_set_comp_cert+0x2a>
    9520:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    9522:	2b00      	cmp	r3, #0
    9524:	d101      	bne.n	952a <atcacert_set_comp_cert+0x2e>
		return ATCACERT_E_BAD_PARAMS;
    9526:	2302      	movs	r3, #2
    9528:	e09e      	b.n	9668 <atcacert_set_comp_cert+0x16c>

	format = comp_cert[70] & 0x0F;
    952a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    952c:	3346      	adds	r3, #70	; 0x46
    952e:	781a      	ldrb	r2, [r3, #0]
    9530:	234b      	movs	r3, #75	; 0x4b
    9532:	18fb      	adds	r3, r7, r3
    9534:	210f      	movs	r1, #15
    9536:	400a      	ands	r2, r1
    9538:	701a      	strb	r2, [r3, #0]
	if (format != 0)
    953a:	234b      	movs	r3, #75	; 0x4b
    953c:	18fb      	adds	r3, r7, r3
    953e:	781b      	ldrb	r3, [r3, #0]
    9540:	2b00      	cmp	r3, #0
    9542:	d001      	beq.n	9548 <atcacert_set_comp_cert+0x4c>
		return ATCACERT_E_DECODING_ERROR; // Unknown format
    9544:	2304      	movs	r3, #4
    9546:	e08f      	b.n	9668 <atcacert_set_comp_cert+0x16c>

	memcpy(enc_dates, &comp_cert[64], 3);
    9548:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    954a:	3340      	adds	r3, #64	; 0x40
    954c:	2244      	movs	r2, #68	; 0x44
    954e:	18ba      	adds	r2, r7, r2
    9550:	0010      	movs	r0, r2
    9552:	0019      	movs	r1, r3
    9554:	2303      	movs	r3, #3
    9556:	001a      	movs	r2, r3
    9558:	4b45      	ldr	r3, [pc, #276]	; (9670 <atcacert_set_comp_cert+0x174>)
    955a:	4798      	blx	r3
	memcpy(signer_id, &comp_cert[67], 2);
    955c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    955e:	3343      	adds	r3, #67	; 0x43
    9560:	2240      	movs	r2, #64	; 0x40
    9562:	18ba      	adds	r2, r7, r2
    9564:	0010      	movs	r0, r2
    9566:	0019      	movs	r1, r3
    9568:	2302      	movs	r3, #2
    956a:	001a      	movs	r2, r3
    956c:	4b40      	ldr	r3, [pc, #256]	; (9670 <atcacert_set_comp_cert+0x174>)
    956e:	4798      	blx	r3
	template_id = (comp_cert[69] >> 4) & 0x0F;
    9570:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    9572:	3345      	adds	r3, #69	; 0x45
    9574:	781a      	ldrb	r2, [r3, #0]
    9576:	234a      	movs	r3, #74	; 0x4a
    9578:	18fb      	adds	r3, r7, r3
    957a:	0912      	lsrs	r2, r2, #4
    957c:	701a      	strb	r2, [r3, #0]
	chain_id = comp_cert[69] & 0x0F;
    957e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    9580:	3345      	adds	r3, #69	; 0x45
    9582:	781a      	ldrb	r2, [r3, #0]
    9584:	2349      	movs	r3, #73	; 0x49
    9586:	18fb      	adds	r3, r7, r3
    9588:	210f      	movs	r1, #15
    958a:	400a      	ands	r2, r1
    958c:	701a      	strb	r2, [r3, #0]
	sn_source = (comp_cert[70] >> 4) & 0x0F;
    958e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    9590:	3346      	adds	r3, #70	; 0x46
    9592:	781a      	ldrb	r2, [r3, #0]
    9594:	2348      	movs	r3, #72	; 0x48
    9596:	18fb      	adds	r3, r7, r3
    9598:	0912      	lsrs	r2, r2, #4
    959a:	701a      	strb	r2, [r3, #0]

	if (template_id != cert_def->template_id || chain_id != cert_def->chain_id || sn_source != cert_def->sn_source)
    959c:	68fb      	ldr	r3, [r7, #12]
    959e:	785b      	ldrb	r3, [r3, #1]
    95a0:	224a      	movs	r2, #74	; 0x4a
    95a2:	18ba      	adds	r2, r7, r2
    95a4:	7812      	ldrb	r2, [r2, #0]
    95a6:	429a      	cmp	r2, r3
    95a8:	d10d      	bne.n	95c6 <atcacert_set_comp_cert+0xca>
    95aa:	68fb      	ldr	r3, [r7, #12]
    95ac:	789b      	ldrb	r3, [r3, #2]
    95ae:	2249      	movs	r2, #73	; 0x49
    95b0:	18ba      	adds	r2, r7, r2
    95b2:	7812      	ldrb	r2, [r2, #0]
    95b4:	429a      	cmp	r2, r3
    95b6:	d106      	bne.n	95c6 <atcacert_set_comp_cert+0xca>
    95b8:	68fb      	ldr	r3, [r7, #12]
    95ba:	791b      	ldrb	r3, [r3, #4]
    95bc:	2248      	movs	r2, #72	; 0x48
    95be:	18ba      	adds	r2, r7, r2
    95c0:	7812      	ldrb	r2, [r2, #0]
    95c2:	429a      	cmp	r2, r3
    95c4:	d001      	beq.n	95ca <atcacert_set_comp_cert+0xce>
		return ATCACERT_E_WRONG_CERT_DEF;
    95c6:	230b      	movs	r3, #11
    95c8:	e04e      	b.n	9668 <atcacert_set_comp_cert+0x16c>

	ret = atcacert_set_signature(
    95ca:	683c      	ldr	r4, [r7, #0]
    95cc:	687a      	ldr	r2, [r7, #4]
    95ce:	68b9      	ldr	r1, [r7, #8]
    95d0:	68f8      	ldr	r0, [r7, #12]
    95d2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    95d4:	9300      	str	r3, [sp, #0]
    95d6:	0023      	movs	r3, r4
    95d8:	4c26      	ldr	r4, [pc, #152]	; (9674 <atcacert_set_comp_cert+0x178>)
    95da:	47a0      	blx	r4
    95dc:	0003      	movs	r3, r0
    95de:	64fb      	str	r3, [r7, #76]	; 0x4c
	    cert_def,
	    cert,
	    cert_size,
	    max_cert_size,
	    &comp_cert[0]);
	if (ret != ATCACERT_E_SUCCESS)
    95e0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    95e2:	2b00      	cmp	r3, #0
    95e4:	d001      	beq.n	95ea <atcacert_set_comp_cert+0xee>
		return ret;
    95e6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    95e8:	e03e      	b.n	9668 <atcacert_set_comp_cert+0x16c>

	ret = atcacert_date_dec_compcert(enc_dates, cert_def->expire_date_format, &issue_date, &expire_date);
    95ea:	68fb      	ldr	r3, [r7, #12]
    95ec:	7b59      	ldrb	r1, [r3, #13]
    95ee:	2310      	movs	r3, #16
    95f0:	18fb      	adds	r3, r7, r3
    95f2:	2228      	movs	r2, #40	; 0x28
    95f4:	18ba      	adds	r2, r7, r2
    95f6:	2044      	movs	r0, #68	; 0x44
    95f8:	1838      	adds	r0, r7, r0
    95fa:	4c1f      	ldr	r4, [pc, #124]	; (9678 <atcacert_set_comp_cert+0x17c>)
    95fc:	47a0      	blx	r4
    95fe:	0003      	movs	r3, r0
    9600:	64fb      	str	r3, [r7, #76]	; 0x4c
	if (ret != ATCACERT_E_SUCCESS)
    9602:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    9604:	2b00      	cmp	r3, #0
    9606:	d001      	beq.n	960c <atcacert_set_comp_cert+0x110>
		return ret;
    9608:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    960a:	e02d      	b.n	9668 <atcacert_set_comp_cert+0x16c>

	ret = atcacert_set_issue_date(cert_def, cert, *cert_size, &issue_date);
    960c:	687b      	ldr	r3, [r7, #4]
    960e:	681a      	ldr	r2, [r3, #0]
    9610:	2328      	movs	r3, #40	; 0x28
    9612:	18fb      	adds	r3, r7, r3
    9614:	68b9      	ldr	r1, [r7, #8]
    9616:	68f8      	ldr	r0, [r7, #12]
    9618:	4c18      	ldr	r4, [pc, #96]	; (967c <atcacert_set_comp_cert+0x180>)
    961a:	47a0      	blx	r4
    961c:	0003      	movs	r3, r0
    961e:	64fb      	str	r3, [r7, #76]	; 0x4c
	if (ret != ATCACERT_E_SUCCESS)
    9620:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    9622:	2b00      	cmp	r3, #0
    9624:	d001      	beq.n	962a <atcacert_set_comp_cert+0x12e>
		return ret;
    9626:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    9628:	e01e      	b.n	9668 <atcacert_set_comp_cert+0x16c>

	ret = atcacert_set_expire_date(cert_def, cert, *cert_size, &expire_date);
    962a:	687b      	ldr	r3, [r7, #4]
    962c:	681a      	ldr	r2, [r3, #0]
    962e:	2310      	movs	r3, #16
    9630:	18fb      	adds	r3, r7, r3
    9632:	68b9      	ldr	r1, [r7, #8]
    9634:	68f8      	ldr	r0, [r7, #12]
    9636:	4c12      	ldr	r4, [pc, #72]	; (9680 <atcacert_set_comp_cert+0x184>)
    9638:	47a0      	blx	r4
    963a:	0003      	movs	r3, r0
    963c:	64fb      	str	r3, [r7, #76]	; 0x4c
	if (ret != ATCACERT_E_SUCCESS)
    963e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    9640:	2b00      	cmp	r3, #0
    9642:	d001      	beq.n	9648 <atcacert_set_comp_cert+0x14c>
		return ret;
    9644:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    9646:	e00f      	b.n	9668 <atcacert_set_comp_cert+0x16c>

	ret = atcacert_set_signer_id(cert_def, cert, *cert_size, signer_id);
    9648:	687b      	ldr	r3, [r7, #4]
    964a:	681a      	ldr	r2, [r3, #0]
    964c:	2340      	movs	r3, #64	; 0x40
    964e:	18fb      	adds	r3, r7, r3
    9650:	68b9      	ldr	r1, [r7, #8]
    9652:	68f8      	ldr	r0, [r7, #12]
    9654:	4c0b      	ldr	r4, [pc, #44]	; (9684 <atcacert_set_comp_cert+0x188>)
    9656:	47a0      	blx	r4
    9658:	0003      	movs	r3, r0
    965a:	64fb      	str	r3, [r7, #76]	; 0x4c
	if (ret != ATCACERT_E_SUCCESS)
    965c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    965e:	2b00      	cmp	r3, #0
    9660:	d001      	beq.n	9666 <atcacert_set_comp_cert+0x16a>
		return ret;
    9662:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    9664:	e000      	b.n	9668 <atcacert_set_comp_cert+0x16c>

	return ATCACERT_E_SUCCESS;
    9666:	2300      	movs	r3, #0
}
    9668:	0018      	movs	r0, r3
    966a:	46bd      	mov	sp, r7
    966c:	b015      	add	sp, #84	; 0x54
    966e:	bd90      	pop	{r4, r7, pc}
    9670:	000127e7 	.word	0x000127e7
    9674:	00008995 	.word	0x00008995
    9678:	00007255 	.word	0x00007255
    967c:	00008bb9 	.word	0x00008bb9
    9680:	00008d01 	.word	0x00008d01
    9684:	00008e2d 	.word	0x00008e2d

00009688 <atcacert_get_comp_cert>:

int atcacert_get_comp_cert( const atcacert_def_t* cert_def,
                            const uint8_t*        cert,
                            size_t cert_size,
                            uint8_t comp_cert[72])
{
    9688:	b590      	push	{r4, r7, lr}
    968a:	b08d      	sub	sp, #52	; 0x34
    968c:	af00      	add	r7, sp, #0
    968e:	60f8      	str	r0, [r7, #12]
    9690:	60b9      	str	r1, [r7, #8]
    9692:	607a      	str	r2, [r7, #4]
    9694:	603b      	str	r3, [r7, #0]
	int ret = 0;
    9696:	2300      	movs	r3, #0
    9698:	62fb      	str	r3, [r7, #44]	; 0x2c
	atcacert_tm_utc_t issue_date;

	if (cert_def == NULL || cert == NULL || comp_cert == NULL)
    969a:	68fb      	ldr	r3, [r7, #12]
    969c:	2b00      	cmp	r3, #0
    969e:	d005      	beq.n	96ac <atcacert_get_comp_cert+0x24>
    96a0:	68bb      	ldr	r3, [r7, #8]
    96a2:	2b00      	cmp	r3, #0
    96a4:	d002      	beq.n	96ac <atcacert_get_comp_cert+0x24>
    96a6:	683b      	ldr	r3, [r7, #0]
    96a8:	2b00      	cmp	r3, #0
    96aa:	d101      	bne.n	96b0 <atcacert_get_comp_cert+0x28>
		return ATCACERT_E_BAD_PARAMS;
    96ac:	2302      	movs	r3, #2
    96ae:	e055      	b.n	975c <atcacert_get_comp_cert+0xd4>

	ret = atcacert_get_signature(cert_def, cert, cert_size, &comp_cert[0]);
    96b0:	683b      	ldr	r3, [r7, #0]
    96b2:	687a      	ldr	r2, [r7, #4]
    96b4:	68b9      	ldr	r1, [r7, #8]
    96b6:	68f8      	ldr	r0, [r7, #12]
    96b8:	4c2a      	ldr	r4, [pc, #168]	; (9764 <atcacert_get_comp_cert+0xdc>)
    96ba:	47a0      	blx	r4
    96bc:	0003      	movs	r3, r0
    96be:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (ret != ATCACERT_E_SUCCESS)
    96c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    96c2:	2b00      	cmp	r3, #0
    96c4:	d001      	beq.n	96ca <atcacert_get_comp_cert+0x42>
		return ret;
    96c6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    96c8:	e048      	b.n	975c <atcacert_get_comp_cert+0xd4>

	ret = atcacert_get_issue_date(cert_def, cert, cert_size, &issue_date);
    96ca:	2314      	movs	r3, #20
    96cc:	18fb      	adds	r3, r7, r3
    96ce:	687a      	ldr	r2, [r7, #4]
    96d0:	68b9      	ldr	r1, [r7, #8]
    96d2:	68f8      	ldr	r0, [r7, #12]
    96d4:	4c24      	ldr	r4, [pc, #144]	; (9768 <atcacert_get_comp_cert+0xe0>)
    96d6:	47a0      	blx	r4
    96d8:	0003      	movs	r3, r0
    96da:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (ret != ATCACERT_E_SUCCESS)
    96dc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    96de:	2b00      	cmp	r3, #0
    96e0:	d001      	beq.n	96e6 <atcacert_get_comp_cert+0x5e>
		return ret;
    96e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    96e4:	e03a      	b.n	975c <atcacert_get_comp_cert+0xd4>
	ret = atcacert_date_enc_compcert(&issue_date, cert_def->expire_years, &comp_cert[64]);
    96e6:	68fb      	ldr	r3, [r7, #12]
    96e8:	7c99      	ldrb	r1, [r3, #18]
    96ea:	683b      	ldr	r3, [r7, #0]
    96ec:	3340      	adds	r3, #64	; 0x40
    96ee:	001a      	movs	r2, r3
    96f0:	2314      	movs	r3, #20
    96f2:	18fb      	adds	r3, r7, r3
    96f4:	0018      	movs	r0, r3
    96f6:	4b1d      	ldr	r3, [pc, #116]	; (976c <atcacert_get_comp_cert+0xe4>)
    96f8:	4798      	blx	r3
    96fa:	0003      	movs	r3, r0
    96fc:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (ret != ATCACERT_E_SUCCESS)
    96fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9700:	2b00      	cmp	r3, #0
    9702:	d001      	beq.n	9708 <atcacert_get_comp_cert+0x80>
		return ret;
    9704:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9706:	e029      	b.n	975c <atcacert_get_comp_cert+0xd4>

	ret = atcacert_get_signer_id(cert_def, cert, cert_size, &comp_cert[67]);
    9708:	683b      	ldr	r3, [r7, #0]
    970a:	3343      	adds	r3, #67	; 0x43
    970c:	687a      	ldr	r2, [r7, #4]
    970e:	68b9      	ldr	r1, [r7, #8]
    9710:	68f8      	ldr	r0, [r7, #12]
    9712:	4c17      	ldr	r4, [pc, #92]	; (9770 <atcacert_get_comp_cert+0xe8>)
    9714:	47a0      	blx	r4
    9716:	0003      	movs	r3, r0
    9718:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (ret != ATCACERT_E_SUCCESS)
    971a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    971c:	2b00      	cmp	r3, #0
    971e:	d001      	beq.n	9724 <atcacert_get_comp_cert+0x9c>
		return ret;
    9720:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9722:	e01b      	b.n	975c <atcacert_get_comp_cert+0xd4>

	comp_cert[69] = ((cert_def->template_id & 0x0F) << 4) | (cert_def->chain_id & 0x0F);
    9724:	683b      	ldr	r3, [r7, #0]
    9726:	3345      	adds	r3, #69	; 0x45
    9728:	68fa      	ldr	r2, [r7, #12]
    972a:	7852      	ldrb	r2, [r2, #1]
    972c:	0112      	lsls	r2, r2, #4
    972e:	b251      	sxtb	r1, r2
    9730:	68fa      	ldr	r2, [r7, #12]
    9732:	7892      	ldrb	r2, [r2, #2]
    9734:	b252      	sxtb	r2, r2
    9736:	200f      	movs	r0, #15
    9738:	4002      	ands	r2, r0
    973a:	b252      	sxtb	r2, r2
    973c:	430a      	orrs	r2, r1
    973e:	b252      	sxtb	r2, r2
    9740:	b2d2      	uxtb	r2, r2
    9742:	701a      	strb	r2, [r3, #0]
	comp_cert[70] = ((uint8_t)(cert_def->sn_source & 0x0F) << 4) | 0;
    9744:	683b      	ldr	r3, [r7, #0]
    9746:	3346      	adds	r3, #70	; 0x46
    9748:	68fa      	ldr	r2, [r7, #12]
    974a:	7912      	ldrb	r2, [r2, #4]
    974c:	0112      	lsls	r2, r2, #4
    974e:	b2d2      	uxtb	r2, r2
    9750:	701a      	strb	r2, [r3, #0]
	comp_cert[71] = 0;
    9752:	683b      	ldr	r3, [r7, #0]
    9754:	3347      	adds	r3, #71	; 0x47
    9756:	2200      	movs	r2, #0
    9758:	701a      	strb	r2, [r3, #0]

	return ATCACERT_E_SUCCESS;
    975a:	2300      	movs	r3, #0
}
    975c:	0018      	movs	r0, r3
    975e:	46bd      	mov	sp, r7
    9760:	b00d      	add	sp, #52	; 0x34
    9762:	bd90      	pop	{r4, r7, pc}
    9764:	00008b15 	.word	0x00008b15
    9768:	00008c55 	.word	0x00008c55
    976c:	0000708d 	.word	0x0000708d
    9770:	00008fc5 	.word	0x00008fc5

00009774 <atcacert_get_tbs>:
int atcacert_get_tbs( const atcacert_def_t* cert_def,
                      const uint8_t*        cert,
                      size_t cert_size,
                      const uint8_t**       tbs,
                      size_t*               tbs_size)
{
    9774:	b580      	push	{r7, lr}
    9776:	b084      	sub	sp, #16
    9778:	af00      	add	r7, sp, #0
    977a:	60f8      	str	r0, [r7, #12]
    977c:	60b9      	str	r1, [r7, #8]
    977e:	607a      	str	r2, [r7, #4]
    9780:	603b      	str	r3, [r7, #0]
	if (cert_def == NULL || cert == NULL || tbs == NULL || tbs_size == NULL)
    9782:	68fb      	ldr	r3, [r7, #12]
    9784:	2b00      	cmp	r3, #0
    9786:	d008      	beq.n	979a <atcacert_get_tbs+0x26>
    9788:	68bb      	ldr	r3, [r7, #8]
    978a:	2b00      	cmp	r3, #0
    978c:	d005      	beq.n	979a <atcacert_get_tbs+0x26>
    978e:	683b      	ldr	r3, [r7, #0]
    9790:	2b00      	cmp	r3, #0
    9792:	d002      	beq.n	979a <atcacert_get_tbs+0x26>
    9794:	69bb      	ldr	r3, [r7, #24]
    9796:	2b00      	cmp	r3, #0
    9798:	d101      	bne.n	979e <atcacert_get_tbs+0x2a>
		return ATCACERT_E_BAD_PARAMS;
    979a:	2302      	movs	r3, #2
    979c:	e027      	b.n	97ee <atcacert_get_tbs+0x7a>

	if ((size_t)cert_def->tbs_cert_loc.offset + (size_t)cert_def->tbs_cert_loc.count > cert_size)
    979e:	68fb      	ldr	r3, [r7, #12]
    97a0:	7b9a      	ldrb	r2, [r3, #14]
    97a2:	7bdb      	ldrb	r3, [r3, #15]
    97a4:	021b      	lsls	r3, r3, #8
    97a6:	4313      	orrs	r3, r2
    97a8:	b29b      	uxth	r3, r3
    97aa:	0019      	movs	r1, r3
    97ac:	68fb      	ldr	r3, [r7, #12]
    97ae:	7c1a      	ldrb	r2, [r3, #16]
    97b0:	7c5b      	ldrb	r3, [r3, #17]
    97b2:	021b      	lsls	r3, r3, #8
    97b4:	4313      	orrs	r3, r2
    97b6:	b29b      	uxth	r3, r3
    97b8:	18ca      	adds	r2, r1, r3
    97ba:	687b      	ldr	r3, [r7, #4]
    97bc:	429a      	cmp	r2, r3
    97be:	d901      	bls.n	97c4 <atcacert_get_tbs+0x50>
		return ATCACERT_E_BAD_CERT;
    97c0:	230a      	movs	r3, #10
    97c2:	e014      	b.n	97ee <atcacert_get_tbs+0x7a>

	*tbs      = &cert[cert_def->tbs_cert_loc.offset];
    97c4:	68fb      	ldr	r3, [r7, #12]
    97c6:	7b9a      	ldrb	r2, [r3, #14]
    97c8:	7bdb      	ldrb	r3, [r3, #15]
    97ca:	021b      	lsls	r3, r3, #8
    97cc:	4313      	orrs	r3, r2
    97ce:	b29b      	uxth	r3, r3
    97d0:	001a      	movs	r2, r3
    97d2:	68bb      	ldr	r3, [r7, #8]
    97d4:	189a      	adds	r2, r3, r2
    97d6:	683b      	ldr	r3, [r7, #0]
    97d8:	601a      	str	r2, [r3, #0]
	*tbs_size = cert_def->tbs_cert_loc.count;
    97da:	68fb      	ldr	r3, [r7, #12]
    97dc:	7c1a      	ldrb	r2, [r3, #16]
    97de:	7c5b      	ldrb	r3, [r3, #17]
    97e0:	021b      	lsls	r3, r3, #8
    97e2:	4313      	orrs	r3, r2
    97e4:	b29b      	uxth	r3, r3
    97e6:	001a      	movs	r2, r3
    97e8:	69bb      	ldr	r3, [r7, #24]
    97ea:	601a      	str	r2, [r3, #0]

	return ATCACERT_E_SUCCESS;
    97ec:	2300      	movs	r3, #0
}
    97ee:	0018      	movs	r0, r3
    97f0:	46bd      	mov	sp, r7
    97f2:	b004      	add	sp, #16
    97f4:	bd80      	pop	{r7, pc}
    97f6:	46c0      	nop			; (mov r8, r8)

000097f8 <atcacert_get_tbs_digest>:

int atcacert_get_tbs_digest( const atcacert_def_t* cert_def,
                             const uint8_t*        cert,
                             size_t cert_size,
                             uint8_t tbs_digest[32])
{
    97f8:	b590      	push	{r4, r7, lr}
    97fa:	b08b      	sub	sp, #44	; 0x2c
    97fc:	af02      	add	r7, sp, #8
    97fe:	60f8      	str	r0, [r7, #12]
    9800:	60b9      	str	r1, [r7, #8]
    9802:	607a      	str	r2, [r7, #4]
    9804:	603b      	str	r3, [r7, #0]
	int ret = ATCACERT_E_SUCCESS;
    9806:	2300      	movs	r3, #0
    9808:	61fb      	str	r3, [r7, #28]
	const uint8_t* tbs = NULL;
    980a:	2300      	movs	r3, #0
    980c:	61bb      	str	r3, [r7, #24]
	size_t tbs_size = 0;
    980e:	2300      	movs	r3, #0
    9810:	617b      	str	r3, [r7, #20]

	if (cert_def == NULL || cert == NULL || tbs_digest == NULL)
    9812:	68fb      	ldr	r3, [r7, #12]
    9814:	2b00      	cmp	r3, #0
    9816:	d005      	beq.n	9824 <atcacert_get_tbs_digest+0x2c>
    9818:	68bb      	ldr	r3, [r7, #8]
    981a:	2b00      	cmp	r3, #0
    981c:	d002      	beq.n	9824 <atcacert_get_tbs_digest+0x2c>
    981e:	683b      	ldr	r3, [r7, #0]
    9820:	2b00      	cmp	r3, #0
    9822:	d101      	bne.n	9828 <atcacert_get_tbs_digest+0x30>
		return ATCACERT_E_BAD_PARAMS;
    9824:	2302      	movs	r3, #2
    9826:	e01f      	b.n	9868 <atcacert_get_tbs_digest+0x70>

	ret = atcacert_get_tbs(cert_def, cert, cert_size, &tbs, &tbs_size);
    9828:	2318      	movs	r3, #24
    982a:	18fc      	adds	r4, r7, r3
    982c:	687a      	ldr	r2, [r7, #4]
    982e:	68b9      	ldr	r1, [r7, #8]
    9830:	68f8      	ldr	r0, [r7, #12]
    9832:	2314      	movs	r3, #20
    9834:	18fb      	adds	r3, r7, r3
    9836:	9300      	str	r3, [sp, #0]
    9838:	0023      	movs	r3, r4
    983a:	4c0d      	ldr	r4, [pc, #52]	; (9870 <atcacert_get_tbs_digest+0x78>)
    983c:	47a0      	blx	r4
    983e:	0003      	movs	r3, r0
    9840:	61fb      	str	r3, [r7, #28]
	if (ret != ATCACERT_E_SUCCESS)
    9842:	69fb      	ldr	r3, [r7, #28]
    9844:	2b00      	cmp	r3, #0
    9846:	d001      	beq.n	984c <atcacert_get_tbs_digest+0x54>
		return ret;
    9848:	69fb      	ldr	r3, [r7, #28]
    984a:	e00d      	b.n	9868 <atcacert_get_tbs_digest+0x70>

	ret = atcac_sw_sha2_256(tbs, tbs_size, tbs_digest);
    984c:	69bb      	ldr	r3, [r7, #24]
    984e:	6979      	ldr	r1, [r7, #20]
    9850:	683a      	ldr	r2, [r7, #0]
    9852:	0018      	movs	r0, r3
    9854:	4b07      	ldr	r3, [pc, #28]	; (9874 <atcacert_get_tbs_digest+0x7c>)
    9856:	4798      	blx	r3
    9858:	0003      	movs	r3, r0
    985a:	61fb      	str	r3, [r7, #28]
	if (ret != ATCACERT_E_SUCCESS)
    985c:	69fb      	ldr	r3, [r7, #28]
    985e:	2b00      	cmp	r3, #0
    9860:	d001      	beq.n	9866 <atcacert_get_tbs_digest+0x6e>
		return ret;
    9862:	69fb      	ldr	r3, [r7, #28]
    9864:	e000      	b.n	9868 <atcacert_get_tbs_digest+0x70>

	return ret;
    9866:	69fb      	ldr	r3, [r7, #28]
}
    9868:	0018      	movs	r0, r3
    986a:	46bd      	mov	sp, r7
    986c:	b009      	add	sp, #36	; 0x24
    986e:	bd90      	pop	{r4, r7, pc}
    9870:	00009775 	.word	0x00009775
    9874:	0000d389 	.word	0x0000d389

00009878 <atcacert_set_cert_element>:
int atcacert_set_cert_element( const atcacert_cert_loc_t* cert_loc,
                               uint8_t*                   cert,
                               size_t cert_size,
                               const uint8_t*             data,
                               size_t data_size)
{
    9878:	b580      	push	{r7, lr}
    987a:	b084      	sub	sp, #16
    987c:	af00      	add	r7, sp, #0
    987e:	60f8      	str	r0, [r7, #12]
    9880:	60b9      	str	r1, [r7, #8]
    9882:	607a      	str	r2, [r7, #4]
    9884:	603b      	str	r3, [r7, #0]
	if (cert_loc == NULL || cert == NULL)
    9886:	68fb      	ldr	r3, [r7, #12]
    9888:	2b00      	cmp	r3, #0
    988a:	d002      	beq.n	9892 <atcacert_set_cert_element+0x1a>
    988c:	68bb      	ldr	r3, [r7, #8]
    988e:	2b00      	cmp	r3, #0
    9890:	d101      	bne.n	9896 <atcacert_set_cert_element+0x1e>
		return ATCACERT_E_BAD_PARAMS;
    9892:	2302      	movs	r3, #2
    9894:	e03c      	b.n	9910 <atcacert_set_cert_element+0x98>

	if (cert_loc->count == 0)
    9896:	68fb      	ldr	r3, [r7, #12]
    9898:	789a      	ldrb	r2, [r3, #2]
    989a:	78db      	ldrb	r3, [r3, #3]
    989c:	021b      	lsls	r3, r3, #8
    989e:	4313      	orrs	r3, r2
    98a0:	b29b      	uxth	r3, r3
    98a2:	2b00      	cmp	r3, #0
    98a4:	d101      	bne.n	98aa <atcacert_set_cert_element+0x32>
		return ATCACERT_E_SUCCESS; // This element doesn't exist in the cert, but we treat this as a success
    98a6:	2300      	movs	r3, #0
    98a8:	e032      	b.n	9910 <atcacert_set_cert_element+0x98>

	if (data == NULL)
    98aa:	683b      	ldr	r3, [r7, #0]
    98ac:	2b00      	cmp	r3, #0
    98ae:	d101      	bne.n	98b4 <atcacert_set_cert_element+0x3c>
		return ATCACERT_E_BAD_PARAMS;
    98b0:	2302      	movs	r3, #2
    98b2:	e02d      	b.n	9910 <atcacert_set_cert_element+0x98>

	if (data_size != cert_loc->count)
    98b4:	68fb      	ldr	r3, [r7, #12]
    98b6:	789a      	ldrb	r2, [r3, #2]
    98b8:	78db      	ldrb	r3, [r3, #3]
    98ba:	021b      	lsls	r3, r3, #8
    98bc:	4313      	orrs	r3, r2
    98be:	b29b      	uxth	r3, r3
    98c0:	1e1a      	subs	r2, r3, #0
    98c2:	69bb      	ldr	r3, [r7, #24]
    98c4:	429a      	cmp	r2, r3
    98c6:	d001      	beq.n	98cc <atcacert_set_cert_element+0x54>
		return ATCACERT_E_UNEXPECTED_ELEM_SIZE;
    98c8:	2307      	movs	r3, #7
    98ca:	e021      	b.n	9910 <atcacert_set_cert_element+0x98>

	if ((size_t)cert_loc->offset + cert_loc->count > cert_size)
    98cc:	68fb      	ldr	r3, [r7, #12]
    98ce:	781a      	ldrb	r2, [r3, #0]
    98d0:	785b      	ldrb	r3, [r3, #1]
    98d2:	021b      	lsls	r3, r3, #8
    98d4:	4313      	orrs	r3, r2
    98d6:	b29b      	uxth	r3, r3
    98d8:	0019      	movs	r1, r3
    98da:	68fb      	ldr	r3, [r7, #12]
    98dc:	789a      	ldrb	r2, [r3, #2]
    98de:	78db      	ldrb	r3, [r3, #3]
    98e0:	021b      	lsls	r3, r3, #8
    98e2:	4313      	orrs	r3, r2
    98e4:	b29b      	uxth	r3, r3
    98e6:	18ca      	adds	r2, r1, r3
    98e8:	687b      	ldr	r3, [r7, #4]
    98ea:	429a      	cmp	r2, r3
    98ec:	d901      	bls.n	98f2 <atcacert_set_cert_element+0x7a>
		return ATCACERT_E_ELEM_OUT_OF_BOUNDS;
    98ee:	2309      	movs	r3, #9
    98f0:	e00e      	b.n	9910 <atcacert_set_cert_element+0x98>

	memcpy(&cert[cert_loc->offset], data, data_size);
    98f2:	68fb      	ldr	r3, [r7, #12]
    98f4:	781a      	ldrb	r2, [r3, #0]
    98f6:	785b      	ldrb	r3, [r3, #1]
    98f8:	021b      	lsls	r3, r3, #8
    98fa:	4313      	orrs	r3, r2
    98fc:	b29b      	uxth	r3, r3
    98fe:	001a      	movs	r2, r3
    9900:	68bb      	ldr	r3, [r7, #8]
    9902:	189b      	adds	r3, r3, r2
    9904:	69ba      	ldr	r2, [r7, #24]
    9906:	6839      	ldr	r1, [r7, #0]
    9908:	0018      	movs	r0, r3
    990a:	4b03      	ldr	r3, [pc, #12]	; (9918 <atcacert_set_cert_element+0xa0>)
    990c:	4798      	blx	r3

	return ATCACERT_E_SUCCESS;
    990e:	2300      	movs	r3, #0
}
    9910:	0018      	movs	r0, r3
    9912:	46bd      	mov	sp, r7
    9914:	b004      	add	sp, #16
    9916:	bd80      	pop	{r7, pc}
    9918:	000127e7 	.word	0x000127e7

0000991c <atcacert_get_cert_element>:
int atcacert_get_cert_element( const atcacert_cert_loc_t* cert_loc,
                               const uint8_t*             cert,
                               size_t cert_size,
                               uint8_t*                   data,
                               size_t data_size)
{
    991c:	b580      	push	{r7, lr}
    991e:	b084      	sub	sp, #16
    9920:	af00      	add	r7, sp, #0
    9922:	60f8      	str	r0, [r7, #12]
    9924:	60b9      	str	r1, [r7, #8]
    9926:	607a      	str	r2, [r7, #4]
    9928:	603b      	str	r3, [r7, #0]
	if (cert_loc == NULL || cert == NULL || data == NULL)
    992a:	68fb      	ldr	r3, [r7, #12]
    992c:	2b00      	cmp	r3, #0
    992e:	d005      	beq.n	993c <atcacert_get_cert_element+0x20>
    9930:	68bb      	ldr	r3, [r7, #8]
    9932:	2b00      	cmp	r3, #0
    9934:	d002      	beq.n	993c <atcacert_get_cert_element+0x20>
    9936:	683b      	ldr	r3, [r7, #0]
    9938:	2b00      	cmp	r3, #0
    993a:	d101      	bne.n	9940 <atcacert_get_cert_element+0x24>
		return ATCACERT_E_BAD_PARAMS;
    993c:	2302      	movs	r3, #2
    993e:	e037      	b.n	99b0 <atcacert_get_cert_element+0x94>

	if (cert_loc->count == 0)
    9940:	68fb      	ldr	r3, [r7, #12]
    9942:	789a      	ldrb	r2, [r3, #2]
    9944:	78db      	ldrb	r3, [r3, #3]
    9946:	021b      	lsls	r3, r3, #8
    9948:	4313      	orrs	r3, r2
    994a:	b29b      	uxth	r3, r3
    994c:	2b00      	cmp	r3, #0
    994e:	d101      	bne.n	9954 <atcacert_get_cert_element+0x38>
		return ATCACERT_E_ELEM_MISSING; // This element doesn't exist in the certificate
    9950:	2308      	movs	r3, #8
    9952:	e02d      	b.n	99b0 <atcacert_get_cert_element+0x94>

	if (cert_loc->count != data_size)
    9954:	68fb      	ldr	r3, [r7, #12]
    9956:	789a      	ldrb	r2, [r3, #2]
    9958:	78db      	ldrb	r3, [r3, #3]
    995a:	021b      	lsls	r3, r3, #8
    995c:	4313      	orrs	r3, r2
    995e:	b29b      	uxth	r3, r3
    9960:	1e1a      	subs	r2, r3, #0
    9962:	69bb      	ldr	r3, [r7, #24]
    9964:	429a      	cmp	r2, r3
    9966:	d001      	beq.n	996c <atcacert_get_cert_element+0x50>
		return ATCACERT_E_UNEXPECTED_ELEM_SIZE;
    9968:	2307      	movs	r3, #7
    996a:	e021      	b.n	99b0 <atcacert_get_cert_element+0x94>

	if ((size_t)cert_loc->offset + cert_loc->count > cert_size)
    996c:	68fb      	ldr	r3, [r7, #12]
    996e:	781a      	ldrb	r2, [r3, #0]
    9970:	785b      	ldrb	r3, [r3, #1]
    9972:	021b      	lsls	r3, r3, #8
    9974:	4313      	orrs	r3, r2
    9976:	b29b      	uxth	r3, r3
    9978:	0019      	movs	r1, r3
    997a:	68fb      	ldr	r3, [r7, #12]
    997c:	789a      	ldrb	r2, [r3, #2]
    997e:	78db      	ldrb	r3, [r3, #3]
    9980:	021b      	lsls	r3, r3, #8
    9982:	4313      	orrs	r3, r2
    9984:	b29b      	uxth	r3, r3
    9986:	18ca      	adds	r2, r1, r3
    9988:	687b      	ldr	r3, [r7, #4]
    998a:	429a      	cmp	r2, r3
    998c:	d901      	bls.n	9992 <atcacert_get_cert_element+0x76>
		return ATCACERT_E_ELEM_OUT_OF_BOUNDS;
    998e:	2309      	movs	r3, #9
    9990:	e00e      	b.n	99b0 <atcacert_get_cert_element+0x94>

	memcpy(data, &cert[cert_loc->offset], data_size);
    9992:	68fb      	ldr	r3, [r7, #12]
    9994:	781a      	ldrb	r2, [r3, #0]
    9996:	785b      	ldrb	r3, [r3, #1]
    9998:	021b      	lsls	r3, r3, #8
    999a:	4313      	orrs	r3, r2
    999c:	b29b      	uxth	r3, r3
    999e:	001a      	movs	r2, r3
    99a0:	68bb      	ldr	r3, [r7, #8]
    99a2:	1899      	adds	r1, r3, r2
    99a4:	69ba      	ldr	r2, [r7, #24]
    99a6:	683b      	ldr	r3, [r7, #0]
    99a8:	0018      	movs	r0, r3
    99aa:	4b03      	ldr	r3, [pc, #12]	; (99b8 <atcacert_get_cert_element+0x9c>)
    99ac:	4798      	blx	r3

	return ATCACERT_E_SUCCESS;
    99ae:	2300      	movs	r3, #0
}
    99b0:	0018      	movs	r0, r3
    99b2:	46bd      	mov	sp, r7
    99b4:	b004      	add	sp, #16
    99b6:	bd80      	pop	{r7, pc}
    99b8:	000127e7 	.word	0x000127e7

000099bc <atcacert_get_key_id>:

int atcacert_get_key_id(const uint8_t public_key[64], uint8_t key_id[20])
{
    99bc:	b580      	push	{r7, lr}
    99be:	b094      	sub	sp, #80	; 0x50
    99c0:	af00      	add	r7, sp, #0
    99c2:	6078      	str	r0, [r7, #4]
    99c4:	6039      	str	r1, [r7, #0]
	uint8_t msg[65];

	if (public_key == NULL || key_id == NULL)
    99c6:	687b      	ldr	r3, [r7, #4]
    99c8:	2b00      	cmp	r3, #0
    99ca:	d002      	beq.n	99d2 <atcacert_get_key_id+0x16>
    99cc:	683b      	ldr	r3, [r7, #0]
    99ce:	2b00      	cmp	r3, #0
    99d0:	d101      	bne.n	99d6 <atcacert_get_key_id+0x1a>
		return ATCACERT_E_BAD_PARAMS;
    99d2:	2302      	movs	r3, #2
    99d4:	e013      	b.n	99fe <atcacert_get_key_id+0x42>

	msg[0] = 0x04;
    99d6:	230c      	movs	r3, #12
    99d8:	18fb      	adds	r3, r7, r3
    99da:	2204      	movs	r2, #4
    99dc:	701a      	strb	r2, [r3, #0]
	memcpy(&msg[1], public_key, 64);
    99de:	6879      	ldr	r1, [r7, #4]
    99e0:	230c      	movs	r3, #12
    99e2:	18fb      	adds	r3, r7, r3
    99e4:	3301      	adds	r3, #1
    99e6:	2240      	movs	r2, #64	; 0x40
    99e8:	0018      	movs	r0, r3
    99ea:	4b07      	ldr	r3, [pc, #28]	; (9a08 <atcacert_get_key_id+0x4c>)
    99ec:	4798      	blx	r3

	return atcac_sw_sha1(msg, sizeof(msg), key_id);
    99ee:	683a      	ldr	r2, [r7, #0]
    99f0:	230c      	movs	r3, #12
    99f2:	18fb      	adds	r3, r7, r3
    99f4:	2141      	movs	r1, #65	; 0x41
    99f6:	0018      	movs	r0, r3
    99f8:	4b04      	ldr	r3, [pc, #16]	; (9a0c <atcacert_get_key_id+0x50>)
    99fa:	4798      	blx	r3
    99fc:	0003      	movs	r3, r0
}
    99fe:	0018      	movs	r0, r3
    9a00:	46bd      	mov	sp, r7
    9a02:	b014      	add	sp, #80	; 0x50
    9a04:	bd80      	pop	{r7, pc}
    9a06:	46c0      	nop			; (mov r8, r8)
    9a08:	000127e7 	.word	0x000127e7
    9a0c:	0000d285 	.word	0x0000d285

00009a10 <atcacert_public_key_add_padding>:

void atcacert_public_key_add_padding(const uint8_t raw_key[64], uint8_t padded_key[72])
{
    9a10:	b580      	push	{r7, lr}
    9a12:	b082      	sub	sp, #8
    9a14:	af00      	add	r7, sp, #0
    9a16:	6078      	str	r0, [r7, #4]
    9a18:	6039      	str	r1, [r7, #0]
	memmove(&padded_key[40], &raw_key[32], 32); // Move Y to padded position
    9a1a:	683b      	ldr	r3, [r7, #0]
    9a1c:	3328      	adds	r3, #40	; 0x28
    9a1e:	0018      	movs	r0, r3
    9a20:	687b      	ldr	r3, [r7, #4]
    9a22:	3320      	adds	r3, #32
    9a24:	2220      	movs	r2, #32
    9a26:	0019      	movs	r1, r3
    9a28:	4b0c      	ldr	r3, [pc, #48]	; (9a5c <atcacert_public_key_add_padding+0x4c>)
    9a2a:	4798      	blx	r3
	memset(&padded_key[36], 0, 4);              // Add Y padding bytes
    9a2c:	683b      	ldr	r3, [r7, #0]
    9a2e:	3324      	adds	r3, #36	; 0x24
    9a30:	2204      	movs	r2, #4
    9a32:	2100      	movs	r1, #0
    9a34:	0018      	movs	r0, r3
    9a36:	4b0a      	ldr	r3, [pc, #40]	; (9a60 <atcacert_public_key_add_padding+0x50>)
    9a38:	4798      	blx	r3
	memmove(&padded_key[4], &raw_key[0], 32);   // Move X to padded position
    9a3a:	683b      	ldr	r3, [r7, #0]
    9a3c:	3304      	adds	r3, #4
    9a3e:	6879      	ldr	r1, [r7, #4]
    9a40:	2220      	movs	r2, #32
    9a42:	0018      	movs	r0, r3
    9a44:	4b05      	ldr	r3, [pc, #20]	; (9a5c <atcacert_public_key_add_padding+0x4c>)
    9a46:	4798      	blx	r3
	memset(&padded_key[0], 0, 4);               // Add X padding bytes
    9a48:	683b      	ldr	r3, [r7, #0]
    9a4a:	2204      	movs	r2, #4
    9a4c:	2100      	movs	r1, #0
    9a4e:	0018      	movs	r0, r3
    9a50:	4b03      	ldr	r3, [pc, #12]	; (9a60 <atcacert_public_key_add_padding+0x50>)
    9a52:	4798      	blx	r3
}
    9a54:	46c0      	nop			; (mov r8, r8)
    9a56:	46bd      	mov	sp, r7
    9a58:	b002      	add	sp, #8
    9a5a:	bd80      	pop	{r7, pc}
    9a5c:	000127f9 	.word	0x000127f9
    9a60:	00012823 	.word	0x00012823

00009a64 <atcacert_public_key_remove_padding>:

void atcacert_public_key_remove_padding(const uint8_t padded_key[72], uint8_t raw_key[64])
{
    9a64:	b580      	push	{r7, lr}
    9a66:	b082      	sub	sp, #8
    9a68:	af00      	add	r7, sp, #0
    9a6a:	6078      	str	r0, [r7, #4]
    9a6c:	6039      	str	r1, [r7, #0]
	memmove(&raw_key[0], &padded_key[4], 32);   // Move X
    9a6e:	687b      	ldr	r3, [r7, #4]
    9a70:	1d19      	adds	r1, r3, #4
    9a72:	683b      	ldr	r3, [r7, #0]
    9a74:	2220      	movs	r2, #32
    9a76:	0018      	movs	r0, r3
    9a78:	4b07      	ldr	r3, [pc, #28]	; (9a98 <atcacert_public_key_remove_padding+0x34>)
    9a7a:	4798      	blx	r3
	memmove(&raw_key[32], &padded_key[40], 32); // Move Y
    9a7c:	683b      	ldr	r3, [r7, #0]
    9a7e:	3320      	adds	r3, #32
    9a80:	0018      	movs	r0, r3
    9a82:	687b      	ldr	r3, [r7, #4]
    9a84:	3328      	adds	r3, #40	; 0x28
    9a86:	2220      	movs	r2, #32
    9a88:	0019      	movs	r1, r3
    9a8a:	4b03      	ldr	r3, [pc, #12]	; (9a98 <atcacert_public_key_remove_padding+0x34>)
    9a8c:	4798      	blx	r3
    9a8e:	46c0      	nop			; (mov r8, r8)
    9a90:	46bd      	mov	sp, r7
    9a92:	b002      	add	sp, #8
    9a94:	bd80      	pop	{r7, pc}
    9a96:	46c0      	nop			; (mov r8, r8)
    9a98:	000127f9 	.word	0x000127f9

00009a9c <atcacert_der_enc_length>:

#include "atcacert_der.h"
#include <string.h>

int atcacert_der_enc_length(uint32_t length, uint8_t* der_length, size_t* der_length_size)
{
    9a9c:	b580      	push	{r7, lr}
    9a9e:	b086      	sub	sp, #24
    9aa0:	af00      	add	r7, sp, #0
    9aa2:	60f8      	str	r0, [r7, #12]
    9aa4:	60b9      	str	r1, [r7, #8]
    9aa6:	607a      	str	r2, [r7, #4]
	size_t der_length_size_calc = 0;
    9aa8:	2300      	movs	r3, #0
    9aaa:	617b      	str	r3, [r7, #20]
	int exp = sizeof(length) - 1;
    9aac:	2303      	movs	r3, #3
    9aae:	613b      	str	r3, [r7, #16]

	if (der_length_size == NULL)
    9ab0:	687b      	ldr	r3, [r7, #4]
    9ab2:	2b00      	cmp	r3, #0
    9ab4:	d101      	bne.n	9aba <atcacert_der_enc_length+0x1e>
		return ATCACERT_E_BAD_PARAMS;
    9ab6:	2302      	movs	r3, #2
    9ab8:	e049      	b.n	9b4e <atcacert_der_enc_length+0xb2>

	if (length < 0x80) {
    9aba:	68fb      	ldr	r3, [r7, #12]
    9abc:	2b7f      	cmp	r3, #127	; 0x7f
    9abe:	d807      	bhi.n	9ad0 <atcacert_der_enc_length+0x34>
		// The length can take the short form with only one byte
		der_length_size_calc = 1;
    9ac0:	2301      	movs	r3, #1
    9ac2:	617b      	str	r3, [r7, #20]
		exp = 0;
    9ac4:	2300      	movs	r3, #0
    9ac6:	613b      	str	r3, [r7, #16]
    9ac8:	e00b      	b.n	9ae2 <atcacert_der_enc_length+0x46>
	}else {
		// Length is long-form, encoded as a multi-byte big-endian unsigned integer

		// Find first non-zero octet
		while (length / ((uint32_t)1 << (8 * exp)) == 0)
			exp--;
    9aca:	693b      	ldr	r3, [r7, #16]
    9acc:	3b01      	subs	r3, #1
    9ace:	613b      	str	r3, [r7, #16]
		exp = 0;
	}else {
		// Length is long-form, encoded as a multi-byte big-endian unsigned integer

		// Find first non-zero octet
		while (length / ((uint32_t)1 << (8 * exp)) == 0)
    9ad0:	693b      	ldr	r3, [r7, #16]
    9ad2:	00db      	lsls	r3, r3, #3
    9ad4:	68fa      	ldr	r2, [r7, #12]
    9ad6:	40da      	lsrs	r2, r3
    9ad8:	1e13      	subs	r3, r2, #0
    9ada:	d0f6      	beq.n	9aca <atcacert_der_enc_length+0x2e>
			exp--;

		der_length_size_calc = 2 + exp;
    9adc:	693b      	ldr	r3, [r7, #16]
    9ade:	3302      	adds	r3, #2
    9ae0:	617b      	str	r3, [r7, #20]
	}

	if (der_length != NULL && *der_length_size < der_length_size_calc) {
    9ae2:	68bb      	ldr	r3, [r7, #8]
    9ae4:	2b00      	cmp	r3, #0
    9ae6:	d009      	beq.n	9afc <atcacert_der_enc_length+0x60>
    9ae8:	687b      	ldr	r3, [r7, #4]
    9aea:	681a      	ldr	r2, [r3, #0]
    9aec:	697b      	ldr	r3, [r7, #20]
    9aee:	429a      	cmp	r2, r3
    9af0:	d204      	bcs.n	9afc <atcacert_der_enc_length+0x60>
		*der_length_size = der_length_size_calc;
    9af2:	687b      	ldr	r3, [r7, #4]
    9af4:	697a      	ldr	r2, [r7, #20]
    9af6:	601a      	str	r2, [r3, #0]
		return ATCACERT_E_BUFFER_TOO_SMALL;
    9af8:	2303      	movs	r3, #3
    9afa:	e028      	b.n	9b4e <atcacert_der_enc_length+0xb2>
	}

	*der_length_size = der_length_size_calc;
    9afc:	687b      	ldr	r3, [r7, #4]
    9afe:	697a      	ldr	r2, [r7, #20]
    9b00:	601a      	str	r2, [r3, #0]

	if (der_length == NULL)
    9b02:	68bb      	ldr	r3, [r7, #8]
    9b04:	2b00      	cmp	r3, #0
    9b06:	d111      	bne.n	9b2c <atcacert_der_enc_length+0x90>
		return ATCACERT_E_SUCCESS; // Caller is only requesting the size
    9b08:	2300      	movs	r3, #0
    9b0a:	e020      	b.n	9b4e <atcacert_der_enc_length+0xb2>

	// Encode length in big-endian format
	for (; exp >= 0; exp--)
		der_length[der_length_size_calc - 1 - exp] = (uint8_t)((length >> (exp * 8)) & 0xFF);
    9b0c:	693b      	ldr	r3, [r7, #16]
    9b0e:	697a      	ldr	r2, [r7, #20]
    9b10:	1ad3      	subs	r3, r2, r3
    9b12:	3b01      	subs	r3, #1
    9b14:	68ba      	ldr	r2, [r7, #8]
    9b16:	18d3      	adds	r3, r2, r3
    9b18:	693a      	ldr	r2, [r7, #16]
    9b1a:	00d2      	lsls	r2, r2, #3
    9b1c:	68f9      	ldr	r1, [r7, #12]
    9b1e:	40d1      	lsrs	r1, r2
    9b20:	000a      	movs	r2, r1
    9b22:	b2d2      	uxtb	r2, r2
    9b24:	701a      	strb	r2, [r3, #0]

	if (der_length == NULL)
		return ATCACERT_E_SUCCESS; // Caller is only requesting the size

	// Encode length in big-endian format
	for (; exp >= 0; exp--)
    9b26:	693b      	ldr	r3, [r7, #16]
    9b28:	3b01      	subs	r3, #1
    9b2a:	613b      	str	r3, [r7, #16]
    9b2c:	693b      	ldr	r3, [r7, #16]
    9b2e:	2b00      	cmp	r3, #0
    9b30:	daec      	bge.n	9b0c <atcacert_der_enc_length+0x70>
		der_length[der_length_size_calc - 1 - exp] = (uint8_t)((length >> (exp * 8)) & 0xFF);

	if (der_length_size_calc > 1)
    9b32:	697b      	ldr	r3, [r7, #20]
    9b34:	2b01      	cmp	r3, #1
    9b36:	d909      	bls.n	9b4c <atcacert_der_enc_length+0xb0>
		der_length[0] = 0x80 | (uint8_t)(der_length_size_calc - 1); // Set number of bytes octet with long-form flag
    9b38:	697b      	ldr	r3, [r7, #20]
    9b3a:	b2db      	uxtb	r3, r3
    9b3c:	3b01      	subs	r3, #1
    9b3e:	b2db      	uxtb	r3, r3
    9b40:	2280      	movs	r2, #128	; 0x80
    9b42:	4252      	negs	r2, r2
    9b44:	4313      	orrs	r3, r2
    9b46:	b2da      	uxtb	r2, r3
    9b48:	68bb      	ldr	r3, [r7, #8]
    9b4a:	701a      	strb	r2, [r3, #0]

	return ATCACERT_E_SUCCESS;
    9b4c:	2300      	movs	r3, #0
}
    9b4e:	0018      	movs	r0, r3
    9b50:	46bd      	mov	sp, r7
    9b52:	b006      	add	sp, #24
    9b54:	bd80      	pop	{r7, pc}
    9b56:	46c0      	nop			; (mov r8, r8)

00009b58 <atcacert_der_dec_length>:

int atcacert_der_dec_length(const uint8_t* der_length, size_t* der_length_size, uint32_t* length)
{
    9b58:	b580      	push	{r7, lr}
    9b5a:	b086      	sub	sp, #24
    9b5c:	af00      	add	r7, sp, #0
    9b5e:	60f8      	str	r0, [r7, #12]
    9b60:	60b9      	str	r1, [r7, #8]
    9b62:	607a      	str	r2, [r7, #4]
	if (der_length == NULL || der_length_size == NULL)
    9b64:	68fb      	ldr	r3, [r7, #12]
    9b66:	2b00      	cmp	r3, #0
    9b68:	d002      	beq.n	9b70 <atcacert_der_dec_length+0x18>
    9b6a:	68bb      	ldr	r3, [r7, #8]
    9b6c:	2b00      	cmp	r3, #0
    9b6e:	d101      	bne.n	9b74 <atcacert_der_dec_length+0x1c>
		return ATCACERT_E_BAD_PARAMS;
    9b70:	2302      	movs	r3, #2
    9b72:	e053      	b.n	9c1c <atcacert_der_dec_length+0xc4>

	if (*der_length_size < 1)
    9b74:	68bb      	ldr	r3, [r7, #8]
    9b76:	681b      	ldr	r3, [r3, #0]
    9b78:	2b00      	cmp	r3, #0
    9b7a:	d101      	bne.n	9b80 <atcacert_der_dec_length+0x28>
		return ATCACERT_E_DECODING_ERROR;
    9b7c:	2304      	movs	r3, #4
    9b7e:	e04d      	b.n	9c1c <atcacert_der_dec_length+0xc4>

	if (der_length[0] & 0x80) {
    9b80:	68fb      	ldr	r3, [r7, #12]
    9b82:	781b      	ldrb	r3, [r3, #0]
    9b84:	b25b      	sxtb	r3, r3
    9b86:	2b00      	cmp	r3, #0
    9b88:	da3c      	bge.n	9c04 <atcacert_der_dec_length+0xac>
		// Long form
		size_t num_bytes = der_length[0] & 0x7F;
    9b8a:	68fb      	ldr	r3, [r7, #12]
    9b8c:	781b      	ldrb	r3, [r3, #0]
    9b8e:	001a      	movs	r2, r3
    9b90:	237f      	movs	r3, #127	; 0x7f
    9b92:	4013      	ands	r3, r2
    9b94:	613b      	str	r3, [r7, #16]
		size_t i;
		if (*der_length_size < num_bytes + 1)
    9b96:	68bb      	ldr	r3, [r7, #8]
    9b98:	681a      	ldr	r2, [r3, #0]
    9b9a:	693b      	ldr	r3, [r7, #16]
    9b9c:	3301      	adds	r3, #1
    9b9e:	429a      	cmp	r2, r3
    9ba0:	d201      	bcs.n	9ba6 <atcacert_der_dec_length+0x4e>
			return ATCACERT_E_DECODING_ERROR;   //  Invalid DER length format, not enough data.
    9ba2:	2304      	movs	r3, #4
    9ba4:	e03a      	b.n	9c1c <atcacert_der_dec_length+0xc4>
		if (num_bytes == 0)
    9ba6:	693b      	ldr	r3, [r7, #16]
    9ba8:	2b00      	cmp	r3, #0
    9baa:	d101      	bne.n	9bb0 <atcacert_der_dec_length+0x58>
			return ATCACERT_E_DECODING_ERROR;   //  Invalid DER length format, indefinite length not supported.
    9bac:	2304      	movs	r3, #4
    9bae:	e035      	b.n	9c1c <atcacert_der_dec_length+0xc4>
		if (num_bytes > sizeof(*length))
    9bb0:	693b      	ldr	r3, [r7, #16]
    9bb2:	2b04      	cmp	r3, #4
    9bb4:	d901      	bls.n	9bba <atcacert_der_dec_length+0x62>
			return ATCACERT_E_DECODING_ERROR;   //  Can't parse DER length format, larger than length.
    9bb6:	2304      	movs	r3, #4
    9bb8:	e030      	b.n	9c1c <atcacert_der_dec_length+0xc4>

		if (length != NULL) {
    9bba:	687b      	ldr	r3, [r7, #4]
    9bbc:	2b00      	cmp	r3, #0
    9bbe:	d01c      	beq.n	9bfa <atcacert_der_dec_length+0xa2>
			// Decode integer in big-endian format
			*length = 0;
    9bc0:	687b      	ldr	r3, [r7, #4]
    9bc2:	2200      	movs	r2, #0
    9bc4:	601a      	str	r2, [r3, #0]
			for (i = 1; i <= num_bytes; i++)
    9bc6:	2301      	movs	r3, #1
    9bc8:	617b      	str	r3, [r7, #20]
    9bca:	e012      	b.n	9bf2 <atcacert_der_dec_length+0x9a>
				*length += der_length[i] * ((uint32_t)1 << (8 * (num_bytes - i)));
    9bcc:	687b      	ldr	r3, [r7, #4]
    9bce:	681a      	ldr	r2, [r3, #0]
    9bd0:	68f9      	ldr	r1, [r7, #12]
    9bd2:	697b      	ldr	r3, [r7, #20]
    9bd4:	18cb      	adds	r3, r1, r3
    9bd6:	781b      	ldrb	r3, [r3, #0]
    9bd8:	0018      	movs	r0, r3
    9bda:	6939      	ldr	r1, [r7, #16]
    9bdc:	697b      	ldr	r3, [r7, #20]
    9bde:	1acb      	subs	r3, r1, r3
    9be0:	00db      	lsls	r3, r3, #3
    9be2:	4098      	lsls	r0, r3
    9be4:	0003      	movs	r3, r0
    9be6:	18d2      	adds	r2, r2, r3
    9be8:	687b      	ldr	r3, [r7, #4]
    9bea:	601a      	str	r2, [r3, #0]
			return ATCACERT_E_DECODING_ERROR;   //  Can't parse DER length format, larger than length.

		if (length != NULL) {
			// Decode integer in big-endian format
			*length = 0;
			for (i = 1; i <= num_bytes; i++)
    9bec:	697b      	ldr	r3, [r7, #20]
    9bee:	3301      	adds	r3, #1
    9bf0:	617b      	str	r3, [r7, #20]
    9bf2:	697a      	ldr	r2, [r7, #20]
    9bf4:	693b      	ldr	r3, [r7, #16]
    9bf6:	429a      	cmp	r2, r3
    9bf8:	d9e8      	bls.n	9bcc <atcacert_der_dec_length+0x74>
				*length += der_length[i] * ((uint32_t)1 << (8 * (num_bytes - i)));
		}
		*der_length_size = num_bytes + 1; // Return the actual number of bytes the DER length encoding used.
    9bfa:	693b      	ldr	r3, [r7, #16]
    9bfc:	1c5a      	adds	r2, r3, #1
    9bfe:	68bb      	ldr	r3, [r7, #8]
    9c00:	601a      	str	r2, [r3, #0]
    9c02:	e00a      	b.n	9c1a <atcacert_der_dec_length+0xc2>
	}else {
		if (length != NULL)
    9c04:	687b      	ldr	r3, [r7, #4]
    9c06:	2b00      	cmp	r3, #0
    9c08:	d004      	beq.n	9c14 <atcacert_der_dec_length+0xbc>
			*length = der_length[0];
    9c0a:	68fb      	ldr	r3, [r7, #12]
    9c0c:	781b      	ldrb	r3, [r3, #0]
    9c0e:	001a      	movs	r2, r3
    9c10:	687b      	ldr	r3, [r7, #4]
    9c12:	601a      	str	r2, [r3, #0]
		*der_length_size = 1; // Return the actual number of bytes the DER length encoding used.
    9c14:	68bb      	ldr	r3, [r7, #8]
    9c16:	2201      	movs	r2, #1
    9c18:	601a      	str	r2, [r3, #0]
	}

	return ATCACERT_E_SUCCESS;
    9c1a:	2300      	movs	r3, #0
}
    9c1c:	0018      	movs	r0, r3
    9c1e:	46bd      	mov	sp, r7
    9c20:	b006      	add	sp, #24
    9c22:	bd80      	pop	{r7, pc}

00009c24 <atcacert_der_enc_integer>:
int atcacert_der_enc_integer( const uint8_t* int_data,
                              size_t int_data_size,
                              uint8_t is_unsigned,
                              uint8_t*       der_int,
                              size_t*        der_int_size)
{
    9c24:	b580      	push	{r7, lr}
    9c26:	b08c      	sub	sp, #48	; 0x30
    9c28:	af00      	add	r7, sp, #0
    9c2a:	60f8      	str	r0, [r7, #12]
    9c2c:	60b9      	str	r1, [r7, #8]
    9c2e:	603b      	str	r3, [r7, #0]
    9c30:	1dfb      	adds	r3, r7, #7
    9c32:	701a      	strb	r2, [r3, #0]
	uint8_t der_length[5];
	size_t der_length_size = sizeof(der_length);
    9c34:	2305      	movs	r3, #5
    9c36:	617b      	str	r3, [r7, #20]
	size_t der_int_size_calc = 0;
    9c38:	2300      	movs	r3, #0
    9c3a:	627b      	str	r3, [r7, #36]	; 0x24
	size_t trim = 0;
    9c3c:	2300      	movs	r3, #0
    9c3e:	62fb      	str	r3, [r7, #44]	; 0x2c
	size_t pad = 0;
    9c40:	2300      	movs	r3, #0
    9c42:	62bb      	str	r3, [r7, #40]	; 0x28

	if (int_data == NULL || der_int_size == NULL || int_data_size <= 0)
    9c44:	68fb      	ldr	r3, [r7, #12]
    9c46:	2b00      	cmp	r3, #0
    9c48:	d005      	beq.n	9c56 <atcacert_der_enc_integer+0x32>
    9c4a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9c4c:	2b00      	cmp	r3, #0
    9c4e:	d002      	beq.n	9c56 <atcacert_der_enc_integer+0x32>
    9c50:	68bb      	ldr	r3, [r7, #8]
    9c52:	2b00      	cmp	r3, #0
    9c54:	d101      	bne.n	9c5a <atcacert_der_enc_integer+0x36>
		return ATCACERT_E_BAD_PARAMS;
    9c56:	2302      	movs	r3, #2
    9c58:	e087      	b.n	9d6a <atcacert_der_enc_integer+0x146>

	if (!(is_unsigned && (int_data[0] & 0x80))) {
    9c5a:	1dfb      	adds	r3, r7, #7
    9c5c:	781b      	ldrb	r3, [r3, #0]
    9c5e:	2b00      	cmp	r3, #0
    9c60:	d008      	beq.n	9c74 <atcacert_der_enc_integer+0x50>
    9c62:	68fb      	ldr	r3, [r7, #12]
    9c64:	781b      	ldrb	r3, [r3, #0]
    9c66:	b25b      	sxtb	r3, r3
    9c68:	2b00      	cmp	r3, #0
    9c6a:	db25      	blt.n	9cb8 <atcacert_der_enc_integer+0x94>
		// This is not an unsigned value that needs a padding byte, trim any unnecessary bytes.
		// Trim a byte when the upper 9 bits are all 0s or all 1s.
		while (
    9c6c:	e002      	b.n	9c74 <atcacert_der_enc_integer+0x50>
		    (int_data_size - trim >= 2) && (
		        ((int_data[trim] == 0x00) && ((int_data[trim + 1] & 0x80) == 0)) ||
		        ((int_data[trim] == 0xFF) && ((int_data[trim + 1] & 0x80) != 0))))
			trim++;
    9c6e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9c70:	3301      	adds	r3, #1
    9c72:	62fb      	str	r3, [r7, #44]	; 0x2c

	if (!(is_unsigned && (int_data[0] & 0x80))) {
		// This is not an unsigned value that needs a padding byte, trim any unnecessary bytes.
		// Trim a byte when the upper 9 bits are all 0s or all 1s.
		while (
		    (int_data_size - trim >= 2) && (
    9c74:	68ba      	ldr	r2, [r7, #8]
    9c76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9c78:	1ad3      	subs	r3, r2, r3
		return ATCACERT_E_BAD_PARAMS;

	if (!(is_unsigned && (int_data[0] & 0x80))) {
		// This is not an unsigned value that needs a padding byte, trim any unnecessary bytes.
		// Trim a byte when the upper 9 bits are all 0s or all 1s.
		while (
    9c7a:	2b01      	cmp	r3, #1
    9c7c:	d91f      	bls.n	9cbe <atcacert_der_enc_integer+0x9a>
		    (int_data_size - trim >= 2) && (
		        ((int_data[trim] == 0x00) && ((int_data[trim + 1] & 0x80) == 0)) ||
    9c7e:	68fa      	ldr	r2, [r7, #12]
    9c80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9c82:	18d3      	adds	r3, r2, r3
    9c84:	781b      	ldrb	r3, [r3, #0]

	if (!(is_unsigned && (int_data[0] & 0x80))) {
		// This is not an unsigned value that needs a padding byte, trim any unnecessary bytes.
		// Trim a byte when the upper 9 bits are all 0s or all 1s.
		while (
		    (int_data_size - trim >= 2) && (
    9c86:	2b00      	cmp	r3, #0
    9c88:	d107      	bne.n	9c9a <atcacert_der_enc_integer+0x76>
		        ((int_data[trim] == 0x00) && ((int_data[trim + 1] & 0x80) == 0)) ||
    9c8a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9c8c:	3301      	adds	r3, #1
    9c8e:	68fa      	ldr	r2, [r7, #12]
    9c90:	18d3      	adds	r3, r2, r3
    9c92:	781b      	ldrb	r3, [r3, #0]
    9c94:	b25b      	sxtb	r3, r3
    9c96:	2b00      	cmp	r3, #0
    9c98:	dae9      	bge.n	9c6e <atcacert_der_enc_integer+0x4a>
		        ((int_data[trim] == 0xFF) && ((int_data[trim + 1] & 0x80) != 0))))
    9c9a:	68fa      	ldr	r2, [r7, #12]
    9c9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9c9e:	18d3      	adds	r3, r2, r3
    9ca0:	781b      	ldrb	r3, [r3, #0]
	if (!(is_unsigned && (int_data[0] & 0x80))) {
		// This is not an unsigned value that needs a padding byte, trim any unnecessary bytes.
		// Trim a byte when the upper 9 bits are all 0s or all 1s.
		while (
		    (int_data_size - trim >= 2) && (
		        ((int_data[trim] == 0x00) && ((int_data[trim + 1] & 0x80) == 0)) ||
    9ca2:	2bff      	cmp	r3, #255	; 0xff
    9ca4:	d10b      	bne.n	9cbe <atcacert_der_enc_integer+0x9a>
		        ((int_data[trim] == 0xFF) && ((int_data[trim + 1] & 0x80) != 0))))
    9ca6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9ca8:	3301      	adds	r3, #1
    9caa:	68fa      	ldr	r2, [r7, #12]
    9cac:	18d3      	adds	r3, r2, r3
    9cae:	781b      	ldrb	r3, [r3, #0]
    9cb0:	b25b      	sxtb	r3, r3
    9cb2:	2b00      	cmp	r3, #0
    9cb4:	dbdb      	blt.n	9c6e <atcacert_der_enc_integer+0x4a>
	size_t pad = 0;

	if (int_data == NULL || der_int_size == NULL || int_data_size <= 0)
		return ATCACERT_E_BAD_PARAMS;

	if (!(is_unsigned && (int_data[0] & 0x80))) {
    9cb6:	e002      	b.n	9cbe <atcacert_der_enc_integer+0x9a>
		        ((int_data[trim] == 0x00) && ((int_data[trim + 1] & 0x80) == 0)) ||
		        ((int_data[trim] == 0xFF) && ((int_data[trim + 1] & 0x80) != 0))))
			trim++;
	}else
		// Will be adding extra byte for unsigned padding so it's not interpreted as negative
		pad = 1;
    9cb8:	2301      	movs	r3, #1
    9cba:	62bb      	str	r3, [r7, #40]	; 0x28
    9cbc:	e000      	b.n	9cc0 <atcacert_der_enc_integer+0x9c>
	size_t pad = 0;

	if (int_data == NULL || der_int_size == NULL || int_data_size <= 0)
		return ATCACERT_E_BAD_PARAMS;

	if (!(is_unsigned && (int_data[0] & 0x80))) {
    9cbe:	46c0      	nop			; (mov r8, r8)
			trim++;
	}else
		// Will be adding extra byte for unsigned padding so it's not interpreted as negative
		pad = 1;

	int ret = atcacert_der_enc_length(int_data_size + pad - trim, der_length, &der_length_size);
    9cc0:	68ba      	ldr	r2, [r7, #8]
    9cc2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    9cc4:	18d2      	adds	r2, r2, r3
    9cc6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9cc8:	1ad3      	subs	r3, r2, r3
    9cca:	2214      	movs	r2, #20
    9ccc:	18ba      	adds	r2, r7, r2
    9cce:	2118      	movs	r1, #24
    9cd0:	1879      	adds	r1, r7, r1
    9cd2:	0018      	movs	r0, r3
    9cd4:	4b27      	ldr	r3, [pc, #156]	; (9d74 <atcacert_der_enc_integer+0x150>)
    9cd6:	4798      	blx	r3
    9cd8:	0003      	movs	r3, r0
    9cda:	623b      	str	r3, [r7, #32]
	if (ret != ATCACERT_E_SUCCESS)
    9cdc:	6a3b      	ldr	r3, [r7, #32]
    9cde:	2b00      	cmp	r3, #0
    9ce0:	d001      	beq.n	9ce6 <atcacert_der_enc_integer+0xc2>
		return ret;
    9ce2:	6a3b      	ldr	r3, [r7, #32]
    9ce4:	e041      	b.n	9d6a <atcacert_der_enc_integer+0x146>

	der_int_size_calc = 1 + der_length_size + int_data_size + pad - trim;
    9ce6:	697a      	ldr	r2, [r7, #20]
    9ce8:	68bb      	ldr	r3, [r7, #8]
    9cea:	18d2      	adds	r2, r2, r3
    9cec:	6abb      	ldr	r3, [r7, #40]	; 0x28
    9cee:	18d2      	adds	r2, r2, r3
    9cf0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9cf2:	1ad3      	subs	r3, r2, r3
    9cf4:	3301      	adds	r3, #1
    9cf6:	627b      	str	r3, [r7, #36]	; 0x24

	if (der_int != NULL && der_int_size_calc > *der_int_size) {
    9cf8:	683b      	ldr	r3, [r7, #0]
    9cfa:	2b00      	cmp	r3, #0
    9cfc:	d009      	beq.n	9d12 <atcacert_der_enc_integer+0xee>
    9cfe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9d00:	681a      	ldr	r2, [r3, #0]
    9d02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    9d04:	429a      	cmp	r2, r3
    9d06:	d204      	bcs.n	9d12 <atcacert_der_enc_integer+0xee>
		*der_int_size = der_int_size_calc;
    9d08:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9d0a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    9d0c:	601a      	str	r2, [r3, #0]
		return ATCACERT_E_BUFFER_TOO_SMALL;
    9d0e:	2303      	movs	r3, #3
    9d10:	e02b      	b.n	9d6a <atcacert_der_enc_integer+0x146>
	}

	*der_int_size = der_int_size_calc;
    9d12:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9d14:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    9d16:	601a      	str	r2, [r3, #0]

	if (der_int == NULL)
    9d18:	683b      	ldr	r3, [r7, #0]
    9d1a:	2b00      	cmp	r3, #0
    9d1c:	d101      	bne.n	9d22 <atcacert_der_enc_integer+0xfe>
		return ATCACERT_E_SUCCESS;                                                      // Caller just wanted the size of the encoded integer
    9d1e:	2300      	movs	r3, #0
    9d20:	e023      	b.n	9d6a <atcacert_der_enc_integer+0x146>

	der_int[0] = 0x02;                                                                  // Integer tag
    9d22:	683b      	ldr	r3, [r7, #0]
    9d24:	2202      	movs	r2, #2
    9d26:	701a      	strb	r2, [r3, #0]
	memcpy(&der_int[1], der_length, der_length_size);                                   // Integer length
    9d28:	683b      	ldr	r3, [r7, #0]
    9d2a:	3301      	adds	r3, #1
    9d2c:	697a      	ldr	r2, [r7, #20]
    9d2e:	2118      	movs	r1, #24
    9d30:	1879      	adds	r1, r7, r1
    9d32:	0018      	movs	r0, r3
    9d34:	4b10      	ldr	r3, [pc, #64]	; (9d78 <atcacert_der_enc_integer+0x154>)
    9d36:	4798      	blx	r3
	if (pad)
    9d38:	6abb      	ldr	r3, [r7, #40]	; 0x28
    9d3a:	2b00      	cmp	r3, #0
    9d3c:	d005      	beq.n	9d4a <atcacert_der_enc_integer+0x126>
		der_int[der_length_size + 1] = 0;                                               // Unsigned integer value requires padding byte so it's not interpreted as negative
    9d3e:	697b      	ldr	r3, [r7, #20]
    9d40:	3301      	adds	r3, #1
    9d42:	683a      	ldr	r2, [r7, #0]
    9d44:	18d3      	adds	r3, r2, r3
    9d46:	2200      	movs	r2, #0
    9d48:	701a      	strb	r2, [r3, #0]
	memcpy(&der_int[der_length_size + 1 + pad], &int_data[trim], int_data_size - trim); // Integer value
    9d4a:	697a      	ldr	r2, [r7, #20]
    9d4c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    9d4e:	18d3      	adds	r3, r2, r3
    9d50:	3301      	adds	r3, #1
    9d52:	683a      	ldr	r2, [r7, #0]
    9d54:	18d0      	adds	r0, r2, r3
    9d56:	68fa      	ldr	r2, [r7, #12]
    9d58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9d5a:	18d1      	adds	r1, r2, r3
    9d5c:	68ba      	ldr	r2, [r7, #8]
    9d5e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9d60:	1ad3      	subs	r3, r2, r3
    9d62:	001a      	movs	r2, r3
    9d64:	4b04      	ldr	r3, [pc, #16]	; (9d78 <atcacert_der_enc_integer+0x154>)
    9d66:	4798      	blx	r3

	return ATCACERT_E_SUCCESS;
    9d68:	2300      	movs	r3, #0
}
    9d6a:	0018      	movs	r0, r3
    9d6c:	46bd      	mov	sp, r7
    9d6e:	b00c      	add	sp, #48	; 0x30
    9d70:	bd80      	pop	{r7, pc}
    9d72:	46c0      	nop			; (mov r8, r8)
    9d74:	00009a9d 	.word	0x00009a9d
    9d78:	000127e7 	.word	0x000127e7

00009d7c <atcacert_der_dec_integer>:

int atcacert_der_dec_integer( const uint8_t* der_int,
                              size_t*        der_int_size,
                              uint8_t*       int_data,
                              size_t*        int_data_size)
{
    9d7c:	b580      	push	{r7, lr}
    9d7e:	b088      	sub	sp, #32
    9d80:	af00      	add	r7, sp, #0
    9d82:	60f8      	str	r0, [r7, #12]
    9d84:	60b9      	str	r1, [r7, #8]
    9d86:	607a      	str	r2, [r7, #4]
    9d88:	603b      	str	r3, [r7, #0]
	int ret = 0;
    9d8a:	2300      	movs	r3, #0
    9d8c:	61fb      	str	r3, [r7, #28]
	size_t der_length_size = 0;
    9d8e:	2300      	movs	r3, #0
    9d90:	61bb      	str	r3, [r7, #24]
	uint32_t int_data_size_calc = 0;
    9d92:	2300      	movs	r3, #0
    9d94:	617b      	str	r3, [r7, #20]

	if (der_int == NULL || der_int_size == NULL || (int_data != NULL && int_data_size == NULL))
    9d96:	68fb      	ldr	r3, [r7, #12]
    9d98:	2b00      	cmp	r3, #0
    9d9a:	d008      	beq.n	9dae <atcacert_der_dec_integer+0x32>
    9d9c:	68bb      	ldr	r3, [r7, #8]
    9d9e:	2b00      	cmp	r3, #0
    9da0:	d005      	beq.n	9dae <atcacert_der_dec_integer+0x32>
    9da2:	687b      	ldr	r3, [r7, #4]
    9da4:	2b00      	cmp	r3, #0
    9da6:	d004      	beq.n	9db2 <atcacert_der_dec_integer+0x36>
    9da8:	683b      	ldr	r3, [r7, #0]
    9daa:	2b00      	cmp	r3, #0
    9dac:	d101      	bne.n	9db2 <atcacert_der_dec_integer+0x36>
		return ATCACERT_E_BAD_PARAMS;
    9dae:	2302      	movs	r3, #2
    9db0:	e056      	b.n	9e60 <atcacert_der_dec_integer+0xe4>

	if (*der_int_size < 1)
    9db2:	68bb      	ldr	r3, [r7, #8]
    9db4:	681b      	ldr	r3, [r3, #0]
    9db6:	2b00      	cmp	r3, #0
    9db8:	d101      	bne.n	9dbe <atcacert_der_dec_integer+0x42>
		return ATCACERT_E_DECODING_ERROR; // No data to decode
    9dba:	2304      	movs	r3, #4
    9dbc:	e050      	b.n	9e60 <atcacert_der_dec_integer+0xe4>

	if (der_int[0] != 0x02)
    9dbe:	68fb      	ldr	r3, [r7, #12]
    9dc0:	781b      	ldrb	r3, [r3, #0]
    9dc2:	2b02      	cmp	r3, #2
    9dc4:	d001      	beq.n	9dca <atcacert_der_dec_integer+0x4e>
		return ATCACERT_E_DECODING_ERROR; // Not an integer tag
    9dc6:	2304      	movs	r3, #4
    9dc8:	e04a      	b.n	9e60 <atcacert_der_dec_integer+0xe4>

	der_length_size = *der_int_size - 1;
    9dca:	68bb      	ldr	r3, [r7, #8]
    9dcc:	681b      	ldr	r3, [r3, #0]
    9dce:	3b01      	subs	r3, #1
    9dd0:	61bb      	str	r3, [r7, #24]
	ret = atcacert_der_dec_length(&der_int[1], &der_length_size, &int_data_size_calc);
    9dd2:	68fb      	ldr	r3, [r7, #12]
    9dd4:	3301      	adds	r3, #1
    9dd6:	2214      	movs	r2, #20
    9dd8:	18ba      	adds	r2, r7, r2
    9dda:	2118      	movs	r1, #24
    9ddc:	1879      	adds	r1, r7, r1
    9dde:	0018      	movs	r0, r3
    9de0:	4b21      	ldr	r3, [pc, #132]	; (9e68 <atcacert_der_dec_integer+0xec>)
    9de2:	4798      	blx	r3
    9de4:	0003      	movs	r3, r0
    9de6:	61fb      	str	r3, [r7, #28]
	if (ret != ATCACERT_E_SUCCESS)
    9de8:	69fb      	ldr	r3, [r7, #28]
    9dea:	2b00      	cmp	r3, #0
    9dec:	d001      	beq.n	9df2 <atcacert_der_dec_integer+0x76>
		return ret;
    9dee:	69fb      	ldr	r3, [r7, #28]
    9df0:	e036      	b.n	9e60 <atcacert_der_dec_integer+0xe4>

	if (*der_int_size < (1 + der_length_size + int_data_size_calc))
    9df2:	68bb      	ldr	r3, [r7, #8]
    9df4:	681a      	ldr	r2, [r3, #0]
    9df6:	69b9      	ldr	r1, [r7, #24]
    9df8:	697b      	ldr	r3, [r7, #20]
    9dfa:	18cb      	adds	r3, r1, r3
    9dfc:	3301      	adds	r3, #1
    9dfe:	429a      	cmp	r2, r3
    9e00:	d201      	bcs.n	9e06 <atcacert_der_dec_integer+0x8a>
		return ATCACERT_E_DECODING_ERROR; // Invalid DER integer, not enough data.
    9e02:	2304      	movs	r3, #4
    9e04:	e02c      	b.n	9e60 <atcacert_der_dec_integer+0xe4>

	*der_int_size = (1 + der_length_size + int_data_size_calc);
    9e06:	69ba      	ldr	r2, [r7, #24]
    9e08:	697b      	ldr	r3, [r7, #20]
    9e0a:	18d3      	adds	r3, r2, r3
    9e0c:	1c5a      	adds	r2, r3, #1
    9e0e:	68bb      	ldr	r3, [r7, #8]
    9e10:	601a      	str	r2, [r3, #0]

	if (int_data == NULL && int_data_size == NULL)
    9e12:	687b      	ldr	r3, [r7, #4]
    9e14:	2b00      	cmp	r3, #0
    9e16:	d104      	bne.n	9e22 <atcacert_der_dec_integer+0xa6>
    9e18:	683b      	ldr	r3, [r7, #0]
    9e1a:	2b00      	cmp	r3, #0
    9e1c:	d101      	bne.n	9e22 <atcacert_der_dec_integer+0xa6>
		return ATCACERT_E_SUCCESS; // Caller doesn't want the actual data, just the der_int_size
    9e1e:	2300      	movs	r3, #0
    9e20:	e01e      	b.n	9e60 <atcacert_der_dec_integer+0xe4>

	if (int_data != NULL && *int_data_size < int_data_size_calc) {
    9e22:	687b      	ldr	r3, [r7, #4]
    9e24:	2b00      	cmp	r3, #0
    9e26:	d009      	beq.n	9e3c <atcacert_der_dec_integer+0xc0>
    9e28:	683b      	ldr	r3, [r7, #0]
    9e2a:	681a      	ldr	r2, [r3, #0]
    9e2c:	697b      	ldr	r3, [r7, #20]
    9e2e:	429a      	cmp	r2, r3
    9e30:	d204      	bcs.n	9e3c <atcacert_der_dec_integer+0xc0>
		*int_data_size = int_data_size_calc;
    9e32:	697a      	ldr	r2, [r7, #20]
    9e34:	683b      	ldr	r3, [r7, #0]
    9e36:	601a      	str	r2, [r3, #0]
		return ATCACERT_E_BUFFER_TOO_SMALL;
    9e38:	2303      	movs	r3, #3
    9e3a:	e011      	b.n	9e60 <atcacert_der_dec_integer+0xe4>
	}

	*int_data_size = int_data_size_calc;
    9e3c:	697a      	ldr	r2, [r7, #20]
    9e3e:	683b      	ldr	r3, [r7, #0]
    9e40:	601a      	str	r2, [r3, #0]

	if (int_data == NULL)
    9e42:	687b      	ldr	r3, [r7, #4]
    9e44:	2b00      	cmp	r3, #0
    9e46:	d101      	bne.n	9e4c <atcacert_der_dec_integer+0xd0>
		return ATCACERT_E_SUCCESS; // Caller doesn't want the actual data, just the int_data_size
    9e48:	2300      	movs	r3, #0
    9e4a:	e009      	b.n	9e60 <atcacert_der_dec_integer+0xe4>

	memcpy(int_data, &der_int[1 + der_length_size], int_data_size_calc);
    9e4c:	69bb      	ldr	r3, [r7, #24]
    9e4e:	3301      	adds	r3, #1
    9e50:	68fa      	ldr	r2, [r7, #12]
    9e52:	18d1      	adds	r1, r2, r3
    9e54:	697a      	ldr	r2, [r7, #20]
    9e56:	687b      	ldr	r3, [r7, #4]
    9e58:	0018      	movs	r0, r3
    9e5a:	4b04      	ldr	r3, [pc, #16]	; (9e6c <atcacert_der_dec_integer+0xf0>)
    9e5c:	4798      	blx	r3

	return ATCACERT_E_SUCCESS;
    9e5e:	2300      	movs	r3, #0
}
    9e60:	0018      	movs	r0, r3
    9e62:	46bd      	mov	sp, r7
    9e64:	b008      	add	sp, #32
    9e66:	bd80      	pop	{r7, pc}
    9e68:	00009b59 	.word	0x00009b59
    9e6c:	000127e7 	.word	0x000127e7

00009e70 <atcacert_der_enc_ecdsa_sig_value>:

int atcacert_der_enc_ecdsa_sig_value( const uint8_t raw_sig[64],
                                      uint8_t*      der_sig,
                                      size_t*       der_sig_size)
{
    9e70:	b590      	push	{r4, r7, lr}
    9e72:	b08b      	sub	sp, #44	; 0x2c
    9e74:	af02      	add	r7, sp, #8
    9e76:	60f8      	str	r0, [r7, #12]
    9e78:	60b9      	str	r1, [r7, #8]
    9e7a:	607a      	str	r2, [r7, #4]
	int ret = 0;
    9e7c:	2300      	movs	r3, #0
    9e7e:	61fb      	str	r3, [r7, #28]
	size_t r_size = 0;
    9e80:	2300      	movs	r3, #0
    9e82:	617b      	str	r3, [r7, #20]
	size_t s_size = 0;
    9e84:	2300      	movs	r3, #0
    9e86:	613b      	str	r3, [r7, #16]
	size_t der_sig_size_calc = 0;
    9e88:	2300      	movs	r3, #0
    9e8a:	61bb      	str	r3, [r7, #24]

	if (raw_sig == NULL || der_sig_size == NULL)
    9e8c:	68fb      	ldr	r3, [r7, #12]
    9e8e:	2b00      	cmp	r3, #0
    9e90:	d002      	beq.n	9e98 <atcacert_der_enc_ecdsa_sig_value+0x28>
    9e92:	687b      	ldr	r3, [r7, #4]
    9e94:	2b00      	cmp	r3, #0
    9e96:	d101      	bne.n	9e9c <atcacert_der_enc_ecdsa_sig_value+0x2c>
		return ATCACERT_E_BAD_PARAMS;
    9e98:	2302      	movs	r3, #2
    9e9a:	e07d      	b.n	9f98 <atcacert_der_enc_ecdsa_sig_value+0x128>

	// Find size of the DER encoded R integer
	ret = atcacert_der_enc_integer(&raw_sig[0], 32, TRUE, NULL, &r_size);
    9e9c:	68f8      	ldr	r0, [r7, #12]
    9e9e:	2314      	movs	r3, #20
    9ea0:	18fb      	adds	r3, r7, r3
    9ea2:	9300      	str	r3, [sp, #0]
    9ea4:	2300      	movs	r3, #0
    9ea6:	2201      	movs	r2, #1
    9ea8:	2120      	movs	r1, #32
    9eaa:	4c3d      	ldr	r4, [pc, #244]	; (9fa0 <atcacert_der_enc_ecdsa_sig_value+0x130>)
    9eac:	47a0      	blx	r4
    9eae:	0003      	movs	r3, r0
    9eb0:	61fb      	str	r3, [r7, #28]
	if (ret != ATCACERT_E_SUCCESS)
    9eb2:	69fb      	ldr	r3, [r7, #28]
    9eb4:	2b00      	cmp	r3, #0
    9eb6:	d001      	beq.n	9ebc <atcacert_der_enc_ecdsa_sig_value+0x4c>
		return ret;
    9eb8:	69fb      	ldr	r3, [r7, #28]
    9eba:	e06d      	b.n	9f98 <atcacert_der_enc_ecdsa_sig_value+0x128>

	// Find size of the DER encoded S integer
	ret = atcacert_der_enc_integer(&raw_sig[32], 32, TRUE, NULL, &s_size);
    9ebc:	68fb      	ldr	r3, [r7, #12]
    9ebe:	3320      	adds	r3, #32
    9ec0:	0018      	movs	r0, r3
    9ec2:	2310      	movs	r3, #16
    9ec4:	18fb      	adds	r3, r7, r3
    9ec6:	9300      	str	r3, [sp, #0]
    9ec8:	2300      	movs	r3, #0
    9eca:	2201      	movs	r2, #1
    9ecc:	2120      	movs	r1, #32
    9ece:	4c34      	ldr	r4, [pc, #208]	; (9fa0 <atcacert_der_enc_ecdsa_sig_value+0x130>)
    9ed0:	47a0      	blx	r4
    9ed2:	0003      	movs	r3, r0
    9ed4:	61fb      	str	r3, [r7, #28]
	if (ret != ATCACERT_E_SUCCESS)
    9ed6:	69fb      	ldr	r3, [r7, #28]
    9ed8:	2b00      	cmp	r3, #0
    9eda:	d001      	beq.n	9ee0 <atcacert_der_enc_ecdsa_sig_value+0x70>
		return ret;
    9edc:	69fb      	ldr	r3, [r7, #28]
    9ede:	e05b      	b.n	9f98 <atcacert_der_enc_ecdsa_sig_value+0x128>

	// This calculation assumes all DER lengths are a single byte, which is fine for 32 byte
	// R and S integers.
	der_sig_size_calc = 5 + r_size + s_size;
    9ee0:	697a      	ldr	r2, [r7, #20]
    9ee2:	693b      	ldr	r3, [r7, #16]
    9ee4:	18d3      	adds	r3, r2, r3
    9ee6:	3305      	adds	r3, #5
    9ee8:	61bb      	str	r3, [r7, #24]

	if (der_sig != NULL && *der_sig_size < der_sig_size_calc) {
    9eea:	68bb      	ldr	r3, [r7, #8]
    9eec:	2b00      	cmp	r3, #0
    9eee:	d009      	beq.n	9f04 <atcacert_der_enc_ecdsa_sig_value+0x94>
    9ef0:	687b      	ldr	r3, [r7, #4]
    9ef2:	681a      	ldr	r2, [r3, #0]
    9ef4:	69bb      	ldr	r3, [r7, #24]
    9ef6:	429a      	cmp	r2, r3
    9ef8:	d204      	bcs.n	9f04 <atcacert_der_enc_ecdsa_sig_value+0x94>
		*der_sig_size = der_sig_size_calc;
    9efa:	687b      	ldr	r3, [r7, #4]
    9efc:	69ba      	ldr	r2, [r7, #24]
    9efe:	601a      	str	r2, [r3, #0]
		return ATCACERT_E_BUFFER_TOO_SMALL;
    9f00:	2303      	movs	r3, #3
    9f02:	e049      	b.n	9f98 <atcacert_der_enc_ecdsa_sig_value+0x128>
	}

	*der_sig_size = der_sig_size_calc;
    9f04:	687b      	ldr	r3, [r7, #4]
    9f06:	69ba      	ldr	r2, [r7, #24]
    9f08:	601a      	str	r2, [r3, #0]

	if (der_sig == NULL)
    9f0a:	68bb      	ldr	r3, [r7, #8]
    9f0c:	2b00      	cmp	r3, #0
    9f0e:	d101      	bne.n	9f14 <atcacert_der_enc_ecdsa_sig_value+0xa4>
		return ATCACERT_E_SUCCESS;                  // Caller just wanted the encoded size
    9f10:	2300      	movs	r3, #0
    9f12:	e041      	b.n	9f98 <atcacert_der_enc_ecdsa_sig_value+0x128>

	der_sig[0] = 0x03;                              // signatureValue bit string tag
    9f14:	68bb      	ldr	r3, [r7, #8]
    9f16:	2203      	movs	r2, #3
    9f18:	701a      	strb	r2, [r3, #0]
	der_sig[1] = (uint8_t)(der_sig_size_calc - 2);  // signatureValue bit string length
    9f1a:	68bb      	ldr	r3, [r7, #8]
    9f1c:	3301      	adds	r3, #1
    9f1e:	69ba      	ldr	r2, [r7, #24]
    9f20:	b2d2      	uxtb	r2, r2
    9f22:	3a02      	subs	r2, #2
    9f24:	b2d2      	uxtb	r2, r2
    9f26:	701a      	strb	r2, [r3, #0]
	der_sig[2] = 0x00;                              // signatureValue bit string spare bits
    9f28:	68bb      	ldr	r3, [r7, #8]
    9f2a:	3302      	adds	r3, #2
    9f2c:	2200      	movs	r2, #0
    9f2e:	701a      	strb	r2, [r3, #0]

	// signatureValue bit string value is the DER encoding of ECDSA-Sig-Value
	der_sig[3] = 0x30;                              // sequence tag
    9f30:	68bb      	ldr	r3, [r7, #8]
    9f32:	3303      	adds	r3, #3
    9f34:	2230      	movs	r2, #48	; 0x30
    9f36:	701a      	strb	r2, [r3, #0]
	der_sig[4] = (uint8_t)(der_sig_size_calc - 5);  // sequence length
    9f38:	68bb      	ldr	r3, [r7, #8]
    9f3a:	3304      	adds	r3, #4
    9f3c:	69ba      	ldr	r2, [r7, #24]
    9f3e:	b2d2      	uxtb	r2, r2
    9f40:	3a05      	subs	r2, #5
    9f42:	b2d2      	uxtb	r2, r2
    9f44:	701a      	strb	r2, [r3, #0]

	// Add R integer
	ret = atcacert_der_enc_integer(&raw_sig[0], 32, TRUE, &der_sig[5], &r_size);
    9f46:	68bb      	ldr	r3, [r7, #8]
    9f48:	1d5a      	adds	r2, r3, #5
    9f4a:	68f8      	ldr	r0, [r7, #12]
    9f4c:	2314      	movs	r3, #20
    9f4e:	18fb      	adds	r3, r7, r3
    9f50:	9300      	str	r3, [sp, #0]
    9f52:	0013      	movs	r3, r2
    9f54:	2201      	movs	r2, #1
    9f56:	2120      	movs	r1, #32
    9f58:	4c11      	ldr	r4, [pc, #68]	; (9fa0 <atcacert_der_enc_ecdsa_sig_value+0x130>)
    9f5a:	47a0      	blx	r4
    9f5c:	0003      	movs	r3, r0
    9f5e:	61fb      	str	r3, [r7, #28]
	if (ret != ATCACERT_E_SUCCESS)
    9f60:	69fb      	ldr	r3, [r7, #28]
    9f62:	2b00      	cmp	r3, #0
    9f64:	d001      	beq.n	9f6a <atcacert_der_enc_ecdsa_sig_value+0xfa>
		return ret;
    9f66:	69fb      	ldr	r3, [r7, #28]
    9f68:	e016      	b.n	9f98 <atcacert_der_enc_ecdsa_sig_value+0x128>

	// Add S integer
	ret = atcacert_der_enc_integer(&raw_sig[32], 32, TRUE, &der_sig[5 + r_size], &s_size);
    9f6a:	68fb      	ldr	r3, [r7, #12]
    9f6c:	3320      	adds	r3, #32
    9f6e:	0018      	movs	r0, r3
    9f70:	697b      	ldr	r3, [r7, #20]
    9f72:	3305      	adds	r3, #5
    9f74:	68ba      	ldr	r2, [r7, #8]
    9f76:	18d2      	adds	r2, r2, r3
    9f78:	2310      	movs	r3, #16
    9f7a:	18fb      	adds	r3, r7, r3
    9f7c:	9300      	str	r3, [sp, #0]
    9f7e:	0013      	movs	r3, r2
    9f80:	2201      	movs	r2, #1
    9f82:	2120      	movs	r1, #32
    9f84:	4c06      	ldr	r4, [pc, #24]	; (9fa0 <atcacert_der_enc_ecdsa_sig_value+0x130>)
    9f86:	47a0      	blx	r4
    9f88:	0003      	movs	r3, r0
    9f8a:	61fb      	str	r3, [r7, #28]
	if (ret != ATCACERT_E_SUCCESS)
    9f8c:	69fb      	ldr	r3, [r7, #28]
    9f8e:	2b00      	cmp	r3, #0
    9f90:	d001      	beq.n	9f96 <atcacert_der_enc_ecdsa_sig_value+0x126>
		return ret;
    9f92:	69fb      	ldr	r3, [r7, #28]
    9f94:	e000      	b.n	9f98 <atcacert_der_enc_ecdsa_sig_value+0x128>

	return ATCACERT_E_SUCCESS;
    9f96:	2300      	movs	r3, #0
}
    9f98:	0018      	movs	r0, r3
    9f9a:	46bd      	mov	sp, r7
    9f9c:	b009      	add	sp, #36	; 0x24
    9f9e:	bd90      	pop	{r4, r7, pc}
    9fa0:	00009c25 	.word	0x00009c25

00009fa4 <atcacert_der_dec_ecdsa_sig_value>:

int atcacert_der_dec_ecdsa_sig_value( const uint8_t* der_sig,
                                      size_t*        der_sig_size,
                                      uint8_t raw_sig[64])
{
    9fa4:	b590      	push	{r4, r7, lr}
    9fa6:	b097      	sub	sp, #92	; 0x5c
    9fa8:	af00      	add	r7, sp, #0
    9faa:	60f8      	str	r0, [r7, #12]
    9fac:	60b9      	str	r1, [r7, #8]
    9fae:	607a      	str	r2, [r7, #4]
	int ret = 0;
    9fb0:	2300      	movs	r3, #0
    9fb2:	657b      	str	r3, [r7, #84]	; 0x54
	size_t curr_idx = 0;
    9fb4:	2300      	movs	r3, #0
    9fb6:	653b      	str	r3, [r7, #80]	; 0x50
	size_t dec_size = 0;
    9fb8:	2300      	movs	r3, #0
    9fba:	64fb      	str	r3, [r7, #76]	; 0x4c
	uint32_t bs_length = 0;
    9fbc:	2300      	movs	r3, #0
    9fbe:	64bb      	str	r3, [r7, #72]	; 0x48
	uint32_t seq_length = 0;
    9fc0:	2300      	movs	r3, #0
    9fc2:	647b      	str	r3, [r7, #68]	; 0x44
	size_t r_size = 0;
    9fc4:	2300      	movs	r3, #0
    9fc6:	643b      	str	r3, [r7, #64]	; 0x40
	size_t s_size = 0;
    9fc8:	2300      	movs	r3, #0
    9fca:	63fb      	str	r3, [r7, #60]	; 0x3c
	uint8_t int_data[33];
	size_t int_data_size = 0;
    9fcc:	2300      	movs	r3, #0
    9fce:	617b      	str	r3, [r7, #20]

	if (der_sig == NULL || der_sig_size == NULL)
    9fd0:	68fb      	ldr	r3, [r7, #12]
    9fd2:	2b00      	cmp	r3, #0
    9fd4:	d002      	beq.n	9fdc <atcacert_der_dec_ecdsa_sig_value+0x38>
    9fd6:	68bb      	ldr	r3, [r7, #8]
    9fd8:	2b00      	cmp	r3, #0
    9fda:	d101      	bne.n	9fe0 <atcacert_der_dec_ecdsa_sig_value+0x3c>
		return ATCACERT_E_BAD_PARAMS;
    9fdc:	2302      	movs	r3, #2
    9fde:	e13f      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>

	if (*der_sig_size < 1)
    9fe0:	68bb      	ldr	r3, [r7, #8]
    9fe2:	681b      	ldr	r3, [r3, #0]
    9fe4:	2b00      	cmp	r3, #0
    9fe6:	d101      	bne.n	9fec <atcacert_der_dec_ecdsa_sig_value+0x48>
		return ATCACERT_E_DECODING_ERROR; // No data to decode
    9fe8:	2304      	movs	r3, #4
    9fea:	e139      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>

	// signatureValue bit string tag
	curr_idx = 0;
    9fec:	2300      	movs	r3, #0
    9fee:	653b      	str	r3, [r7, #80]	; 0x50
	if (der_sig[curr_idx] != 0x03)
    9ff0:	68fa      	ldr	r2, [r7, #12]
    9ff2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    9ff4:	18d3      	adds	r3, r2, r3
    9ff6:	781b      	ldrb	r3, [r3, #0]
    9ff8:	2b03      	cmp	r3, #3
    9ffa:	d001      	beq.n	a000 <atcacert_der_dec_ecdsa_sig_value+0x5c>
		return ATCACERT_E_DECODING_ERROR; // Unexpected tag value
    9ffc:	2304      	movs	r3, #4
    9ffe:	e12f      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>
	curr_idx++;
    a000:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a002:	3301      	adds	r3, #1
    a004:	653b      	str	r3, [r7, #80]	; 0x50

	// signatureValue bit string length
	dec_size = *der_sig_size - curr_idx;
    a006:	68bb      	ldr	r3, [r7, #8]
    a008:	681a      	ldr	r2, [r3, #0]
    a00a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a00c:	1ad3      	subs	r3, r2, r3
    a00e:	64fb      	str	r3, [r7, #76]	; 0x4c
	ret = atcacert_der_dec_length(&der_sig[curr_idx], &dec_size, &bs_length);
    a010:	68fa      	ldr	r2, [r7, #12]
    a012:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a014:	18d3      	adds	r3, r2, r3
    a016:	2248      	movs	r2, #72	; 0x48
    a018:	18ba      	adds	r2, r7, r2
    a01a:	214c      	movs	r1, #76	; 0x4c
    a01c:	1879      	adds	r1, r7, r1
    a01e:	0018      	movs	r0, r3
    a020:	4b91      	ldr	r3, [pc, #580]	; (a268 <atcacert_der_dec_ecdsa_sig_value+0x2c4>)
    a022:	4798      	blx	r3
    a024:	0003      	movs	r3, r0
    a026:	657b      	str	r3, [r7, #84]	; 0x54
	if (ret != ATCACERT_E_SUCCESS)
    a028:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    a02a:	2b00      	cmp	r3, #0
    a02c:	d001      	beq.n	a032 <atcacert_der_dec_ecdsa_sig_value+0x8e>
		return ret; // Failed to decode length
    a02e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    a030:	e116      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>
	curr_idx += dec_size;
    a032:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    a034:	6d3a      	ldr	r2, [r7, #80]	; 0x50
    a036:	18d3      	adds	r3, r2, r3
    a038:	653b      	str	r3, [r7, #80]	; 0x50
	if (curr_idx + bs_length > *der_sig_size)
    a03a:	6cba      	ldr	r2, [r7, #72]	; 0x48
    a03c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a03e:	18d2      	adds	r2, r2, r3
    a040:	68bb      	ldr	r3, [r7, #8]
    a042:	681b      	ldr	r3, [r3, #0]
    a044:	429a      	cmp	r2, r3
    a046:	d901      	bls.n	a04c <atcacert_der_dec_ecdsa_sig_value+0xa8>
		return ATCACERT_E_DECODING_ERROR; // Not enough data in buffer to decode the rest
    a048:	2304      	movs	r3, #4
    a04a:	e109      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>

	// signatureValue bit string spare bits
	if (curr_idx >= *der_sig_size)
    a04c:	68bb      	ldr	r3, [r7, #8]
    a04e:	681a      	ldr	r2, [r3, #0]
    a050:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a052:	429a      	cmp	r2, r3
    a054:	d801      	bhi.n	a05a <atcacert_der_dec_ecdsa_sig_value+0xb6>
		return ATCACERT_E_DECODING_ERROR;   // No data left
    a056:	2304      	movs	r3, #4
    a058:	e102      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>
	if (der_sig[curr_idx] != 0x00)
    a05a:	68fa      	ldr	r2, [r7, #12]
    a05c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a05e:	18d3      	adds	r3, r2, r3
    a060:	781b      	ldrb	r3, [r3, #0]
    a062:	2b00      	cmp	r3, #0
    a064:	d001      	beq.n	a06a <atcacert_der_dec_ecdsa_sig_value+0xc6>
		return ATCACERT_E_DECODING_ERROR;   // Unexpected spare bits value
    a066:	2304      	movs	r3, #4
    a068:	e0fa      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>
	curr_idx++;
    a06a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a06c:	3301      	adds	r3, #1
    a06e:	653b      	str	r3, [r7, #80]	; 0x50

	// signatureValue bit string value is the DER encoding of ECDSA-Sig-Value

	// sequence tag
	if (curr_idx >= *der_sig_size)
    a070:	68bb      	ldr	r3, [r7, #8]
    a072:	681a      	ldr	r2, [r3, #0]
    a074:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a076:	429a      	cmp	r2, r3
    a078:	d801      	bhi.n	a07e <atcacert_der_dec_ecdsa_sig_value+0xda>
		return ATCACERT_E_DECODING_ERROR;   // No data left
    a07a:	2304      	movs	r3, #4
    a07c:	e0f0      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>
	if (der_sig[curr_idx] != 0x30)
    a07e:	68fa      	ldr	r2, [r7, #12]
    a080:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a082:	18d3      	adds	r3, r2, r3
    a084:	781b      	ldrb	r3, [r3, #0]
    a086:	2b30      	cmp	r3, #48	; 0x30
    a088:	d001      	beq.n	a08e <atcacert_der_dec_ecdsa_sig_value+0xea>
		return ATCACERT_E_DECODING_ERROR;   // Unexpected tag value
    a08a:	2304      	movs	r3, #4
    a08c:	e0e8      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>
	curr_idx++;
    a08e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a090:	3301      	adds	r3, #1
    a092:	653b      	str	r3, [r7, #80]	; 0x50

	// sequence length
	if (curr_idx >= *der_sig_size)
    a094:	68bb      	ldr	r3, [r7, #8]
    a096:	681a      	ldr	r2, [r3, #0]
    a098:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a09a:	429a      	cmp	r2, r3
    a09c:	d801      	bhi.n	a0a2 <atcacert_der_dec_ecdsa_sig_value+0xfe>
		return ATCACERT_E_DECODING_ERROR; // No data left
    a09e:	2304      	movs	r3, #4
    a0a0:	e0de      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>
	dec_size = *der_sig_size - curr_idx;
    a0a2:	68bb      	ldr	r3, [r7, #8]
    a0a4:	681a      	ldr	r2, [r3, #0]
    a0a6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a0a8:	1ad3      	subs	r3, r2, r3
    a0aa:	64fb      	str	r3, [r7, #76]	; 0x4c
	ret = atcacert_der_dec_length(&der_sig[curr_idx], &dec_size, &seq_length);
    a0ac:	68fa      	ldr	r2, [r7, #12]
    a0ae:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a0b0:	18d3      	adds	r3, r2, r3
    a0b2:	2244      	movs	r2, #68	; 0x44
    a0b4:	18ba      	adds	r2, r7, r2
    a0b6:	214c      	movs	r1, #76	; 0x4c
    a0b8:	1879      	adds	r1, r7, r1
    a0ba:	0018      	movs	r0, r3
    a0bc:	4b6a      	ldr	r3, [pc, #424]	; (a268 <atcacert_der_dec_ecdsa_sig_value+0x2c4>)
    a0be:	4798      	blx	r3
    a0c0:	0003      	movs	r3, r0
    a0c2:	657b      	str	r3, [r7, #84]	; 0x54
	if (ret != ATCACERT_E_SUCCESS)
    a0c4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    a0c6:	2b00      	cmp	r3, #0
    a0c8:	d001      	beq.n	a0ce <atcacert_der_dec_ecdsa_sig_value+0x12a>
		return ret; // Failed to decode length
    a0ca:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    a0cc:	e0c8      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>
	curr_idx += dec_size;
    a0ce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    a0d0:	6d3a      	ldr	r2, [r7, #80]	; 0x50
    a0d2:	18d3      	adds	r3, r2, r3
    a0d4:	653b      	str	r3, [r7, #80]	; 0x50
	if (curr_idx + seq_length > *der_sig_size)
    a0d6:	6c7a      	ldr	r2, [r7, #68]	; 0x44
    a0d8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a0da:	18d2      	adds	r2, r2, r3
    a0dc:	68bb      	ldr	r3, [r7, #8]
    a0de:	681b      	ldr	r3, [r3, #0]
    a0e0:	429a      	cmp	r2, r3
    a0e2:	d901      	bls.n	a0e8 <atcacert_der_dec_ecdsa_sig_value+0x144>
		return ATCACERT_E_DECODING_ERROR; // Not enough data in buffer to decode the rest
    a0e4:	2304      	movs	r3, #4
    a0e6:	e0bb      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>

	// R integer
	if (curr_idx >= *der_sig_size)
    a0e8:	68bb      	ldr	r3, [r7, #8]
    a0ea:	681a      	ldr	r2, [r3, #0]
    a0ec:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a0ee:	429a      	cmp	r2, r3
    a0f0:	d801      	bhi.n	a0f6 <atcacert_der_dec_ecdsa_sig_value+0x152>
		return ATCACERT_E_DECODING_ERROR; // No data left
    a0f2:	2304      	movs	r3, #4
    a0f4:	e0b4      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>
	r_size = *der_sig_size - curr_idx;
    a0f6:	68bb      	ldr	r3, [r7, #8]
    a0f8:	681a      	ldr	r2, [r3, #0]
    a0fa:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a0fc:	1ad3      	subs	r3, r2, r3
    a0fe:	643b      	str	r3, [r7, #64]	; 0x40
	int_data_size = sizeof(int_data);
    a100:	2321      	movs	r3, #33	; 0x21
    a102:	617b      	str	r3, [r7, #20]
	ret = atcacert_der_dec_integer(&der_sig[curr_idx], &r_size, int_data, &int_data_size);
    a104:	68fa      	ldr	r2, [r7, #12]
    a106:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a108:	18d0      	adds	r0, r2, r3
    a10a:	2314      	movs	r3, #20
    a10c:	18fb      	adds	r3, r7, r3
    a10e:	2218      	movs	r2, #24
    a110:	18ba      	adds	r2, r7, r2
    a112:	2140      	movs	r1, #64	; 0x40
    a114:	1879      	adds	r1, r7, r1
    a116:	4c55      	ldr	r4, [pc, #340]	; (a26c <atcacert_der_dec_ecdsa_sig_value+0x2c8>)
    a118:	47a0      	blx	r4
    a11a:	0003      	movs	r3, r0
    a11c:	657b      	str	r3, [r7, #84]	; 0x54
	if (ret != ATCACERT_E_SUCCESS)
    a11e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    a120:	2b00      	cmp	r3, #0
    a122:	d001      	beq.n	a128 <atcacert_der_dec_ecdsa_sig_value+0x184>
		return ret; // Failed to decode length
    a124:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    a126:	e09b      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>
	curr_idx += r_size;
    a128:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    a12a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
    a12c:	18d3      	adds	r3, r2, r3
    a12e:	653b      	str	r3, [r7, #80]	; 0x50

	if (raw_sig != NULL)
    a130:	687b      	ldr	r3, [r7, #4]
    a132:	2b00      	cmp	r3, #0
    a134:	d005      	beq.n	a142 <atcacert_der_dec_ecdsa_sig_value+0x19e>
		memset(raw_sig, 0, 64); // Zero out the raw sig as the decoded integers may not touch all bytes
    a136:	687b      	ldr	r3, [r7, #4]
    a138:	2240      	movs	r2, #64	; 0x40
    a13a:	2100      	movs	r1, #0
    a13c:	0018      	movs	r0, r3
    a13e:	4b4c      	ldr	r3, [pc, #304]	; (a270 <atcacert_der_dec_ecdsa_sig_value+0x2cc>)
    a140:	4798      	blx	r3

	if (int_data_size <= 32) {
    a142:	697b      	ldr	r3, [r7, #20]
    a144:	2b20      	cmp	r3, #32
    a146:	d80e      	bhi.n	a166 <atcacert_der_dec_ecdsa_sig_value+0x1c2>
		if (raw_sig != NULL)
    a148:	687b      	ldr	r3, [r7, #4]
    a14a:	2b00      	cmp	r3, #0
    a14c:	d023      	beq.n	a196 <atcacert_der_dec_ecdsa_sig_value+0x1f2>
			memcpy(&raw_sig[32 - int_data_size], &int_data[0], int_data_size);
    a14e:	697b      	ldr	r3, [r7, #20]
    a150:	2220      	movs	r2, #32
    a152:	1ad3      	subs	r3, r2, r3
    a154:	687a      	ldr	r2, [r7, #4]
    a156:	18d3      	adds	r3, r2, r3
    a158:	697a      	ldr	r2, [r7, #20]
    a15a:	2118      	movs	r1, #24
    a15c:	1879      	adds	r1, r7, r1
    a15e:	0018      	movs	r0, r3
    a160:	4b44      	ldr	r3, [pc, #272]	; (a274 <atcacert_der_dec_ecdsa_sig_value+0x2d0>)
    a162:	4798      	blx	r3
    a164:	e017      	b.n	a196 <atcacert_der_dec_ecdsa_sig_value+0x1f2>
	}else if (int_data_size == 33) {
    a166:	697b      	ldr	r3, [r7, #20]
    a168:	2b21      	cmp	r3, #33	; 0x21
    a16a:	d112      	bne.n	a192 <atcacert_der_dec_ecdsa_sig_value+0x1ee>
		if (int_data[0] != 0x00)
    a16c:	2318      	movs	r3, #24
    a16e:	18fb      	adds	r3, r7, r3
    a170:	781b      	ldrb	r3, [r3, #0]
    a172:	2b00      	cmp	r3, #0
    a174:	d001      	beq.n	a17a <atcacert_der_dec_ecdsa_sig_value+0x1d6>
			return ATCACERT_E_DECODING_ERROR; // R integer is too large
    a176:	2304      	movs	r3, #4
    a178:	e072      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>
		// DER integer was 0-padded to keep it positive
		if (raw_sig != NULL)
    a17a:	687b      	ldr	r3, [r7, #4]
    a17c:	2b00      	cmp	r3, #0
    a17e:	d00a      	beq.n	a196 <atcacert_der_dec_ecdsa_sig_value+0x1f2>
			memcpy(&raw_sig[0], &int_data[1], 32);
    a180:	2318      	movs	r3, #24
    a182:	18fb      	adds	r3, r7, r3
    a184:	1c59      	adds	r1, r3, #1
    a186:	687b      	ldr	r3, [r7, #4]
    a188:	2220      	movs	r2, #32
    a18a:	0018      	movs	r0, r3
    a18c:	4b39      	ldr	r3, [pc, #228]	; (a274 <atcacert_der_dec_ecdsa_sig_value+0x2d0>)
    a18e:	4798      	blx	r3
    a190:	e001      	b.n	a196 <atcacert_der_dec_ecdsa_sig_value+0x1f2>
	}else
		return ATCACERT_E_DECODING_ERROR; // R integer is too large
    a192:	2304      	movs	r3, #4
    a194:	e064      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>

	// S integer
	if (curr_idx >= *der_sig_size)
    a196:	68bb      	ldr	r3, [r7, #8]
    a198:	681a      	ldr	r2, [r3, #0]
    a19a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a19c:	429a      	cmp	r2, r3
    a19e:	d801      	bhi.n	a1a4 <atcacert_der_dec_ecdsa_sig_value+0x200>
		return ATCACERT_E_DECODING_ERROR; // No data left
    a1a0:	2304      	movs	r3, #4
    a1a2:	e05d      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>
	s_size = *der_sig_size - curr_idx;
    a1a4:	68bb      	ldr	r3, [r7, #8]
    a1a6:	681a      	ldr	r2, [r3, #0]
    a1a8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a1aa:	1ad3      	subs	r3, r2, r3
    a1ac:	63fb      	str	r3, [r7, #60]	; 0x3c
	int_data_size = sizeof(int_data);
    a1ae:	2321      	movs	r3, #33	; 0x21
    a1b0:	617b      	str	r3, [r7, #20]
	ret = atcacert_der_dec_integer(&der_sig[curr_idx], &s_size, int_data, &int_data_size);
    a1b2:	68fa      	ldr	r2, [r7, #12]
    a1b4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    a1b6:	18d0      	adds	r0, r2, r3
    a1b8:	2314      	movs	r3, #20
    a1ba:	18fb      	adds	r3, r7, r3
    a1bc:	2218      	movs	r2, #24
    a1be:	18ba      	adds	r2, r7, r2
    a1c0:	213c      	movs	r1, #60	; 0x3c
    a1c2:	1879      	adds	r1, r7, r1
    a1c4:	4c29      	ldr	r4, [pc, #164]	; (a26c <atcacert_der_dec_ecdsa_sig_value+0x2c8>)
    a1c6:	47a0      	blx	r4
    a1c8:	0003      	movs	r3, r0
    a1ca:	657b      	str	r3, [r7, #84]	; 0x54
	if (ret != ATCACERT_E_SUCCESS)
    a1cc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    a1ce:	2b00      	cmp	r3, #0
    a1d0:	d001      	beq.n	a1d6 <atcacert_der_dec_ecdsa_sig_value+0x232>
		return ret; // Failed to decode length
    a1d2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    a1d4:	e044      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>
	curr_idx += s_size;
    a1d6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    a1d8:	6d3a      	ldr	r2, [r7, #80]	; 0x50
    a1da:	18d3      	adds	r3, r2, r3
    a1dc:	653b      	str	r3, [r7, #80]	; 0x50

	if (int_data_size <= 32) {
    a1de:	697b      	ldr	r3, [r7, #20]
    a1e0:	2b20      	cmp	r3, #32
    a1e2:	d80e      	bhi.n	a202 <atcacert_der_dec_ecdsa_sig_value+0x25e>
		if (raw_sig != NULL)
    a1e4:	687b      	ldr	r3, [r7, #4]
    a1e6:	2b00      	cmp	r3, #0
    a1e8:	d025      	beq.n	a236 <atcacert_der_dec_ecdsa_sig_value+0x292>
			memcpy(&raw_sig[64 - int_data_size], &int_data[0], int_data_size);
    a1ea:	697b      	ldr	r3, [r7, #20]
    a1ec:	2240      	movs	r2, #64	; 0x40
    a1ee:	1ad3      	subs	r3, r2, r3
    a1f0:	687a      	ldr	r2, [r7, #4]
    a1f2:	18d3      	adds	r3, r2, r3
    a1f4:	697a      	ldr	r2, [r7, #20]
    a1f6:	2118      	movs	r1, #24
    a1f8:	1879      	adds	r1, r7, r1
    a1fa:	0018      	movs	r0, r3
    a1fc:	4b1d      	ldr	r3, [pc, #116]	; (a274 <atcacert_der_dec_ecdsa_sig_value+0x2d0>)
    a1fe:	4798      	blx	r3
    a200:	e019      	b.n	a236 <atcacert_der_dec_ecdsa_sig_value+0x292>
	}else if (int_data_size == 33) {
    a202:	697b      	ldr	r3, [r7, #20]
    a204:	2b21      	cmp	r3, #33	; 0x21
    a206:	d114      	bne.n	a232 <atcacert_der_dec_ecdsa_sig_value+0x28e>
		if (int_data[0] != 0x00)
    a208:	2318      	movs	r3, #24
    a20a:	18fb      	adds	r3, r7, r3
    a20c:	781b      	ldrb	r3, [r3, #0]
    a20e:	2b00      	cmp	r3, #0
    a210:	d001      	beq.n	a216 <atcacert_der_dec_ecdsa_sig_value+0x272>
			return ATCACERT_E_DECODING_ERROR; // S integer is too large
    a212:	2304      	movs	r3, #4
    a214:	e024      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>
		// DER integer was 0-padded to keep it positive
		if (raw_sig != NULL)
    a216:	687b      	ldr	r3, [r7, #4]
    a218:	2b00      	cmp	r3, #0
    a21a:	d00c      	beq.n	a236 <atcacert_der_dec_ecdsa_sig_value+0x292>
			memcpy(&raw_sig[32], &int_data[1], 32);
    a21c:	687b      	ldr	r3, [r7, #4]
    a21e:	3320      	adds	r3, #32
    a220:	0018      	movs	r0, r3
    a222:	2318      	movs	r3, #24
    a224:	18fb      	adds	r3, r7, r3
    a226:	3301      	adds	r3, #1
    a228:	2220      	movs	r2, #32
    a22a:	0019      	movs	r1, r3
    a22c:	4b11      	ldr	r3, [pc, #68]	; (a274 <atcacert_der_dec_ecdsa_sig_value+0x2d0>)
    a22e:	4798      	blx	r3
    a230:	e001      	b.n	a236 <atcacert_der_dec_ecdsa_sig_value+0x292>
	}else
		return ATCACERT_E_DECODING_ERROR; // S integer is too large
    a232:	2304      	movs	r3, #4
    a234:	e014      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>

	if (seq_length != r_size + s_size)
    a236:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    a238:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    a23a:	18d2      	adds	r2, r2, r3
    a23c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    a23e:	429a      	cmp	r2, r3
    a240:	d001      	beq.n	a246 <atcacert_der_dec_ecdsa_sig_value+0x2a2>
		return ATCACERT_E_DECODING_ERROR; // Unexpected extra data in sequence
    a242:	2304      	movs	r3, #4
    a244:	e00c      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>

	if (bs_length != r_size + s_size + 3)
    a246:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    a248:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    a24a:	18d3      	adds	r3, r2, r3
    a24c:	1cda      	adds	r2, r3, #3
    a24e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    a250:	429a      	cmp	r2, r3
    a252:	d001      	beq.n	a258 <atcacert_der_dec_ecdsa_sig_value+0x2b4>
		return ATCACERT_E_DECODING_ERROR; // Unexpected extra data in bit string
    a254:	2304      	movs	r3, #4
    a256:	e003      	b.n	a260 <atcacert_der_dec_ecdsa_sig_value+0x2bc>

	*der_sig_size = curr_idx;
    a258:	68bb      	ldr	r3, [r7, #8]
    a25a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
    a25c:	601a      	str	r2, [r3, #0]

	return ATCACERT_E_SUCCESS;
    a25e:	2300      	movs	r3, #0
    a260:	0018      	movs	r0, r3
    a262:	46bd      	mov	sp, r7
    a264:	b017      	add	sp, #92	; 0x5c
    a266:	bd90      	pop	{r4, r7, pc}
    a268:	00009b59 	.word	0x00009b59
    a26c:	00009d7d 	.word	0x00009d7d
    a270:	00012823 	.word	0x00012823
    a274:	000127e7 	.word	0x000127e7

0000a278 <atcacert_verify_cert_hw>:

int atcacert_verify_cert_hw( const atcacert_def_t* cert_def,
                             const uint8_t*        cert,
                             size_t cert_size,
                             const uint8_t ca_public_key[64])
{
    a278:	b590      	push	{r4, r7, lr}
    a27a:	b09f      	sub	sp, #124	; 0x7c
    a27c:	af00      	add	r7, sp, #0
    a27e:	60f8      	str	r0, [r7, #12]
    a280:	60b9      	str	r1, [r7, #8]
    a282:	607a      	str	r2, [r7, #4]
    a284:	603b      	str	r3, [r7, #0]
	int ret = 0;
    a286:	2300      	movs	r3, #0
    a288:	677b      	str	r3, [r7, #116]	; 0x74
	uint8_t tbs_digest[32];
	uint8_t signature[64];
	bool is_verified = false;
    a28a:	2313      	movs	r3, #19
    a28c:	18fb      	adds	r3, r7, r3
    a28e:	2200      	movs	r2, #0
    a290:	701a      	strb	r2, [r3, #0]

	if (cert_def == NULL || ca_public_key == NULL || cert == NULL)
    a292:	68fb      	ldr	r3, [r7, #12]
    a294:	2b00      	cmp	r3, #0
    a296:	d005      	beq.n	a2a4 <atcacert_verify_cert_hw+0x2c>
    a298:	683b      	ldr	r3, [r7, #0]
    a29a:	2b00      	cmp	r3, #0
    a29c:	d002      	beq.n	a2a4 <atcacert_verify_cert_hw+0x2c>
    a29e:	68bb      	ldr	r3, [r7, #8]
    a2a0:	2b00      	cmp	r3, #0
    a2a2:	d101      	bne.n	a2a8 <atcacert_verify_cert_hw+0x30>
		return ATCACERT_E_BAD_PARAMS;
    a2a4:	2302      	movs	r3, #2
    a2a6:	e034      	b.n	a312 <atcacert_verify_cert_hw+0x9a>

	ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);
    a2a8:	2354      	movs	r3, #84	; 0x54
    a2aa:	18fb      	adds	r3, r7, r3
    a2ac:	687a      	ldr	r2, [r7, #4]
    a2ae:	68b9      	ldr	r1, [r7, #8]
    a2b0:	68f8      	ldr	r0, [r7, #12]
    a2b2:	4c1a      	ldr	r4, [pc, #104]	; (a31c <atcacert_verify_cert_hw+0xa4>)
    a2b4:	47a0      	blx	r4
    a2b6:	0003      	movs	r3, r0
    a2b8:	677b      	str	r3, [r7, #116]	; 0x74
	if (ret != ATCACERT_E_SUCCESS)
    a2ba:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    a2bc:	2b00      	cmp	r3, #0
    a2be:	d001      	beq.n	a2c4 <atcacert_verify_cert_hw+0x4c>
		return ret;
    a2c0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    a2c2:	e026      	b.n	a312 <atcacert_verify_cert_hw+0x9a>

	ret = atcacert_get_signature(cert_def, cert, cert_size, signature);
    a2c4:	2314      	movs	r3, #20
    a2c6:	18fb      	adds	r3, r7, r3
    a2c8:	687a      	ldr	r2, [r7, #4]
    a2ca:	68b9      	ldr	r1, [r7, #8]
    a2cc:	68f8      	ldr	r0, [r7, #12]
    a2ce:	4c14      	ldr	r4, [pc, #80]	; (a320 <atcacert_verify_cert_hw+0xa8>)
    a2d0:	47a0      	blx	r4
    a2d2:	0003      	movs	r3, r0
    a2d4:	677b      	str	r3, [r7, #116]	; 0x74
	if (ret != ATCACERT_E_SUCCESS)
    a2d6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    a2d8:	2b00      	cmp	r3, #0
    a2da:	d001      	beq.n	a2e0 <atcacert_verify_cert_hw+0x68>
		return ret;
    a2dc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    a2de:	e018      	b.n	a312 <atcacert_verify_cert_hw+0x9a>

	ret = atcab_verify_extern(tbs_digest, signature, ca_public_key, &is_verified);
    a2e0:	2313      	movs	r3, #19
    a2e2:	18fb      	adds	r3, r7, r3
    a2e4:	683a      	ldr	r2, [r7, #0]
    a2e6:	2114      	movs	r1, #20
    a2e8:	1879      	adds	r1, r7, r1
    a2ea:	2054      	movs	r0, #84	; 0x54
    a2ec:	1838      	adds	r0, r7, r0
    a2ee:	4c0d      	ldr	r4, [pc, #52]	; (a324 <atcacert_verify_cert_hw+0xac>)
    a2f0:	47a0      	blx	r4
    a2f2:	0003      	movs	r3, r0
    a2f4:	677b      	str	r3, [r7, #116]	; 0x74
	if (ret != ATCA_SUCCESS)
    a2f6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    a2f8:	2b00      	cmp	r3, #0
    a2fa:	d001      	beq.n	a300 <atcacert_verify_cert_hw+0x88>
		return ret;
    a2fc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    a2fe:	e008      	b.n	a312 <atcacert_verify_cert_hw+0x9a>

	return is_verified ? ATCACERT_E_SUCCESS : ATCACERT_E_VERIFY_FAILED;
    a300:	2313      	movs	r3, #19
    a302:	18fb      	adds	r3, r7, r3
    a304:	781b      	ldrb	r3, [r3, #0]
    a306:	2b00      	cmp	r3, #0
    a308:	d001      	beq.n	a30e <atcacert_verify_cert_hw+0x96>
    a30a:	2300      	movs	r3, #0
    a30c:	e001      	b.n	a312 <atcacert_verify_cert_hw+0x9a>
    a30e:	230c      	movs	r3, #12
    a310:	46c0      	nop			; (mov r8, r8)
}
    a312:	0018      	movs	r0, r3
    a314:	46bd      	mov	sp, r7
    a316:	b01f      	add	sp, #124	; 0x7c
    a318:	bd90      	pop	{r4, r7, pc}
    a31a:	46c0      	nop			; (mov r8, r8)
    a31c:	000097f9 	.word	0x000097f9
    a320:	00008b15 	.word	0x00008b15
    a324:	0000b7a9 	.word	0x0000b7a9

0000a328 <atcacert_gen_challenge_hw>:

int atcacert_gen_challenge_hw( uint8_t challenge[32] )
{
    a328:	b580      	push	{r7, lr}
    a32a:	b082      	sub	sp, #8
    a32c:	af00      	add	r7, sp, #0
    a32e:	6078      	str	r0, [r7, #4]
	if (challenge == NULL)
    a330:	687b      	ldr	r3, [r7, #4]
    a332:	2b00      	cmp	r3, #0
    a334:	d101      	bne.n	a33a <atcacert_gen_challenge_hw+0x12>
		return ATCACERT_E_BAD_PARAMS;
    a336:	2302      	movs	r3, #2
    a338:	e004      	b.n	a344 <atcacert_gen_challenge_hw+0x1c>

	return atcab_random(challenge);
    a33a:	687b      	ldr	r3, [r7, #4]
    a33c:	0018      	movs	r0, r3
    a33e:	4b03      	ldr	r3, [pc, #12]	; (a34c <atcacert_gen_challenge_hw+0x24>)
    a340:	4798      	blx	r3
    a342:	0003      	movs	r3, r0
}
    a344:	0018      	movs	r0, r3
    a346:	46bd      	mov	sp, r7
    a348:	b002      	add	sp, #8
    a34a:	bd80      	pop	{r7, pc}
    a34c:	0000afd5 	.word	0x0000afd5

0000a350 <atcacert_verify_response_hw>:

int atcacert_verify_response_hw( const uint8_t device_public_key[64],
                                 const uint8_t challenge[32],
                                 const uint8_t response[64])
{
    a350:	b590      	push	{r4, r7, lr}
    a352:	b087      	sub	sp, #28
    a354:	af00      	add	r7, sp, #0
    a356:	60f8      	str	r0, [r7, #12]
    a358:	60b9      	str	r1, [r7, #8]
    a35a:	607a      	str	r2, [r7, #4]
	int ret = 0;
    a35c:	2300      	movs	r3, #0
    a35e:	617b      	str	r3, [r7, #20]
	bool is_verified = false;
    a360:	2313      	movs	r3, #19
    a362:	18fb      	adds	r3, r7, r3
    a364:	2200      	movs	r2, #0
    a366:	701a      	strb	r2, [r3, #0]

	if (device_public_key == NULL || challenge == NULL || response == NULL)
    a368:	68fb      	ldr	r3, [r7, #12]
    a36a:	2b00      	cmp	r3, #0
    a36c:	d005      	beq.n	a37a <atcacert_verify_response_hw+0x2a>
    a36e:	68bb      	ldr	r3, [r7, #8]
    a370:	2b00      	cmp	r3, #0
    a372:	d002      	beq.n	a37a <atcacert_verify_response_hw+0x2a>
    a374:	687b      	ldr	r3, [r7, #4]
    a376:	2b00      	cmp	r3, #0
    a378:	d101      	bne.n	a37e <atcacert_verify_response_hw+0x2e>
		return ATCACERT_E_BAD_PARAMS;
    a37a:	2302      	movs	r3, #2
    a37c:	e016      	b.n	a3ac <atcacert_verify_response_hw+0x5c>

	ret = atcab_verify_extern(challenge, response, device_public_key, &is_verified);
    a37e:	2313      	movs	r3, #19
    a380:	18fb      	adds	r3, r7, r3
    a382:	68fa      	ldr	r2, [r7, #12]
    a384:	6879      	ldr	r1, [r7, #4]
    a386:	68b8      	ldr	r0, [r7, #8]
    a388:	4c0a      	ldr	r4, [pc, #40]	; (a3b4 <atcacert_verify_response_hw+0x64>)
    a38a:	47a0      	blx	r4
    a38c:	0003      	movs	r3, r0
    a38e:	617b      	str	r3, [r7, #20]
	if (ret != ATCA_SUCCESS)
    a390:	697b      	ldr	r3, [r7, #20]
    a392:	2b00      	cmp	r3, #0
    a394:	d001      	beq.n	a39a <atcacert_verify_response_hw+0x4a>
		return ret;
    a396:	697b      	ldr	r3, [r7, #20]
    a398:	e008      	b.n	a3ac <atcacert_verify_response_hw+0x5c>

	return is_verified ? ATCACERT_E_SUCCESS : ATCACERT_E_VERIFY_FAILED;
    a39a:	2313      	movs	r3, #19
    a39c:	18fb      	adds	r3, r7, r3
    a39e:	781b      	ldrb	r3, [r3, #0]
    a3a0:	2b00      	cmp	r3, #0
    a3a2:	d001      	beq.n	a3a8 <atcacert_verify_response_hw+0x58>
    a3a4:	2300      	movs	r3, #0
    a3a6:	e001      	b.n	a3ac <atcacert_verify_response_hw+0x5c>
    a3a8:	230c      	movs	r3, #12
    a3aa:	46c0      	nop			; (mov r8, r8)
    a3ac:	0018      	movs	r0, r3
    a3ae:	46bd      	mov	sp, r7
    a3b0:	b007      	add	sp, #28
    a3b2:	bd90      	pop	{r4, r7, pc}
    a3b4:	0000b7a9 	.word	0x0000b7a9

0000a3b8 <newATCACommand>:
/** \brief constructor for ATCACommand
 * \param[in] device_type - specifies which set of commands and execution times should be associated with this command object
 * \return ATCACommand instance
 */
ATCACommand newATCACommand( ATCADeviceType device_type )  // constructor
{
    a3b8:	b590      	push	{r4, r7, lr}
    a3ba:	b085      	sub	sp, #20
    a3bc:	af00      	add	r7, sp, #0
    a3be:	0002      	movs	r2, r0
    a3c0:	1dfb      	adds	r3, r7, #7
    a3c2:	701a      	strb	r2, [r3, #0]
	ATCA_STATUS status = ATCA_SUCCESS;
    a3c4:	230b      	movs	r3, #11
    a3c6:	18fb      	adds	r3, r7, r3
    a3c8:	2200      	movs	r2, #0
    a3ca:	701a      	strb	r2, [r3, #0]
	ATCACommand cacmd = (ATCACommand)malloc(sizeof(struct atca_command));
    a3cc:	2008      	movs	r0, #8
    a3ce:	4b11      	ldr	r3, [pc, #68]	; (a414 <newATCACommand+0x5c>)
    a3d0:	4798      	blx	r3
    a3d2:	0003      	movs	r3, r0
    a3d4:	60fb      	str	r3, [r7, #12]

	cacmd->dt = device_type;
    a3d6:	68fb      	ldr	r3, [r7, #12]
    a3d8:	1dfa      	adds	r2, r7, #7
    a3da:	7812      	ldrb	r2, [r2, #0]
    a3dc:	701a      	strb	r2, [r3, #0]
	status = atInitExecTimes(cacmd, device_type);  // setup typical execution times for this device type
    a3de:	230b      	movs	r3, #11
    a3e0:	18fc      	adds	r4, r7, r3
    a3e2:	1dfb      	adds	r3, r7, #7
    a3e4:	781a      	ldrb	r2, [r3, #0]
    a3e6:	68fb      	ldr	r3, [r7, #12]
    a3e8:	0011      	movs	r1, r2
    a3ea:	0018      	movs	r0, r3
    a3ec:	4b0a      	ldr	r3, [pc, #40]	; (a418 <newATCACommand+0x60>)
    a3ee:	4798      	blx	r3
    a3f0:	0003      	movs	r3, r0
    a3f2:	7023      	strb	r3, [r4, #0]

	if (status != ATCA_SUCCESS) {
    a3f4:	230b      	movs	r3, #11
    a3f6:	18fb      	adds	r3, r7, r3
    a3f8:	781b      	ldrb	r3, [r3, #0]
    a3fa:	2b00      	cmp	r3, #0
    a3fc:	d005      	beq.n	a40a <newATCACommand+0x52>
		free(cacmd);
    a3fe:	68fb      	ldr	r3, [r7, #12]
    a400:	0018      	movs	r0, r3
    a402:	4b06      	ldr	r3, [pc, #24]	; (a41c <newATCACommand+0x64>)
    a404:	4798      	blx	r3
		cacmd = NULL;
    a406:	2300      	movs	r3, #0
    a408:	60fb      	str	r3, [r7, #12]
	}

	return cacmd;
    a40a:	68fb      	ldr	r3, [r7, #12]
}
    a40c:	0018      	movs	r0, r3
    a40e:	46bd      	mov	sp, r7
    a410:	b005      	add	sp, #20
    a412:	bd90      	pop	{r4, r7, pc}
    a414:	000127a1 	.word	0x000127a1
    a418:	0000a7b1 	.word	0x0000a7b1
    a41c:	000127b5 	.word	0x000127b5

0000a420 <atGenDig>:
 * \param[in] packet    pointer to the packet containing the command being built
 * \param[in] hasMACKey
 * \return ATCA_STATUS
 */
ATCA_STATUS atGenDig(ATCACommand cacmd, ATCAPacket *packet, bool hasMACKey )
{
    a420:	b580      	push	{r7, lr}
    a422:	b084      	sub	sp, #16
    a424:	af00      	add	r7, sp, #0
    a426:	60f8      	str	r0, [r7, #12]
    a428:	60b9      	str	r1, [r7, #8]
    a42a:	1dfb      	adds	r3, r7, #7
    a42c:	701a      	strb	r2, [r3, #0]

	// Set the opcode & parameters
	packet->opcode = ATCA_GENDIG;
    a42e:	68bb      	ldr	r3, [r7, #8]
    a430:	2215      	movs	r2, #21
    a432:	709a      	strb	r2, [r3, #2]

	if ( packet->param1 == 0x03 ) // shared nonce mode
    a434:	68bb      	ldr	r3, [r7, #8]
    a436:	78db      	ldrb	r3, [r3, #3]
    a438:	2b03      	cmp	r3, #3
    a43a:	d103      	bne.n	a444 <atGenDig+0x24>
		packet->txsize = GENDIG_COUNT + 32;
    a43c:	68bb      	ldr	r3, [r7, #8]
    a43e:	2227      	movs	r2, #39	; 0x27
    a440:	705a      	strb	r2, [r3, #1]
    a442:	e00a      	b.n	a45a <atGenDig+0x3a>
	else if ( hasMACKey == true )
    a444:	1dfb      	adds	r3, r7, #7
    a446:	781b      	ldrb	r3, [r3, #0]
    a448:	2b00      	cmp	r3, #0
    a44a:	d003      	beq.n	a454 <atGenDig+0x34>
		packet->txsize = GENDIG_COUNT_DATA;
    a44c:	68bb      	ldr	r3, [r7, #8]
    a44e:	220b      	movs	r2, #11
    a450:	705a      	strb	r2, [r3, #1]
    a452:	e002      	b.n	a45a <atGenDig+0x3a>
	else
		packet->txsize = GENDIG_COUNT;
    a454:	68bb      	ldr	r3, [r7, #8]
    a456:	2207      	movs	r2, #7
    a458:	705a      	strb	r2, [r3, #1]

	packet->rxsize = GENDIG_RSP_SIZE;
    a45a:	68bb      	ldr	r3, [r7, #8]
    a45c:	228a      	movs	r2, #138	; 0x8a
    a45e:	2104      	movs	r1, #4
    a460:	5299      	strh	r1, [r3, r2]

	atCalcCrc( packet );
    a462:	68bb      	ldr	r3, [r7, #8]
    a464:	0018      	movs	r0, r3
    a466:	4b03      	ldr	r3, [pc, #12]	; (a474 <atGenDig+0x54>)
    a468:	4798      	blx	r3
	return ATCA_SUCCESS;
    a46a:	2300      	movs	r3, #0
}
    a46c:	0018      	movs	r0, r3
    a46e:	46bd      	mov	sp, r7
    a470:	b004      	add	sp, #16
    a472:	bd80      	pop	{r7, pc}
    a474:	0000a915 	.word	0x0000a915

0000a478 <atGenKey>:
 * \param[in] packet    pointer to the packet containing the command being built
 * \param[in] isPubKey  indicates whether "other data" is present in packet
 * \return ATCA_STATUS
 */
ATCA_STATUS atGenKey(ATCACommand cacmd, ATCAPacket *packet, bool isPubKey )
{
    a478:	b580      	push	{r7, lr}
    a47a:	b084      	sub	sp, #16
    a47c:	af00      	add	r7, sp, #0
    a47e:	60f8      	str	r0, [r7, #12]
    a480:	60b9      	str	r1, [r7, #8]
    a482:	1dfb      	adds	r3, r7, #7
    a484:	701a      	strb	r2, [r3, #0]

	// Set the opcode & parameters
	packet->opcode = ATCA_GENKEY;
    a486:	68bb      	ldr	r3, [r7, #8]
    a488:	2240      	movs	r2, #64	; 0x40
    a48a:	709a      	strb	r2, [r3, #2]

	switch ( isPubKey ) {
    a48c:	1dfb      	adds	r3, r7, #7
    a48e:	781b      	ldrb	r3, [r3, #0]
    a490:	2b01      	cmp	r3, #1
    a492:	d103      	bne.n	a49c <atGenKey+0x24>
	case true:
		packet->txsize = GENKEY_COUNT_DATA;
    a494:	68bb      	ldr	r3, [r7, #8]
    a496:	220a      	movs	r2, #10
    a498:	705a      	strb	r2, [r3, #1]
		break;
    a49a:	e003      	b.n	a4a4 <atGenKey+0x2c>
	case false:
		packet->txsize = GENKEY_COUNT;
    a49c:	68bb      	ldr	r3, [r7, #8]
    a49e:	2207      	movs	r2, #7
    a4a0:	705a      	strb	r2, [r3, #1]
		break;
    a4a2:	46c0      	nop			; (mov r8, r8)
	}

	packet->rxsize = GENKEY_RSP_SIZE_LONG;
    a4a4:	68bb      	ldr	r3, [r7, #8]
    a4a6:	228a      	movs	r2, #138	; 0x8a
    a4a8:	214b      	movs	r1, #75	; 0x4b
    a4aa:	5299      	strh	r1, [r3, r2]

	atCalcCrc( packet );
    a4ac:	68bb      	ldr	r3, [r7, #8]
    a4ae:	0018      	movs	r0, r3
    a4b0:	4b03      	ldr	r3, [pc, #12]	; (a4c0 <atGenKey+0x48>)
    a4b2:	4798      	blx	r3
	return ATCA_SUCCESS;
    a4b4:	2300      	movs	r3, #0
}
    a4b6:	0018      	movs	r0, r3
    a4b8:	46bd      	mov	sp, r7
    a4ba:	b004      	add	sp, #16
    a4bc:	bd80      	pop	{r7, pc}
    a4be:	46c0      	nop			; (mov r8, r8)
    a4c0:	0000a915 	.word	0x0000a915

0000a4c4 <atInfo>:
 * \param[in] cacmd   instance
 * \param[in] packet  pointer to the packet containing the command being built
 * \return ATCA_STATUS
 */
ATCA_STATUS atInfo( ATCACommand cacmd, ATCAPacket *packet )
{
    a4c4:	b580      	push	{r7, lr}
    a4c6:	b082      	sub	sp, #8
    a4c8:	af00      	add	r7, sp, #0
    a4ca:	6078      	str	r0, [r7, #4]
    a4cc:	6039      	str	r1, [r7, #0]

	// Set the opcode & parameters
	packet->opcode = ATCA_INFO;
    a4ce:	683b      	ldr	r3, [r7, #0]
    a4d0:	2230      	movs	r2, #48	; 0x30
    a4d2:	709a      	strb	r2, [r3, #2]
	packet->txsize = INFO_COUNT;
    a4d4:	683b      	ldr	r3, [r7, #0]
    a4d6:	2207      	movs	r2, #7
    a4d8:	705a      	strb	r2, [r3, #1]
	packet->rxsize = INFO_RSP_SIZE;
    a4da:	683b      	ldr	r3, [r7, #0]
    a4dc:	228a      	movs	r2, #138	; 0x8a
    a4de:	2107      	movs	r1, #7
    a4e0:	5299      	strh	r1, [r3, r2]

	atCalcCrc( packet );
    a4e2:	683b      	ldr	r3, [r7, #0]
    a4e4:	0018      	movs	r0, r3
    a4e6:	4b03      	ldr	r3, [pc, #12]	; (a4f4 <atInfo+0x30>)
    a4e8:	4798      	blx	r3
	return ATCA_SUCCESS;
    a4ea:	2300      	movs	r3, #0
}
    a4ec:	0018      	movs	r0, r3
    a4ee:	46bd      	mov	sp, r7
    a4f0:	b002      	add	sp, #8
    a4f2:	bd80      	pop	{r7, pc}
    a4f4:	0000a915 	.word	0x0000a915

0000a4f8 <atLock>:
 * \param[in] cacmd   instance
 * \param[in] packet  pointer to the packet containing the command being built
 * \return ATCA_STATUS
 */
ATCA_STATUS atLock(  ATCACommand cacmd, ATCAPacket *packet )
{
    a4f8:	b580      	push	{r7, lr}
    a4fa:	b082      	sub	sp, #8
    a4fc:	af00      	add	r7, sp, #0
    a4fe:	6078      	str	r0, [r7, #4]
    a500:	6039      	str	r1, [r7, #0]

	// Set the opcode & parameters
	packet->opcode = ATCA_LOCK;
    a502:	683b      	ldr	r3, [r7, #0]
    a504:	2217      	movs	r2, #23
    a506:	709a      	strb	r2, [r3, #2]
	packet->txsize = LOCK_COUNT;
    a508:	683b      	ldr	r3, [r7, #0]
    a50a:	2207      	movs	r2, #7
    a50c:	705a      	strb	r2, [r3, #1]
	packet->rxsize = LOCK_RSP_SIZE;
    a50e:	683b      	ldr	r3, [r7, #0]
    a510:	228a      	movs	r2, #138	; 0x8a
    a512:	2104      	movs	r1, #4
    a514:	5299      	strh	r1, [r3, r2]

	atCalcCrc( packet );
    a516:	683b      	ldr	r3, [r7, #0]
    a518:	0018      	movs	r0, r3
    a51a:	4b03      	ldr	r3, [pc, #12]	; (a528 <atLock+0x30>)
    a51c:	4798      	blx	r3
	return ATCA_SUCCESS;
    a51e:	2300      	movs	r3, #0
}
    a520:	0018      	movs	r0, r3
    a522:	46bd      	mov	sp, r7
    a524:	b002      	add	sp, #8
    a526:	bd80      	pop	{r7, pc}
    a528:	0000a915 	.word	0x0000a915

0000a52c <atNonce>:
 * \param[in] cacmd   instance
 * \param[in] packet  pointer to the packet containing the command being built
 * \return ATCA_STATUS
 */
ATCA_STATUS atNonce( ATCACommand cacmd, ATCAPacket *packet )
{
    a52c:	b580      	push	{r7, lr}
    a52e:	b084      	sub	sp, #16
    a530:	af00      	add	r7, sp, #0
    a532:	6078      	str	r0, [r7, #4]
    a534:	6039      	str	r1, [r7, #0]
	// Set the opcode & parameters
	// variable packet size
	packet->opcode = ATCA_NONCE;
    a536:	683b      	ldr	r3, [r7, #0]
    a538:	2216      	movs	r2, #22
    a53a:	709a      	strb	r2, [r3, #2]
	int mode = packet->param1 & 0x03;
    a53c:	683b      	ldr	r3, [r7, #0]
    a53e:	78db      	ldrb	r3, [r3, #3]
    a540:	001a      	movs	r2, r3
    a542:	2303      	movs	r3, #3
    a544:	4013      	ands	r3, r2
    a546:	60fb      	str	r3, [r7, #12]

	if ( (mode == 0 || mode == 1) ) {       // mode[0:1] == 0 | 1 then NumIn is 20 bytes
    a548:	68fb      	ldr	r3, [r7, #12]
    a54a:	2b00      	cmp	r3, #0
    a54c:	d002      	beq.n	a554 <atNonce+0x28>
    a54e:	68fb      	ldr	r3, [r7, #12]
    a550:	2b01      	cmp	r3, #1
    a552:	d107      	bne.n	a564 <atNonce+0x38>
		packet->txsize = NONCE_COUNT_SHORT; // 20 byte challenge
    a554:	683b      	ldr	r3, [r7, #0]
    a556:	221b      	movs	r2, #27
    a558:	705a      	strb	r2, [r3, #1]
		packet->rxsize = NONCE_RSP_SIZE_LONG;
    a55a:	683b      	ldr	r3, [r7, #0]
    a55c:	228a      	movs	r2, #138	; 0x8a
    a55e:	2123      	movs	r1, #35	; 0x23
    a560:	5299      	strh	r1, [r3, r2]
    a562:	e00c      	b.n	a57e <atNonce+0x52>
	} else if ( mode == 0x03 ) {            // NumIn is 32 bytes
    a564:	68fb      	ldr	r3, [r7, #12]
    a566:	2b03      	cmp	r3, #3
    a568:	d107      	bne.n	a57a <atNonce+0x4e>
		packet->txsize = NONCE_COUNT_LONG;  // 32 byte challenge
    a56a:	683b      	ldr	r3, [r7, #0]
    a56c:	2227      	movs	r2, #39	; 0x27
    a56e:	705a      	strb	r2, [r3, #1]
		packet->rxsize = NONCE_RSP_SIZE_SHORT;
    a570:	683b      	ldr	r3, [r7, #0]
    a572:	228a      	movs	r2, #138	; 0x8a
    a574:	2104      	movs	r1, #4
    a576:	5299      	strh	r1, [r3, r2]
    a578:	e001      	b.n	a57e <atNonce+0x52>
	} else
		return ATCA_BAD_PARAM;
    a57a:	23e2      	movs	r3, #226	; 0xe2
    a57c:	e004      	b.n	a588 <atNonce+0x5c>

	atCalcCrc( packet );
    a57e:	683b      	ldr	r3, [r7, #0]
    a580:	0018      	movs	r0, r3
    a582:	4b03      	ldr	r3, [pc, #12]	; (a590 <atNonce+0x64>)
    a584:	4798      	blx	r3
	return ATCA_SUCCESS;
    a586:	2300      	movs	r3, #0
}
    a588:	0018      	movs	r0, r3
    a58a:	46bd      	mov	sp, r7
    a58c:	b004      	add	sp, #16
    a58e:	bd80      	pop	{r7, pc}
    a590:	0000a915 	.word	0x0000a915

0000a594 <atPrivWrite>:
 * \param[in] cacmd   instance
 * \param[in] packet  pointer to the packet containing the command being built
 * \return ATCA_STATUS
 */
ATCA_STATUS atPrivWrite( ATCACommand cacmd, ATCAPacket *packet )
{
    a594:	b580      	push	{r7, lr}
    a596:	b082      	sub	sp, #8
    a598:	af00      	add	r7, sp, #0
    a59a:	6078      	str	r0, [r7, #4]
    a59c:	6039      	str	r1, [r7, #0]
	// Set the opcode & parameters
	packet->opcode = ATCA_PRIVWRITE;
    a59e:	683b      	ldr	r3, [r7, #0]
    a5a0:	2246      	movs	r2, #70	; 0x46
    a5a2:	709a      	strb	r2, [r3, #2]
	packet->txsize = PRIVWRITE_COUNT;
    a5a4:	683b      	ldr	r3, [r7, #0]
    a5a6:	224b      	movs	r2, #75	; 0x4b
    a5a8:	705a      	strb	r2, [r3, #1]
	packet->rxsize = PRIVWRITE_RSP_SIZE;
    a5aa:	683b      	ldr	r3, [r7, #0]
    a5ac:	228a      	movs	r2, #138	; 0x8a
    a5ae:	2104      	movs	r1, #4
    a5b0:	5299      	strh	r1, [r3, r2]

	atCalcCrc( packet );
    a5b2:	683b      	ldr	r3, [r7, #0]
    a5b4:	0018      	movs	r0, r3
    a5b6:	4b03      	ldr	r3, [pc, #12]	; (a5c4 <atPrivWrite+0x30>)
    a5b8:	4798      	blx	r3
	return ATCA_SUCCESS;
    a5ba:	2300      	movs	r3, #0
}
    a5bc:	0018      	movs	r0, r3
    a5be:	46bd      	mov	sp, r7
    a5c0:	b002      	add	sp, #8
    a5c2:	bd80      	pop	{r7, pc}
    a5c4:	0000a915 	.word	0x0000a915

0000a5c8 <atRandom>:
 * \param[in] cacmd   instance
 * \param[in] packet  pointer to the packet containing the command being built
 * \return ATCA_STATUS
 */
ATCA_STATUS atRandom( ATCACommand cacmd, ATCAPacket *packet )
{
    a5c8:	b580      	push	{r7, lr}
    a5ca:	b082      	sub	sp, #8
    a5cc:	af00      	add	r7, sp, #0
    a5ce:	6078      	str	r0, [r7, #4]
    a5d0:	6039      	str	r1, [r7, #0]

	// Set the opcode & parameters
	packet->opcode = ATCA_RANDOM;
    a5d2:	683b      	ldr	r3, [r7, #0]
    a5d4:	221b      	movs	r2, #27
    a5d6:	709a      	strb	r2, [r3, #2]
	packet->txsize = RANDOM_COUNT;
    a5d8:	683b      	ldr	r3, [r7, #0]
    a5da:	2207      	movs	r2, #7
    a5dc:	705a      	strb	r2, [r3, #1]
	packet->rxsize = RANDOM_RSP_SIZE;
    a5de:	683b      	ldr	r3, [r7, #0]
    a5e0:	228a      	movs	r2, #138	; 0x8a
    a5e2:	2123      	movs	r1, #35	; 0x23
    a5e4:	5299      	strh	r1, [r3, r2]

	atCalcCrc( packet );
    a5e6:	683b      	ldr	r3, [r7, #0]
    a5e8:	0018      	movs	r0, r3
    a5ea:	4b03      	ldr	r3, [pc, #12]	; (a5f8 <atRandom+0x30>)
    a5ec:	4798      	blx	r3
	return ATCA_SUCCESS;
    a5ee:	2300      	movs	r3, #0
}
    a5f0:	0018      	movs	r0, r3
    a5f2:	46bd      	mov	sp, r7
    a5f4:	b002      	add	sp, #8
    a5f6:	bd80      	pop	{r7, pc}
    a5f8:	0000a915 	.word	0x0000a915

0000a5fc <atRead>:
 * \param[in] cacmd   instance
 * \param[in] packet  pointer to the packet containing the command being built
 * \return ATCA_STATUS
 */
ATCA_STATUS atRead( ATCACommand cacmd, ATCAPacket *packet )
{
    a5fc:	b580      	push	{r7, lr}
    a5fe:	b082      	sub	sp, #8
    a600:	af00      	add	r7, sp, #0
    a602:	6078      	str	r0, [r7, #4]
    a604:	6039      	str	r1, [r7, #0]

	// Set the opcode & parameters
	packet->opcode = ATCA_READ;
    a606:	683b      	ldr	r3, [r7, #0]
    a608:	2202      	movs	r2, #2
    a60a:	709a      	strb	r2, [r3, #2]
	packet->txsize = READ_COUNT;
    a60c:	683b      	ldr	r3, [r7, #0]
    a60e:	2207      	movs	r2, #7
    a610:	705a      	strb	r2, [r3, #1]

	// variable response size based on read type
	if ((packet->param1 & 0x80) == 0 )
    a612:	683b      	ldr	r3, [r7, #0]
    a614:	78db      	ldrb	r3, [r3, #3]
    a616:	b25b      	sxtb	r3, r3
    a618:	2b00      	cmp	r3, #0
    a61a:	db04      	blt.n	a626 <atRead+0x2a>
		packet->rxsize = READ_4_RSP_SIZE;
    a61c:	683b      	ldr	r3, [r7, #0]
    a61e:	228a      	movs	r2, #138	; 0x8a
    a620:	2107      	movs	r1, #7
    a622:	5299      	strh	r1, [r3, r2]
    a624:	e003      	b.n	a62e <atRead+0x32>
	else
		packet->rxsize = READ_32_RSP_SIZE;
    a626:	683b      	ldr	r3, [r7, #0]
    a628:	228a      	movs	r2, #138	; 0x8a
    a62a:	2123      	movs	r1, #35	; 0x23
    a62c:	5299      	strh	r1, [r3, r2]

	atCalcCrc( packet );
    a62e:	683b      	ldr	r3, [r7, #0]
    a630:	0018      	movs	r0, r3
    a632:	4b03      	ldr	r3, [pc, #12]	; (a640 <atRead+0x44>)
    a634:	4798      	blx	r3
	return ATCA_SUCCESS;
    a636:	2300      	movs	r3, #0
}
    a638:	0018      	movs	r0, r3
    a63a:	46bd      	mov	sp, r7
    a63c:	b002      	add	sp, #8
    a63e:	bd80      	pop	{r7, pc}
    a640:	0000a915 	.word	0x0000a915

0000a644 <atSign>:
 * \param[in] cacmd   instance
 * \param[in] packet  pointer to the packet containing the command being built
 * \return ATCA_STATUS
 */
ATCA_STATUS atSign( ATCACommand cacmd, ATCAPacket *packet )
{
    a644:	b580      	push	{r7, lr}
    a646:	b082      	sub	sp, #8
    a648:	af00      	add	r7, sp, #0
    a64a:	6078      	str	r0, [r7, #4]
    a64c:	6039      	str	r1, [r7, #0]

	// Set the opcode & parameters
	packet->opcode = ATCA_SIGN;
    a64e:	683b      	ldr	r3, [r7, #0]
    a650:	2241      	movs	r2, #65	; 0x41
    a652:	709a      	strb	r2, [r3, #2]
	packet->txsize = SIGN_COUNT;
    a654:	683b      	ldr	r3, [r7, #0]
    a656:	2207      	movs	r2, #7
    a658:	705a      	strb	r2, [r3, #1]

	// could be a 64 or 72 byte response depending upon the key configuration for the KeyID
	packet->rxsize = ATCA_RSP_SIZE_64;
    a65a:	683b      	ldr	r3, [r7, #0]
    a65c:	228a      	movs	r2, #138	; 0x8a
    a65e:	2143      	movs	r1, #67	; 0x43
    a660:	5299      	strh	r1, [r3, r2]

	atCalcCrc( packet );
    a662:	683b      	ldr	r3, [r7, #0]
    a664:	0018      	movs	r0, r3
    a666:	4b03      	ldr	r3, [pc, #12]	; (a674 <atSign+0x30>)
    a668:	4798      	blx	r3
	return ATCA_SUCCESS;
    a66a:	2300      	movs	r3, #0
}
    a66c:	0018      	movs	r0, r3
    a66e:	46bd      	mov	sp, r7
    a670:	b002      	add	sp, #8
    a672:	bd80      	pop	{r7, pc}
    a674:	0000a915 	.word	0x0000a915

0000a678 <atVerify>:
 * \param[in] cacmd   instance
 * \param[in] packet  pointer to the packet containing the command being built
 * \return ATCA_STATUS
 */
ATCA_STATUS atVerify( ATCACommand cacmd, ATCAPacket *packet )
{
    a678:	b580      	push	{r7, lr}
    a67a:	b082      	sub	sp, #8
    a67c:	af00      	add	r7, sp, #0
    a67e:	6078      	str	r0, [r7, #4]
    a680:	6039      	str	r1, [r7, #0]

	// Set the opcode & parameters
	packet->opcode = ATCA_VERIFY;
    a682:	683b      	ldr	r3, [r7, #0]
    a684:	2245      	movs	r2, #69	; 0x45
    a686:	709a      	strb	r2, [r3, #2]

	// variable packet size based on mode
	switch ( packet->param1 ) {
    a688:	683b      	ldr	r3, [r7, #0]
    a68a:	78db      	ldrb	r3, [r3, #3]
    a68c:	2b07      	cmp	r3, #7
    a68e:	d814      	bhi.n	a6ba <atVerify+0x42>
    a690:	009a      	lsls	r2, r3, #2
    a692:	4b11      	ldr	r3, [pc, #68]	; (a6d8 <atVerify+0x60>)
    a694:	18d3      	adds	r3, r2, r3
    a696:	681b      	ldr	r3, [r3, #0]
    a698:	469f      	mov	pc, r3
	case 0:  // Stored mode
		packet->txsize = VERIFY_256_STORED_COUNT;
    a69a:	683b      	ldr	r3, [r7, #0]
    a69c:	2247      	movs	r2, #71	; 0x47
    a69e:	705a      	strb	r2, [r3, #1]
		break;
    a6a0:	e00d      	b.n	a6be <atVerify+0x46>
	case 1:  // ValidateExternal mode
		packet->txsize = VERIFY_256_EXTERNAL_COUNT;
    a6a2:	683b      	ldr	r3, [r7, #0]
    a6a4:	2287      	movs	r2, #135	; 0x87
    a6a6:	705a      	strb	r2, [r3, #1]
		break;
    a6a8:	e009      	b.n	a6be <atVerify+0x46>
	case 2:  // External mode
		packet->txsize = VERIFY_256_EXTERNAL_COUNT;
    a6aa:	683b      	ldr	r3, [r7, #0]
    a6ac:	2287      	movs	r2, #135	; 0x87
    a6ae:	705a      	strb	r2, [r3, #1]
		break;
    a6b0:	e005      	b.n	a6be <atVerify+0x46>
	case 3:     // Validate mode
	case 7:     // Invalidate mode
		packet->txsize = VERIFY_256_VALIDATE_COUNT;
    a6b2:	683b      	ldr	r3, [r7, #0]
    a6b4:	225a      	movs	r2, #90	; 0x5a
    a6b6:	705a      	strb	r2, [r3, #1]
		break;
    a6b8:	e001      	b.n	a6be <atVerify+0x46>
	default:
		return ATCA_BAD_PARAM;
    a6ba:	23e2      	movs	r3, #226	; 0xe2
    a6bc:	e008      	b.n	a6d0 <atVerify+0x58>
	}
	packet->rxsize = VERIFY_RSP_SIZE;
    a6be:	683b      	ldr	r3, [r7, #0]
    a6c0:	228a      	movs	r2, #138	; 0x8a
    a6c2:	2104      	movs	r1, #4
    a6c4:	5299      	strh	r1, [r3, r2]

	atCalcCrc( packet );
    a6c6:	683b      	ldr	r3, [r7, #0]
    a6c8:	0018      	movs	r0, r3
    a6ca:	4b04      	ldr	r3, [pc, #16]	; (a6dc <atVerify+0x64>)
    a6cc:	4798      	blx	r3
	return ATCA_SUCCESS;
    a6ce:	2300      	movs	r3, #0
}
    a6d0:	0018      	movs	r0, r3
    a6d2:	46bd      	mov	sp, r7
    a6d4:	b002      	add	sp, #8
    a6d6:	bd80      	pop	{r7, pc}
    a6d8:	000152b4 	.word	0x000152b4
    a6dc:	0000a915 	.word	0x0000a915

0000a6e0 <atWrite>:
 * \param[in] cacmd   instance
 * \param[in] packet  pointer to the packet containing the command being built
 * \return ATCA_STATUS
 */
ATCA_STATUS atWrite( ATCACommand cacmd, ATCAPacket *packet )
{
    a6e0:	b580      	push	{r7, lr}
    a6e2:	b084      	sub	sp, #16
    a6e4:	af00      	add	r7, sp, #0
    a6e6:	6078      	str	r0, [r7, #4]
    a6e8:	6039      	str	r1, [r7, #0]
	int macsize;
	int writesize;

	// Set the opcode & parameters
	packet->opcode = ATCA_WRITE;
    a6ea:	683b      	ldr	r3, [r7, #0]
    a6ec:	2212      	movs	r2, #18
    a6ee:	709a      	strb	r2, [r3, #2]

	macsize = ( packet->param1 & 0x40 ? 32 : 0 );  // if encrypted, use MAC
    a6f0:	683b      	ldr	r3, [r7, #0]
    a6f2:	78db      	ldrb	r3, [r3, #3]
    a6f4:	001a      	movs	r2, r3
    a6f6:	2340      	movs	r3, #64	; 0x40
    a6f8:	4013      	ands	r3, r2
    a6fa:	d001      	beq.n	a700 <atWrite+0x20>
    a6fc:	2320      	movs	r3, #32
    a6fe:	e000      	b.n	a702 <atWrite+0x22>
    a700:	2300      	movs	r3, #0
    a702:	60fb      	str	r3, [r7, #12]
	writesize = ( packet->param1 & 0x80 ? 32 : 4 );
    a704:	683b      	ldr	r3, [r7, #0]
    a706:	78db      	ldrb	r3, [r3, #3]
    a708:	b25b      	sxtb	r3, r3
    a70a:	2b00      	cmp	r3, #0
    a70c:	da01      	bge.n	a712 <atWrite+0x32>
    a70e:	2320      	movs	r3, #32
    a710:	e000      	b.n	a714 <atWrite+0x34>
    a712:	2304      	movs	r3, #4
    a714:	60bb      	str	r3, [r7, #8]

	if ( macsize == 32 && writesize == 32 )
    a716:	68fb      	ldr	r3, [r7, #12]
    a718:	2b20      	cmp	r3, #32
    a71a:	d106      	bne.n	a72a <atWrite+0x4a>
    a71c:	68bb      	ldr	r3, [r7, #8]
    a71e:	2b20      	cmp	r3, #32
    a720:	d103      	bne.n	a72a <atWrite+0x4a>
		packet->txsize = WRITE_COUNT_LONG_MAC;
    a722:	683b      	ldr	r3, [r7, #0]
    a724:	2247      	movs	r2, #71	; 0x47
    a726:	705a      	strb	r2, [r3, #1]
    a728:	e01c      	b.n	a764 <atWrite+0x84>
	else if ( macsize == 32 && writesize == 4 )
    a72a:	68fb      	ldr	r3, [r7, #12]
    a72c:	2b20      	cmp	r3, #32
    a72e:	d106      	bne.n	a73e <atWrite+0x5e>
    a730:	68bb      	ldr	r3, [r7, #8]
    a732:	2b04      	cmp	r3, #4
    a734:	d103      	bne.n	a73e <atWrite+0x5e>
		packet->txsize = WRITE_COUNT_SHORT_MAC;
    a736:	683b      	ldr	r3, [r7, #0]
    a738:	222b      	movs	r2, #43	; 0x2b
    a73a:	705a      	strb	r2, [r3, #1]
    a73c:	e012      	b.n	a764 <atWrite+0x84>
	else if ( macsize == 0 && writesize == 32 )
    a73e:	68fb      	ldr	r3, [r7, #12]
    a740:	2b00      	cmp	r3, #0
    a742:	d106      	bne.n	a752 <atWrite+0x72>
    a744:	68bb      	ldr	r3, [r7, #8]
    a746:	2b20      	cmp	r3, #32
    a748:	d103      	bne.n	a752 <atWrite+0x72>
		packet->txsize = WRITE_COUNT_LONG;
    a74a:	683b      	ldr	r3, [r7, #0]
    a74c:	2227      	movs	r2, #39	; 0x27
    a74e:	705a      	strb	r2, [r3, #1]
    a750:	e008      	b.n	a764 <atWrite+0x84>
	else if ( macsize == 0 && writesize == 4 )
    a752:	68fb      	ldr	r3, [r7, #12]
    a754:	2b00      	cmp	r3, #0
    a756:	d105      	bne.n	a764 <atWrite+0x84>
    a758:	68bb      	ldr	r3, [r7, #8]
    a75a:	2b04      	cmp	r3, #4
    a75c:	d102      	bne.n	a764 <atWrite+0x84>
		packet->txsize = WRITE_COUNT_SHORT;
    a75e:	683b      	ldr	r3, [r7, #0]
    a760:	220b      	movs	r2, #11
    a762:	705a      	strb	r2, [r3, #1]

	packet->rxsize = WRITE_RSP_SIZE;
    a764:	683b      	ldr	r3, [r7, #0]
    a766:	228a      	movs	r2, #138	; 0x8a
    a768:	2104      	movs	r1, #4
    a76a:	5299      	strh	r1, [r3, r2]
	atCalcCrc( packet );
    a76c:	683b      	ldr	r3, [r7, #0]
    a76e:	0018      	movs	r0, r3
    a770:	4b03      	ldr	r3, [pc, #12]	; (a780 <atWrite+0xa0>)
    a772:	4798      	blx	r3
	return ATCA_SUCCESS;
    a774:	2300      	movs	r3, #0
}
    a776:	0018      	movs	r0, r3
    a778:	46bd      	mov	sp, r7
    a77a:	b004      	add	sp, #16
    a77c:	bd80      	pop	{r7, pc}
    a77e:	46c0      	nop			; (mov r8, r8)
    a780:	0000a915 	.word	0x0000a915

0000a784 <deleteATCACommand>:
/** \brief ATCACommand destructor
 * \param[in] cacmd instance of a command object
 */

void deleteATCACommand( ATCACommand *cacmd )  // destructor
{
    a784:	b580      	push	{r7, lr}
    a786:	b082      	sub	sp, #8
    a788:	af00      	add	r7, sp, #0
    a78a:	6078      	str	r0, [r7, #4]
	if ( *cacmd )
    a78c:	687b      	ldr	r3, [r7, #4]
    a78e:	681b      	ldr	r3, [r3, #0]
    a790:	2b00      	cmp	r3, #0
    a792:	d004      	beq.n	a79e <deleteATCACommand+0x1a>
		free((void*)*cacmd);
    a794:	687b      	ldr	r3, [r7, #4]
    a796:	681b      	ldr	r3, [r3, #0]
    a798:	0018      	movs	r0, r3
    a79a:	4b04      	ldr	r3, [pc, #16]	; (a7ac <deleteATCACommand+0x28>)
    a79c:	4798      	blx	r3

	*cacmd = NULL;
    a79e:	687b      	ldr	r3, [r7, #4]
    a7a0:	2200      	movs	r2, #0
    a7a2:	601a      	str	r2, [r3, #0]
}
    a7a4:	46c0      	nop			; (mov r8, r8)
    a7a6:	46bd      	mov	sp, r7
    a7a8:	b002      	add	sp, #8
    a7aa:	bd80      	pop	{r7, pc}
    a7ac:	000127b5 	.word	0x000127b5

0000a7b0 <atInitExecTimes>:
 * \param[in] device_type - the device type - execution times vary by device type
 * \return ATCA_STATUS
 */

ATCA_STATUS atInitExecTimes(ATCACommand cacmd, ATCADeviceType device_type)
{
    a7b0:	b580      	push	{r7, lr}
    a7b2:	b082      	sub	sp, #8
    a7b4:	af00      	add	r7, sp, #0
    a7b6:	6078      	str	r0, [r7, #4]
    a7b8:	000a      	movs	r2, r1
    a7ba:	1cfb      	adds	r3, r7, #3
    a7bc:	701a      	strb	r2, [r3, #0]
	switch ( device_type ) {
    a7be:	1cfb      	adds	r3, r7, #3
    a7c0:	781b      	ldrb	r3, [r3, #0]
    a7c2:	2b00      	cmp	r3, #0
    a7c4:	d006      	beq.n	a7d4 <atInitExecTimes+0x24>
    a7c6:	db09      	blt.n	a7dc <atInitExecTimes+0x2c>
    a7c8:	2b02      	cmp	r3, #2
    a7ca:	dc07      	bgt.n	a7dc <atInitExecTimes+0x2c>
	case ATECC108A:
	case ATECC508A:
		cacmd->execution_times = exectimes_x08a;
    a7cc:	687b      	ldr	r3, [r7, #4]
    a7ce:	4a07      	ldr	r2, [pc, #28]	; (a7ec <atInitExecTimes+0x3c>)
    a7d0:	605a      	str	r2, [r3, #4]
		break;
    a7d2:	e005      	b.n	a7e0 <atInitExecTimes+0x30>
	case ATSHA204A:
		cacmd->execution_times = exectimes_204a;
    a7d4:	687b      	ldr	r3, [r7, #4]
    a7d6:	4a06      	ldr	r2, [pc, #24]	; (a7f0 <atInitExecTimes+0x40>)
    a7d8:	605a      	str	r2, [r3, #4]
		break;
    a7da:	e001      	b.n	a7e0 <atInitExecTimes+0x30>
	default:
		return ATCA_BAD_PARAM;
    a7dc:	23e2      	movs	r3, #226	; 0xe2
    a7de:	e000      	b.n	a7e2 <atInitExecTimes+0x32>
		break;
	}

	return ATCA_SUCCESS;
    a7e0:	2300      	movs	r3, #0
}
    a7e2:	0018      	movs	r0, r3
    a7e4:	46bd      	mov	sp, r7
    a7e6:	b002      	add	sp, #8
    a7e8:	bd80      	pop	{r7, pc}
    a7ea:	46c0      	nop			; (mov r8, r8)
    a7ec:	200000a4 	.word	0x200000a4
    a7f0:	200000d0 	.word	0x200000d0

0000a7f4 <atGetExecTime>:
 * \param[in] cmd - the specific command for which to lookup the execution time
 * \return typical execution time in milleseconds for the given command
 */

uint16_t atGetExecTime( ATCACommand cacmd, ATCA_CmdMap cmd )
{
    a7f4:	b580      	push	{r7, lr}
    a7f6:	b082      	sub	sp, #8
    a7f8:	af00      	add	r7, sp, #0
    a7fa:	6078      	str	r0, [r7, #4]
    a7fc:	000a      	movs	r2, r1
    a7fe:	1cfb      	adds	r3, r7, #3
    a800:	701a      	strb	r2, [r3, #0]
	return cacmd->execution_times[cmd];
    a802:	687b      	ldr	r3, [r7, #4]
    a804:	685a      	ldr	r2, [r3, #4]
    a806:	1cfb      	adds	r3, r7, #3
    a808:	781b      	ldrb	r3, [r3, #0]
    a80a:	005b      	lsls	r3, r3, #1
    a80c:	18d3      	adds	r3, r2, r3
    a80e:	881b      	ldrh	r3, [r3, #0]
}
    a810:	0018      	movs	r0, r3
    a812:	46bd      	mov	sp, r7
    a814:	b002      	add	sp, #8
    a816:	bd80      	pop	{r7, pc}

0000a818 <atCRC>:
 * \param[in] data pointer to the data over which to compute the CRC
 * \param[out] crc pointer to the place where the two-bytes of CRC will be placed
 */

void atCRC( uint8_t length, uint8_t *data, uint8_t *crc)
{
    a818:	b580      	push	{r7, lr}
    a81a:	b088      	sub	sp, #32
    a81c:	af00      	add	r7, sp, #0
    a81e:	60b9      	str	r1, [r7, #8]
    a820:	607a      	str	r2, [r7, #4]
    a822:	230f      	movs	r3, #15
    a824:	18fb      	adds	r3, r7, r3
    a826:	1c02      	adds	r2, r0, #0
    a828:	701a      	strb	r2, [r3, #0]
	uint8_t counter;
	uint16_t crc_register = 0;
    a82a:	231c      	movs	r3, #28
    a82c:	18fb      	adds	r3, r7, r3
    a82e:	2200      	movs	r2, #0
    a830:	801a      	strh	r2, [r3, #0]
	uint16_t polynom = 0x8005;
    a832:	2318      	movs	r3, #24
    a834:	18fb      	adds	r3, r7, r3
    a836:	4a36      	ldr	r2, [pc, #216]	; (a910 <atCRC+0xf8>)
    a838:	801a      	strh	r2, [r3, #0]
	uint8_t shift_register;
	uint8_t data_bit, crc_bit;

	for (counter = 0; counter < length; counter++) {
    a83a:	231f      	movs	r3, #31
    a83c:	18fb      	adds	r3, r7, r3
    a83e:	2200      	movs	r2, #0
    a840:	701a      	strb	r2, [r3, #0]
    a842:	e049      	b.n	a8d8 <atCRC+0xc0>
		for (shift_register = 0x01; shift_register > 0x00; shift_register <<= 1) {
    a844:	231b      	movs	r3, #27
    a846:	18fb      	adds	r3, r7, r3
    a848:	2201      	movs	r2, #1
    a84a:	701a      	strb	r2, [r3, #0]
    a84c:	e038      	b.n	a8c0 <atCRC+0xa8>
			data_bit = (data[counter] & shift_register) ? 1 : 0;
    a84e:	231f      	movs	r3, #31
    a850:	18fb      	adds	r3, r7, r3
    a852:	781b      	ldrb	r3, [r3, #0]
    a854:	68ba      	ldr	r2, [r7, #8]
    a856:	18d3      	adds	r3, r2, r3
    a858:	781b      	ldrb	r3, [r3, #0]
    a85a:	221b      	movs	r2, #27
    a85c:	18ba      	adds	r2, r7, r2
    a85e:	7812      	ldrb	r2, [r2, #0]
    a860:	4013      	ands	r3, r2
    a862:	b2db      	uxtb	r3, r3
    a864:	1e5a      	subs	r2, r3, #1
    a866:	4193      	sbcs	r3, r2
    a868:	b2da      	uxtb	r2, r3
    a86a:	2317      	movs	r3, #23
    a86c:	18fb      	adds	r3, r7, r3
    a86e:	701a      	strb	r2, [r3, #0]
			crc_bit = crc_register >> 15;
    a870:	231c      	movs	r3, #28
    a872:	18fb      	adds	r3, r7, r3
    a874:	881b      	ldrh	r3, [r3, #0]
    a876:	0bdb      	lsrs	r3, r3, #15
    a878:	b29a      	uxth	r2, r3
    a87a:	2316      	movs	r3, #22
    a87c:	18fb      	adds	r3, r7, r3
    a87e:	701a      	strb	r2, [r3, #0]
			crc_register <<= 1;
    a880:	231c      	movs	r3, #28
    a882:	18fa      	adds	r2, r7, r3
    a884:	231c      	movs	r3, #28
    a886:	18fb      	adds	r3, r7, r3
    a888:	881b      	ldrh	r3, [r3, #0]
    a88a:	18db      	adds	r3, r3, r3
    a88c:	8013      	strh	r3, [r2, #0]
			if (data_bit != crc_bit)
    a88e:	2317      	movs	r3, #23
    a890:	18fa      	adds	r2, r7, r3
    a892:	2316      	movs	r3, #22
    a894:	18fb      	adds	r3, r7, r3
    a896:	7812      	ldrb	r2, [r2, #0]
    a898:	781b      	ldrb	r3, [r3, #0]
    a89a:	429a      	cmp	r2, r3
    a89c:	d009      	beq.n	a8b2 <atCRC+0x9a>
				crc_register ^= polynom;
    a89e:	231c      	movs	r3, #28
    a8a0:	18fb      	adds	r3, r7, r3
    a8a2:	221c      	movs	r2, #28
    a8a4:	18b9      	adds	r1, r7, r2
    a8a6:	2218      	movs	r2, #24
    a8a8:	18ba      	adds	r2, r7, r2
    a8aa:	8809      	ldrh	r1, [r1, #0]
    a8ac:	8812      	ldrh	r2, [r2, #0]
    a8ae:	404a      	eors	r2, r1
    a8b0:	801a      	strh	r2, [r3, #0]
	uint16_t polynom = 0x8005;
	uint8_t shift_register;
	uint8_t data_bit, crc_bit;

	for (counter = 0; counter < length; counter++) {
		for (shift_register = 0x01; shift_register > 0x00; shift_register <<= 1) {
    a8b2:	231b      	movs	r3, #27
    a8b4:	18fa      	adds	r2, r7, r3
    a8b6:	231b      	movs	r3, #27
    a8b8:	18fb      	adds	r3, r7, r3
    a8ba:	781b      	ldrb	r3, [r3, #0]
    a8bc:	18db      	adds	r3, r3, r3
    a8be:	7013      	strb	r3, [r2, #0]
    a8c0:	231b      	movs	r3, #27
    a8c2:	18fb      	adds	r3, r7, r3
    a8c4:	781b      	ldrb	r3, [r3, #0]
    a8c6:	2b00      	cmp	r3, #0
    a8c8:	d1c1      	bne.n	a84e <atCRC+0x36>
	uint16_t crc_register = 0;
	uint16_t polynom = 0x8005;
	uint8_t shift_register;
	uint8_t data_bit, crc_bit;

	for (counter = 0; counter < length; counter++) {
    a8ca:	231f      	movs	r3, #31
    a8cc:	18fb      	adds	r3, r7, r3
    a8ce:	781a      	ldrb	r2, [r3, #0]
    a8d0:	231f      	movs	r3, #31
    a8d2:	18fb      	adds	r3, r7, r3
    a8d4:	3201      	adds	r2, #1
    a8d6:	701a      	strb	r2, [r3, #0]
    a8d8:	231f      	movs	r3, #31
    a8da:	18fa      	adds	r2, r7, r3
    a8dc:	230f      	movs	r3, #15
    a8de:	18fb      	adds	r3, r7, r3
    a8e0:	7812      	ldrb	r2, [r2, #0]
    a8e2:	781b      	ldrb	r3, [r3, #0]
    a8e4:	429a      	cmp	r2, r3
    a8e6:	d3ad      	bcc.n	a844 <atCRC+0x2c>
			crc_register <<= 1;
			if (data_bit != crc_bit)
				crc_register ^= polynom;
		}
	}
	crc[0] = (uint8_t)(crc_register & 0x00FF);
    a8e8:	231c      	movs	r3, #28
    a8ea:	18fb      	adds	r3, r7, r3
    a8ec:	881b      	ldrh	r3, [r3, #0]
    a8ee:	b2da      	uxtb	r2, r3
    a8f0:	687b      	ldr	r3, [r7, #4]
    a8f2:	701a      	strb	r2, [r3, #0]
	crc[1] = (uint8_t)(crc_register >> 8);
    a8f4:	687b      	ldr	r3, [r7, #4]
    a8f6:	3301      	adds	r3, #1
    a8f8:	221c      	movs	r2, #28
    a8fa:	18ba      	adds	r2, r7, r2
    a8fc:	8812      	ldrh	r2, [r2, #0]
    a8fe:	0a12      	lsrs	r2, r2, #8
    a900:	b292      	uxth	r2, r2
    a902:	b2d2      	uxtb	r2, r2
    a904:	701a      	strb	r2, [r3, #0]
}
    a906:	46c0      	nop			; (mov r8, r8)
    a908:	46bd      	mov	sp, r7
    a90a:	b008      	add	sp, #32
    a90c:	bd80      	pop	{r7, pc}
    a90e:	46c0      	nop			; (mov r8, r8)
    a910:	ffff8005 	.word	0xffff8005

0000a914 <atCalcCrc>:
/** \brief This function calculates CRC and adds it to the correct offset in the packet data
 * \param[in] packet Packet to calculate CRC data for
 */

void atCalcCrc( ATCAPacket *packet )
{
    a914:	b580      	push	{r7, lr}
    a916:	b084      	sub	sp, #16
    a918:	af00      	add	r7, sp, #0
    a91a:	6078      	str	r0, [r7, #4]
	uint8_t length, *crc;

	length = packet->txsize - ATCA_CRC_SIZE;
    a91c:	687b      	ldr	r3, [r7, #4]
    a91e:	785a      	ldrb	r2, [r3, #1]
    a920:	230f      	movs	r3, #15
    a922:	18fb      	adds	r3, r7, r3
    a924:	3a02      	subs	r2, #2
    a926:	701a      	strb	r2, [r3, #0]
	// computer pointer to CRC in the packet
	crc = &(packet->txsize) + length;
    a928:	687b      	ldr	r3, [r7, #4]
    a92a:	1c5a      	adds	r2, r3, #1
    a92c:	230f      	movs	r3, #15
    a92e:	18fb      	adds	r3, r7, r3
    a930:	781b      	ldrb	r3, [r3, #0]
    a932:	18d3      	adds	r3, r2, r3
    a934:	60bb      	str	r3, [r7, #8]

	// stuff CRC into packet
	atCRC(length, &(packet->txsize), crc);
    a936:	687b      	ldr	r3, [r7, #4]
    a938:	1c59      	adds	r1, r3, #1
    a93a:	68ba      	ldr	r2, [r7, #8]
    a93c:	230f      	movs	r3, #15
    a93e:	18fb      	adds	r3, r7, r3
    a940:	781b      	ldrb	r3, [r3, #0]
    a942:	0018      	movs	r0, r3
    a944:	4b02      	ldr	r3, [pc, #8]	; (a950 <atCalcCrc+0x3c>)
    a946:	4798      	blx	r3
}
    a948:	46c0      	nop			; (mov r8, r8)
    a94a:	46bd      	mov	sp, r7
    a94c:	b004      	add	sp, #16
    a94e:	bd80      	pop	{r7, pc}
    a950:	0000a819 	.word	0x0000a819

0000a954 <isATCAError>:
 * \param[in] data pointer to received data - expected to be in the form of a CA device response frame
 * \return ATCA_STATUS indicating type of error or no error
 */

ATCA_STATUS isATCAError( uint8_t *data )
{
    a954:	b580      	push	{r7, lr}
    a956:	b084      	sub	sp, #16
    a958:	af00      	add	r7, sp, #0
    a95a:	6078      	str	r0, [r7, #4]
	uint8_t good[4] = { 0x04, 0x00, 0x03, 0x40 };
    a95c:	230c      	movs	r3, #12
    a95e:	18fa      	adds	r2, r7, r3
    a960:	4b1b      	ldr	r3, [pc, #108]	; (a9d0 <isATCAError+0x7c>)
    a962:	0010      	movs	r0, r2
    a964:	0019      	movs	r1, r3
    a966:	2304      	movs	r3, #4
    a968:	001a      	movs	r2, r3
    a96a:	4b1a      	ldr	r3, [pc, #104]	; (a9d4 <isATCAError+0x80>)
    a96c:	4798      	blx	r3

	if ( memcmp( data, good, 4 ) == 0 )
    a96e:	230c      	movs	r3, #12
    a970:	18f9      	adds	r1, r7, r3
    a972:	687b      	ldr	r3, [r7, #4]
    a974:	2204      	movs	r2, #4
    a976:	0018      	movs	r0, r3
    a978:	4b17      	ldr	r3, [pc, #92]	; (a9d8 <isATCAError+0x84>)
    a97a:	4798      	blx	r3
    a97c:	1e03      	subs	r3, r0, #0
    a97e:	d101      	bne.n	a984 <isATCAError+0x30>
		return ATCA_SUCCESS;
    a980:	2300      	movs	r3, #0
    a982:	e020      	b.n	a9c6 <isATCAError+0x72>

	if ( data[0] == 0x04 ) {    // error packets are always 4 bytes long
    a984:	687b      	ldr	r3, [r7, #4]
    a986:	781b      	ldrb	r3, [r3, #0]
    a988:	2b04      	cmp	r3, #4
    a98a:	d11b      	bne.n	a9c4 <isATCAError+0x70>
		switch ( data[1] ) {
    a98c:	687b      	ldr	r3, [r7, #4]
    a98e:	3301      	adds	r3, #1
    a990:	781b      	ldrb	r3, [r3, #0]
    a992:	2b0f      	cmp	r3, #15
    a994:	d00e      	beq.n	a9b4 <isATCAError+0x60>
    a996:	dc04      	bgt.n	a9a2 <isATCAError+0x4e>
    a998:	2b01      	cmp	r3, #1
    a99a:	d007      	beq.n	a9ac <isATCAError+0x58>
    a99c:	2b03      	cmp	r3, #3
    a99e:	d007      	beq.n	a9b0 <isATCAError+0x5c>
    a9a0:	e00e      	b.n	a9c0 <isATCAError+0x6c>
    a9a2:	2b11      	cmp	r3, #17
    a9a4:	d008      	beq.n	a9b8 <isATCAError+0x64>
    a9a6:	2bff      	cmp	r3, #255	; 0xff
    a9a8:	d008      	beq.n	a9bc <isATCAError+0x68>
    a9aa:	e009      	b.n	a9c0 <isATCAError+0x6c>
		case 0x01:              // checkmac or verify failed
			return ATCA_CHECKMAC_VERIFY_FAILED;
    a9ac:	23d1      	movs	r3, #209	; 0xd1
    a9ae:	e00a      	b.n	a9c6 <isATCAError+0x72>
			break;
		case 0x03: // command received byte length, opcode or parameter was illegal
			return ATCA_BAD_OPCODE;
    a9b0:	23f2      	movs	r3, #242	; 0xf2
    a9b2:	e008      	b.n	a9c6 <isATCAError+0x72>
			break;
		case 0x0f: // chip can't execute the command
			return ATCA_EXECUTION_ERROR;
    a9b4:	23f4      	movs	r3, #244	; 0xf4
    a9b6:	e006      	b.n	a9c6 <isATCAError+0x72>
			break;
		case 0x11: // chip was successfully woken up
			return ATCA_WAKE_SUCCESS;
    a9b8:	23f3      	movs	r3, #243	; 0xf3
    a9ba:	e004      	b.n	a9c6 <isATCAError+0x72>
			break;
		case 0xff: // bad crc found or other comm error
			return ATCA_STATUS_CRC;
    a9bc:	23d4      	movs	r3, #212	; 0xd4
    a9be:	e002      	b.n	a9c6 <isATCAError+0x72>
			break;
		default:
			return ATCA_GEN_FAIL;
    a9c0:	23e1      	movs	r3, #225	; 0xe1
    a9c2:	e000      	b.n	a9c6 <isATCAError+0x72>
			break;
		}
	} else
		return ATCA_SUCCESS;
    a9c4:	2300      	movs	r3, #0
}
    a9c6:	0018      	movs	r0, r3
    a9c8:	46bd      	mov	sp, r7
    a9ca:	b004      	add	sp, #16
    a9cc:	bd80      	pop	{r7, pc}
    a9ce:	46c0      	nop			; (mov r8, r8)
    a9d0:	000152d4 	.word	0x000152d4
    a9d4:	000127e7 	.word	0x000127e7
    a9d8:	000127c9 	.word	0x000127c9

0000a9dc <newATCADevice>:
 * \param[in] cfg  pointer to an interface configuration object
 * \return reference to a new ATCADevice
 */

ATCADevice newATCADevice(ATCAIfaceCfg *cfg )
{
    a9dc:	b580      	push	{r7, lr}
    a9de:	b084      	sub	sp, #16
    a9e0:	af00      	add	r7, sp, #0
    a9e2:	6078      	str	r0, [r7, #4]
	ATCADevice cadev = NULL;
    a9e4:	2300      	movs	r3, #0
    a9e6:	60fb      	str	r3, [r7, #12]

	if (cfg == NULL)
    a9e8:	687b      	ldr	r3, [r7, #4]
    a9ea:	2b00      	cmp	r3, #0
    a9ec:	d101      	bne.n	a9f2 <newATCADevice+0x16>
		return NULL;
    a9ee:	2300      	movs	r3, #0
    a9f0:	e022      	b.n	aa38 <newATCADevice+0x5c>

	cadev = (ATCADevice)malloc(sizeof(struct atca_device));
    a9f2:	2008      	movs	r0, #8
    a9f4:	4b12      	ldr	r3, [pc, #72]	; (aa40 <newATCADevice+0x64>)
    a9f6:	4798      	blx	r3
    a9f8:	0003      	movs	r3, r0
    a9fa:	60fb      	str	r3, [r7, #12]
	cadev->mCommands = (ATCACommand)newATCACommand(cfg->devtype);
    a9fc:	687b      	ldr	r3, [r7, #4]
    a9fe:	785b      	ldrb	r3, [r3, #1]
    aa00:	0018      	movs	r0, r3
    aa02:	4b10      	ldr	r3, [pc, #64]	; (aa44 <newATCADevice+0x68>)
    aa04:	4798      	blx	r3
    aa06:	0002      	movs	r2, r0
    aa08:	68fb      	ldr	r3, [r7, #12]
    aa0a:	601a      	str	r2, [r3, #0]
	cadev->mIface    = (ATCAIface)newATCAIface(cfg);
    aa0c:	687b      	ldr	r3, [r7, #4]
    aa0e:	0018      	movs	r0, r3
    aa10:	4b0d      	ldr	r3, [pc, #52]	; (aa48 <newATCADevice+0x6c>)
    aa12:	4798      	blx	r3
    aa14:	0002      	movs	r2, r0
    aa16:	68fb      	ldr	r3, [r7, #12]
    aa18:	605a      	str	r2, [r3, #4]

	if (cadev->mCommands == NULL || cadev->mIface == NULL) {
    aa1a:	68fb      	ldr	r3, [r7, #12]
    aa1c:	681b      	ldr	r3, [r3, #0]
    aa1e:	2b00      	cmp	r3, #0
    aa20:	d003      	beq.n	aa2a <newATCADevice+0x4e>
    aa22:	68fb      	ldr	r3, [r7, #12]
    aa24:	685b      	ldr	r3, [r3, #4]
    aa26:	2b00      	cmp	r3, #0
    aa28:	d105      	bne.n	aa36 <newATCADevice+0x5a>
		free(cadev);
    aa2a:	68fb      	ldr	r3, [r7, #12]
    aa2c:	0018      	movs	r0, r3
    aa2e:	4b07      	ldr	r3, [pc, #28]	; (aa4c <newATCADevice+0x70>)
    aa30:	4798      	blx	r3
		cadev = NULL;
    aa32:	2300      	movs	r3, #0
    aa34:	60fb      	str	r3, [r7, #12]
	}

	return cadev;
    aa36:	68fb      	ldr	r3, [r7, #12]
}
    aa38:	0018      	movs	r0, r3
    aa3a:	46bd      	mov	sp, r7
    aa3c:	b004      	add	sp, #16
    aa3e:	bd80      	pop	{r7, pc}
    aa40:	000127a1 	.word	0x000127a1
    aa44:	0000a3b9 	.word	0x0000a3b9
    aa48:	0000aac5 	.word	0x0000aac5
    aa4c:	000127b5 	.word	0x000127b5

0000aa50 <atGetCommands>:
/** \brief returns a reference to the ATCACommand object for the device
 * \param[in] dev  reference to a device
 * \return reference to the ATCACommand object for the device
 */
ATCACommand atGetCommands( ATCADevice dev )
{
    aa50:	b580      	push	{r7, lr}
    aa52:	b082      	sub	sp, #8
    aa54:	af00      	add	r7, sp, #0
    aa56:	6078      	str	r0, [r7, #4]
	return dev->mCommands;
    aa58:	687b      	ldr	r3, [r7, #4]
    aa5a:	681b      	ldr	r3, [r3, #0]
}
    aa5c:	0018      	movs	r0, r3
    aa5e:	46bd      	mov	sp, r7
    aa60:	b002      	add	sp, #8
    aa62:	bd80      	pop	{r7, pc}

0000aa64 <atGetIFace>:
 * \param[in] dev  reference to a device
 * \return reference to the ATCAIface object for the device
 */

ATCAIface atGetIFace( ATCADevice dev )
{
    aa64:	b580      	push	{r7, lr}
    aa66:	b082      	sub	sp, #8
    aa68:	af00      	add	r7, sp, #0
    aa6a:	6078      	str	r0, [r7, #4]
	return dev->mIface;
    aa6c:	687b      	ldr	r3, [r7, #4]
    aa6e:	685b      	ldr	r3, [r3, #4]
}
    aa70:	0018      	movs	r0, r3
    aa72:	46bd      	mov	sp, r7
    aa74:	b002      	add	sp, #8
    aa76:	bd80      	pop	{r7, pc}

0000aa78 <deleteATCADevice>:
 * \param[in] cadev  pointer to a reference to a device
 *
 */

void deleteATCADevice( ATCADevice *cadev ) // destructor
{
    aa78:	b580      	push	{r7, lr}
    aa7a:	b084      	sub	sp, #16
    aa7c:	af00      	add	r7, sp, #0
    aa7e:	6078      	str	r0, [r7, #4]
	struct atca_device *dev = *cadev;
    aa80:	687b      	ldr	r3, [r7, #4]
    aa82:	681b      	ldr	r3, [r3, #0]
    aa84:	60fb      	str	r3, [r7, #12]

	if ( *cadev ) {
    aa86:	687b      	ldr	r3, [r7, #4]
    aa88:	681b      	ldr	r3, [r3, #0]
    aa8a:	2b00      	cmp	r3, #0
    aa8c:	d00d      	beq.n	aaaa <deleteATCADevice+0x32>
		deleteATCACommand( (ATCACommand*)&(dev->mCommands));
    aa8e:	68fb      	ldr	r3, [r7, #12]
    aa90:	0018      	movs	r0, r3
    aa92:	4b09      	ldr	r3, [pc, #36]	; (aab8 <deleteATCADevice+0x40>)
    aa94:	4798      	blx	r3
		deleteATCAIface((ATCAIface*)&(dev->mIface));
    aa96:	68fb      	ldr	r3, [r7, #12]
    aa98:	3304      	adds	r3, #4
    aa9a:	0018      	movs	r0, r3
    aa9c:	4b07      	ldr	r3, [pc, #28]	; (aabc <deleteATCADevice+0x44>)
    aa9e:	4798      	blx	r3
		free((void*)*cadev);
    aaa0:	687b      	ldr	r3, [r7, #4]
    aaa2:	681b      	ldr	r3, [r3, #0]
    aaa4:	0018      	movs	r0, r3
    aaa6:	4b06      	ldr	r3, [pc, #24]	; (aac0 <deleteATCADevice+0x48>)
    aaa8:	4798      	blx	r3
	}

	*cadev = NULL;
    aaaa:	687b      	ldr	r3, [r7, #4]
    aaac:	2200      	movs	r2, #0
    aaae:	601a      	str	r2, [r3, #0]
}
    aab0:	46c0      	nop			; (mov r8, r8)
    aab2:	46bd      	mov	sp, r7
    aab4:	b004      	add	sp, #16
    aab6:	bd80      	pop	{r7, pc}
    aab8:	0000a785 	.word	0x0000a785
    aabc:	0000ac4d 	.word	0x0000ac4d
    aac0:	000127b5 	.word	0x000127b5

0000aac4 <newATCAIface>:
 * \param[in] cfg  points to the logical configuration for the interface
 * \return ATCAIface
 */

ATCAIface newATCAIface(ATCAIfaceCfg *cfg)  // constructor
{
    aac4:	b580      	push	{r7, lr}
    aac6:	b084      	sub	sp, #16
    aac8:	af00      	add	r7, sp, #0
    aaca:	6078      	str	r0, [r7, #4]
	ATCAIface caiface = (ATCAIface)malloc(sizeof(struct atca_iface));
    aacc:	2028      	movs	r0, #40	; 0x28
    aace:	4b0e      	ldr	r3, [pc, #56]	; (ab08 <newATCAIface+0x44>)
    aad0:	4798      	blx	r3
    aad2:	0003      	movs	r3, r0
    aad4:	60fb      	str	r3, [r7, #12]

	caiface->mType = cfg->iface_type;
    aad6:	687b      	ldr	r3, [r7, #4]
    aad8:	781a      	ldrb	r2, [r3, #0]
    aada:	68fb      	ldr	r3, [r7, #12]
    aadc:	701a      	strb	r2, [r3, #0]
	caiface->mIfaceCFG = cfg;
    aade:	68fb      	ldr	r3, [r7, #12]
    aae0:	687a      	ldr	r2, [r7, #4]
    aae2:	605a      	str	r2, [r3, #4]

	if (atinit(caiface) != ATCA_SUCCESS) {
    aae4:	68fb      	ldr	r3, [r7, #12]
    aae6:	0018      	movs	r0, r3
    aae8:	4b08      	ldr	r3, [pc, #32]	; (ab0c <newATCAIface+0x48>)
    aaea:	4798      	blx	r3
    aaec:	1e03      	subs	r3, r0, #0
    aaee:	d005      	beq.n	aafc <newATCAIface+0x38>
		free(caiface);
    aaf0:	68fb      	ldr	r3, [r7, #12]
    aaf2:	0018      	movs	r0, r3
    aaf4:	4b06      	ldr	r3, [pc, #24]	; (ab10 <newATCAIface+0x4c>)
    aaf6:	4798      	blx	r3
		caiface = NULL;
    aaf8:	2300      	movs	r3, #0
    aafa:	60fb      	str	r3, [r7, #12]
	}

	return caiface;
    aafc:	68fb      	ldr	r3, [r7, #12]
}
    aafe:	0018      	movs	r0, r3
    ab00:	46bd      	mov	sp, r7
    ab02:	b004      	add	sp, #16
    ab04:	bd80      	pop	{r7, pc}
    ab06:	46c0      	nop			; (mov r8, r8)
    ab08:	000127a1 	.word	0x000127a1
    ab0c:	0000ab15 	.word	0x0000ab15
    ab10:	000127b5 	.word	0x000127b5

0000ab14 <atinit>:

// public ATCAIface methods

ATCA_STATUS atinit(ATCAIface caiface)
{
    ab14:	b590      	push	{r4, r7, lr}
    ab16:	b08d      	sub	sp, #52	; 0x34
    ab18:	af00      	add	r7, sp, #0
    ab1a:	6078      	str	r0, [r7, #4]
	ATCA_STATUS status = ATCA_COMM_FAIL;
    ab1c:	232f      	movs	r3, #47	; 0x2f
    ab1e:	18fb      	adds	r3, r7, r3
    ab20:	22f0      	movs	r2, #240	; 0xf0
    ab22:	701a      	strb	r2, [r3, #0]
	ATCAHAL_t hal;

	_atinit( caiface, &hal );
    ab24:	2308      	movs	r3, #8
    ab26:	18fa      	adds	r2, r7, r3
    ab28:	687b      	ldr	r3, [r7, #4]
    ab2a:	0011      	movs	r1, r2
    ab2c:	0018      	movs	r0, r3
    ab2e:	4b14      	ldr	r3, [pc, #80]	; (ab80 <atinit+0x6c>)
    ab30:	4798      	blx	r3

	status = caiface->atinit( &hal, caiface->mIfaceCFG );
    ab32:	687b      	ldr	r3, [r7, #4]
    ab34:	689a      	ldr	r2, [r3, #8]
    ab36:	687b      	ldr	r3, [r7, #4]
    ab38:	6859      	ldr	r1, [r3, #4]
    ab3a:	232f      	movs	r3, #47	; 0x2f
    ab3c:	18fc      	adds	r4, r7, r3
    ab3e:	2308      	movs	r3, #8
    ab40:	18fb      	adds	r3, r7, r3
    ab42:	0018      	movs	r0, r3
    ab44:	4790      	blx	r2
    ab46:	0003      	movs	r3, r0
    ab48:	7023      	strb	r3, [r4, #0]
	if (status == ATCA_SUCCESS) {
    ab4a:	232f      	movs	r3, #47	; 0x2f
    ab4c:	18fb      	adds	r3, r7, r3
    ab4e:	781b      	ldrb	r3, [r3, #0]
    ab50:	2b00      	cmp	r3, #0
    ab52:	d10d      	bne.n	ab70 <atinit+0x5c>
		caiface->hal_data = hal.hal_data;
    ab54:	2308      	movs	r3, #8
    ab56:	18fb      	adds	r3, r7, r3
    ab58:	6a1a      	ldr	r2, [r3, #32]
    ab5a:	687b      	ldr	r3, [r7, #4]
    ab5c:	625a      	str	r2, [r3, #36]	; 0x24

		// Perform the post init
		status = caiface->atpostinit( caiface );
    ab5e:	687b      	ldr	r3, [r7, #4]
    ab60:	68db      	ldr	r3, [r3, #12]
    ab62:	222f      	movs	r2, #47	; 0x2f
    ab64:	18bc      	adds	r4, r7, r2
    ab66:	687a      	ldr	r2, [r7, #4]
    ab68:	0010      	movs	r0, r2
    ab6a:	4798      	blx	r3
    ab6c:	0003      	movs	r3, r0
    ab6e:	7023      	strb	r3, [r4, #0]
	}

	return status;
    ab70:	232f      	movs	r3, #47	; 0x2f
    ab72:	18fb      	adds	r3, r7, r3
    ab74:	781b      	ldrb	r3, [r3, #0]
}
    ab76:	0018      	movs	r0, r3
    ab78:	46bd      	mov	sp, r7
    ab7a:	b00d      	add	sp, #52	; 0x34
    ab7c:	bd90      	pop	{r4, r7, pc}
    ab7e:	46c0      	nop			; (mov r8, r8)
    ab80:	0000ac91 	.word	0x0000ac91

0000ab84 <atsend>:

ATCA_STATUS atsend(ATCAIface caiface, uint8_t *txdata, int txlength)
{
    ab84:	b580      	push	{r7, lr}
    ab86:	b084      	sub	sp, #16
    ab88:	af00      	add	r7, sp, #0
    ab8a:	60f8      	str	r0, [r7, #12]
    ab8c:	60b9      	str	r1, [r7, #8]
    ab8e:	607a      	str	r2, [r7, #4]
	return caiface->atsend(caiface, txdata, txlength);
    ab90:	68fb      	ldr	r3, [r7, #12]
    ab92:	691b      	ldr	r3, [r3, #16]
    ab94:	687a      	ldr	r2, [r7, #4]
    ab96:	68b9      	ldr	r1, [r7, #8]
    ab98:	68f8      	ldr	r0, [r7, #12]
    ab9a:	4798      	blx	r3
    ab9c:	0003      	movs	r3, r0
}
    ab9e:	0018      	movs	r0, r3
    aba0:	46bd      	mov	sp, r7
    aba2:	b004      	add	sp, #16
    aba4:	bd80      	pop	{r7, pc}
    aba6:	46c0      	nop			; (mov r8, r8)

0000aba8 <atreceive>:

ATCA_STATUS atreceive( ATCAIface caiface, uint8_t *rxdata, uint16_t *rxlength)
{
    aba8:	b580      	push	{r7, lr}
    abaa:	b084      	sub	sp, #16
    abac:	af00      	add	r7, sp, #0
    abae:	60f8      	str	r0, [r7, #12]
    abb0:	60b9      	str	r1, [r7, #8]
    abb2:	607a      	str	r2, [r7, #4]
	return caiface->atreceive(caiface, rxdata, rxlength);
    abb4:	68fb      	ldr	r3, [r7, #12]
    abb6:	695b      	ldr	r3, [r3, #20]
    abb8:	687a      	ldr	r2, [r7, #4]
    abba:	68b9      	ldr	r1, [r7, #8]
    abbc:	68f8      	ldr	r0, [r7, #12]
    abbe:	4798      	blx	r3
    abc0:	0003      	movs	r3, r0
}
    abc2:	0018      	movs	r0, r3
    abc4:	46bd      	mov	sp, r7
    abc6:	b004      	add	sp, #16
    abc8:	bd80      	pop	{r7, pc}
    abca:	46c0      	nop			; (mov r8, r8)

0000abcc <atwake>:

ATCA_STATUS atwake(ATCAIface caiface)
{
    abcc:	b580      	push	{r7, lr}
    abce:	b082      	sub	sp, #8
    abd0:	af00      	add	r7, sp, #0
    abd2:	6078      	str	r0, [r7, #4]
	return caiface->atwake(caiface);
    abd4:	687b      	ldr	r3, [r7, #4]
    abd6:	699b      	ldr	r3, [r3, #24]
    abd8:	687a      	ldr	r2, [r7, #4]
    abda:	0010      	movs	r0, r2
    abdc:	4798      	blx	r3
    abde:	0003      	movs	r3, r0
}
    abe0:	0018      	movs	r0, r3
    abe2:	46bd      	mov	sp, r7
    abe4:	b002      	add	sp, #8
    abe6:	bd80      	pop	{r7, pc}

0000abe8 <atidle>:

ATCA_STATUS atidle(ATCAIface caiface)
{
    abe8:	b580      	push	{r7, lr}
    abea:	b082      	sub	sp, #8
    abec:	af00      	add	r7, sp, #0
    abee:	6078      	str	r0, [r7, #4]
	atca_delay_ms(1);
    abf0:	2001      	movs	r0, #1
    abf2:	4b06      	ldr	r3, [pc, #24]	; (ac0c <atidle+0x24>)
    abf4:	4798      	blx	r3
	return caiface->atidle(caiface);
    abf6:	687b      	ldr	r3, [r7, #4]
    abf8:	69db      	ldr	r3, [r3, #28]
    abfa:	687a      	ldr	r2, [r7, #4]
    abfc:	0010      	movs	r0, r2
    abfe:	4798      	blx	r3
    ac00:	0003      	movs	r3, r0
}
    ac02:	0018      	movs	r0, r3
    ac04:	46bd      	mov	sp, r7
    ac06:	b002      	add	sp, #8
    ac08:	bd80      	pop	{r7, pc}
    ac0a:	46c0      	nop			; (mov r8, r8)
    ac0c:	0000e3d5 	.word	0x0000e3d5

0000ac10 <atsleep>:

ATCA_STATUS atsleep(ATCAIface caiface)
{
    ac10:	b580      	push	{r7, lr}
    ac12:	b082      	sub	sp, #8
    ac14:	af00      	add	r7, sp, #0
    ac16:	6078      	str	r0, [r7, #4]
	atca_delay_ms(1);
    ac18:	2001      	movs	r0, #1
    ac1a:	4b06      	ldr	r3, [pc, #24]	; (ac34 <atsleep+0x24>)
    ac1c:	4798      	blx	r3
	return caiface->atsleep(caiface);
    ac1e:	687b      	ldr	r3, [r7, #4]
    ac20:	6a1b      	ldr	r3, [r3, #32]
    ac22:	687a      	ldr	r2, [r7, #4]
    ac24:	0010      	movs	r0, r2
    ac26:	4798      	blx	r3
    ac28:	0003      	movs	r3, r0
}
    ac2a:	0018      	movs	r0, r3
    ac2c:	46bd      	mov	sp, r7
    ac2e:	b002      	add	sp, #8
    ac30:	bd80      	pop	{r7, pc}
    ac32:	46c0      	nop			; (mov r8, r8)
    ac34:	0000e3d5 	.word	0x0000e3d5

0000ac38 <atgetifacecfg>:

ATCAIfaceCfg * atgetifacecfg(ATCAIface caiface)
{
    ac38:	b580      	push	{r7, lr}
    ac3a:	b082      	sub	sp, #8
    ac3c:	af00      	add	r7, sp, #0
    ac3e:	6078      	str	r0, [r7, #4]
	return caiface->mIfaceCFG;
    ac40:	687b      	ldr	r3, [r7, #4]
    ac42:	685b      	ldr	r3, [r3, #4]
}
    ac44:	0018      	movs	r0, r3
    ac46:	46bd      	mov	sp, r7
    ac48:	b002      	add	sp, #8
    ac4a:	bd80      	pop	{r7, pc}

0000ac4c <deleteATCAIface>:
{
	return caiface->hal_data;
}

void deleteATCAIface(ATCAIface *caiface) // destructor
{
    ac4c:	b580      	push	{r7, lr}
    ac4e:	b082      	sub	sp, #8
    ac50:	af00      	add	r7, sp, #0
    ac52:	6078      	str	r0, [r7, #4]
	if ( *caiface ) {
    ac54:	687b      	ldr	r3, [r7, #4]
    ac56:	681b      	ldr	r3, [r3, #0]
    ac58:	2b00      	cmp	r3, #0
    ac5a:	d00e      	beq.n	ac7a <deleteATCAIface+0x2e>
		hal_iface_release( (*caiface)->mType, (*caiface)->hal_data);  // let HAL clean up and disable physical level interface if ref count is 0
    ac5c:	687b      	ldr	r3, [r7, #4]
    ac5e:	681b      	ldr	r3, [r3, #0]
    ac60:	781a      	ldrb	r2, [r3, #0]
    ac62:	687b      	ldr	r3, [r7, #4]
    ac64:	681b      	ldr	r3, [r3, #0]
    ac66:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    ac68:	0019      	movs	r1, r3
    ac6a:	0010      	movs	r0, r2
    ac6c:	4b06      	ldr	r3, [pc, #24]	; (ac88 <deleteATCAIface+0x3c>)
    ac6e:	4798      	blx	r3
		free((void*)*caiface);
    ac70:	687b      	ldr	r3, [r7, #4]
    ac72:	681b      	ldr	r3, [r3, #0]
    ac74:	0018      	movs	r0, r3
    ac76:	4b05      	ldr	r3, [pc, #20]	; (ac8c <deleteATCAIface+0x40>)
    ac78:	4798      	blx	r3
	}

	*caiface = NULL;
    ac7a:	687b      	ldr	r3, [r7, #4]
    ac7c:	2200      	movs	r2, #0
    ac7e:	601a      	str	r2, [r3, #0]
}
    ac80:	46c0      	nop			; (mov r8, r8)
    ac82:	46bd      	mov	sp, r7
    ac84:	b002      	add	sp, #8
    ac86:	bd80      	pop	{r7, pc}
    ac88:	0000da81 	.word	0x0000da81
    ac8c:	000127b5 	.word	0x000127b5

0000ac90 <_atinit>:

ATCA_STATUS _atinit(ATCAIface caiface, ATCAHAL_t *hal)
{
    ac90:	b580      	push	{r7, lr}
    ac92:	b082      	sub	sp, #8
    ac94:	af00      	add	r7, sp, #0
    ac96:	6078      	str	r0, [r7, #4]
    ac98:	6039      	str	r1, [r7, #0]
	// get method mapping to HAL methods for this interface
	hal_iface_init( caiface->mIfaceCFG, hal );
    ac9a:	687b      	ldr	r3, [r7, #4]
    ac9c:	685b      	ldr	r3, [r3, #4]
    ac9e:	683a      	ldr	r2, [r7, #0]
    aca0:	0011      	movs	r1, r2
    aca2:	0018      	movs	r0, r3
    aca4:	4b13      	ldr	r3, [pc, #76]	; (acf4 <_atinit+0x64>)
    aca6:	4798      	blx	r3
	caiface->atinit     = hal->halinit;
    aca8:	683b      	ldr	r3, [r7, #0]
    acaa:	681a      	ldr	r2, [r3, #0]
    acac:	687b      	ldr	r3, [r7, #4]
    acae:	609a      	str	r2, [r3, #8]
	caiface->atpostinit = hal->halpostinit;
    acb0:	683b      	ldr	r3, [r7, #0]
    acb2:	685a      	ldr	r2, [r3, #4]
    acb4:	687b      	ldr	r3, [r7, #4]
    acb6:	60da      	str	r2, [r3, #12]
	caiface->atsend     = hal->halsend;
    acb8:	683b      	ldr	r3, [r7, #0]
    acba:	689a      	ldr	r2, [r3, #8]
    acbc:	687b      	ldr	r3, [r7, #4]
    acbe:	611a      	str	r2, [r3, #16]
	caiface->atreceive  = hal->halreceive;
    acc0:	683b      	ldr	r3, [r7, #0]
    acc2:	68da      	ldr	r2, [r3, #12]
    acc4:	687b      	ldr	r3, [r7, #4]
    acc6:	615a      	str	r2, [r3, #20]
	caiface->atwake     = hal->halwake;
    acc8:	683b      	ldr	r3, [r7, #0]
    acca:	691a      	ldr	r2, [r3, #16]
    accc:	687b      	ldr	r3, [r7, #4]
    acce:	619a      	str	r2, [r3, #24]
	caiface->atsleep    = hal->halsleep;
    acd0:	683b      	ldr	r3, [r7, #0]
    acd2:	699a      	ldr	r2, [r3, #24]
    acd4:	687b      	ldr	r3, [r7, #4]
    acd6:	621a      	str	r2, [r3, #32]
	caiface->atidle     = hal->halidle;
    acd8:	683b      	ldr	r3, [r7, #0]
    acda:	695a      	ldr	r2, [r3, #20]
    acdc:	687b      	ldr	r3, [r7, #4]
    acde:	61da      	str	r2, [r3, #28]
	caiface->hal_data   = hal->hal_data;
    ace0:	683b      	ldr	r3, [r7, #0]
    ace2:	6a1a      	ldr	r2, [r3, #32]
    ace4:	687b      	ldr	r3, [r7, #4]
    ace6:	625a      	str	r2, [r3, #36]	; 0x24

	return ATCA_SUCCESS;
    ace8:	2300      	movs	r3, #0
}
    acea:	0018      	movs	r0, r3
    acec:	46bd      	mov	sp, r7
    acee:	b002      	add	sp, #8
    acf0:	bd80      	pop	{r7, pc}
    acf2:	46c0      	nop			; (mov r8, r8)
    acf4:	0000d9e9 	.word	0x0000d9e9

0000acf8 <atcab_init>:
 *  \param[in] cfg is a pointer to an interface configuration.  This is usually a predefined configuration found in atca_cfgs.h
 *  \return ATCA_STATUS
 *  \see atcab_init_device()
 */
ATCA_STATUS atcab_init( ATCAIfaceCfg *cfg )
{
    acf8:	b580      	push	{r7, lr}
    acfa:	b082      	sub	sp, #8
    acfc:	af00      	add	r7, sp, #0
    acfe:	6078      	str	r0, [r7, #4]
	if ( _gDevice )     // if there's already a device created, release it
    ad00:	4b18      	ldr	r3, [pc, #96]	; (ad64 <atcab_init+0x6c>)
    ad02:	681b      	ldr	r3, [r3, #0]
    ad04:	2b00      	cmp	r3, #0
    ad06:	d001      	beq.n	ad0c <atcab_init+0x14>
		atcab_release();
    ad08:	4b17      	ldr	r3, [pc, #92]	; (ad68 <atcab_init+0x70>)
    ad0a:	4798      	blx	r3

	_gDevice = newATCADevice( cfg );
    ad0c:	687b      	ldr	r3, [r7, #4]
    ad0e:	0018      	movs	r0, r3
    ad10:	4b16      	ldr	r3, [pc, #88]	; (ad6c <atcab_init+0x74>)
    ad12:	4798      	blx	r3
    ad14:	0002      	movs	r2, r0
    ad16:	4b13      	ldr	r3, [pc, #76]	; (ad64 <atcab_init+0x6c>)
    ad18:	601a      	str	r2, [r3, #0]
	if ( _gDevice == NULL )
    ad1a:	4b12      	ldr	r3, [pc, #72]	; (ad64 <atcab_init+0x6c>)
    ad1c:	681b      	ldr	r3, [r3, #0]
    ad1e:	2b00      	cmp	r3, #0
    ad20:	d101      	bne.n	ad26 <atcab_init+0x2e>
		return ATCA_GEN_FAIL; // Device creation failed
    ad22:	23e1      	movs	r3, #225	; 0xe1
    ad24:	e01a      	b.n	ad5c <atcab_init+0x64>

	_gCommandObj = atGetCommands( _gDevice );
    ad26:	4b0f      	ldr	r3, [pc, #60]	; (ad64 <atcab_init+0x6c>)
    ad28:	681b      	ldr	r3, [r3, #0]
    ad2a:	0018      	movs	r0, r3
    ad2c:	4b10      	ldr	r3, [pc, #64]	; (ad70 <atcab_init+0x78>)
    ad2e:	4798      	blx	r3
    ad30:	0002      	movs	r2, r0
    ad32:	4b10      	ldr	r3, [pc, #64]	; (ad74 <atcab_init+0x7c>)
    ad34:	601a      	str	r2, [r3, #0]
	_gIface = atGetIFace( _gDevice );
    ad36:	4b0b      	ldr	r3, [pc, #44]	; (ad64 <atcab_init+0x6c>)
    ad38:	681b      	ldr	r3, [r3, #0]
    ad3a:	0018      	movs	r0, r3
    ad3c:	4b0e      	ldr	r3, [pc, #56]	; (ad78 <atcab_init+0x80>)
    ad3e:	4798      	blx	r3
    ad40:	0002      	movs	r2, r0
    ad42:	4b0e      	ldr	r3, [pc, #56]	; (ad7c <atcab_init+0x84>)
    ad44:	601a      	str	r2, [r3, #0]

	if ( _gCommandObj == NULL || _gIface == NULL )
    ad46:	4b0b      	ldr	r3, [pc, #44]	; (ad74 <atcab_init+0x7c>)
    ad48:	681b      	ldr	r3, [r3, #0]
    ad4a:	2b00      	cmp	r3, #0
    ad4c:	d003      	beq.n	ad56 <atcab_init+0x5e>
    ad4e:	4b0b      	ldr	r3, [pc, #44]	; (ad7c <atcab_init+0x84>)
    ad50:	681b      	ldr	r3, [r3, #0]
    ad52:	2b00      	cmp	r3, #0
    ad54:	d101      	bne.n	ad5a <atcab_init+0x62>
		return ATCA_GEN_FAIL; // More of an assert to make everything was constructed properly
    ad56:	23e1      	movs	r3, #225	; 0xe1
    ad58:	e000      	b.n	ad5c <atcab_init+0x64>

	return ATCA_SUCCESS;
    ad5a:	2300      	movs	r3, #0
}
    ad5c:	0018      	movs	r0, r3
    ad5e:	46bd      	mov	sp, r7
    ad60:	b002      	add	sp, #8
    ad62:	bd80      	pop	{r7, pc}
    ad64:	200007e0 	.word	0x200007e0
    ad68:	0000ad81 	.word	0x0000ad81
    ad6c:	0000a9dd 	.word	0x0000a9dd
    ad70:	0000aa51 	.word	0x0000aa51
    ad74:	200007e4 	.word	0x200007e4
    ad78:	0000aa65 	.word	0x0000aa65
    ad7c:	200007e8 	.word	0x200007e8

0000ad80 <atcab_release>:
/** \brief release (free) the global ATCADevice instance.
 *  This must be called in order to release or free up the interface.
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_release( void )
{
    ad80:	b580      	push	{r7, lr}
    ad82:	af00      	add	r7, sp, #0
	deleteATCADevice(&_gDevice);
    ad84:	4b03      	ldr	r3, [pc, #12]	; (ad94 <atcab_release+0x14>)
    ad86:	0018      	movs	r0, r3
    ad88:	4b03      	ldr	r3, [pc, #12]	; (ad98 <atcab_release+0x18>)
    ad8a:	4798      	blx	r3
	return ATCA_SUCCESS;
    ad8c:	2300      	movs	r3, #0
}
    ad8e:	0018      	movs	r0, r3
    ad90:	46bd      	mov	sp, r7
    ad92:	bd80      	pop	{r7, pc}
    ad94:	200007e0 	.word	0x200007e0
    ad98:	0000aa79 	.word	0x0000aa79

0000ad9c <atcab_wakeup>:

/** \brief wakeup the CryptoAuth device
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_wakeup(void)
{
    ad9c:	b580      	push	{r7, lr}
    ad9e:	af00      	add	r7, sp, #0
	if ( _gDevice == NULL )
    ada0:	4b07      	ldr	r3, [pc, #28]	; (adc0 <atcab_wakeup+0x24>)
    ada2:	681b      	ldr	r3, [r3, #0]
    ada4:	2b00      	cmp	r3, #0
    ada6:	d101      	bne.n	adac <atcab_wakeup+0x10>
		return ATCA_GEN_FAIL;
    ada8:	23e1      	movs	r3, #225	; 0xe1
    adaa:	e005      	b.n	adb8 <atcab_wakeup+0x1c>

	return atwake(_gIface);
    adac:	4b05      	ldr	r3, [pc, #20]	; (adc4 <atcab_wakeup+0x28>)
    adae:	681b      	ldr	r3, [r3, #0]
    adb0:	0018      	movs	r0, r3
    adb2:	4b05      	ldr	r3, [pc, #20]	; (adc8 <atcab_wakeup+0x2c>)
    adb4:	4798      	blx	r3
    adb6:	0003      	movs	r3, r0
}
    adb8:	0018      	movs	r0, r3
    adba:	46bd      	mov	sp, r7
    adbc:	bd80      	pop	{r7, pc}
    adbe:	46c0      	nop			; (mov r8, r8)
    adc0:	200007e0 	.word	0x200007e0
    adc4:	200007e8 	.word	0x200007e8
    adc8:	0000abcd 	.word	0x0000abcd

0000adcc <atcab_idle>:

/** \brief idle the CryptoAuth device
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_idle(void)
{
    adcc:	b580      	push	{r7, lr}
    adce:	af00      	add	r7, sp, #0
	if ( _gDevice == NULL )
    add0:	4b07      	ldr	r3, [pc, #28]	; (adf0 <atcab_idle+0x24>)
    add2:	681b      	ldr	r3, [r3, #0]
    add4:	2b00      	cmp	r3, #0
    add6:	d101      	bne.n	addc <atcab_idle+0x10>
		return ATCA_GEN_FAIL;
    add8:	23e1      	movs	r3, #225	; 0xe1
    adda:	e005      	b.n	ade8 <atcab_idle+0x1c>

	return atidle(_gIface);
    addc:	4b05      	ldr	r3, [pc, #20]	; (adf4 <atcab_idle+0x28>)
    adde:	681b      	ldr	r3, [r3, #0]
    ade0:	0018      	movs	r0, r3
    ade2:	4b05      	ldr	r3, [pc, #20]	; (adf8 <atcab_idle+0x2c>)
    ade4:	4798      	blx	r3
    ade6:	0003      	movs	r3, r0
}
    ade8:	0018      	movs	r0, r3
    adea:	46bd      	mov	sp, r7
    adec:	bd80      	pop	{r7, pc}
    adee:	46c0      	nop			; (mov r8, r8)
    adf0:	200007e0 	.word	0x200007e0
    adf4:	200007e8 	.word	0x200007e8
    adf8:	0000abe9 	.word	0x0000abe9

0000adfc <atcab_sleep>:

/** \brief invoke sleep on the CryptoAuth device
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_sleep(void)
{
    adfc:	b580      	push	{r7, lr}
    adfe:	af00      	add	r7, sp, #0
	if ( _gDevice == NULL )
    ae00:	4b07      	ldr	r3, [pc, #28]	; (ae20 <atcab_sleep+0x24>)
    ae02:	681b      	ldr	r3, [r3, #0]
    ae04:	2b00      	cmp	r3, #0
    ae06:	d101      	bne.n	ae0c <atcab_sleep+0x10>
		return ATCA_GEN_FAIL;
    ae08:	23e1      	movs	r3, #225	; 0xe1
    ae0a:	e005      	b.n	ae18 <atcab_sleep+0x1c>

	return atsleep(_gIface);
    ae0c:	4b05      	ldr	r3, [pc, #20]	; (ae24 <atcab_sleep+0x28>)
    ae0e:	681b      	ldr	r3, [r3, #0]
    ae10:	0018      	movs	r0, r3
    ae12:	4b05      	ldr	r3, [pc, #20]	; (ae28 <atcab_sleep+0x2c>)
    ae14:	4798      	blx	r3
    ae16:	0003      	movs	r3, r0
}
    ae18:	0018      	movs	r0, r3
    ae1a:	46bd      	mov	sp, r7
    ae1c:	bd80      	pop	{r7, pc}
    ae1e:	46c0      	nop			; (mov r8, r8)
    ae20:	200007e0 	.word	0x200007e0
    ae24:	200007e8 	.word	0x200007e8
    ae28:	0000ac11 	.word	0x0000ac11

0000ae2c <_atcab_exit>:

/** \brief common cleanup code which idles the device after any operation
 *  \return ATCA_STATUS
 */
static ATCA_STATUS _atcab_exit(void)
{
    ae2c:	b580      	push	{r7, lr}
    ae2e:	af00      	add	r7, sp, #0
	return atcab_idle();
    ae30:	4b02      	ldr	r3, [pc, #8]	; (ae3c <_atcab_exit+0x10>)
    ae32:	4798      	blx	r3
    ae34:	0003      	movs	r3, r0
}
    ae36:	0018      	movs	r0, r3
    ae38:	46bd      	mov	sp, r7
    ae3a:	bd80      	pop	{r7, pc}
    ae3c:	0000adcd 	.word	0x0000adcd

0000ae40 <atcab_info>:
 *  \param[out] revision - 4-byte storage for receiving the revision number from the device
 *  \return ATCA_STATUS
 */

ATCA_STATUS atcab_info( uint8_t *revision )
{
    ae40:	b590      	push	{r4, r7, lr}
    ae42:	b0a9      	sub	sp, #164	; 0xa4
    ae44:	af00      	add	r7, sp, #0
    ae46:	6078      	str	r0, [r7, #4]
	ATCAPacket packet;
	ATCA_STATUS status = ATCA_GEN_FAIL;
    ae48:	239f      	movs	r3, #159	; 0x9f
    ae4a:	18fb      	adds	r3, r7, r3
    ae4c:	22e1      	movs	r2, #225	; 0xe1
    ae4e:	701a      	strb	r2, [r3, #0]
	uint32_t execution_time;

	if ( !_gDevice )
    ae50:	4b54      	ldr	r3, [pc, #336]	; (afa4 <atcab_info+0x164>)
    ae52:	681b      	ldr	r3, [r3, #0]
    ae54:	2b00      	cmp	r3, #0
    ae56:	d101      	bne.n	ae5c <atcab_info+0x1c>
		return ATCA_GEN_FAIL;
    ae58:	23e1      	movs	r3, #225	; 0xe1
    ae5a:	e09e      	b.n	af9a <atcab_info+0x15a>

	// build an info command
	packet.param1 = INFO_MODE_REVISION;
    ae5c:	230c      	movs	r3, #12
    ae5e:	18fb      	adds	r3, r7, r3
    ae60:	2200      	movs	r2, #0
    ae62:	70da      	strb	r2, [r3, #3]
	packet.param2 = 0;
    ae64:	230c      	movs	r3, #12
    ae66:	18fb      	adds	r3, r7, r3
    ae68:	2200      	movs	r2, #0
    ae6a:	809a      	strh	r2, [r3, #4]

	do {
		if ( (status = atInfo( _gCommandObj, &packet )) != ATCA_SUCCESS )
    ae6c:	4b4e      	ldr	r3, [pc, #312]	; (afa8 <atcab_info+0x168>)
    ae6e:	681b      	ldr	r3, [r3, #0]
    ae70:	229f      	movs	r2, #159	; 0x9f
    ae72:	18bc      	adds	r4, r7, r2
    ae74:	220c      	movs	r2, #12
    ae76:	18ba      	adds	r2, r7, r2
    ae78:	0011      	movs	r1, r2
    ae7a:	0018      	movs	r0, r3
    ae7c:	4b4b      	ldr	r3, [pc, #300]	; (afac <atcab_info+0x16c>)
    ae7e:	4798      	blx	r3
    ae80:	0003      	movs	r3, r0
    ae82:	7023      	strb	r3, [r4, #0]
    ae84:	239f      	movs	r3, #159	; 0x9f
    ae86:	18fb      	adds	r3, r7, r3
    ae88:	781b      	ldrb	r3, [r3, #0]
    ae8a:	2b00      	cmp	r3, #0
    ae8c:	d000      	beq.n	ae90 <atcab_info+0x50>
    ae8e:	e071      	b.n	af74 <atcab_info+0x134>
			break;

		execution_time = atGetExecTime( _gCommandObj, CMD_INFO);
    ae90:	4b45      	ldr	r3, [pc, #276]	; (afa8 <atcab_info+0x168>)
    ae92:	681b      	ldr	r3, [r3, #0]
    ae94:	2108      	movs	r1, #8
    ae96:	0018      	movs	r0, r3
    ae98:	4b45      	ldr	r3, [pc, #276]	; (afb0 <atcab_info+0x170>)
    ae9a:	4798      	blx	r3
    ae9c:	0003      	movs	r3, r0
    ae9e:	2298      	movs	r2, #152	; 0x98
    aea0:	18ba      	adds	r2, r7, r2
    aea2:	6013      	str	r3, [r2, #0]

		if ( (status = atcab_wakeup()) != ATCA_SUCCESS )
    aea4:	239f      	movs	r3, #159	; 0x9f
    aea6:	18fc      	adds	r4, r7, r3
    aea8:	4b42      	ldr	r3, [pc, #264]	; (afb4 <atcab_info+0x174>)
    aeaa:	4798      	blx	r3
    aeac:	0003      	movs	r3, r0
    aeae:	7023      	strb	r3, [r4, #0]
    aeb0:	239f      	movs	r3, #159	; 0x9f
    aeb2:	18fb      	adds	r3, r7, r3
    aeb4:	781b      	ldrb	r3, [r3, #0]
    aeb6:	2b00      	cmp	r3, #0
    aeb8:	d15e      	bne.n	af78 <atcab_info+0x138>
			break;

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
    aeba:	4b3f      	ldr	r3, [pc, #252]	; (afb8 <atcab_info+0x178>)
    aebc:	6818      	ldr	r0, [r3, #0]
    aebe:	230c      	movs	r3, #12
    aec0:	18fb      	adds	r3, r7, r3
    aec2:	785b      	ldrb	r3, [r3, #1]
    aec4:	001a      	movs	r2, r3
    aec6:	239f      	movs	r3, #159	; 0x9f
    aec8:	18fc      	adds	r4, r7, r3
    aeca:	230c      	movs	r3, #12
    aecc:	18fb      	adds	r3, r7, r3
    aece:	0019      	movs	r1, r3
    aed0:	4b3a      	ldr	r3, [pc, #232]	; (afbc <atcab_info+0x17c>)
    aed2:	4798      	blx	r3
    aed4:	0003      	movs	r3, r0
    aed6:	7023      	strb	r3, [r4, #0]
    aed8:	239f      	movs	r3, #159	; 0x9f
    aeda:	18fb      	adds	r3, r7, r3
    aedc:	781b      	ldrb	r3, [r3, #0]
    aede:	2b00      	cmp	r3, #0
    aee0:	d14c      	bne.n	af7c <atcab_info+0x13c>
			break;

		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);
    aee2:	2398      	movs	r3, #152	; 0x98
    aee4:	18fb      	adds	r3, r7, r3
    aee6:	681b      	ldr	r3, [r3, #0]
    aee8:	0018      	movs	r0, r3
    aeea:	4b35      	ldr	r3, [pc, #212]	; (afc0 <atcab_info+0x180>)
    aeec:	4798      	blx	r3

		// receive the response
		if ( (status = atreceive( _gIface, &(packet.data[0]), &(packet.rxsize) )) != ATCA_SUCCESS )
    aeee:	4b32      	ldr	r3, [pc, #200]	; (afb8 <atcab_info+0x178>)
    aef0:	6818      	ldr	r0, [r3, #0]
    aef2:	239f      	movs	r3, #159	; 0x9f
    aef4:	18fc      	adds	r4, r7, r3
    aef6:	230c      	movs	r3, #12
    aef8:	18fb      	adds	r3, r7, r3
    aefa:	338a      	adds	r3, #138	; 0x8a
    aefc:	001a      	movs	r2, r3
    aefe:	230c      	movs	r3, #12
    af00:	18fb      	adds	r3, r7, r3
    af02:	3306      	adds	r3, #6
    af04:	0019      	movs	r1, r3
    af06:	4b2f      	ldr	r3, [pc, #188]	; (afc4 <atcab_info+0x184>)
    af08:	4798      	blx	r3
    af0a:	0003      	movs	r3, r0
    af0c:	7023      	strb	r3, [r4, #0]
    af0e:	239f      	movs	r3, #159	; 0x9f
    af10:	18fb      	adds	r3, r7, r3
    af12:	781b      	ldrb	r3, [r3, #0]
    af14:	2b00      	cmp	r3, #0
    af16:	d133      	bne.n	af80 <atcab_info+0x140>
			break;

		// Check response size
		if (packet.rxsize < 4) {
    af18:	230c      	movs	r3, #12
    af1a:	18fb      	adds	r3, r7, r3
    af1c:	228a      	movs	r2, #138	; 0x8a
    af1e:	5a9b      	ldrh	r3, [r3, r2]
    af20:	2b03      	cmp	r3, #3
    af22:	d80f      	bhi.n	af44 <atcab_info+0x104>
			if (packet.rxsize > 0)
    af24:	230c      	movs	r3, #12
    af26:	18fb      	adds	r3, r7, r3
    af28:	228a      	movs	r2, #138	; 0x8a
    af2a:	5a9b      	ldrh	r3, [r3, r2]
    af2c:	2b00      	cmp	r3, #0
    af2e:	d004      	beq.n	af3a <atcab_info+0xfa>
				status = ATCA_RX_FAIL;
    af30:	239f      	movs	r3, #159	; 0x9f
    af32:	18fb      	adds	r3, r7, r3
    af34:	22e6      	movs	r2, #230	; 0xe6
    af36:	701a      	strb	r2, [r3, #0]
			else
				status = ATCA_RX_NO_RESPONSE;
			break;
    af38:	e025      	b.n	af86 <atcab_info+0x146>
		// Check response size
		if (packet.rxsize < 4) {
			if (packet.rxsize > 0)
				status = ATCA_RX_FAIL;
			else
				status = ATCA_RX_NO_RESPONSE;
    af3a:	239f      	movs	r3, #159	; 0x9f
    af3c:	18fb      	adds	r3, r7, r3
    af3e:	22e7      	movs	r2, #231	; 0xe7
    af40:	701a      	strb	r2, [r3, #0]
			break;
    af42:	e020      	b.n	af86 <atcab_info+0x146>
		}

		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
    af44:	239f      	movs	r3, #159	; 0x9f
    af46:	18fc      	adds	r4, r7, r3
    af48:	230c      	movs	r3, #12
    af4a:	18fb      	adds	r3, r7, r3
    af4c:	3306      	adds	r3, #6
    af4e:	0018      	movs	r0, r3
    af50:	4b1d      	ldr	r3, [pc, #116]	; (afc8 <atcab_info+0x188>)
    af52:	4798      	blx	r3
    af54:	0003      	movs	r3, r0
    af56:	7023      	strb	r3, [r4, #0]
    af58:	239f      	movs	r3, #159	; 0x9f
    af5a:	18fb      	adds	r3, r7, r3
    af5c:	781b      	ldrb	r3, [r3, #0]
    af5e:	2b00      	cmp	r3, #0
    af60:	d110      	bne.n	af84 <atcab_info+0x144>
			break;

		memcpy( revision, &packet.data[1], 4 );  // don't include the receive length, only payload
    af62:	230c      	movs	r3, #12
    af64:	18fb      	adds	r3, r7, r3
    af66:	1dd9      	adds	r1, r3, #7
    af68:	687b      	ldr	r3, [r7, #4]
    af6a:	2204      	movs	r2, #4
    af6c:	0018      	movs	r0, r3
    af6e:	4b17      	ldr	r3, [pc, #92]	; (afcc <atcab_info+0x18c>)
    af70:	4798      	blx	r3
    af72:	e008      	b.n	af86 <atcab_info+0x146>
	packet.param1 = INFO_MODE_REVISION;
	packet.param2 = 0;

	do {
		if ( (status = atInfo( _gCommandObj, &packet )) != ATCA_SUCCESS )
			break;
    af74:	46c0      	nop			; (mov r8, r8)
    af76:	e006      	b.n	af86 <atcab_info+0x146>

		execution_time = atGetExecTime( _gCommandObj, CMD_INFO);

		if ( (status = atcab_wakeup()) != ATCA_SUCCESS )
			break;
    af78:	46c0      	nop			; (mov r8, r8)
    af7a:	e004      	b.n	af86 <atcab_info+0x146>

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
			break;
    af7c:	46c0      	nop			; (mov r8, r8)
    af7e:	e002      	b.n	af86 <atcab_info+0x146>
		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);

		// receive the response
		if ( (status = atreceive( _gIface, &(packet.data[0]), &(packet.rxsize) )) != ATCA_SUCCESS )
			break;
    af80:	46c0      	nop			; (mov r8, r8)
    af82:	e000      	b.n	af86 <atcab_info+0x146>
				status = ATCA_RX_NO_RESPONSE;
			break;
		}

		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
			break;
    af84:	46c0      	nop			; (mov r8, r8)

		memcpy( revision, &packet.data[1], 4 );  // don't include the receive length, only payload
	} while (0);

	if ( status != ATCA_COMM_FAIL )   // don't keep shoving more stuff at the chip if there's something wrong with comm
    af86:	239f      	movs	r3, #159	; 0x9f
    af88:	18fb      	adds	r3, r7, r3
    af8a:	781b      	ldrb	r3, [r3, #0]
    af8c:	2bf0      	cmp	r3, #240	; 0xf0
    af8e:	d001      	beq.n	af94 <atcab_info+0x154>
		_atcab_exit();
    af90:	4b0f      	ldr	r3, [pc, #60]	; (afd0 <atcab_info+0x190>)
    af92:	4798      	blx	r3

	return status;
    af94:	239f      	movs	r3, #159	; 0x9f
    af96:	18fb      	adds	r3, r7, r3
    af98:	781b      	ldrb	r3, [r3, #0]
}
    af9a:	0018      	movs	r0, r3
    af9c:	46bd      	mov	sp, r7
    af9e:	b029      	add	sp, #164	; 0xa4
    afa0:	bd90      	pop	{r4, r7, pc}
    afa2:	46c0      	nop			; (mov r8, r8)
    afa4:	200007e0 	.word	0x200007e0
    afa8:	200007e4 	.word	0x200007e4
    afac:	0000a4c5 	.word	0x0000a4c5
    afb0:	0000a7f5 	.word	0x0000a7f5
    afb4:	0000ad9d 	.word	0x0000ad9d
    afb8:	200007e8 	.word	0x200007e8
    afbc:	0000ab85 	.word	0x0000ab85
    afc0:	0000e3d5 	.word	0x0000e3d5
    afc4:	0000aba9 	.word	0x0000aba9
    afc8:	0000a955 	.word	0x0000a955
    afcc:	000127e7 	.word	0x000127e7
    afd0:	0000ae2d 	.word	0x0000ae2d

0000afd4 <atcab_random>:
/** \brief Get a 32 byte random number from the CryptoAuth device
 *	\param[out] rand_out ptr to 32 bytes of storage for random number
 *	\return status of the operation
 */
ATCA_STATUS atcab_random(uint8_t *rand_out)
{
    afd4:	b590      	push	{r4, r7, lr}
    afd6:	b0a7      	sub	sp, #156	; 0x9c
    afd8:	af00      	add	r7, sp, #0
    afda:	6078      	str	r0, [r7, #4]
	ATCA_STATUS status = ATCA_GEN_FAIL;
    afdc:	2397      	movs	r3, #151	; 0x97
    afde:	18fb      	adds	r3, r7, r3
    afe0:	22e1      	movs	r2, #225	; 0xe1
    afe2:	701a      	strb	r2, [r3, #0]
	ATCAPacket packet;
	uint16_t execution_time = 0;
    afe4:	2394      	movs	r3, #148	; 0x94
    afe6:	18fb      	adds	r3, r7, r3
    afe8:	2200      	movs	r2, #0
    afea:	801a      	strh	r2, [r3, #0]

	if ( !_gDevice )
    afec:	4b4d      	ldr	r3, [pc, #308]	; (b124 <atcab_random+0x150>)
    afee:	681b      	ldr	r3, [r3, #0]
    aff0:	2b00      	cmp	r3, #0
    aff2:	d101      	bne.n	aff8 <atcab_random+0x24>
		return ATCA_GEN_FAIL;
    aff4:	23e1      	movs	r3, #225	; 0xe1
    aff6:	e091      	b.n	b11c <atcab_random+0x148>

	// build an random command
	packet.param1 = RANDOM_SEED_UPDATE;
    aff8:	2308      	movs	r3, #8
    affa:	18fb      	adds	r3, r7, r3
    affc:	2200      	movs	r2, #0
    affe:	70da      	strb	r2, [r3, #3]
	packet.param2 = 0x0000;
    b000:	2308      	movs	r3, #8
    b002:	18fb      	adds	r3, r7, r3
    b004:	2200      	movs	r2, #0
    b006:	809a      	strh	r2, [r3, #4]
	status = atRandom( _gCommandObj, &packet );
    b008:	4b47      	ldr	r3, [pc, #284]	; (b128 <atcab_random+0x154>)
    b00a:	681b      	ldr	r3, [r3, #0]
    b00c:	2297      	movs	r2, #151	; 0x97
    b00e:	18bc      	adds	r4, r7, r2
    b010:	2208      	movs	r2, #8
    b012:	18ba      	adds	r2, r7, r2
    b014:	0011      	movs	r1, r2
    b016:	0018      	movs	r0, r3
    b018:	4b44      	ldr	r3, [pc, #272]	; (b12c <atcab_random+0x158>)
    b01a:	4798      	blx	r3
    b01c:	0003      	movs	r3, r0
    b01e:	7023      	strb	r3, [r4, #0]
	execution_time = atGetExecTime( _gCommandObj, CMD_RANDOM);
    b020:	4b41      	ldr	r3, [pc, #260]	; (b128 <atcab_random+0x154>)
    b022:	681b      	ldr	r3, [r3, #0]
    b024:	2294      	movs	r2, #148	; 0x94
    b026:	18bc      	adds	r4, r7, r2
    b028:	210e      	movs	r1, #14
    b02a:	0018      	movs	r0, r3
    b02c:	4b40      	ldr	r3, [pc, #256]	; (b130 <atcab_random+0x15c>)
    b02e:	4798      	blx	r3
    b030:	0003      	movs	r3, r0
    b032:	8023      	strh	r3, [r4, #0]

	do {
		if ( (status = atcab_wakeup()) != ATCA_SUCCESS )
    b034:	2397      	movs	r3, #151	; 0x97
    b036:	18fc      	adds	r4, r7, r3
    b038:	4b3e      	ldr	r3, [pc, #248]	; (b134 <atcab_random+0x160>)
    b03a:	4798      	blx	r3
    b03c:	0003      	movs	r3, r0
    b03e:	7023      	strb	r3, [r4, #0]
    b040:	2397      	movs	r3, #151	; 0x97
    b042:	18fb      	adds	r3, r7, r3
    b044:	781b      	ldrb	r3, [r3, #0]
    b046:	2b00      	cmp	r3, #0
    b048:	d15c      	bne.n	b104 <atcab_random+0x130>
			break;

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS)
    b04a:	4b3b      	ldr	r3, [pc, #236]	; (b138 <atcab_random+0x164>)
    b04c:	6818      	ldr	r0, [r3, #0]
    b04e:	2308      	movs	r3, #8
    b050:	18fb      	adds	r3, r7, r3
    b052:	785b      	ldrb	r3, [r3, #1]
    b054:	001a      	movs	r2, r3
    b056:	2397      	movs	r3, #151	; 0x97
    b058:	18fc      	adds	r4, r7, r3
    b05a:	2308      	movs	r3, #8
    b05c:	18fb      	adds	r3, r7, r3
    b05e:	0019      	movs	r1, r3
    b060:	4b36      	ldr	r3, [pc, #216]	; (b13c <atcab_random+0x168>)
    b062:	4798      	blx	r3
    b064:	0003      	movs	r3, r0
    b066:	7023      	strb	r3, [r4, #0]
    b068:	2397      	movs	r3, #151	; 0x97
    b06a:	18fb      	adds	r3, r7, r3
    b06c:	781b      	ldrb	r3, [r3, #0]
    b06e:	2b00      	cmp	r3, #0
    b070:	d14a      	bne.n	b108 <atcab_random+0x134>
			break;

		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);
    b072:	2394      	movs	r3, #148	; 0x94
    b074:	18fb      	adds	r3, r7, r3
    b076:	881b      	ldrh	r3, [r3, #0]
    b078:	0018      	movs	r0, r3
    b07a:	4b31      	ldr	r3, [pc, #196]	; (b140 <atcab_random+0x16c>)
    b07c:	4798      	blx	r3

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &packet.rxsize)) != ATCA_SUCCESS)
    b07e:	4b2e      	ldr	r3, [pc, #184]	; (b138 <atcab_random+0x164>)
    b080:	6818      	ldr	r0, [r3, #0]
    b082:	2397      	movs	r3, #151	; 0x97
    b084:	18fc      	adds	r4, r7, r3
    b086:	2308      	movs	r3, #8
    b088:	18fb      	adds	r3, r7, r3
    b08a:	338a      	adds	r3, #138	; 0x8a
    b08c:	001a      	movs	r2, r3
    b08e:	2308      	movs	r3, #8
    b090:	18fb      	adds	r3, r7, r3
    b092:	3306      	adds	r3, #6
    b094:	0019      	movs	r1, r3
    b096:	4b2b      	ldr	r3, [pc, #172]	; (b144 <atcab_random+0x170>)
    b098:	4798      	blx	r3
    b09a:	0003      	movs	r3, r0
    b09c:	7023      	strb	r3, [r4, #0]
    b09e:	2397      	movs	r3, #151	; 0x97
    b0a0:	18fb      	adds	r3, r7, r3
    b0a2:	781b      	ldrb	r3, [r3, #0]
    b0a4:	2b00      	cmp	r3, #0
    b0a6:	d131      	bne.n	b10c <atcab_random+0x138>
			break;

		// Check response size
		if (packet.rxsize < 4) {
    b0a8:	2308      	movs	r3, #8
    b0aa:	18fb      	adds	r3, r7, r3
    b0ac:	228a      	movs	r2, #138	; 0x8a
    b0ae:	5a9b      	ldrh	r3, [r3, r2]
    b0b0:	2b03      	cmp	r3, #3
    b0b2:	d80f      	bhi.n	b0d4 <atcab_random+0x100>
			if (packet.rxsize > 0)
    b0b4:	2308      	movs	r3, #8
    b0b6:	18fb      	adds	r3, r7, r3
    b0b8:	228a      	movs	r2, #138	; 0x8a
    b0ba:	5a9b      	ldrh	r3, [r3, r2]
    b0bc:	2b00      	cmp	r3, #0
    b0be:	d004      	beq.n	b0ca <atcab_random+0xf6>
				status = ATCA_RX_FAIL;
    b0c0:	2397      	movs	r3, #151	; 0x97
    b0c2:	18fb      	adds	r3, r7, r3
    b0c4:	22e6      	movs	r2, #230	; 0xe6
    b0c6:	701a      	strb	r2, [r3, #0]
			else
				status = ATCA_RX_NO_RESPONSE;
			break;
    b0c8:	e023      	b.n	b112 <atcab_random+0x13e>
		// Check response size
		if (packet.rxsize < 4) {
			if (packet.rxsize > 0)
				status = ATCA_RX_FAIL;
			else
				status = ATCA_RX_NO_RESPONSE;
    b0ca:	2397      	movs	r3, #151	; 0x97
    b0cc:	18fb      	adds	r3, r7, r3
    b0ce:	22e7      	movs	r2, #231	; 0xe7
    b0d0:	701a      	strb	r2, [r3, #0]
			break;
    b0d2:	e01e      	b.n	b112 <atcab_random+0x13e>
		}

		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
    b0d4:	2397      	movs	r3, #151	; 0x97
    b0d6:	18fc      	adds	r4, r7, r3
    b0d8:	2308      	movs	r3, #8
    b0da:	18fb      	adds	r3, r7, r3
    b0dc:	3306      	adds	r3, #6
    b0de:	0018      	movs	r0, r3
    b0e0:	4b19      	ldr	r3, [pc, #100]	; (b148 <atcab_random+0x174>)
    b0e2:	4798      	blx	r3
    b0e4:	0003      	movs	r3, r0
    b0e6:	7023      	strb	r3, [r4, #0]
    b0e8:	2397      	movs	r3, #151	; 0x97
    b0ea:	18fb      	adds	r3, r7, r3
    b0ec:	781b      	ldrb	r3, [r3, #0]
    b0ee:	2b00      	cmp	r3, #0
    b0f0:	d10e      	bne.n	b110 <atcab_random+0x13c>
			break;

		memcpy( rand_out, &packet.data[1], 32 );  // data[0] is the length byte of the response
    b0f2:	2308      	movs	r3, #8
    b0f4:	18fb      	adds	r3, r7, r3
    b0f6:	1dd9      	adds	r1, r3, #7
    b0f8:	687b      	ldr	r3, [r7, #4]
    b0fa:	2220      	movs	r2, #32
    b0fc:	0018      	movs	r0, r3
    b0fe:	4b13      	ldr	r3, [pc, #76]	; (b14c <atcab_random+0x178>)
    b100:	4798      	blx	r3
    b102:	e006      	b.n	b112 <atcab_random+0x13e>
	status = atRandom( _gCommandObj, &packet );
	execution_time = atGetExecTime( _gCommandObj, CMD_RANDOM);

	do {
		if ( (status = atcab_wakeup()) != ATCA_SUCCESS )
			break;
    b104:	46c0      	nop			; (mov r8, r8)
    b106:	e004      	b.n	b112 <atcab_random+0x13e>

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS)
			break;
    b108:	46c0      	nop			; (mov r8, r8)
    b10a:	e002      	b.n	b112 <atcab_random+0x13e>
		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &packet.rxsize)) != ATCA_SUCCESS)
			break;
    b10c:	46c0      	nop			; (mov r8, r8)
    b10e:	e000      	b.n	b112 <atcab_random+0x13e>
				status = ATCA_RX_NO_RESPONSE;
			break;
		}

		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
			break;
    b110:	46c0      	nop			; (mov r8, r8)

		memcpy( rand_out, &packet.data[1], 32 );  // data[0] is the length byte of the response
		
	} while (0);

	_atcab_exit();
    b112:	4b0f      	ldr	r3, [pc, #60]	; (b150 <atcab_random+0x17c>)
    b114:	4798      	blx	r3
	return status;
    b116:	2397      	movs	r3, #151	; 0x97
    b118:	18fb      	adds	r3, r7, r3
    b11a:	781b      	ldrb	r3, [r3, #0]
}
    b11c:	0018      	movs	r0, r3
    b11e:	46bd      	mov	sp, r7
    b120:	b027      	add	sp, #156	; 0x9c
    b122:	bd90      	pop	{r4, r7, pc}
    b124:	200007e0 	.word	0x200007e0
    b128:	200007e4 	.word	0x200007e4
    b12c:	0000a5c9 	.word	0x0000a5c9
    b130:	0000a7f5 	.word	0x0000a7f5
    b134:	0000ad9d 	.word	0x0000ad9d
    b138:	200007e8 	.word	0x200007e8
    b13c:	0000ab85 	.word	0x0000ab85
    b140:	0000e3d5 	.word	0x0000e3d5
    b144:	0000aba9 	.word	0x0000aba9
    b148:	0000a955 	.word	0x0000a955
    b14c:	000127e7 	.word	0x000127e7
    b150:	0000ae2d 	.word	0x0000ae2d

0000b154 <atcab_genkey>:
 *   \param[in]  slot    slot number where ECC key is configured
 *   \param[out] pubkey  64 bytes of returned public key for given slot
 *   \return ATCA_STATUS
 */
ATCA_STATUS atcab_genkey( int slot, uint8_t *pubkey )
{
    b154:	b590      	push	{r4, r7, lr}
    b156:	b0a7      	sub	sp, #156	; 0x9c
    b158:	af00      	add	r7, sp, #0
    b15a:	6078      	str	r0, [r7, #4]
    b15c:	6039      	str	r1, [r7, #0]
	ATCAPacket packet;
	uint16_t execution_time = 0;
    b15e:	2394      	movs	r3, #148	; 0x94
    b160:	18fb      	adds	r3, r7, r3
    b162:	2200      	movs	r2, #0
    b164:	801a      	strh	r2, [r3, #0]
	ATCA_STATUS status = ATCA_GEN_FAIL;
    b166:	2397      	movs	r3, #151	; 0x97
    b168:	18fb      	adds	r3, r7, r3
    b16a:	22e1      	movs	r2, #225	; 0xe1
    b16c:	701a      	strb	r2, [r3, #0]

	// build a genkey command
	packet.param1 = GENKEY_MODE_PRIVATE_KEY_GENERATE;   // a random private key is generated and stored in slot keyID
    b16e:	2308      	movs	r3, #8
    b170:	18fb      	adds	r3, r7, r3
    b172:	2204      	movs	r2, #4
    b174:	70da      	strb	r2, [r3, #3]
	packet.param2 = (uint16_t)slot;                     // slot and KeyID are the same thing
    b176:	687b      	ldr	r3, [r7, #4]
    b178:	b29a      	uxth	r2, r3
    b17a:	2308      	movs	r3, #8
    b17c:	18fb      	adds	r3, r7, r3
    b17e:	809a      	strh	r2, [r3, #4]

	do {
		if ( (status = atGenKey( _gCommandObj, &packet, false )) != ATCA_SUCCESS )
    b180:	4b4a      	ldr	r3, [pc, #296]	; (b2ac <atcab_genkey+0x158>)
    b182:	681b      	ldr	r3, [r3, #0]
    b184:	2297      	movs	r2, #151	; 0x97
    b186:	18bc      	adds	r4, r7, r2
    b188:	2208      	movs	r2, #8
    b18a:	18b9      	adds	r1, r7, r2
    b18c:	2200      	movs	r2, #0
    b18e:	0018      	movs	r0, r3
    b190:	4b47      	ldr	r3, [pc, #284]	; (b2b0 <atcab_genkey+0x15c>)
    b192:	4798      	blx	r3
    b194:	0003      	movs	r3, r0
    b196:	7023      	strb	r3, [r4, #0]
    b198:	2397      	movs	r3, #151	; 0x97
    b19a:	18fb      	adds	r3, r7, r3
    b19c:	781b      	ldrb	r3, [r3, #0]
    b19e:	2b00      	cmp	r3, #0
    b1a0:	d000      	beq.n	b1a4 <atcab_genkey+0x50>
    b1a2:	e071      	b.n	b288 <atcab_genkey+0x134>
			break;

		execution_time = atGetExecTime( _gCommandObj, CMD_GENKEY);
    b1a4:	4b41      	ldr	r3, [pc, #260]	; (b2ac <atcab_genkey+0x158>)
    b1a6:	681b      	ldr	r3, [r3, #0]
    b1a8:	2294      	movs	r2, #148	; 0x94
    b1aa:	18bc      	adds	r4, r7, r2
    b1ac:	2106      	movs	r1, #6
    b1ae:	0018      	movs	r0, r3
    b1b0:	4b40      	ldr	r3, [pc, #256]	; (b2b4 <atcab_genkey+0x160>)
    b1b2:	4798      	blx	r3
    b1b4:	0003      	movs	r3, r0
    b1b6:	8023      	strh	r3, [r4, #0]

		if ( (status = atcab_wakeup()) != ATCA_SUCCESS )
    b1b8:	2397      	movs	r3, #151	; 0x97
    b1ba:	18fc      	adds	r4, r7, r3
    b1bc:	4b3e      	ldr	r3, [pc, #248]	; (b2b8 <atcab_genkey+0x164>)
    b1be:	4798      	blx	r3
    b1c0:	0003      	movs	r3, r0
    b1c2:	7023      	strb	r3, [r4, #0]
    b1c4:	2397      	movs	r3, #151	; 0x97
    b1c6:	18fb      	adds	r3, r7, r3
    b1c8:	781b      	ldrb	r3, [r3, #0]
    b1ca:	2b00      	cmp	r3, #0
    b1cc:	d15e      	bne.n	b28c <atcab_genkey+0x138>
			break;

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
    b1ce:	4b3b      	ldr	r3, [pc, #236]	; (b2bc <atcab_genkey+0x168>)
    b1d0:	6818      	ldr	r0, [r3, #0]
    b1d2:	2308      	movs	r3, #8
    b1d4:	18fb      	adds	r3, r7, r3
    b1d6:	785b      	ldrb	r3, [r3, #1]
    b1d8:	001a      	movs	r2, r3
    b1da:	2397      	movs	r3, #151	; 0x97
    b1dc:	18fc      	adds	r4, r7, r3
    b1de:	2308      	movs	r3, #8
    b1e0:	18fb      	adds	r3, r7, r3
    b1e2:	0019      	movs	r1, r3
    b1e4:	4b36      	ldr	r3, [pc, #216]	; (b2c0 <atcab_genkey+0x16c>)
    b1e6:	4798      	blx	r3
    b1e8:	0003      	movs	r3, r0
    b1ea:	7023      	strb	r3, [r4, #0]
    b1ec:	2397      	movs	r3, #151	; 0x97
    b1ee:	18fb      	adds	r3, r7, r3
    b1f0:	781b      	ldrb	r3, [r3, #0]
    b1f2:	2b00      	cmp	r3, #0
    b1f4:	d14c      	bne.n	b290 <atcab_genkey+0x13c>
			break;

		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);
    b1f6:	2394      	movs	r3, #148	; 0x94
    b1f8:	18fb      	adds	r3, r7, r3
    b1fa:	881b      	ldrh	r3, [r3, #0]
    b1fc:	0018      	movs	r0, r3
    b1fe:	4b31      	ldr	r3, [pc, #196]	; (b2c4 <atcab_genkey+0x170>)
    b200:	4798      	blx	r3

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &(packet.rxsize) )) != ATCA_SUCCESS )
    b202:	4b2e      	ldr	r3, [pc, #184]	; (b2bc <atcab_genkey+0x168>)
    b204:	6818      	ldr	r0, [r3, #0]
    b206:	2397      	movs	r3, #151	; 0x97
    b208:	18fc      	adds	r4, r7, r3
    b20a:	2308      	movs	r3, #8
    b20c:	18fb      	adds	r3, r7, r3
    b20e:	338a      	adds	r3, #138	; 0x8a
    b210:	001a      	movs	r2, r3
    b212:	2308      	movs	r3, #8
    b214:	18fb      	adds	r3, r7, r3
    b216:	3306      	adds	r3, #6
    b218:	0019      	movs	r1, r3
    b21a:	4b2b      	ldr	r3, [pc, #172]	; (b2c8 <atcab_genkey+0x174>)
    b21c:	4798      	blx	r3
    b21e:	0003      	movs	r3, r0
    b220:	7023      	strb	r3, [r4, #0]
    b222:	2397      	movs	r3, #151	; 0x97
    b224:	18fb      	adds	r3, r7, r3
    b226:	781b      	ldrb	r3, [r3, #0]
    b228:	2b00      	cmp	r3, #0
    b22a:	d133      	bne.n	b294 <atcab_genkey+0x140>
			break;

		// Check response size
		if (packet.rxsize < 4) {
    b22c:	2308      	movs	r3, #8
    b22e:	18fb      	adds	r3, r7, r3
    b230:	228a      	movs	r2, #138	; 0x8a
    b232:	5a9b      	ldrh	r3, [r3, r2]
    b234:	2b03      	cmp	r3, #3
    b236:	d80f      	bhi.n	b258 <atcab_genkey+0x104>
			if (packet.rxsize > 0)
    b238:	2308      	movs	r3, #8
    b23a:	18fb      	adds	r3, r7, r3
    b23c:	228a      	movs	r2, #138	; 0x8a
    b23e:	5a9b      	ldrh	r3, [r3, r2]
    b240:	2b00      	cmp	r3, #0
    b242:	d004      	beq.n	b24e <atcab_genkey+0xfa>
				status = ATCA_RX_FAIL;
    b244:	2397      	movs	r3, #151	; 0x97
    b246:	18fb      	adds	r3, r7, r3
    b248:	22e6      	movs	r2, #230	; 0xe6
    b24a:	701a      	strb	r2, [r3, #0]
			else
				status = ATCA_RX_NO_RESPONSE;
			break;
    b24c:	e025      	b.n	b29a <atcab_genkey+0x146>
		// Check response size
		if (packet.rxsize < 4) {
			if (packet.rxsize > 0)
				status = ATCA_RX_FAIL;
			else
				status = ATCA_RX_NO_RESPONSE;
    b24e:	2397      	movs	r3, #151	; 0x97
    b250:	18fb      	adds	r3, r7, r3
    b252:	22e7      	movs	r2, #231	; 0xe7
    b254:	701a      	strb	r2, [r3, #0]
			break;
    b256:	e020      	b.n	b29a <atcab_genkey+0x146>
		}

		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
    b258:	2397      	movs	r3, #151	; 0x97
    b25a:	18fc      	adds	r4, r7, r3
    b25c:	2308      	movs	r3, #8
    b25e:	18fb      	adds	r3, r7, r3
    b260:	3306      	adds	r3, #6
    b262:	0018      	movs	r0, r3
    b264:	4b19      	ldr	r3, [pc, #100]	; (b2cc <atcab_genkey+0x178>)
    b266:	4798      	blx	r3
    b268:	0003      	movs	r3, r0
    b26a:	7023      	strb	r3, [r4, #0]
    b26c:	2397      	movs	r3, #151	; 0x97
    b26e:	18fb      	adds	r3, r7, r3
    b270:	781b      	ldrb	r3, [r3, #0]
    b272:	2b00      	cmp	r3, #0
    b274:	d110      	bne.n	b298 <atcab_genkey+0x144>
			break;

		memcpy(pubkey, &packet.data[1], 64 );
    b276:	2308      	movs	r3, #8
    b278:	18fb      	adds	r3, r7, r3
    b27a:	1dd9      	adds	r1, r3, #7
    b27c:	683b      	ldr	r3, [r7, #0]
    b27e:	2240      	movs	r2, #64	; 0x40
    b280:	0018      	movs	r0, r3
    b282:	4b13      	ldr	r3, [pc, #76]	; (b2d0 <atcab_genkey+0x17c>)
    b284:	4798      	blx	r3
    b286:	e008      	b.n	b29a <atcab_genkey+0x146>
	packet.param1 = GENKEY_MODE_PRIVATE_KEY_GENERATE;   // a random private key is generated and stored in slot keyID
	packet.param2 = (uint16_t)slot;                     // slot and KeyID are the same thing

	do {
		if ( (status = atGenKey( _gCommandObj, &packet, false )) != ATCA_SUCCESS )
			break;
    b288:	46c0      	nop			; (mov r8, r8)
    b28a:	e006      	b.n	b29a <atcab_genkey+0x146>

		execution_time = atGetExecTime( _gCommandObj, CMD_GENKEY);

		if ( (status = atcab_wakeup()) != ATCA_SUCCESS )
			break;
    b28c:	46c0      	nop			; (mov r8, r8)
    b28e:	e004      	b.n	b29a <atcab_genkey+0x146>

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
			break;
    b290:	46c0      	nop			; (mov r8, r8)
    b292:	e002      	b.n	b29a <atcab_genkey+0x146>
		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &(packet.rxsize) )) != ATCA_SUCCESS )
			break;
    b294:	46c0      	nop			; (mov r8, r8)
    b296:	e000      	b.n	b29a <atcab_genkey+0x146>
				status = ATCA_RX_NO_RESPONSE;
			break;
		}

		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
			break;
    b298:	46c0      	nop			; (mov r8, r8)

		memcpy(pubkey, &packet.data[1], 64 );
	} while (0);

	_atcab_exit();
    b29a:	4b0e      	ldr	r3, [pc, #56]	; (b2d4 <atcab_genkey+0x180>)
    b29c:	4798      	blx	r3
	return status;
    b29e:	2397      	movs	r3, #151	; 0x97
    b2a0:	18fb      	adds	r3, r7, r3
    b2a2:	781b      	ldrb	r3, [r3, #0]
}
    b2a4:	0018      	movs	r0, r3
    b2a6:	46bd      	mov	sp, r7
    b2a8:	b027      	add	sp, #156	; 0x9c
    b2aa:	bd90      	pop	{r4, r7, pc}
    b2ac:	200007e4 	.word	0x200007e4
    b2b0:	0000a479 	.word	0x0000a479
    b2b4:	0000a7f5 	.word	0x0000a7f5
    b2b8:	0000ad9d 	.word	0x0000ad9d
    b2bc:	200007e8 	.word	0x200007e8
    b2c0:	0000ab85 	.word	0x0000ab85
    b2c4:	0000e3d5 	.word	0x0000e3d5
    b2c8:	0000aba9 	.word	0x0000aba9
    b2cc:	0000a955 	.word	0x0000a955
    b2d0:	000127e7 	.word	0x000127e7
    b2d4:	0000ae2d 	.word	0x0000ae2d

0000b2d8 <atcab_nonce_rand>:
 *  \param[in] seed - pointer to 20 bytes of data which will be used to calculate TempKey
 *  \param[out] rand_out - pointer to 32 bytes of data that is the output of the Nonce command
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_nonce_rand(const uint8_t *seed, uint8_t* rand_out)
{
    b2d8:	b580      	push	{r7, lr}
    b2da:	b082      	sub	sp, #8
    b2dc:	af00      	add	r7, sp, #0
    b2de:	6078      	str	r0, [r7, #4]
    b2e0:	6039      	str	r1, [r7, #0]
	return atcab_challenge_seed_update(seed, rand_out);
    b2e2:	683a      	ldr	r2, [r7, #0]
    b2e4:	687b      	ldr	r3, [r7, #4]
    b2e6:	0011      	movs	r1, r2
    b2e8:	0018      	movs	r0, r3
    b2ea:	4b03      	ldr	r3, [pc, #12]	; (b2f8 <atcab_nonce_rand+0x20>)
    b2ec:	4798      	blx	r3
    b2ee:	0003      	movs	r3, r0
}
    b2f0:	0018      	movs	r0, r3
    b2f2:	46bd      	mov	sp, r7
    b2f4:	b002      	add	sp, #8
    b2f6:	bd80      	pop	{r7, pc}
    b2f8:	0000b47d 	.word	0x0000b47d

0000b2fc <atcab_challenge>:
/** \brief send a challenge to the device (a pass-through nonce)
 *  \param[in] challenge - pointer to 32 bytes of data which will be sent as the challenge
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_challenge(const uint8_t *challenge)
{
    b2fc:	b590      	push	{r4, r7, lr}
    b2fe:	b0a7      	sub	sp, #156	; 0x9c
    b300:	af00      	add	r7, sp, #0
    b302:	6078      	str	r0, [r7, #4]
	ATCA_STATUS status = ATCA_GEN_FAIL;
    b304:	2397      	movs	r3, #151	; 0x97
    b306:	18fb      	adds	r3, r7, r3
    b308:	22e1      	movs	r2, #225	; 0xe1
    b30a:	701a      	strb	r2, [r3, #0]
	ATCAPacket packet;
	uint16_t execution_time = 0;
    b30c:	2394      	movs	r3, #148	; 0x94
    b30e:	18fb      	adds	r3, r7, r3
    b310:	2200      	movs	r2, #0
    b312:	801a      	strh	r2, [r3, #0]

	do {
		// Verify the inputs
		if (challenge == NULL) {
    b314:	687b      	ldr	r3, [r7, #4]
    b316:	2b00      	cmp	r3, #0
    b318:	d104      	bne.n	b324 <atcab_challenge+0x28>
			status = ATCA_BAD_PARAM;
    b31a:	2397      	movs	r3, #151	; 0x97
    b31c:	18fb      	adds	r3, r7, r3
    b31e:	22e2      	movs	r2, #226	; 0xe2
    b320:	701a      	strb	r2, [r3, #0]
			break;
    b322:	e08c      	b.n	b43e <atcab_challenge+0x142>
		}

		// build a nonce command (pass through mode)
		packet.param1 = NONCE_MODE_PASSTHROUGH;
    b324:	2308      	movs	r3, #8
    b326:	18fb      	adds	r3, r7, r3
    b328:	2203      	movs	r2, #3
    b32a:	70da      	strb	r2, [r3, #3]
		packet.param2 = 0x0000;
    b32c:	2308      	movs	r3, #8
    b32e:	18fb      	adds	r3, r7, r3
    b330:	2200      	movs	r2, #0
    b332:	809a      	strh	r2, [r3, #4]
		memcpy( packet.data, challenge, 32 );
    b334:	6879      	ldr	r1, [r7, #4]
    b336:	2308      	movs	r3, #8
    b338:	18fb      	adds	r3, r7, r3
    b33a:	3306      	adds	r3, #6
    b33c:	2220      	movs	r2, #32
    b33e:	0018      	movs	r0, r3
    b340:	4b43      	ldr	r3, [pc, #268]	; (b450 <atcab_challenge+0x154>)
    b342:	4798      	blx	r3

		if ((status = atNonce( _gCommandObj, &packet )) != ATCA_SUCCESS )
    b344:	4b43      	ldr	r3, [pc, #268]	; (b454 <atcab_challenge+0x158>)
    b346:	681b      	ldr	r3, [r3, #0]
    b348:	2297      	movs	r2, #151	; 0x97
    b34a:	18bc      	adds	r4, r7, r2
    b34c:	2208      	movs	r2, #8
    b34e:	18ba      	adds	r2, r7, r2
    b350:	0011      	movs	r1, r2
    b352:	0018      	movs	r0, r3
    b354:	4b40      	ldr	r3, [pc, #256]	; (b458 <atcab_challenge+0x15c>)
    b356:	4798      	blx	r3
    b358:	0003      	movs	r3, r0
    b35a:	7023      	strb	r3, [r4, #0]
    b35c:	2397      	movs	r3, #151	; 0x97
    b35e:	18fb      	adds	r3, r7, r3
    b360:	781b      	ldrb	r3, [r3, #0]
    b362:	2b00      	cmp	r3, #0
    b364:	d164      	bne.n	b430 <atcab_challenge+0x134>
			break;

		execution_time = atGetExecTime( _gCommandObj, CMD_NONCE);
    b366:	4b3b      	ldr	r3, [pc, #236]	; (b454 <atcab_challenge+0x158>)
    b368:	681b      	ldr	r3, [r3, #0]
    b36a:	2294      	movs	r2, #148	; 0x94
    b36c:	18bc      	adds	r4, r7, r2
    b36e:	210b      	movs	r1, #11
    b370:	0018      	movs	r0, r3
    b372:	4b3a      	ldr	r3, [pc, #232]	; (b45c <atcab_challenge+0x160>)
    b374:	4798      	blx	r3
    b376:	0003      	movs	r3, r0
    b378:	8023      	strh	r3, [r4, #0]

		if ((status = atcab_wakeup()) != ATCA_SUCCESS )
    b37a:	2397      	movs	r3, #151	; 0x97
    b37c:	18fc      	adds	r4, r7, r3
    b37e:	4b38      	ldr	r3, [pc, #224]	; (b460 <atcab_challenge+0x164>)
    b380:	4798      	blx	r3
    b382:	0003      	movs	r3, r0
    b384:	7023      	strb	r3, [r4, #0]
    b386:	2397      	movs	r3, #151	; 0x97
    b388:	18fb      	adds	r3, r7, r3
    b38a:	781b      	ldrb	r3, [r3, #0]
    b38c:	2b00      	cmp	r3, #0
    b38e:	d151      	bne.n	b434 <atcab_challenge+0x138>
			break;

		// send the command
		if ((status = atsend( _gIface, (uint8_t*)&packet, packet.txsize)) != ATCA_SUCCESS )
    b390:	4b34      	ldr	r3, [pc, #208]	; (b464 <atcab_challenge+0x168>)
    b392:	6818      	ldr	r0, [r3, #0]
    b394:	2308      	movs	r3, #8
    b396:	18fb      	adds	r3, r7, r3
    b398:	785b      	ldrb	r3, [r3, #1]
    b39a:	001a      	movs	r2, r3
    b39c:	2397      	movs	r3, #151	; 0x97
    b39e:	18fc      	adds	r4, r7, r3
    b3a0:	2308      	movs	r3, #8
    b3a2:	18fb      	adds	r3, r7, r3
    b3a4:	0019      	movs	r1, r3
    b3a6:	4b30      	ldr	r3, [pc, #192]	; (b468 <atcab_challenge+0x16c>)
    b3a8:	4798      	blx	r3
    b3aa:	0003      	movs	r3, r0
    b3ac:	7023      	strb	r3, [r4, #0]
    b3ae:	2397      	movs	r3, #151	; 0x97
    b3b0:	18fb      	adds	r3, r7, r3
    b3b2:	781b      	ldrb	r3, [r3, #0]
    b3b4:	2b00      	cmp	r3, #0
    b3b6:	d13f      	bne.n	b438 <atcab_challenge+0x13c>
			break;

		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);
    b3b8:	2394      	movs	r3, #148	; 0x94
    b3ba:	18fb      	adds	r3, r7, r3
    b3bc:	881b      	ldrh	r3, [r3, #0]
    b3be:	0018      	movs	r0, r3
    b3c0:	4b2a      	ldr	r3, [pc, #168]	; (b46c <atcab_challenge+0x170>)
    b3c2:	4798      	blx	r3

		// receive the response
		if ((status = atreceive( _gIface, packet.data, &(packet.rxsize))) != ATCA_SUCCESS )
    b3c4:	4b27      	ldr	r3, [pc, #156]	; (b464 <atcab_challenge+0x168>)
    b3c6:	6818      	ldr	r0, [r3, #0]
    b3c8:	2397      	movs	r3, #151	; 0x97
    b3ca:	18fc      	adds	r4, r7, r3
    b3cc:	2308      	movs	r3, #8
    b3ce:	18fb      	adds	r3, r7, r3
    b3d0:	338a      	adds	r3, #138	; 0x8a
    b3d2:	001a      	movs	r2, r3
    b3d4:	2308      	movs	r3, #8
    b3d6:	18fb      	adds	r3, r7, r3
    b3d8:	3306      	adds	r3, #6
    b3da:	0019      	movs	r1, r3
    b3dc:	4b24      	ldr	r3, [pc, #144]	; (b470 <atcab_challenge+0x174>)
    b3de:	4798      	blx	r3
    b3e0:	0003      	movs	r3, r0
    b3e2:	7023      	strb	r3, [r4, #0]
    b3e4:	2397      	movs	r3, #151	; 0x97
    b3e6:	18fb      	adds	r3, r7, r3
    b3e8:	781b      	ldrb	r3, [r3, #0]
    b3ea:	2b00      	cmp	r3, #0
    b3ec:	d126      	bne.n	b43c <atcab_challenge+0x140>
			break;

		// Check response size
		if (packet.rxsize < 4) {
    b3ee:	2308      	movs	r3, #8
    b3f0:	18fb      	adds	r3, r7, r3
    b3f2:	228a      	movs	r2, #138	; 0x8a
    b3f4:	5a9b      	ldrh	r3, [r3, r2]
    b3f6:	2b03      	cmp	r3, #3
    b3f8:	d80f      	bhi.n	b41a <atcab_challenge+0x11e>
			if (packet.rxsize > 0)
    b3fa:	2308      	movs	r3, #8
    b3fc:	18fb      	adds	r3, r7, r3
    b3fe:	228a      	movs	r2, #138	; 0x8a
    b400:	5a9b      	ldrh	r3, [r3, r2]
    b402:	2b00      	cmp	r3, #0
    b404:	d004      	beq.n	b410 <atcab_challenge+0x114>
				status = ATCA_RX_FAIL;
    b406:	2397      	movs	r3, #151	; 0x97
    b408:	18fb      	adds	r3, r7, r3
    b40a:	22e6      	movs	r2, #230	; 0xe6
    b40c:	701a      	strb	r2, [r3, #0]
			else
				status = ATCA_RX_NO_RESPONSE;
			break;
    b40e:	e016      	b.n	b43e <atcab_challenge+0x142>
		// Check response size
		if (packet.rxsize < 4) {
			if (packet.rxsize > 0)
				status = ATCA_RX_FAIL;
			else
				status = ATCA_RX_NO_RESPONSE;
    b410:	2397      	movs	r3, #151	; 0x97
    b412:	18fb      	adds	r3, r7, r3
    b414:	22e7      	movs	r2, #231	; 0xe7
    b416:	701a      	strb	r2, [r3, #0]
			break;
    b418:	e011      	b.n	b43e <atcab_challenge+0x142>
		}

		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
    b41a:	2397      	movs	r3, #151	; 0x97
    b41c:	18fc      	adds	r4, r7, r3
    b41e:	2308      	movs	r3, #8
    b420:	18fb      	adds	r3, r7, r3
    b422:	3306      	adds	r3, #6
    b424:	0018      	movs	r0, r3
    b426:	4b13      	ldr	r3, [pc, #76]	; (b474 <atcab_challenge+0x178>)
    b428:	4798      	blx	r3
    b42a:	0003      	movs	r3, r0
    b42c:	7023      	strb	r3, [r4, #0]
    b42e:	e006      	b.n	b43e <atcab_challenge+0x142>
		packet.param1 = NONCE_MODE_PASSTHROUGH;
		packet.param2 = 0x0000;
		memcpy( packet.data, challenge, 32 );

		if ((status = atNonce( _gCommandObj, &packet )) != ATCA_SUCCESS )
			break;
    b430:	46c0      	nop			; (mov r8, r8)
    b432:	e004      	b.n	b43e <atcab_challenge+0x142>

		execution_time = atGetExecTime( _gCommandObj, CMD_NONCE);

		if ((status = atcab_wakeup()) != ATCA_SUCCESS )
			break;
    b434:	46c0      	nop			; (mov r8, r8)
    b436:	e002      	b.n	b43e <atcab_challenge+0x142>

		// send the command
		if ((status = atsend( _gIface, (uint8_t*)&packet, packet.txsize)) != ATCA_SUCCESS )
			break;
    b438:	46c0      	nop			; (mov r8, r8)
    b43a:	e000      	b.n	b43e <atcab_challenge+0x142>
		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);

		// receive the response
		if ((status = atreceive( _gIface, packet.data, &(packet.rxsize))) != ATCA_SUCCESS )
			break;
    b43c:	46c0      	nop			; (mov r8, r8)
		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
			break;

	} while (0);

	_atcab_exit();
    b43e:	4b0e      	ldr	r3, [pc, #56]	; (b478 <atcab_challenge+0x17c>)
    b440:	4798      	blx	r3
	return status;
    b442:	2397      	movs	r3, #151	; 0x97
    b444:	18fb      	adds	r3, r7, r3
    b446:	781b      	ldrb	r3, [r3, #0]
}
    b448:	0018      	movs	r0, r3
    b44a:	46bd      	mov	sp, r7
    b44c:	b027      	add	sp, #156	; 0x9c
    b44e:	bd90      	pop	{r4, r7, pc}
    b450:	000127e7 	.word	0x000127e7
    b454:	200007e4 	.word	0x200007e4
    b458:	0000a52d 	.word	0x0000a52d
    b45c:	0000a7f5 	.word	0x0000a7f5
    b460:	0000ad9d 	.word	0x0000ad9d
    b464:	200007e8 	.word	0x200007e8
    b468:	0000ab85 	.word	0x0000ab85
    b46c:	0000e3d5 	.word	0x0000e3d5
    b470:	0000aba9 	.word	0x0000aba9
    b474:	0000a955 	.word	0x0000a955
    b478:	0000ae2d 	.word	0x0000ae2d

0000b47c <atcab_challenge_seed_update>:
 *  \param[in] seed - pointer to 32 bytes of data which will be sent as the challenge
 *  \param[out] rand_out - points to space to receive random number
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_challenge_seed_update( const uint8_t *seed, uint8_t* rand_out )
{
    b47c:	b590      	push	{r4, r7, lr}
    b47e:	b0a7      	sub	sp, #156	; 0x9c
    b480:	af00      	add	r7, sp, #0
    b482:	6078      	str	r0, [r7, #4]
    b484:	6039      	str	r1, [r7, #0]
	ATCA_STATUS status = ATCA_GEN_FAIL;
    b486:	2397      	movs	r3, #151	; 0x97
    b488:	18fb      	adds	r3, r7, r3
    b48a:	22e1      	movs	r2, #225	; 0xe1
    b48c:	701a      	strb	r2, [r3, #0]
	ATCAPacket packet;
	uint16_t execution_time = 0;
    b48e:	2394      	movs	r3, #148	; 0x94
    b490:	18fb      	adds	r3, r7, r3
    b492:	2200      	movs	r2, #0
    b494:	801a      	strh	r2, [r3, #0]

	do {
		// Verify the inputs
		if (seed == NULL || rand_out == NULL) {
    b496:	687b      	ldr	r3, [r7, #4]
    b498:	2b00      	cmp	r3, #0
    b49a:	d002      	beq.n	b4a2 <atcab_challenge_seed_update+0x26>
    b49c:	683b      	ldr	r3, [r7, #0]
    b49e:	2b00      	cmp	r3, #0
    b4a0:	d104      	bne.n	b4ac <atcab_challenge_seed_update+0x30>
			status = ATCA_BAD_PARAM;
    b4a2:	2397      	movs	r3, #151	; 0x97
    b4a4:	18fb      	adds	r3, r7, r3
    b4a6:	22e2      	movs	r2, #226	; 0xe2
    b4a8:	701a      	strb	r2, [r3, #0]
			break;
    b4aa:	e09c      	b.n	b5e6 <atcab_challenge_seed_update+0x16a>
		}

		// build a nonce command (pass through mode)
		packet.param1 = NONCE_MODE_SEED_UPDATE;
    b4ac:	2308      	movs	r3, #8
    b4ae:	18fb      	adds	r3, r7, r3
    b4b0:	2200      	movs	r2, #0
    b4b2:	70da      	strb	r2, [r3, #3]
		packet.param2 = 0x0000;
    b4b4:	2308      	movs	r3, #8
    b4b6:	18fb      	adds	r3, r7, r3
    b4b8:	2200      	movs	r2, #0
    b4ba:	809a      	strh	r2, [r3, #4]
		memcpy( packet.data, seed, 20 );
    b4bc:	6879      	ldr	r1, [r7, #4]
    b4be:	2308      	movs	r3, #8
    b4c0:	18fb      	adds	r3, r7, r3
    b4c2:	3306      	adds	r3, #6
    b4c4:	2214      	movs	r2, #20
    b4c6:	0018      	movs	r0, r3
    b4c8:	4b4b      	ldr	r3, [pc, #300]	; (b5f8 <atcab_challenge_seed_update+0x17c>)
    b4ca:	4798      	blx	r3

		if ((status = atNonce(_gCommandObj, &packet)) != ATCA_SUCCESS) break;
    b4cc:	4b4b      	ldr	r3, [pc, #300]	; (b5fc <atcab_challenge_seed_update+0x180>)
    b4ce:	681b      	ldr	r3, [r3, #0]
    b4d0:	2297      	movs	r2, #151	; 0x97
    b4d2:	18bc      	adds	r4, r7, r2
    b4d4:	2208      	movs	r2, #8
    b4d6:	18ba      	adds	r2, r7, r2
    b4d8:	0011      	movs	r1, r2
    b4da:	0018      	movs	r0, r3
    b4dc:	4b48      	ldr	r3, [pc, #288]	; (b600 <atcab_challenge_seed_update+0x184>)
    b4de:	4798      	blx	r3
    b4e0:	0003      	movs	r3, r0
    b4e2:	7023      	strb	r3, [r4, #0]
    b4e4:	2397      	movs	r3, #151	; 0x97
    b4e6:	18fb      	adds	r3, r7, r3
    b4e8:	781b      	ldrb	r3, [r3, #0]
    b4ea:	2b00      	cmp	r3, #0
    b4ec:	d000      	beq.n	b4f0 <atcab_challenge_seed_update+0x74>
    b4ee:	e071      	b.n	b5d4 <atcab_challenge_seed_update+0x158>

		execution_time = atGetExecTime(_gCommandObj, CMD_NONCE);
    b4f0:	4b42      	ldr	r3, [pc, #264]	; (b5fc <atcab_challenge_seed_update+0x180>)
    b4f2:	681b      	ldr	r3, [r3, #0]
    b4f4:	2294      	movs	r2, #148	; 0x94
    b4f6:	18bc      	adds	r4, r7, r2
    b4f8:	210b      	movs	r1, #11
    b4fa:	0018      	movs	r0, r3
    b4fc:	4b41      	ldr	r3, [pc, #260]	; (b604 <atcab_challenge_seed_update+0x188>)
    b4fe:	4798      	blx	r3
    b500:	0003      	movs	r3, r0
    b502:	8023      	strh	r3, [r4, #0]

		if ((status = atcab_wakeup()) != ATCA_SUCCESS ) break;
    b504:	2397      	movs	r3, #151	; 0x97
    b506:	18fc      	adds	r4, r7, r3
    b508:	4b3f      	ldr	r3, [pc, #252]	; (b608 <atcab_challenge_seed_update+0x18c>)
    b50a:	4798      	blx	r3
    b50c:	0003      	movs	r3, r0
    b50e:	7023      	strb	r3, [r4, #0]
    b510:	2397      	movs	r3, #151	; 0x97
    b512:	18fb      	adds	r3, r7, r3
    b514:	781b      	ldrb	r3, [r3, #0]
    b516:	2b00      	cmp	r3, #0
    b518:	d15e      	bne.n	b5d8 <atcab_challenge_seed_update+0x15c>

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize)) != ATCA_SUCCESS ) break;
    b51a:	4b3c      	ldr	r3, [pc, #240]	; (b60c <atcab_challenge_seed_update+0x190>)
    b51c:	6818      	ldr	r0, [r3, #0]
    b51e:	2308      	movs	r3, #8
    b520:	18fb      	adds	r3, r7, r3
    b522:	785b      	ldrb	r3, [r3, #1]
    b524:	001a      	movs	r2, r3
    b526:	2397      	movs	r3, #151	; 0x97
    b528:	18fc      	adds	r4, r7, r3
    b52a:	2308      	movs	r3, #8
    b52c:	18fb      	adds	r3, r7, r3
    b52e:	0019      	movs	r1, r3
    b530:	4b37      	ldr	r3, [pc, #220]	; (b610 <atcab_challenge_seed_update+0x194>)
    b532:	4798      	blx	r3
    b534:	0003      	movs	r3, r0
    b536:	7023      	strb	r3, [r4, #0]
    b538:	2397      	movs	r3, #151	; 0x97
    b53a:	18fb      	adds	r3, r7, r3
    b53c:	781b      	ldrb	r3, [r3, #0]
    b53e:	2b00      	cmp	r3, #0
    b540:	d14c      	bne.n	b5dc <atcab_challenge_seed_update+0x160>

		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);
    b542:	2394      	movs	r3, #148	; 0x94
    b544:	18fb      	adds	r3, r7, r3
    b546:	881b      	ldrh	r3, [r3, #0]
    b548:	0018      	movs	r0, r3
    b54a:	4b32      	ldr	r3, [pc, #200]	; (b614 <atcab_challenge_seed_update+0x198>)
    b54c:	4798      	blx	r3

		// receive the response
		if ((status = atreceive(_gIface, packet.data, &(packet.rxsize))) != ATCA_SUCCESS) break;
    b54e:	4b2f      	ldr	r3, [pc, #188]	; (b60c <atcab_challenge_seed_update+0x190>)
    b550:	6818      	ldr	r0, [r3, #0]
    b552:	2397      	movs	r3, #151	; 0x97
    b554:	18fc      	adds	r4, r7, r3
    b556:	2308      	movs	r3, #8
    b558:	18fb      	adds	r3, r7, r3
    b55a:	338a      	adds	r3, #138	; 0x8a
    b55c:	001a      	movs	r2, r3
    b55e:	2308      	movs	r3, #8
    b560:	18fb      	adds	r3, r7, r3
    b562:	3306      	adds	r3, #6
    b564:	0019      	movs	r1, r3
    b566:	4b2c      	ldr	r3, [pc, #176]	; (b618 <atcab_challenge_seed_update+0x19c>)
    b568:	4798      	blx	r3
    b56a:	0003      	movs	r3, r0
    b56c:	7023      	strb	r3, [r4, #0]
    b56e:	2397      	movs	r3, #151	; 0x97
    b570:	18fb      	adds	r3, r7, r3
    b572:	781b      	ldrb	r3, [r3, #0]
    b574:	2b00      	cmp	r3, #0
    b576:	d133      	bne.n	b5e0 <atcab_challenge_seed_update+0x164>

		// Check response size
		if (packet.rxsize < 4) {
    b578:	2308      	movs	r3, #8
    b57a:	18fb      	adds	r3, r7, r3
    b57c:	228a      	movs	r2, #138	; 0x8a
    b57e:	5a9b      	ldrh	r3, [r3, r2]
    b580:	2b03      	cmp	r3, #3
    b582:	d80f      	bhi.n	b5a4 <atcab_challenge_seed_update+0x128>
			if (packet.rxsize > 0)
    b584:	2308      	movs	r3, #8
    b586:	18fb      	adds	r3, r7, r3
    b588:	228a      	movs	r2, #138	; 0x8a
    b58a:	5a9b      	ldrh	r3, [r3, r2]
    b58c:	2b00      	cmp	r3, #0
    b58e:	d004      	beq.n	b59a <atcab_challenge_seed_update+0x11e>
				status = ATCA_RX_FAIL;
    b590:	2397      	movs	r3, #151	; 0x97
    b592:	18fb      	adds	r3, r7, r3
    b594:	22e6      	movs	r2, #230	; 0xe6
    b596:	701a      	strb	r2, [r3, #0]
			else
				status = ATCA_RX_NO_RESPONSE;
			break;
    b598:	e025      	b.n	b5e6 <atcab_challenge_seed_update+0x16a>
		// Check response size
		if (packet.rxsize < 4) {
			if (packet.rxsize > 0)
				status = ATCA_RX_FAIL;
			else
				status = ATCA_RX_NO_RESPONSE;
    b59a:	2397      	movs	r3, #151	; 0x97
    b59c:	18fb      	adds	r3, r7, r3
    b59e:	22e7      	movs	r2, #231	; 0xe7
    b5a0:	701a      	strb	r2, [r3, #0]
			break;
    b5a2:	e020      	b.n	b5e6 <atcab_challenge_seed_update+0x16a>
		}

		if ((status = isATCAError(packet.data)) != ATCA_SUCCESS) break;
    b5a4:	2397      	movs	r3, #151	; 0x97
    b5a6:	18fc      	adds	r4, r7, r3
    b5a8:	2308      	movs	r3, #8
    b5aa:	18fb      	adds	r3, r7, r3
    b5ac:	3306      	adds	r3, #6
    b5ae:	0018      	movs	r0, r3
    b5b0:	4b1a      	ldr	r3, [pc, #104]	; (b61c <atcab_challenge_seed_update+0x1a0>)
    b5b2:	4798      	blx	r3
    b5b4:	0003      	movs	r3, r0
    b5b6:	7023      	strb	r3, [r4, #0]
    b5b8:	2397      	movs	r3, #151	; 0x97
    b5ba:	18fb      	adds	r3, r7, r3
    b5bc:	781b      	ldrb	r3, [r3, #0]
    b5be:	2b00      	cmp	r3, #0
    b5c0:	d110      	bne.n	b5e4 <atcab_challenge_seed_update+0x168>

		memcpy(&rand_out[0], &packet.data[ATCA_RSP_DATA_IDX], 32);
    b5c2:	2308      	movs	r3, #8
    b5c4:	18fb      	adds	r3, r7, r3
    b5c6:	1dd9      	adds	r1, r3, #7
    b5c8:	683b      	ldr	r3, [r7, #0]
    b5ca:	2220      	movs	r2, #32
    b5cc:	0018      	movs	r0, r3
    b5ce:	4b0a      	ldr	r3, [pc, #40]	; (b5f8 <atcab_challenge_seed_update+0x17c>)
    b5d0:	4798      	blx	r3
    b5d2:	e008      	b.n	b5e6 <atcab_challenge_seed_update+0x16a>
		// build a nonce command (pass through mode)
		packet.param1 = NONCE_MODE_SEED_UPDATE;
		packet.param2 = 0x0000;
		memcpy( packet.data, seed, 20 );

		if ((status = atNonce(_gCommandObj, &packet)) != ATCA_SUCCESS) break;
    b5d4:	46c0      	nop			; (mov r8, r8)
    b5d6:	e006      	b.n	b5e6 <atcab_challenge_seed_update+0x16a>

		execution_time = atGetExecTime(_gCommandObj, CMD_NONCE);

		if ((status = atcab_wakeup()) != ATCA_SUCCESS ) break;
    b5d8:	46c0      	nop			; (mov r8, r8)
    b5da:	e004      	b.n	b5e6 <atcab_challenge_seed_update+0x16a>

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize)) != ATCA_SUCCESS ) break;
    b5dc:	46c0      	nop			; (mov r8, r8)
    b5de:	e002      	b.n	b5e6 <atcab_challenge_seed_update+0x16a>

		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);

		// receive the response
		if ((status = atreceive(_gIface, packet.data, &(packet.rxsize))) != ATCA_SUCCESS) break;
    b5e0:	46c0      	nop			; (mov r8, r8)
    b5e2:	e000      	b.n	b5e6 <atcab_challenge_seed_update+0x16a>
			else
				status = ATCA_RX_NO_RESPONSE;
			break;
		}

		if ((status = isATCAError(packet.data)) != ATCA_SUCCESS) break;
    b5e4:	46c0      	nop			; (mov r8, r8)

		memcpy(&rand_out[0], &packet.data[ATCA_RSP_DATA_IDX], 32);

	} while (0);

	_atcab_exit();
    b5e6:	4b0e      	ldr	r3, [pc, #56]	; (b620 <atcab_challenge_seed_update+0x1a4>)
    b5e8:	4798      	blx	r3
	return status;
    b5ea:	2397      	movs	r3, #151	; 0x97
    b5ec:	18fb      	adds	r3, r7, r3
    b5ee:	781b      	ldrb	r3, [r3, #0]
}
    b5f0:	0018      	movs	r0, r3
    b5f2:	46bd      	mov	sp, r7
    b5f4:	b027      	add	sp, #156	; 0x9c
    b5f6:	bd90      	pop	{r4, r7, pc}
    b5f8:	000127e7 	.word	0x000127e7
    b5fc:	200007e4 	.word	0x200007e4
    b600:	0000a52d 	.word	0x0000a52d
    b604:	0000a7f5 	.word	0x0000a7f5
    b608:	0000ad9d 	.word	0x0000ad9d
    b60c:	200007e8 	.word	0x200007e8
    b610:	0000ab85 	.word	0x0000ab85
    b614:	0000e3d5 	.word	0x0000e3d5
    b618:	0000aba9 	.word	0x0000aba9
    b61c:	0000a955 	.word	0x0000a955
    b620:	0000ae2d 	.word	0x0000ae2d

0000b624 <atcab_read_serial_number>:
/** \brief read the serial number of the device
 *  \param[out] serial_number  pointer to space to receive serial number. This space should be 9 bytes long
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_read_serial_number(uint8_t* serial_number)
{
    b624:	b5b0      	push	{r4, r5, r7, lr}
    b626:	b08e      	sub	sp, #56	; 0x38
    b628:	af02      	add	r7, sp, #8
    b62a:	6078      	str	r0, [r7, #4]
	// read config zone bytes 0-3 and 4-7, concatenate the two bits into serial_number
	uint8_t status = ATCA_GEN_FAIL;
    b62c:	232f      	movs	r3, #47	; 0x2f
    b62e:	18fb      	adds	r3, r7, r3
    b630:	22e1      	movs	r2, #225	; 0xe1
    b632:	701a      	strb	r2, [r3, #0]
	uint8_t bytes_read[ATCA_BLOCK_SIZE];
	uint8_t block = 0;
    b634:	232e      	movs	r3, #46	; 0x2e
    b636:	18fb      	adds	r3, r7, r3
    b638:	2200      	movs	r2, #0
    b63a:	701a      	strb	r2, [r3, #0]
	uint8_t cpyIndex = 0;
    b63c:	232d      	movs	r3, #45	; 0x2d
    b63e:	18fb      	adds	r3, r7, r3
    b640:	2200      	movs	r2, #0
    b642:	701a      	strb	r2, [r3, #0]
	uint8_t offset = 0;
    b644:	232c      	movs	r3, #44	; 0x2c
    b646:	18fb      	adds	r3, r7, r3
    b648:	2200      	movs	r2, #0
    b64a:	701a      	strb	r2, [r3, #0]

	do {
		memset(serial_number, 0x00, ATCA_SERIAL_NUM_SIZE);
    b64c:	687b      	ldr	r3, [r7, #4]
    b64e:	2209      	movs	r2, #9
    b650:	2100      	movs	r1, #0
    b652:	0018      	movs	r0, r3
    b654:	4b50      	ldr	r3, [pc, #320]	; (b798 <atcab_read_serial_number+0x174>)
    b656:	4798      	blx	r3
		// Read first 32 byte block.  Copy the bytes into the config_data buffer
		block = 0;
    b658:	232e      	movs	r3, #46	; 0x2e
    b65a:	18fb      	adds	r3, r7, r3
    b65c:	2200      	movs	r2, #0
    b65e:	701a      	strb	r2, [r3, #0]
		offset = 0;
    b660:	232c      	movs	r3, #44	; 0x2c
    b662:	18fb      	adds	r3, r7, r3
    b664:	2200      	movs	r2, #0
    b666:	701a      	strb	r2, [r3, #0]
		if ( (status = atcab_read_zone(ATCA_ZONE_CONFIG, 0, block, offset, bytes_read, ATCA_WORD_SIZE)) != ATCA_SUCCESS )
    b668:	232f      	movs	r3, #47	; 0x2f
    b66a:	18fc      	adds	r4, r7, r3
    b66c:	232c      	movs	r3, #44	; 0x2c
    b66e:	18fb      	adds	r3, r7, r3
    b670:	7819      	ldrb	r1, [r3, #0]
    b672:	232e      	movs	r3, #46	; 0x2e
    b674:	18fb      	adds	r3, r7, r3
    b676:	781a      	ldrb	r2, [r3, #0]
    b678:	2304      	movs	r3, #4
    b67a:	9301      	str	r3, [sp, #4]
    b67c:	230c      	movs	r3, #12
    b67e:	18fb      	adds	r3, r7, r3
    b680:	9300      	str	r3, [sp, #0]
    b682:	000b      	movs	r3, r1
    b684:	2100      	movs	r1, #0
    b686:	2000      	movs	r0, #0
    b688:	4d44      	ldr	r5, [pc, #272]	; (b79c <atcab_read_serial_number+0x178>)
    b68a:	47a8      	blx	r5
    b68c:	0003      	movs	r3, r0
    b68e:	7023      	strb	r3, [r4, #0]
    b690:	232f      	movs	r3, #47	; 0x2f
    b692:	18fb      	adds	r3, r7, r3
    b694:	781b      	ldrb	r3, [r3, #0]
    b696:	2b00      	cmp	r3, #0
    b698:	d16f      	bne.n	b77a <atcab_read_serial_number+0x156>
			break;

		memcpy(&serial_number[cpyIndex], bytes_read, ATCA_WORD_SIZE);
    b69a:	232d      	movs	r3, #45	; 0x2d
    b69c:	18fb      	adds	r3, r7, r3
    b69e:	781b      	ldrb	r3, [r3, #0]
    b6a0:	687a      	ldr	r2, [r7, #4]
    b6a2:	18d3      	adds	r3, r2, r3
    b6a4:	220c      	movs	r2, #12
    b6a6:	18b9      	adds	r1, r7, r2
    b6a8:	2204      	movs	r2, #4
    b6aa:	0018      	movs	r0, r3
    b6ac:	4b3c      	ldr	r3, [pc, #240]	; (b7a0 <atcab_read_serial_number+0x17c>)
    b6ae:	4798      	blx	r3
		cpyIndex += ATCA_WORD_SIZE;
    b6b0:	232d      	movs	r3, #45	; 0x2d
    b6b2:	18fb      	adds	r3, r7, r3
    b6b4:	222d      	movs	r2, #45	; 0x2d
    b6b6:	18ba      	adds	r2, r7, r2
    b6b8:	7812      	ldrb	r2, [r2, #0]
    b6ba:	3204      	adds	r2, #4
    b6bc:	701a      	strb	r2, [r3, #0]

		block = 0;
    b6be:	232e      	movs	r3, #46	; 0x2e
    b6c0:	18fb      	adds	r3, r7, r3
    b6c2:	2200      	movs	r2, #0
    b6c4:	701a      	strb	r2, [r3, #0]
		offset = 2;
    b6c6:	232c      	movs	r3, #44	; 0x2c
    b6c8:	18fb      	adds	r3, r7, r3
    b6ca:	2202      	movs	r2, #2
    b6cc:	701a      	strb	r2, [r3, #0]
		if ( (status = atcab_read_zone(ATCA_ZONE_CONFIG, 0, block, offset, bytes_read, ATCA_WORD_SIZE)) != ATCA_SUCCESS )
    b6ce:	232f      	movs	r3, #47	; 0x2f
    b6d0:	18fc      	adds	r4, r7, r3
    b6d2:	232c      	movs	r3, #44	; 0x2c
    b6d4:	18fb      	adds	r3, r7, r3
    b6d6:	7819      	ldrb	r1, [r3, #0]
    b6d8:	232e      	movs	r3, #46	; 0x2e
    b6da:	18fb      	adds	r3, r7, r3
    b6dc:	781a      	ldrb	r2, [r3, #0]
    b6de:	2304      	movs	r3, #4
    b6e0:	9301      	str	r3, [sp, #4]
    b6e2:	230c      	movs	r3, #12
    b6e4:	18fb      	adds	r3, r7, r3
    b6e6:	9300      	str	r3, [sp, #0]
    b6e8:	000b      	movs	r3, r1
    b6ea:	2100      	movs	r1, #0
    b6ec:	2000      	movs	r0, #0
    b6ee:	4d2b      	ldr	r5, [pc, #172]	; (b79c <atcab_read_serial_number+0x178>)
    b6f0:	47a8      	blx	r5
    b6f2:	0003      	movs	r3, r0
    b6f4:	7023      	strb	r3, [r4, #0]
    b6f6:	232f      	movs	r3, #47	; 0x2f
    b6f8:	18fb      	adds	r3, r7, r3
    b6fa:	781b      	ldrb	r3, [r3, #0]
    b6fc:	2b00      	cmp	r3, #0
    b6fe:	d13e      	bne.n	b77e <atcab_read_serial_number+0x15a>
			break;

		memcpy(&serial_number[cpyIndex], bytes_read, ATCA_WORD_SIZE);
    b700:	232d      	movs	r3, #45	; 0x2d
    b702:	18fb      	adds	r3, r7, r3
    b704:	781b      	ldrb	r3, [r3, #0]
    b706:	687a      	ldr	r2, [r7, #4]
    b708:	18d3      	adds	r3, r2, r3
    b70a:	220c      	movs	r2, #12
    b70c:	18b9      	adds	r1, r7, r2
    b70e:	2204      	movs	r2, #4
    b710:	0018      	movs	r0, r3
    b712:	4b23      	ldr	r3, [pc, #140]	; (b7a0 <atcab_read_serial_number+0x17c>)
    b714:	4798      	blx	r3
		cpyIndex += ATCA_WORD_SIZE;
    b716:	232d      	movs	r3, #45	; 0x2d
    b718:	18fb      	adds	r3, r7, r3
    b71a:	222d      	movs	r2, #45	; 0x2d
    b71c:	18ba      	adds	r2, r7, r2
    b71e:	7812      	ldrb	r2, [r2, #0]
    b720:	3204      	adds	r2, #4
    b722:	701a      	strb	r2, [r3, #0]

		block = 0;
    b724:	232e      	movs	r3, #46	; 0x2e
    b726:	18fb      	adds	r3, r7, r3
    b728:	2200      	movs	r2, #0
    b72a:	701a      	strb	r2, [r3, #0]
		offset = 3;
    b72c:	232c      	movs	r3, #44	; 0x2c
    b72e:	18fb      	adds	r3, r7, r3
    b730:	2203      	movs	r2, #3
    b732:	701a      	strb	r2, [r3, #0]
		if ( (status = atcab_read_zone(ATCA_ZONE_CONFIG, 0, block, offset, bytes_read, ATCA_WORD_SIZE)) != ATCA_SUCCESS )
    b734:	232f      	movs	r3, #47	; 0x2f
    b736:	18fc      	adds	r4, r7, r3
    b738:	232c      	movs	r3, #44	; 0x2c
    b73a:	18fb      	adds	r3, r7, r3
    b73c:	7819      	ldrb	r1, [r3, #0]
    b73e:	232e      	movs	r3, #46	; 0x2e
    b740:	18fb      	adds	r3, r7, r3
    b742:	781a      	ldrb	r2, [r3, #0]
    b744:	2304      	movs	r3, #4
    b746:	9301      	str	r3, [sp, #4]
    b748:	230c      	movs	r3, #12
    b74a:	18fb      	adds	r3, r7, r3
    b74c:	9300      	str	r3, [sp, #0]
    b74e:	000b      	movs	r3, r1
    b750:	2100      	movs	r1, #0
    b752:	2000      	movs	r0, #0
    b754:	4d11      	ldr	r5, [pc, #68]	; (b79c <atcab_read_serial_number+0x178>)
    b756:	47a8      	blx	r5
    b758:	0003      	movs	r3, r0
    b75a:	7023      	strb	r3, [r4, #0]
    b75c:	232f      	movs	r3, #47	; 0x2f
    b75e:	18fb      	adds	r3, r7, r3
    b760:	781b      	ldrb	r3, [r3, #0]
    b762:	2b00      	cmp	r3, #0
    b764:	d10d      	bne.n	b782 <atcab_read_serial_number+0x15e>
			break;

		memcpy(&serial_number[cpyIndex], bytes_read, 1);
    b766:	232d      	movs	r3, #45	; 0x2d
    b768:	18fb      	adds	r3, r7, r3
    b76a:	781b      	ldrb	r3, [r3, #0]
    b76c:	687a      	ldr	r2, [r7, #4]
    b76e:	18d3      	adds	r3, r2, r3
    b770:	220c      	movs	r2, #12
    b772:	18ba      	adds	r2, r7, r2
    b774:	7812      	ldrb	r2, [r2, #0]
    b776:	701a      	strb	r2, [r3, #0]
    b778:	e004      	b.n	b784 <atcab_read_serial_number+0x160>
		memset(serial_number, 0x00, ATCA_SERIAL_NUM_SIZE);
		// Read first 32 byte block.  Copy the bytes into the config_data buffer
		block = 0;
		offset = 0;
		if ( (status = atcab_read_zone(ATCA_ZONE_CONFIG, 0, block, offset, bytes_read, ATCA_WORD_SIZE)) != ATCA_SUCCESS )
			break;
    b77a:	46c0      	nop			; (mov r8, r8)
    b77c:	e002      	b.n	b784 <atcab_read_serial_number+0x160>
		cpyIndex += ATCA_WORD_SIZE;

		block = 0;
		offset = 2;
		if ( (status = atcab_read_zone(ATCA_ZONE_CONFIG, 0, block, offset, bytes_read, ATCA_WORD_SIZE)) != ATCA_SUCCESS )
			break;
    b77e:	46c0      	nop			; (mov r8, r8)
    b780:	e000      	b.n	b784 <atcab_read_serial_number+0x160>
		cpyIndex += ATCA_WORD_SIZE;

		block = 0;
		offset = 3;
		if ( (status = atcab_read_zone(ATCA_ZONE_CONFIG, 0, block, offset, bytes_read, ATCA_WORD_SIZE)) != ATCA_SUCCESS )
			break;
    b782:	46c0      	nop			; (mov r8, r8)

		memcpy(&serial_number[cpyIndex], bytes_read, 1);

	} while (0);

	_atcab_exit();
    b784:	4b07      	ldr	r3, [pc, #28]	; (b7a4 <atcab_read_serial_number+0x180>)
    b786:	4798      	blx	r3
	return status;
    b788:	232f      	movs	r3, #47	; 0x2f
    b78a:	18fb      	adds	r3, r7, r3
    b78c:	781b      	ldrb	r3, [r3, #0]
}
    b78e:	0018      	movs	r0, r3
    b790:	46bd      	mov	sp, r7
    b792:	b00c      	add	sp, #48	; 0x30
    b794:	bdb0      	pop	{r4, r5, r7, pc}
    b796:	46c0      	nop			; (mov r8, r8)
    b798:	00012823 	.word	0x00012823
    b79c:	0000bd1d 	.word	0x0000bd1d
    b7a0:	000127e7 	.word	0x000127e7
    b7a4:	0000ae2d 	.word	0x0000ae2d

0000b7a8 <atcab_verify_extern>:
 *  \param[in]  pubkey     pointer
 *  \param[out] verified   boolean whether or not the challenge/signature/pubkey verified
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_verify_extern(const uint8_t *message, const uint8_t *signature, const uint8_t *pubkey, bool *verified)
{
    b7a8:	b590      	push	{r4, r7, lr}
    b7aa:	b0a9      	sub	sp, #164	; 0xa4
    b7ac:	af00      	add	r7, sp, #0
    b7ae:	60f8      	str	r0, [r7, #12]
    b7b0:	60b9      	str	r1, [r7, #8]
    b7b2:	607a      	str	r2, [r7, #4]
    b7b4:	603b      	str	r3, [r7, #0]
	ATCA_STATUS status;
	ATCAPacket packet;
	uint16_t execution_time = 0;
    b7b6:	239c      	movs	r3, #156	; 0x9c
    b7b8:	18fb      	adds	r3, r7, r3
    b7ba:	2200      	movs	r2, #0
    b7bc:	801a      	strh	r2, [r3, #0]

	do {
		*verified = false;
    b7be:	683b      	ldr	r3, [r7, #0]
    b7c0:	2200      	movs	r2, #0
    b7c2:	701a      	strb	r2, [r3, #0]

		// nonce passthrough
		if ( (status = atcab_challenge(message)) != ATCA_SUCCESS )
    b7c4:	239f      	movs	r3, #159	; 0x9f
    b7c6:	18fc      	adds	r4, r7, r3
    b7c8:	68fb      	ldr	r3, [r7, #12]
    b7ca:	0018      	movs	r0, r3
    b7cc:	4b5d      	ldr	r3, [pc, #372]	; (b944 <atcab_verify_extern+0x19c>)
    b7ce:	4798      	blx	r3
    b7d0:	0003      	movs	r3, r0
    b7d2:	7023      	strb	r3, [r4, #0]
    b7d4:	239f      	movs	r3, #159	; 0x9f
    b7d6:	18fb      	adds	r3, r7, r3
    b7d8:	781b      	ldrb	r3, [r3, #0]
    b7da:	2b00      	cmp	r3, #0
    b7dc:	d000      	beq.n	b7e0 <atcab_verify_extern+0x38>
    b7de:	e09f      	b.n	b920 <atcab_verify_extern+0x178>
			break;

		// build a verify command
		packet.param1 = VERIFY_MODE_EXTERNAL; //verify the signature
    b7e0:	2310      	movs	r3, #16
    b7e2:	18fb      	adds	r3, r7, r3
    b7e4:	2202      	movs	r2, #2
    b7e6:	70da      	strb	r2, [r3, #3]
		packet.param2 = VERIFY_KEY_P256;
    b7e8:	2310      	movs	r3, #16
    b7ea:	18fb      	adds	r3, r7, r3
    b7ec:	2204      	movs	r2, #4
    b7ee:	809a      	strh	r2, [r3, #4]
		memcpy( &packet.data[0], signature, ATCA_SIG_SIZE);
    b7f0:	68b9      	ldr	r1, [r7, #8]
    b7f2:	2310      	movs	r3, #16
    b7f4:	18fb      	adds	r3, r7, r3
    b7f6:	3306      	adds	r3, #6
    b7f8:	2240      	movs	r2, #64	; 0x40
    b7fa:	0018      	movs	r0, r3
    b7fc:	4b52      	ldr	r3, [pc, #328]	; (b948 <atcab_verify_extern+0x1a0>)
    b7fe:	4798      	blx	r3
		memcpy( &packet.data[64], pubkey, ATCA_PUB_KEY_SIZE);
    b800:	6879      	ldr	r1, [r7, #4]
    b802:	2310      	movs	r3, #16
    b804:	18fb      	adds	r3, r7, r3
    b806:	3346      	adds	r3, #70	; 0x46
    b808:	2240      	movs	r2, #64	; 0x40
    b80a:	0018      	movs	r0, r3
    b80c:	4b4e      	ldr	r3, [pc, #312]	; (b948 <atcab_verify_extern+0x1a0>)
    b80e:	4798      	blx	r3

		if ( (status = atVerify( _gCommandObj, &packet )) != ATCA_SUCCESS )
    b810:	4b4e      	ldr	r3, [pc, #312]	; (b94c <atcab_verify_extern+0x1a4>)
    b812:	681b      	ldr	r3, [r3, #0]
    b814:	229f      	movs	r2, #159	; 0x9f
    b816:	18bc      	adds	r4, r7, r2
    b818:	2210      	movs	r2, #16
    b81a:	18ba      	adds	r2, r7, r2
    b81c:	0011      	movs	r1, r2
    b81e:	0018      	movs	r0, r3
    b820:	4b4b      	ldr	r3, [pc, #300]	; (b950 <atcab_verify_extern+0x1a8>)
    b822:	4798      	blx	r3
    b824:	0003      	movs	r3, r0
    b826:	7023      	strb	r3, [r4, #0]
    b828:	239f      	movs	r3, #159	; 0x9f
    b82a:	18fb      	adds	r3, r7, r3
    b82c:	781b      	ldrb	r3, [r3, #0]
    b82e:	2b00      	cmp	r3, #0
    b830:	d000      	beq.n	b834 <atcab_verify_extern+0x8c>
    b832:	e077      	b.n	b924 <atcab_verify_extern+0x17c>
			break;

		execution_time = atGetExecTime( _gCommandObj, CMD_VERIFY );
    b834:	4b45      	ldr	r3, [pc, #276]	; (b94c <atcab_verify_extern+0x1a4>)
    b836:	681b      	ldr	r3, [r3, #0]
    b838:	229c      	movs	r2, #156	; 0x9c
    b83a:	18bc      	adds	r4, r7, r2
    b83c:	2113      	movs	r1, #19
    b83e:	0018      	movs	r0, r3
    b840:	4b44      	ldr	r3, [pc, #272]	; (b954 <atcab_verify_extern+0x1ac>)
    b842:	4798      	blx	r3
    b844:	0003      	movs	r3, r0
    b846:	8023      	strh	r3, [r4, #0]

		if ( (status = atcab_wakeup()) != ATCA_SUCCESS )
    b848:	239f      	movs	r3, #159	; 0x9f
    b84a:	18fc      	adds	r4, r7, r3
    b84c:	4b42      	ldr	r3, [pc, #264]	; (b958 <atcab_verify_extern+0x1b0>)
    b84e:	4798      	blx	r3
    b850:	0003      	movs	r3, r0
    b852:	7023      	strb	r3, [r4, #0]
    b854:	239f      	movs	r3, #159	; 0x9f
    b856:	18fb      	adds	r3, r7, r3
    b858:	781b      	ldrb	r3, [r3, #0]
    b85a:	2b00      	cmp	r3, #0
    b85c:	d164      	bne.n	b928 <atcab_verify_extern+0x180>
			break;

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
    b85e:	4b3f      	ldr	r3, [pc, #252]	; (b95c <atcab_verify_extern+0x1b4>)
    b860:	6818      	ldr	r0, [r3, #0]
    b862:	2310      	movs	r3, #16
    b864:	18fb      	adds	r3, r7, r3
    b866:	785b      	ldrb	r3, [r3, #1]
    b868:	001a      	movs	r2, r3
    b86a:	239f      	movs	r3, #159	; 0x9f
    b86c:	18fc      	adds	r4, r7, r3
    b86e:	2310      	movs	r3, #16
    b870:	18fb      	adds	r3, r7, r3
    b872:	0019      	movs	r1, r3
    b874:	4b3a      	ldr	r3, [pc, #232]	; (b960 <atcab_verify_extern+0x1b8>)
    b876:	4798      	blx	r3
    b878:	0003      	movs	r3, r0
    b87a:	7023      	strb	r3, [r4, #0]
    b87c:	239f      	movs	r3, #159	; 0x9f
    b87e:	18fb      	adds	r3, r7, r3
    b880:	781b      	ldrb	r3, [r3, #0]
    b882:	2b00      	cmp	r3, #0
    b884:	d152      	bne.n	b92c <atcab_verify_extern+0x184>
			break;

		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);
    b886:	239c      	movs	r3, #156	; 0x9c
    b888:	18fb      	adds	r3, r7, r3
    b88a:	881b      	ldrh	r3, [r3, #0]
    b88c:	0018      	movs	r0, r3
    b88e:	4b35      	ldr	r3, [pc, #212]	; (b964 <atcab_verify_extern+0x1bc>)
    b890:	4798      	blx	r3

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &(packet.rxsize) )) != ATCA_SUCCESS )
    b892:	4b32      	ldr	r3, [pc, #200]	; (b95c <atcab_verify_extern+0x1b4>)
    b894:	6818      	ldr	r0, [r3, #0]
    b896:	239f      	movs	r3, #159	; 0x9f
    b898:	18fc      	adds	r4, r7, r3
    b89a:	2310      	movs	r3, #16
    b89c:	18fb      	adds	r3, r7, r3
    b89e:	338a      	adds	r3, #138	; 0x8a
    b8a0:	001a      	movs	r2, r3
    b8a2:	2310      	movs	r3, #16
    b8a4:	18fb      	adds	r3, r7, r3
    b8a6:	3306      	adds	r3, #6
    b8a8:	0019      	movs	r1, r3
    b8aa:	4b2f      	ldr	r3, [pc, #188]	; (b968 <atcab_verify_extern+0x1c0>)
    b8ac:	4798      	blx	r3
    b8ae:	0003      	movs	r3, r0
    b8b0:	7023      	strb	r3, [r4, #0]
    b8b2:	239f      	movs	r3, #159	; 0x9f
    b8b4:	18fb      	adds	r3, r7, r3
    b8b6:	781b      	ldrb	r3, [r3, #0]
    b8b8:	2b00      	cmp	r3, #0
    b8ba:	d139      	bne.n	b930 <atcab_verify_extern+0x188>
			break;

		// Check response size
		if (packet.rxsize < 4) {
    b8bc:	2310      	movs	r3, #16
    b8be:	18fb      	adds	r3, r7, r3
    b8c0:	228a      	movs	r2, #138	; 0x8a
    b8c2:	5a9b      	ldrh	r3, [r3, r2]
    b8c4:	2b03      	cmp	r3, #3
    b8c6:	d80f      	bhi.n	b8e8 <atcab_verify_extern+0x140>
			if (packet.rxsize > 0)
    b8c8:	2310      	movs	r3, #16
    b8ca:	18fb      	adds	r3, r7, r3
    b8cc:	228a      	movs	r2, #138	; 0x8a
    b8ce:	5a9b      	ldrh	r3, [r3, r2]
    b8d0:	2b00      	cmp	r3, #0
    b8d2:	d004      	beq.n	b8de <atcab_verify_extern+0x136>
				status = ATCA_RX_FAIL;
    b8d4:	239f      	movs	r3, #159	; 0x9f
    b8d6:	18fb      	adds	r3, r7, r3
    b8d8:	22e6      	movs	r2, #230	; 0xe6
    b8da:	701a      	strb	r2, [r3, #0]
			else
				status = ATCA_RX_NO_RESPONSE;
			break;
    b8dc:	e029      	b.n	b932 <atcab_verify_extern+0x18a>
		// Check response size
		if (packet.rxsize < 4) {
			if (packet.rxsize > 0)
				status = ATCA_RX_FAIL;
			else
				status = ATCA_RX_NO_RESPONSE;
    b8de:	239f      	movs	r3, #159	; 0x9f
    b8e0:	18fb      	adds	r3, r7, r3
    b8e2:	22e7      	movs	r2, #231	; 0xe7
    b8e4:	701a      	strb	r2, [r3, #0]
			break;
    b8e6:	e024      	b.n	b932 <atcab_verify_extern+0x18a>
		}

		status = isATCAError(packet.data);
    b8e8:	239f      	movs	r3, #159	; 0x9f
    b8ea:	18fc      	adds	r4, r7, r3
    b8ec:	2310      	movs	r3, #16
    b8ee:	18fb      	adds	r3, r7, r3
    b8f0:	3306      	adds	r3, #6
    b8f2:	0018      	movs	r0, r3
    b8f4:	4b1d      	ldr	r3, [pc, #116]	; (b96c <atcab_verify_extern+0x1c4>)
    b8f6:	4798      	blx	r3
    b8f8:	0003      	movs	r3, r0
    b8fa:	7023      	strb	r3, [r4, #0]
		*verified = (status == 0);
    b8fc:	239f      	movs	r3, #159	; 0x9f
    b8fe:	18fb      	adds	r3, r7, r3
    b900:	781b      	ldrb	r3, [r3, #0]
    b902:	425a      	negs	r2, r3
    b904:	4153      	adcs	r3, r2
    b906:	b2da      	uxtb	r2, r3
    b908:	683b      	ldr	r3, [r7, #0]
    b90a:	701a      	strb	r2, [r3, #0]
		if (status == ATCA_CHECKMAC_VERIFY_FAILED)
    b90c:	239f      	movs	r3, #159	; 0x9f
    b90e:	18fb      	adds	r3, r7, r3
    b910:	781b      	ldrb	r3, [r3, #0]
    b912:	2bd1      	cmp	r3, #209	; 0xd1
    b914:	d10d      	bne.n	b932 <atcab_verify_extern+0x18a>
			status = ATCA_SUCCESS; // Verify failed, but command succeeded
    b916:	239f      	movs	r3, #159	; 0x9f
    b918:	18fb      	adds	r3, r7, r3
    b91a:	2200      	movs	r2, #0
    b91c:	701a      	strb	r2, [r3, #0]
    b91e:	e008      	b.n	b932 <atcab_verify_extern+0x18a>
	do {
		*verified = false;

		// nonce passthrough
		if ( (status = atcab_challenge(message)) != ATCA_SUCCESS )
			break;
    b920:	46c0      	nop			; (mov r8, r8)
    b922:	e006      	b.n	b932 <atcab_verify_extern+0x18a>
		packet.param2 = VERIFY_KEY_P256;
		memcpy( &packet.data[0], signature, ATCA_SIG_SIZE);
		memcpy( &packet.data[64], pubkey, ATCA_PUB_KEY_SIZE);

		if ( (status = atVerify( _gCommandObj, &packet )) != ATCA_SUCCESS )
			break;
    b924:	46c0      	nop			; (mov r8, r8)
    b926:	e004      	b.n	b932 <atcab_verify_extern+0x18a>

		execution_time = atGetExecTime( _gCommandObj, CMD_VERIFY );

		if ( (status = atcab_wakeup()) != ATCA_SUCCESS )
			break;
    b928:	46c0      	nop			; (mov r8, r8)
    b92a:	e002      	b.n	b932 <atcab_verify_extern+0x18a>

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
			break;
    b92c:	46c0      	nop			; (mov r8, r8)
    b92e:	e000      	b.n	b932 <atcab_verify_extern+0x18a>
		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &(packet.rxsize) )) != ATCA_SUCCESS )
			break;
    b930:	46c0      	nop			; (mov r8, r8)
		*verified = (status == 0);
		if (status == ATCA_CHECKMAC_VERIFY_FAILED)
			status = ATCA_SUCCESS; // Verify failed, but command succeeded
	} while (0);

	_atcab_exit();
    b932:	4b0f      	ldr	r3, [pc, #60]	; (b970 <atcab_verify_extern+0x1c8>)
    b934:	4798      	blx	r3
	return status;
    b936:	239f      	movs	r3, #159	; 0x9f
    b938:	18fb      	adds	r3, r7, r3
    b93a:	781b      	ldrb	r3, [r3, #0]
}
    b93c:	0018      	movs	r0, r3
    b93e:	46bd      	mov	sp, r7
    b940:	b029      	add	sp, #164	; 0xa4
    b942:	bd90      	pop	{r4, r7, pc}
    b944:	0000b2fd 	.word	0x0000b2fd
    b948:	000127e7 	.word	0x000127e7
    b94c:	200007e4 	.word	0x200007e4
    b950:	0000a679 	.word	0x0000a679
    b954:	0000a7f5 	.word	0x0000a7f5
    b958:	0000ad9d 	.word	0x0000ad9d
    b95c:	200007e8 	.word	0x200007e8
    b960:	0000ab85 	.word	0x0000ab85
    b964:	0000e3d5 	.word	0x0000e3d5
    b968:	0000aba9 	.word	0x0000aba9
    b96c:	0000a955 	.word	0x0000a955
    b970:	0000ae2d 	.word	0x0000ae2d

0000b974 <atcab_get_addr>:
 *  \param[in] offset
 *  \param[in] addr
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_get_addr(uint8_t zone, uint8_t slot, uint8_t block, uint8_t offset, uint16_t* addr)
{
    b974:	b5b0      	push	{r4, r5, r7, lr}
    b976:	b084      	sub	sp, #16
    b978:	af00      	add	r7, sp, #0
    b97a:	0005      	movs	r5, r0
    b97c:	000c      	movs	r4, r1
    b97e:	0010      	movs	r0, r2
    b980:	0019      	movs	r1, r3
    b982:	1dfb      	adds	r3, r7, #7
    b984:	1c2a      	adds	r2, r5, #0
    b986:	701a      	strb	r2, [r3, #0]
    b988:	1dbb      	adds	r3, r7, #6
    b98a:	1c22      	adds	r2, r4, #0
    b98c:	701a      	strb	r2, [r3, #0]
    b98e:	1d7b      	adds	r3, r7, #5
    b990:	1c02      	adds	r2, r0, #0
    b992:	701a      	strb	r2, [r3, #0]
    b994:	1d3b      	adds	r3, r7, #4
    b996:	1c0a      	adds	r2, r1, #0
    b998:	701a      	strb	r2, [r3, #0]
	ATCA_STATUS status = ATCA_SUCCESS;
    b99a:	230f      	movs	r3, #15
    b99c:	18fb      	adds	r3, r7, r3
    b99e:	2200      	movs	r2, #0
    b9a0:	701a      	strb	r2, [r3, #0]
	uint8_t memzone = zone & 0x03;
    b9a2:	230e      	movs	r3, #14
    b9a4:	18fb      	adds	r3, r7, r3
    b9a6:	1dfa      	adds	r2, r7, #7
    b9a8:	7812      	ldrb	r2, [r2, #0]
    b9aa:	2103      	movs	r1, #3
    b9ac:	400a      	ands	r2, r1
    b9ae:	701a      	strb	r2, [r3, #0]

	if (addr == NULL)
    b9b0:	6a3b      	ldr	r3, [r7, #32]
    b9b2:	2b00      	cmp	r3, #0
    b9b4:	d101      	bne.n	b9ba <atcab_get_addr+0x46>
		return ATCA_BAD_PARAM;
    b9b6:	23e2      	movs	r3, #226	; 0xe2
    b9b8:	e053      	b.n	ba62 <atcab_get_addr+0xee>
	if ((memzone != ATCA_ZONE_CONFIG) && (memzone != ATCA_ZONE_DATA) && (memzone != ATCA_ZONE_OTP))
    b9ba:	230e      	movs	r3, #14
    b9bc:	18fb      	adds	r3, r7, r3
    b9be:	781b      	ldrb	r3, [r3, #0]
    b9c0:	2b00      	cmp	r3, #0
    b9c2:	d00b      	beq.n	b9dc <atcab_get_addr+0x68>
    b9c4:	230e      	movs	r3, #14
    b9c6:	18fb      	adds	r3, r7, r3
    b9c8:	781b      	ldrb	r3, [r3, #0]
    b9ca:	2b02      	cmp	r3, #2
    b9cc:	d006      	beq.n	b9dc <atcab_get_addr+0x68>
    b9ce:	230e      	movs	r3, #14
    b9d0:	18fb      	adds	r3, r7, r3
    b9d2:	781b      	ldrb	r3, [r3, #0]
    b9d4:	2b01      	cmp	r3, #1
    b9d6:	d001      	beq.n	b9dc <atcab_get_addr+0x68>
		return ATCA_BAD_PARAM;
    b9d8:	23e2      	movs	r3, #226	; 0xe2
    b9da:	e042      	b.n	ba62 <atcab_get_addr+0xee>
	do {
		// Initialize the addr to 00
		*addr = 0;
    b9dc:	6a3b      	ldr	r3, [r7, #32]
    b9de:	2200      	movs	r2, #0
    b9e0:	801a      	strh	r2, [r3, #0]
		// Mask the offset
		offset = offset & (uint8_t)0x07;
    b9e2:	1d3b      	adds	r3, r7, #4
    b9e4:	1d3a      	adds	r2, r7, #4
    b9e6:	7812      	ldrb	r2, [r2, #0]
    b9e8:	2107      	movs	r1, #7
    b9ea:	400a      	ands	r2, r1
    b9ec:	701a      	strb	r2, [r3, #0]
		if ((memzone == ATCA_ZONE_CONFIG) || (memzone == ATCA_ZONE_OTP)) {
    b9ee:	230e      	movs	r3, #14
    b9f0:	18fb      	adds	r3, r7, r3
    b9f2:	781b      	ldrb	r3, [r3, #0]
    b9f4:	2b00      	cmp	r3, #0
    b9f6:	d004      	beq.n	ba02 <atcab_get_addr+0x8e>
    b9f8:	230e      	movs	r3, #14
    b9fa:	18fb      	adds	r3, r7, r3
    b9fc:	781b      	ldrb	r3, [r3, #0]
    b9fe:	2b01      	cmp	r3, #1
    ba00:	d110      	bne.n	ba24 <atcab_get_addr+0xb0>
			*addr = block << 3;
    ba02:	1d7b      	adds	r3, r7, #5
    ba04:	781b      	ldrb	r3, [r3, #0]
    ba06:	b29b      	uxth	r3, r3
    ba08:	00db      	lsls	r3, r3, #3
    ba0a:	b29a      	uxth	r2, r3
    ba0c:	6a3b      	ldr	r3, [r7, #32]
    ba0e:	801a      	strh	r2, [r3, #0]
			*addr |= offset;
    ba10:	6a3b      	ldr	r3, [r7, #32]
    ba12:	881a      	ldrh	r2, [r3, #0]
    ba14:	1d3b      	adds	r3, r7, #4
    ba16:	781b      	ldrb	r3, [r3, #0]
    ba18:	b29b      	uxth	r3, r3
    ba1a:	4313      	orrs	r3, r2
    ba1c:	b29a      	uxth	r2, r3
    ba1e:	6a3b      	ldr	r3, [r7, #32]
    ba20:	801a      	strh	r2, [r3, #0]
    ba22:	e01b      	b.n	ba5c <atcab_get_addr+0xe8>
		}else {  // ATCA_ZONE_DATA
			*addr = slot << 3;
    ba24:	1dbb      	adds	r3, r7, #6
    ba26:	781b      	ldrb	r3, [r3, #0]
    ba28:	b29b      	uxth	r3, r3
    ba2a:	00db      	lsls	r3, r3, #3
    ba2c:	b29a      	uxth	r2, r3
    ba2e:	6a3b      	ldr	r3, [r7, #32]
    ba30:	801a      	strh	r2, [r3, #0]
			*addr  |= offset;
    ba32:	6a3b      	ldr	r3, [r7, #32]
    ba34:	881a      	ldrh	r2, [r3, #0]
    ba36:	1d3b      	adds	r3, r7, #4
    ba38:	781b      	ldrb	r3, [r3, #0]
    ba3a:	b29b      	uxth	r3, r3
    ba3c:	4313      	orrs	r3, r2
    ba3e:	b29a      	uxth	r2, r3
    ba40:	6a3b      	ldr	r3, [r7, #32]
    ba42:	801a      	strh	r2, [r3, #0]
			*addr |= block << 8;
    ba44:	6a3b      	ldr	r3, [r7, #32]
    ba46:	881b      	ldrh	r3, [r3, #0]
    ba48:	b21a      	sxth	r2, r3
    ba4a:	1d7b      	adds	r3, r7, #5
    ba4c:	781b      	ldrb	r3, [r3, #0]
    ba4e:	021b      	lsls	r3, r3, #8
    ba50:	b21b      	sxth	r3, r3
    ba52:	4313      	orrs	r3, r2
    ba54:	b21b      	sxth	r3, r3
    ba56:	b29a      	uxth	r2, r3
    ba58:	6a3b      	ldr	r3, [r7, #32]
    ba5a:	801a      	strh	r2, [r3, #0]
		}
	} while (0);

	return status;
    ba5c:	230f      	movs	r3, #15
    ba5e:	18fb      	adds	r3, r7, r3
    ba60:	781b      	ldrb	r3, [r3, #0]
}
    ba62:	0018      	movs	r0, r3
    ba64:	46bd      	mov	sp, r7
    ba66:	b004      	add	sp, #16
    ba68:	bdb0      	pop	{r4, r5, r7, pc}
    ba6a:	46c0      	nop			; (mov r8, r8)

0000ba6c <atcab_is_locked>:
 *  \param[in]  zone      The zone to query for locked (use LOCK_ZONE_CONFIG or LOCK_ZONE_DATA)
 *  \param[out] islocked  true if the specified zone is locked
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_is_locked(uint8_t zone, bool *islocked)
{
    ba6c:	b5b0      	push	{r4, r5, r7, lr}
    ba6e:	b086      	sub	sp, #24
    ba70:	af02      	add	r7, sp, #8
    ba72:	0002      	movs	r2, r0
    ba74:	6039      	str	r1, [r7, #0]
    ba76:	1dfb      	adds	r3, r7, #7
    ba78:	701a      	strb	r2, [r3, #0]
	uint8_t ret = ATCA_GEN_FAIL;
    ba7a:	230e      	movs	r3, #14
    ba7c:	18fb      	adds	r3, r7, r3
    ba7e:	22e1      	movs	r2, #225	; 0xe1
    ba80:	701a      	strb	r2, [r3, #0]
	uint8_t word_data[ATCA_WORD_SIZE];
	uint8_t zone_idx = 2;
    ba82:	230f      	movs	r3, #15
    ba84:	18fb      	adds	r3, r7, r3
    ba86:	2202      	movs	r2, #2
    ba88:	701a      	strb	r2, [r3, #0]

	do {
		// Read the word with the lock bytes (UserExtra, Selector, LockValue, LockConfig) (config block = 2, word offset = 5)
		if ( (ret = atcab_read_zone(ATCA_ZONE_CONFIG, 0, 2 /*block*/, 5 /*offset*/, word_data, ATCA_WORD_SIZE)) != ATCA_SUCCESS )
    ba8a:	230e      	movs	r3, #14
    ba8c:	18fc      	adds	r4, r7, r3
    ba8e:	2304      	movs	r3, #4
    ba90:	9301      	str	r3, [sp, #4]
    ba92:	2308      	movs	r3, #8
    ba94:	18fb      	adds	r3, r7, r3
    ba96:	9300      	str	r3, [sp, #0]
    ba98:	2305      	movs	r3, #5
    ba9a:	2202      	movs	r2, #2
    ba9c:	2100      	movs	r1, #0
    ba9e:	2000      	movs	r0, #0
    baa0:	4d18      	ldr	r5, [pc, #96]	; (bb04 <atcab_is_locked+0x98>)
    baa2:	47a8      	blx	r5
    baa4:	0003      	movs	r3, r0
    baa6:	7023      	strb	r3, [r4, #0]
    baa8:	230e      	movs	r3, #14
    baaa:	18fb      	adds	r3, r7, r3
    baac:	781b      	ldrb	r3, [r3, #0]
    baae:	2b00      	cmp	r3, #0
    bab0:	d11f      	bne.n	baf2 <atcab_is_locked+0x86>
			break;

		// Determine the index into the word_data based on the zone we are querying for
		if (zone == LOCK_ZONE_DATA) zone_idx = 2;
    bab2:	1dfb      	adds	r3, r7, #7
    bab4:	781b      	ldrb	r3, [r3, #0]
    bab6:	2b01      	cmp	r3, #1
    bab8:	d103      	bne.n	bac2 <atcab_is_locked+0x56>
    baba:	230f      	movs	r3, #15
    babc:	18fb      	adds	r3, r7, r3
    babe:	2202      	movs	r2, #2
    bac0:	701a      	strb	r2, [r3, #0]
		if (zone == LOCK_ZONE_CONFIG) zone_idx = 3;
    bac2:	1dfb      	adds	r3, r7, #7
    bac4:	781b      	ldrb	r3, [r3, #0]
    bac6:	2b00      	cmp	r3, #0
    bac8:	d103      	bne.n	bad2 <atcab_is_locked+0x66>
    baca:	230f      	movs	r3, #15
    bacc:	18fb      	adds	r3, r7, r3
    bace:	2203      	movs	r2, #3
    bad0:	701a      	strb	r2, [r3, #0]

		// Set the locked return variable base on the value.
		if (word_data[zone_idx] == 0)
    bad2:	230f      	movs	r3, #15
    bad4:	18fb      	adds	r3, r7, r3
    bad6:	781b      	ldrb	r3, [r3, #0]
    bad8:	2208      	movs	r2, #8
    bada:	18ba      	adds	r2, r7, r2
    badc:	5cd3      	ldrb	r3, [r2, r3]
    bade:	2b00      	cmp	r3, #0
    bae0:	d103      	bne.n	baea <atcab_is_locked+0x7e>
			*islocked = true;
    bae2:	683b      	ldr	r3, [r7, #0]
    bae4:	2201      	movs	r2, #1
    bae6:	701a      	strb	r2, [r3, #0]
    bae8:	e004      	b.n	baf4 <atcab_is_locked+0x88>
		else
			*islocked = false;
    baea:	683b      	ldr	r3, [r7, #0]
    baec:	2200      	movs	r2, #0
    baee:	701a      	strb	r2, [r3, #0]
    baf0:	e000      	b.n	baf4 <atcab_is_locked+0x88>
	uint8_t zone_idx = 2;

	do {
		// Read the word with the lock bytes (UserExtra, Selector, LockValue, LockConfig) (config block = 2, word offset = 5)
		if ( (ret = atcab_read_zone(ATCA_ZONE_CONFIG, 0, 2 /*block*/, 5 /*offset*/, word_data, ATCA_WORD_SIZE)) != ATCA_SUCCESS )
			break;
    baf2:	46c0      	nop			; (mov r8, r8)
		else
			*islocked = false;

	} while (0);

	return ret;
    baf4:	230e      	movs	r3, #14
    baf6:	18fb      	adds	r3, r7, r3
    baf8:	781b      	ldrb	r3, [r3, #0]
}
    bafa:	0018      	movs	r0, r3
    bafc:	46bd      	mov	sp, r7
    bafe:	b004      	add	sp, #16
    bb00:	bdb0      	pop	{r4, r5, r7, pc}
    bb02:	46c0      	nop			; (mov r8, r8)
    bb04:	0000bd1d 	.word	0x0000bd1d

0000bb08 <atcab_write_zone>:
 *  \param[in] data    Data to be written.
 *  \param[in] len     Number of bytes to be written. Must be either 4 or 32.
 *  \return ATCA_SUCCESS on success
 */
ATCA_STATUS atcab_write_zone(uint8_t zone, uint8_t slot, uint8_t block, uint8_t offset, const uint8_t *data, uint8_t len)
{
    bb08:	b5b0      	push	{r4, r5, r7, lr}
    bb0a:	b0aa      	sub	sp, #168	; 0xa8
    bb0c:	af02      	add	r7, sp, #8
    bb0e:	0005      	movs	r5, r0
    bb10:	000c      	movs	r4, r1
    bb12:	0010      	movs	r0, r2
    bb14:	0019      	movs	r1, r3
    bb16:	1dfb      	adds	r3, r7, #7
    bb18:	1c2a      	adds	r2, r5, #0
    bb1a:	701a      	strb	r2, [r3, #0]
    bb1c:	1dbb      	adds	r3, r7, #6
    bb1e:	1c22      	adds	r2, r4, #0
    bb20:	701a      	strb	r2, [r3, #0]
    bb22:	1d7b      	adds	r3, r7, #5
    bb24:	1c02      	adds	r2, r0, #0
    bb26:	701a      	strb	r2, [r3, #0]
    bb28:	1d3b      	adds	r3, r7, #4
    bb2a:	1c0a      	adds	r2, r1, #0
    bb2c:	701a      	strb	r2, [r3, #0]
	ATCA_STATUS status = ATCA_GEN_FAIL;
    bb2e:	239f      	movs	r3, #159	; 0x9f
    bb30:	18fb      	adds	r3, r7, r3
    bb32:	22e1      	movs	r2, #225	; 0xe1
    bb34:	701a      	strb	r2, [r3, #0]
	ATCAPacket packet;
	uint16_t addr;
	uint16_t execution_time = 0;
    bb36:	239c      	movs	r3, #156	; 0x9c
    bb38:	18fb      	adds	r3, r7, r3
    bb3a:	2200      	movs	r2, #0
    bb3c:	801a      	strh	r2, [r3, #0]

	// Check the input parameters
	if (data == NULL)
    bb3e:	23b0      	movs	r3, #176	; 0xb0
    bb40:	18fb      	adds	r3, r7, r3
    bb42:	681b      	ldr	r3, [r3, #0]
    bb44:	2b00      	cmp	r3, #0
    bb46:	d101      	bne.n	bb4c <atcab_write_zone+0x44>
		return ATCA_BAD_PARAM;
    bb48:	23e2      	movs	r3, #226	; 0xe2
    bb4a:	e0ca      	b.n	bce2 <atcab_write_zone+0x1da>

	if ( len != 4 && len != 32 )
    bb4c:	23b4      	movs	r3, #180	; 0xb4
    bb4e:	18fb      	adds	r3, r7, r3
    bb50:	781b      	ldrb	r3, [r3, #0]
    bb52:	2b04      	cmp	r3, #4
    bb54:	d006      	beq.n	bb64 <atcab_write_zone+0x5c>
    bb56:	23b4      	movs	r3, #180	; 0xb4
    bb58:	18fb      	adds	r3, r7, r3
    bb5a:	781b      	ldrb	r3, [r3, #0]
    bb5c:	2b20      	cmp	r3, #32
    bb5e:	d001      	beq.n	bb64 <atcab_write_zone+0x5c>
		return ATCA_BAD_PARAM;
    bb60:	23e2      	movs	r3, #226	; 0xe2
    bb62:	e0be      	b.n	bce2 <atcab_write_zone+0x1da>

	do {
		// The get address function checks the remaining variables
		if ( (status = atcab_get_addr(zone, slot, block, offset, &addr)) != ATCA_SUCCESS )
    bb64:	239f      	movs	r3, #159	; 0x9f
    bb66:	18fc      	adds	r4, r7, r3
    bb68:	1d3b      	adds	r3, r7, #4
    bb6a:	781d      	ldrb	r5, [r3, #0]
    bb6c:	1d7b      	adds	r3, r7, #5
    bb6e:	781a      	ldrb	r2, [r3, #0]
    bb70:	1dbb      	adds	r3, r7, #6
    bb72:	7819      	ldrb	r1, [r3, #0]
    bb74:	1dfb      	adds	r3, r7, #7
    bb76:	7818      	ldrb	r0, [r3, #0]
    bb78:	230e      	movs	r3, #14
    bb7a:	18fb      	adds	r3, r7, r3
    bb7c:	9300      	str	r3, [sp, #0]
    bb7e:	002b      	movs	r3, r5
    bb80:	4d5a      	ldr	r5, [pc, #360]	; (bcec <atcab_write_zone+0x1e4>)
    bb82:	47a8      	blx	r5
    bb84:	0003      	movs	r3, r0
    bb86:	7023      	strb	r3, [r4, #0]
    bb88:	239f      	movs	r3, #159	; 0x9f
    bb8a:	18fb      	adds	r3, r7, r3
    bb8c:	781b      	ldrb	r3, [r3, #0]
    bb8e:	2b00      	cmp	r3, #0
    bb90:	d000      	beq.n	bb94 <atcab_write_zone+0x8c>
    bb92:	e098      	b.n	bcc6 <atcab_write_zone+0x1be>
			break;

		// If there are 32 bytes to write, then xor the bit into the mode
		if (len == ATCA_BLOCK_SIZE)
    bb94:	23b4      	movs	r3, #180	; 0xb4
    bb96:	18fb      	adds	r3, r7, r3
    bb98:	781b      	ldrb	r3, [r3, #0]
    bb9a:	2b20      	cmp	r3, #32
    bb9c:	d106      	bne.n	bbac <atcab_write_zone+0xa4>
			zone = zone | ATCA_ZONE_READWRITE_32;
    bb9e:	1dfb      	adds	r3, r7, #7
    bba0:	1dfa      	adds	r2, r7, #7
    bba2:	7812      	ldrb	r2, [r2, #0]
    bba4:	2180      	movs	r1, #128	; 0x80
    bba6:	4249      	negs	r1, r1
    bba8:	430a      	orrs	r2, r1
    bbaa:	701a      	strb	r2, [r3, #0]

		// build a write command
		packet.param1 = zone;
    bbac:	2310      	movs	r3, #16
    bbae:	18fb      	adds	r3, r7, r3
    bbb0:	1dfa      	adds	r2, r7, #7
    bbb2:	7812      	ldrb	r2, [r2, #0]
    bbb4:	70da      	strb	r2, [r3, #3]
		packet.param2 = addr;
    bbb6:	230e      	movs	r3, #14
    bbb8:	18fb      	adds	r3, r7, r3
    bbba:	881a      	ldrh	r2, [r3, #0]
    bbbc:	2310      	movs	r3, #16
    bbbe:	18fb      	adds	r3, r7, r3
    bbc0:	809a      	strh	r2, [r3, #4]
		memcpy( packet.data, data, len );
    bbc2:	23b4      	movs	r3, #180	; 0xb4
    bbc4:	18fb      	adds	r3, r7, r3
    bbc6:	781a      	ldrb	r2, [r3, #0]
    bbc8:	23b0      	movs	r3, #176	; 0xb0
    bbca:	18fb      	adds	r3, r7, r3
    bbcc:	6819      	ldr	r1, [r3, #0]
    bbce:	2310      	movs	r3, #16
    bbd0:	18fb      	adds	r3, r7, r3
    bbd2:	3306      	adds	r3, #6
    bbd4:	0018      	movs	r0, r3
    bbd6:	4b46      	ldr	r3, [pc, #280]	; (bcf0 <atcab_write_zone+0x1e8>)
    bbd8:	4798      	blx	r3

		if ( (status = atWrite( _gCommandObj, &packet )) != ATCA_SUCCESS )
    bbda:	4b46      	ldr	r3, [pc, #280]	; (bcf4 <atcab_write_zone+0x1ec>)
    bbdc:	681b      	ldr	r3, [r3, #0]
    bbde:	229f      	movs	r2, #159	; 0x9f
    bbe0:	18bc      	adds	r4, r7, r2
    bbe2:	2210      	movs	r2, #16
    bbe4:	18ba      	adds	r2, r7, r2
    bbe6:	0011      	movs	r1, r2
    bbe8:	0018      	movs	r0, r3
    bbea:	4b43      	ldr	r3, [pc, #268]	; (bcf8 <atcab_write_zone+0x1f0>)
    bbec:	4798      	blx	r3
    bbee:	0003      	movs	r3, r0
    bbf0:	7023      	strb	r3, [r4, #0]
    bbf2:	239f      	movs	r3, #159	; 0x9f
    bbf4:	18fb      	adds	r3, r7, r3
    bbf6:	781b      	ldrb	r3, [r3, #0]
    bbf8:	2b00      	cmp	r3, #0
    bbfa:	d166      	bne.n	bcca <atcab_write_zone+0x1c2>
			break;

		execution_time = atGetExecTime( _gCommandObj, CMD_WRITEMEM);
    bbfc:	4b3d      	ldr	r3, [pc, #244]	; (bcf4 <atcab_write_zone+0x1ec>)
    bbfe:	681b      	ldr	r3, [r3, #0]
    bc00:	229c      	movs	r2, #156	; 0x9c
    bc02:	18bc      	adds	r4, r7, r2
    bc04:	2114      	movs	r1, #20
    bc06:	0018      	movs	r0, r3
    bc08:	4b3c      	ldr	r3, [pc, #240]	; (bcfc <atcab_write_zone+0x1f4>)
    bc0a:	4798      	blx	r3
    bc0c:	0003      	movs	r3, r0
    bc0e:	8023      	strh	r3, [r4, #0]

		if ( (status = atcab_wakeup()) != ATCA_SUCCESS )
    bc10:	239f      	movs	r3, #159	; 0x9f
    bc12:	18fc      	adds	r4, r7, r3
    bc14:	4b3a      	ldr	r3, [pc, #232]	; (bd00 <atcab_write_zone+0x1f8>)
    bc16:	4798      	blx	r3
    bc18:	0003      	movs	r3, r0
    bc1a:	7023      	strb	r3, [r4, #0]
    bc1c:	239f      	movs	r3, #159	; 0x9f
    bc1e:	18fb      	adds	r3, r7, r3
    bc20:	781b      	ldrb	r3, [r3, #0]
    bc22:	2b00      	cmp	r3, #0
    bc24:	d153      	bne.n	bcce <atcab_write_zone+0x1c6>
			break;

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
    bc26:	4b37      	ldr	r3, [pc, #220]	; (bd04 <atcab_write_zone+0x1fc>)
    bc28:	6818      	ldr	r0, [r3, #0]
    bc2a:	2310      	movs	r3, #16
    bc2c:	18fb      	adds	r3, r7, r3
    bc2e:	785b      	ldrb	r3, [r3, #1]
    bc30:	001a      	movs	r2, r3
    bc32:	239f      	movs	r3, #159	; 0x9f
    bc34:	18fc      	adds	r4, r7, r3
    bc36:	2310      	movs	r3, #16
    bc38:	18fb      	adds	r3, r7, r3
    bc3a:	0019      	movs	r1, r3
    bc3c:	4b32      	ldr	r3, [pc, #200]	; (bd08 <atcab_write_zone+0x200>)
    bc3e:	4798      	blx	r3
    bc40:	0003      	movs	r3, r0
    bc42:	7023      	strb	r3, [r4, #0]
    bc44:	239f      	movs	r3, #159	; 0x9f
    bc46:	18fb      	adds	r3, r7, r3
    bc48:	781b      	ldrb	r3, [r3, #0]
    bc4a:	2b00      	cmp	r3, #0
    bc4c:	d141      	bne.n	bcd2 <atcab_write_zone+0x1ca>
			break;

		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);
    bc4e:	239c      	movs	r3, #156	; 0x9c
    bc50:	18fb      	adds	r3, r7, r3
    bc52:	881b      	ldrh	r3, [r3, #0]
    bc54:	0018      	movs	r0, r3
    bc56:	4b2d      	ldr	r3, [pc, #180]	; (bd0c <atcab_write_zone+0x204>)
    bc58:	4798      	blx	r3

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &(packet.rxsize) )) != ATCA_SUCCESS )
    bc5a:	4b2a      	ldr	r3, [pc, #168]	; (bd04 <atcab_write_zone+0x1fc>)
    bc5c:	6818      	ldr	r0, [r3, #0]
    bc5e:	239f      	movs	r3, #159	; 0x9f
    bc60:	18fc      	adds	r4, r7, r3
    bc62:	2310      	movs	r3, #16
    bc64:	18fb      	adds	r3, r7, r3
    bc66:	338a      	adds	r3, #138	; 0x8a
    bc68:	001a      	movs	r2, r3
    bc6a:	2310      	movs	r3, #16
    bc6c:	18fb      	adds	r3, r7, r3
    bc6e:	3306      	adds	r3, #6
    bc70:	0019      	movs	r1, r3
    bc72:	4b27      	ldr	r3, [pc, #156]	; (bd10 <atcab_write_zone+0x208>)
    bc74:	4798      	blx	r3
    bc76:	0003      	movs	r3, r0
    bc78:	7023      	strb	r3, [r4, #0]
    bc7a:	239f      	movs	r3, #159	; 0x9f
    bc7c:	18fb      	adds	r3, r7, r3
    bc7e:	781b      	ldrb	r3, [r3, #0]
    bc80:	2b00      	cmp	r3, #0
    bc82:	d128      	bne.n	bcd6 <atcab_write_zone+0x1ce>
			break;

		// Check response size
		if (packet.rxsize < 4) {
    bc84:	2310      	movs	r3, #16
    bc86:	18fb      	adds	r3, r7, r3
    bc88:	228a      	movs	r2, #138	; 0x8a
    bc8a:	5a9b      	ldrh	r3, [r3, r2]
    bc8c:	2b03      	cmp	r3, #3
    bc8e:	d80f      	bhi.n	bcb0 <atcab_write_zone+0x1a8>
			if (packet.rxsize > 0)
    bc90:	2310      	movs	r3, #16
    bc92:	18fb      	adds	r3, r7, r3
    bc94:	228a      	movs	r2, #138	; 0x8a
    bc96:	5a9b      	ldrh	r3, [r3, r2]
    bc98:	2b00      	cmp	r3, #0
    bc9a:	d004      	beq.n	bca6 <atcab_write_zone+0x19e>
				status = ATCA_RX_FAIL;
    bc9c:	239f      	movs	r3, #159	; 0x9f
    bc9e:	18fb      	adds	r3, r7, r3
    bca0:	22e6      	movs	r2, #230	; 0xe6
    bca2:	701a      	strb	r2, [r3, #0]
			else
				status = ATCA_RX_NO_RESPONSE;
			break;
    bca4:	e018      	b.n	bcd8 <atcab_write_zone+0x1d0>
		// Check response size
		if (packet.rxsize < 4) {
			if (packet.rxsize > 0)
				status = ATCA_RX_FAIL;
			else
				status = ATCA_RX_NO_RESPONSE;
    bca6:	239f      	movs	r3, #159	; 0x9f
    bca8:	18fb      	adds	r3, r7, r3
    bcaa:	22e7      	movs	r2, #231	; 0xe7
    bcac:	701a      	strb	r2, [r3, #0]
			break;
    bcae:	e013      	b.n	bcd8 <atcab_write_zone+0x1d0>
		}

		status = isATCAError(packet.data);
    bcb0:	239f      	movs	r3, #159	; 0x9f
    bcb2:	18fc      	adds	r4, r7, r3
    bcb4:	2310      	movs	r3, #16
    bcb6:	18fb      	adds	r3, r7, r3
    bcb8:	3306      	adds	r3, #6
    bcba:	0018      	movs	r0, r3
    bcbc:	4b15      	ldr	r3, [pc, #84]	; (bd14 <atcab_write_zone+0x20c>)
    bcbe:	4798      	blx	r3
    bcc0:	0003      	movs	r3, r0
    bcc2:	7023      	strb	r3, [r4, #0]
    bcc4:	e008      	b.n	bcd8 <atcab_write_zone+0x1d0>
		return ATCA_BAD_PARAM;

	do {
		// The get address function checks the remaining variables
		if ( (status = atcab_get_addr(zone, slot, block, offset, &addr)) != ATCA_SUCCESS )
			break;
    bcc6:	46c0      	nop			; (mov r8, r8)
    bcc8:	e006      	b.n	bcd8 <atcab_write_zone+0x1d0>
		packet.param1 = zone;
		packet.param2 = addr;
		memcpy( packet.data, data, len );

		if ( (status = atWrite( _gCommandObj, &packet )) != ATCA_SUCCESS )
			break;
    bcca:	46c0      	nop			; (mov r8, r8)
    bccc:	e004      	b.n	bcd8 <atcab_write_zone+0x1d0>

		execution_time = atGetExecTime( _gCommandObj, CMD_WRITEMEM);

		if ( (status = atcab_wakeup()) != ATCA_SUCCESS )
			break;
    bcce:	46c0      	nop			; (mov r8, r8)
    bcd0:	e002      	b.n	bcd8 <atcab_write_zone+0x1d0>

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
			break;
    bcd2:	46c0      	nop			; (mov r8, r8)
    bcd4:	e000      	b.n	bcd8 <atcab_write_zone+0x1d0>
		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &(packet.rxsize) )) != ATCA_SUCCESS )
			break;
    bcd6:	46c0      	nop			; (mov r8, r8)

		status = isATCAError(packet.data);

	} while (0);

	_atcab_exit();
    bcd8:	4b0f      	ldr	r3, [pc, #60]	; (bd18 <atcab_write_zone+0x210>)
    bcda:	4798      	blx	r3
	return status;
    bcdc:	239f      	movs	r3, #159	; 0x9f
    bcde:	18fb      	adds	r3, r7, r3
    bce0:	781b      	ldrb	r3, [r3, #0]
}
    bce2:	0018      	movs	r0, r3
    bce4:	46bd      	mov	sp, r7
    bce6:	b028      	add	sp, #160	; 0xa0
    bce8:	bdb0      	pop	{r4, r5, r7, pc}
    bcea:	46c0      	nop			; (mov r8, r8)
    bcec:	0000b975 	.word	0x0000b975
    bcf0:	000127e7 	.word	0x000127e7
    bcf4:	200007e4 	.word	0x200007e4
    bcf8:	0000a6e1 	.word	0x0000a6e1
    bcfc:	0000a7f5 	.word	0x0000a7f5
    bd00:	0000ad9d 	.word	0x0000ad9d
    bd04:	200007e8 	.word	0x200007e8
    bd08:	0000ab85 	.word	0x0000ab85
    bd0c:	0000e3d5 	.word	0x0000e3d5
    bd10:	0000aba9 	.word	0x0000aba9
    bd14:	0000a955 	.word	0x0000a955
    bd18:	0000ae2d 	.word	0x0000ae2d

0000bd1c <atcab_read_zone>:
 *  \param[in] data
 *  \param[in] len  Must be either 4 or 32
 *  returns ATCA_STATUS
 */
ATCA_STATUS atcab_read_zone(uint8_t zone, uint8_t slot, uint8_t block, uint8_t offset, uint8_t *data, uint8_t len)
{
    bd1c:	b5b0      	push	{r4, r5, r7, lr}
    bd1e:	b0aa      	sub	sp, #168	; 0xa8
    bd20:	af02      	add	r7, sp, #8
    bd22:	0005      	movs	r5, r0
    bd24:	000c      	movs	r4, r1
    bd26:	0010      	movs	r0, r2
    bd28:	0019      	movs	r1, r3
    bd2a:	1dfb      	adds	r3, r7, #7
    bd2c:	1c2a      	adds	r2, r5, #0
    bd2e:	701a      	strb	r2, [r3, #0]
    bd30:	1dbb      	adds	r3, r7, #6
    bd32:	1c22      	adds	r2, r4, #0
    bd34:	701a      	strb	r2, [r3, #0]
    bd36:	1d7b      	adds	r3, r7, #5
    bd38:	1c02      	adds	r2, r0, #0
    bd3a:	701a      	strb	r2, [r3, #0]
    bd3c:	1d3b      	adds	r3, r7, #4
    bd3e:	1c0a      	adds	r2, r1, #0
    bd40:	701a      	strb	r2, [r3, #0]
	ATCA_STATUS status = ATCA_SUCCESS;
    bd42:	239f      	movs	r3, #159	; 0x9f
    bd44:	18fb      	adds	r3, r7, r3
    bd46:	2200      	movs	r2, #0
    bd48:	701a      	strb	r2, [r3, #0]
	ATCAPacket packet = {0};
    bd4a:	2310      	movs	r3, #16
    bd4c:	18fb      	adds	r3, r7, r3
    bd4e:	0018      	movs	r0, r3
    bd50:	238c      	movs	r3, #140	; 0x8c
    bd52:	001a      	movs	r2, r3
    bd54:	2100      	movs	r1, #0
    bd56:	4b73      	ldr	r3, [pc, #460]	; (bf24 <atcab_read_zone+0x208>)
    bd58:	4798      	blx	r3
	uint16_t addr;
	uint16_t execution_time = 0;
    bd5a:	239c      	movs	r3, #156	; 0x9c
    bd5c:	18fb      	adds	r3, r7, r3
    bd5e:	2200      	movs	r2, #0
    bd60:	801a      	strh	r2, [r3, #0]

	do {
		// Check the input parameters
		if (data == NULL)
    bd62:	23b0      	movs	r3, #176	; 0xb0
    bd64:	18fb      	adds	r3, r7, r3
    bd66:	681b      	ldr	r3, [r3, #0]
    bd68:	2b00      	cmp	r3, #0
    bd6a:	d101      	bne.n	bd70 <atcab_read_zone+0x54>
			return ATCA_BAD_PARAM;
    bd6c:	23e2      	movs	r3, #226	; 0xe2
    bd6e:	e0d5      	b.n	bf1c <atcab_read_zone+0x200>

		if ( len != 4 && len != 32 )
    bd70:	23b4      	movs	r3, #180	; 0xb4
    bd72:	18fb      	adds	r3, r7, r3
    bd74:	781b      	ldrb	r3, [r3, #0]
    bd76:	2b04      	cmp	r3, #4
    bd78:	d006      	beq.n	bd88 <atcab_read_zone+0x6c>
    bd7a:	23b4      	movs	r3, #180	; 0xb4
    bd7c:	18fb      	adds	r3, r7, r3
    bd7e:	781b      	ldrb	r3, [r3, #0]
    bd80:	2b20      	cmp	r3, #32
    bd82:	d001      	beq.n	bd88 <atcab_read_zone+0x6c>
			return ATCA_BAD_PARAM;
    bd84:	23e2      	movs	r3, #226	; 0xe2
    bd86:	e0c9      	b.n	bf1c <atcab_read_zone+0x200>

		// The get address function checks the remaining variables
		if ( (status = atcab_get_addr(zone, slot, block, offset, &addr)) != ATCA_SUCCESS )
    bd88:	239f      	movs	r3, #159	; 0x9f
    bd8a:	18fc      	adds	r4, r7, r3
    bd8c:	1d3b      	adds	r3, r7, #4
    bd8e:	781d      	ldrb	r5, [r3, #0]
    bd90:	1d7b      	adds	r3, r7, #5
    bd92:	781a      	ldrb	r2, [r3, #0]
    bd94:	1dbb      	adds	r3, r7, #6
    bd96:	7819      	ldrb	r1, [r3, #0]
    bd98:	1dfb      	adds	r3, r7, #7
    bd9a:	7818      	ldrb	r0, [r3, #0]
    bd9c:	230e      	movs	r3, #14
    bd9e:	18fb      	adds	r3, r7, r3
    bda0:	9300      	str	r3, [sp, #0]
    bda2:	002b      	movs	r3, r5
    bda4:	4d60      	ldr	r5, [pc, #384]	; (bf28 <atcab_read_zone+0x20c>)
    bda6:	47a8      	blx	r5
    bda8:	0003      	movs	r3, r0
    bdaa:	7023      	strb	r3, [r4, #0]
    bdac:	239f      	movs	r3, #159	; 0x9f
    bdae:	18fb      	adds	r3, r7, r3
    bdb0:	781b      	ldrb	r3, [r3, #0]
    bdb2:	2b00      	cmp	r3, #0
    bdb4:	d000      	beq.n	bdb8 <atcab_read_zone+0x9c>
    bdb6:	e0a1      	b.n	befc <atcab_read_zone+0x1e0>
			break;

		// If there are 32 bytes to write, then xor the bit into the mode
		if (len == ATCA_BLOCK_SIZE)
    bdb8:	23b4      	movs	r3, #180	; 0xb4
    bdba:	18fb      	adds	r3, r7, r3
    bdbc:	781b      	ldrb	r3, [r3, #0]
    bdbe:	2b20      	cmp	r3, #32
    bdc0:	d106      	bne.n	bdd0 <atcab_read_zone+0xb4>
			zone = zone | ATCA_ZONE_READWRITE_32;
    bdc2:	1dfb      	adds	r3, r7, #7
    bdc4:	1dfa      	adds	r2, r7, #7
    bdc6:	7812      	ldrb	r2, [r2, #0]
    bdc8:	2180      	movs	r1, #128	; 0x80
    bdca:	4249      	negs	r1, r1
    bdcc:	430a      	orrs	r2, r1
    bdce:	701a      	strb	r2, [r3, #0]

		// build a read command
		packet.param1 = zone;
    bdd0:	2310      	movs	r3, #16
    bdd2:	18fb      	adds	r3, r7, r3
    bdd4:	1dfa      	adds	r2, r7, #7
    bdd6:	7812      	ldrb	r2, [r2, #0]
    bdd8:	70da      	strb	r2, [r3, #3]
		packet.param2 = addr;
    bdda:	230e      	movs	r3, #14
    bddc:	18fb      	adds	r3, r7, r3
    bdde:	881a      	ldrh	r2, [r3, #0]
    bde0:	2310      	movs	r3, #16
    bde2:	18fb      	adds	r3, r7, r3
    bde4:	809a      	strh	r2, [r3, #4]

		if ( (status = atRead( _gCommandObj, &packet )) != ATCA_SUCCESS )
    bde6:	4b51      	ldr	r3, [pc, #324]	; (bf2c <atcab_read_zone+0x210>)
    bde8:	681b      	ldr	r3, [r3, #0]
    bdea:	229f      	movs	r2, #159	; 0x9f
    bdec:	18bc      	adds	r4, r7, r2
    bdee:	2210      	movs	r2, #16
    bdf0:	18ba      	adds	r2, r7, r2
    bdf2:	0011      	movs	r1, r2
    bdf4:	0018      	movs	r0, r3
    bdf6:	4b4e      	ldr	r3, [pc, #312]	; (bf30 <atcab_read_zone+0x214>)
    bdf8:	4798      	blx	r3
    bdfa:	0003      	movs	r3, r0
    bdfc:	7023      	strb	r3, [r4, #0]
    bdfe:	239f      	movs	r3, #159	; 0x9f
    be00:	18fb      	adds	r3, r7, r3
    be02:	781b      	ldrb	r3, [r3, #0]
    be04:	2b00      	cmp	r3, #0
    be06:	d000      	beq.n	be0a <atcab_read_zone+0xee>
    be08:	e07a      	b.n	bf00 <atcab_read_zone+0x1e4>
			break;

		execution_time = atGetExecTime( _gCommandObj, CMD_READMEM);
    be0a:	4b48      	ldr	r3, [pc, #288]	; (bf2c <atcab_read_zone+0x210>)
    be0c:	681b      	ldr	r3, [r3, #0]
    be0e:	229c      	movs	r2, #156	; 0x9c
    be10:	18bc      	adds	r4, r7, r2
    be12:	210f      	movs	r1, #15
    be14:	0018      	movs	r0, r3
    be16:	4b47      	ldr	r3, [pc, #284]	; (bf34 <atcab_read_zone+0x218>)
    be18:	4798      	blx	r3
    be1a:	0003      	movs	r3, r0
    be1c:	8023      	strh	r3, [r4, #0]

		if ( (status = atcab_wakeup()) != ATCA_SUCCESS ) break;
    be1e:	239f      	movs	r3, #159	; 0x9f
    be20:	18fc      	adds	r4, r7, r3
    be22:	4b45      	ldr	r3, [pc, #276]	; (bf38 <atcab_read_zone+0x21c>)
    be24:	4798      	blx	r3
    be26:	0003      	movs	r3, r0
    be28:	7023      	strb	r3, [r4, #0]
    be2a:	239f      	movs	r3, #159	; 0x9f
    be2c:	18fb      	adds	r3, r7, r3
    be2e:	781b      	ldrb	r3, [r3, #0]
    be30:	2b00      	cmp	r3, #0
    be32:	d167      	bne.n	bf04 <atcab_read_zone+0x1e8>
		
		
		atca_delay_ms(200); //LL test duration
    be34:	20c8      	movs	r0, #200	; 0xc8
    be36:	4b41      	ldr	r3, [pc, #260]	; (bf3c <atcab_read_zone+0x220>)
    be38:	4798      	blx	r3
		//delay_ms(500);

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
    be3a:	4b41      	ldr	r3, [pc, #260]	; (bf40 <atcab_read_zone+0x224>)
    be3c:	6818      	ldr	r0, [r3, #0]
    be3e:	2310      	movs	r3, #16
    be40:	18fb      	adds	r3, r7, r3
    be42:	785b      	ldrb	r3, [r3, #1]
    be44:	001a      	movs	r2, r3
    be46:	239f      	movs	r3, #159	; 0x9f
    be48:	18fc      	adds	r4, r7, r3
    be4a:	2310      	movs	r3, #16
    be4c:	18fb      	adds	r3, r7, r3
    be4e:	0019      	movs	r1, r3
    be50:	4b3c      	ldr	r3, [pc, #240]	; (bf44 <atcab_read_zone+0x228>)
    be52:	4798      	blx	r3
    be54:	0003      	movs	r3, r0
    be56:	7023      	strb	r3, [r4, #0]
    be58:	239f      	movs	r3, #159	; 0x9f
    be5a:	18fb      	adds	r3, r7, r3
    be5c:	781b      	ldrb	r3, [r3, #0]
    be5e:	2b00      	cmp	r3, #0
    be60:	d152      	bne.n	bf08 <atcab_read_zone+0x1ec>
			break;

		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);
    be62:	239c      	movs	r3, #156	; 0x9c
    be64:	18fb      	adds	r3, r7, r3
    be66:	881b      	ldrh	r3, [r3, #0]
    be68:	0018      	movs	r0, r3
    be6a:	4b34      	ldr	r3, [pc, #208]	; (bf3c <atcab_read_zone+0x220>)
    be6c:	4798      	blx	r3

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &(packet.rxsize) )) != ATCA_SUCCESS )
    be6e:	4b34      	ldr	r3, [pc, #208]	; (bf40 <atcab_read_zone+0x224>)
    be70:	6818      	ldr	r0, [r3, #0]
    be72:	239f      	movs	r3, #159	; 0x9f
    be74:	18fc      	adds	r4, r7, r3
    be76:	2310      	movs	r3, #16
    be78:	18fb      	adds	r3, r7, r3
    be7a:	338a      	adds	r3, #138	; 0x8a
    be7c:	001a      	movs	r2, r3
    be7e:	2310      	movs	r3, #16
    be80:	18fb      	adds	r3, r7, r3
    be82:	3306      	adds	r3, #6
    be84:	0019      	movs	r1, r3
    be86:	4b30      	ldr	r3, [pc, #192]	; (bf48 <atcab_read_zone+0x22c>)
    be88:	4798      	blx	r3
    be8a:	0003      	movs	r3, r0
    be8c:	7023      	strb	r3, [r4, #0]
    be8e:	239f      	movs	r3, #159	; 0x9f
    be90:	18fb      	adds	r3, r7, r3
    be92:	781b      	ldrb	r3, [r3, #0]
    be94:	2b00      	cmp	r3, #0
    be96:	d139      	bne.n	bf0c <atcab_read_zone+0x1f0>
			break;

		// Check response size
		if (packet.rxsize < 4) {
    be98:	2310      	movs	r3, #16
    be9a:	18fb      	adds	r3, r7, r3
    be9c:	228a      	movs	r2, #138	; 0x8a
    be9e:	5a9b      	ldrh	r3, [r3, r2]
    bea0:	2b03      	cmp	r3, #3
    bea2:	d80f      	bhi.n	bec4 <atcab_read_zone+0x1a8>
			if (packet.rxsize > 0)
    bea4:	2310      	movs	r3, #16
    bea6:	18fb      	adds	r3, r7, r3
    bea8:	228a      	movs	r2, #138	; 0x8a
    beaa:	5a9b      	ldrh	r3, [r3, r2]
    beac:	2b00      	cmp	r3, #0
    beae:	d004      	beq.n	beba <atcab_read_zone+0x19e>
				status = ATCA_RX_FAIL;
    beb0:	239f      	movs	r3, #159	; 0x9f
    beb2:	18fb      	adds	r3, r7, r3
    beb4:	22e6      	movs	r2, #230	; 0xe6
    beb6:	701a      	strb	r2, [r3, #0]
			else
				status = ATCA_RX_NO_RESPONSE;
			break;
    beb8:	e02b      	b.n	bf12 <atcab_read_zone+0x1f6>
		// Check response size
		if (packet.rxsize < 4) {
			if (packet.rxsize > 0)
				status = ATCA_RX_FAIL;
			else
				status = ATCA_RX_NO_RESPONSE;
    beba:	239f      	movs	r3, #159	; 0x9f
    bebc:	18fb      	adds	r3, r7, r3
    bebe:	22e7      	movs	r2, #231	; 0xe7
    bec0:	701a      	strb	r2, [r3, #0]
			break;
    bec2:	e026      	b.n	bf12 <atcab_read_zone+0x1f6>
		}

		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
    bec4:	239f      	movs	r3, #159	; 0x9f
    bec6:	18fc      	adds	r4, r7, r3
    bec8:	2310      	movs	r3, #16
    beca:	18fb      	adds	r3, r7, r3
    becc:	3306      	adds	r3, #6
    bece:	0018      	movs	r0, r3
    bed0:	4b1e      	ldr	r3, [pc, #120]	; (bf4c <atcab_read_zone+0x230>)
    bed2:	4798      	blx	r3
    bed4:	0003      	movs	r3, r0
    bed6:	7023      	strb	r3, [r4, #0]
    bed8:	239f      	movs	r3, #159	; 0x9f
    beda:	18fb      	adds	r3, r7, r3
    bedc:	781b      	ldrb	r3, [r3, #0]
    bede:	2b00      	cmp	r3, #0
    bee0:	d116      	bne.n	bf10 <atcab_read_zone+0x1f4>
			break;

		memcpy( data, &packet.data[1], len );
    bee2:	23b4      	movs	r3, #180	; 0xb4
    bee4:	18fb      	adds	r3, r7, r3
    bee6:	781a      	ldrb	r2, [r3, #0]
    bee8:	2310      	movs	r3, #16
    beea:	18fb      	adds	r3, r7, r3
    beec:	1dd9      	adds	r1, r3, #7
    beee:	23b0      	movs	r3, #176	; 0xb0
    bef0:	18fb      	adds	r3, r7, r3
    bef2:	681b      	ldr	r3, [r3, #0]
    bef4:	0018      	movs	r0, r3
    bef6:	4b16      	ldr	r3, [pc, #88]	; (bf50 <atcab_read_zone+0x234>)
    bef8:	4798      	blx	r3
    befa:	e00a      	b.n	bf12 <atcab_read_zone+0x1f6>
		if ( len != 4 && len != 32 )
			return ATCA_BAD_PARAM;

		// The get address function checks the remaining variables
		if ( (status = atcab_get_addr(zone, slot, block, offset, &addr)) != ATCA_SUCCESS )
			break;
    befc:	46c0      	nop			; (mov r8, r8)
    befe:	e008      	b.n	bf12 <atcab_read_zone+0x1f6>
		// build a read command
		packet.param1 = zone;
		packet.param2 = addr;

		if ( (status = atRead( _gCommandObj, &packet )) != ATCA_SUCCESS )
			break;
    bf00:	46c0      	nop			; (mov r8, r8)
    bf02:	e006      	b.n	bf12 <atcab_read_zone+0x1f6>

		execution_time = atGetExecTime( _gCommandObj, CMD_READMEM);

		if ( (status = atcab_wakeup()) != ATCA_SUCCESS ) break;
    bf04:	46c0      	nop			; (mov r8, r8)
    bf06:	e004      	b.n	bf12 <atcab_read_zone+0x1f6>
		atca_delay_ms(200); //LL test duration
		//delay_ms(500);

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
			break;
    bf08:	46c0      	nop			; (mov r8, r8)
    bf0a:	e002      	b.n	bf12 <atcab_read_zone+0x1f6>
		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &(packet.rxsize) )) != ATCA_SUCCESS )
			break;
    bf0c:	46c0      	nop			; (mov r8, r8)
    bf0e:	e000      	b.n	bf12 <atcab_read_zone+0x1f6>
				status = ATCA_RX_NO_RESPONSE;
			break;
		}

		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
			break;
    bf10:	46c0      	nop			; (mov r8, r8)

		memcpy( data, &packet.data[1], len );
	} while (0);

	_atcab_exit();
    bf12:	4b10      	ldr	r3, [pc, #64]	; (bf54 <atcab_read_zone+0x238>)
    bf14:	4798      	blx	r3
	return status;
    bf16:	239f      	movs	r3, #159	; 0x9f
    bf18:	18fb      	adds	r3, r7, r3
    bf1a:	781b      	ldrb	r3, [r3, #0]
}
    bf1c:	0018      	movs	r0, r3
    bf1e:	46bd      	mov	sp, r7
    bf20:	b028      	add	sp, #160	; 0xa0
    bf22:	bdb0      	pop	{r4, r5, r7, pc}
    bf24:	00012823 	.word	0x00012823
    bf28:	0000b975 	.word	0x0000b975
    bf2c:	200007e4 	.word	0x200007e4
    bf30:	0000a5fd 	.word	0x0000a5fd
    bf34:	0000a7f5 	.word	0x0000a7f5
    bf38:	0000ad9d 	.word	0x0000ad9d
    bf3c:	0000e3d5 	.word	0x0000e3d5
    bf40:	200007e8 	.word	0x200007e8
    bf44:	0000ab85 	.word	0x0000ab85
    bf48:	0000aba9 	.word	0x0000aba9
    bf4c:	0000a955 	.word	0x0000a955
    bf50:	000127e7 	.word	0x000127e7
    bf54:	0000ae2d 	.word	0x0000ae2d

0000bf58 <atcab_write_ecc_config_zone>:
/** \brief given an ECC configuration zone buffer, write its parts to the device's config zone
 *  \param[in] config_data pointer to buffer containing a contiguous set of bytes to write to the config zone
 *  \returns ATCA_STATUS
 */
ATCA_STATUS atcab_write_ecc_config_zone(const uint8_t* config_data)
{
    bf58:	b5b0      	push	{r4, r5, r7, lr}
    bf5a:	b0aa      	sub	sp, #168	; 0xa8
    bf5c:	af02      	add	r7, sp, #8
    bf5e:	6078      	str	r0, [r7, #4]
	ATCA_STATUS status = ATCA_GEN_FAIL;
    bf60:	239f      	movs	r3, #159	; 0x9f
    bf62:	18fb      	adds	r3, r7, r3
    bf64:	22e1      	movs	r2, #225	; 0xe1
    bf66:	701a      	strb	r2, [r3, #0]
	ATCAPacket packet;
	uint16_t execution_time = 0;
    bf68:	239a      	movs	r3, #154	; 0x9a
    bf6a:	18fb      	adds	r3, r7, r3
    bf6c:	2200      	movs	r2, #0
    bf6e:	801a      	strh	r2, [r3, #0]
	uint8_t zone = 0, block = 0, offset = 0, slot = 0, index = 0;
    bf70:	2399      	movs	r3, #153	; 0x99
    bf72:	18fb      	adds	r3, r7, r3
    bf74:	2200      	movs	r2, #0
    bf76:	701a      	strb	r2, [r3, #0]
    bf78:	239e      	movs	r3, #158	; 0x9e
    bf7a:	18fb      	adds	r3, r7, r3
    bf7c:	2200      	movs	r2, #0
    bf7e:	701a      	strb	r2, [r3, #0]
    bf80:	239d      	movs	r3, #157	; 0x9d
    bf82:	18fb      	adds	r3, r7, r3
    bf84:	2200      	movs	r2, #0
    bf86:	701a      	strb	r2, [r3, #0]
    bf88:	2398      	movs	r3, #152	; 0x98
    bf8a:	18fb      	adds	r3, r7, r3
    bf8c:	2200      	movs	r2, #0
    bf8e:	701a      	strb	r2, [r3, #0]
    bf90:	239c      	movs	r3, #156	; 0x9c
    bf92:	18fb      	adds	r3, r7, r3
    bf94:	2200      	movs	r2, #0
    bf96:	701a      	strb	r2, [r3, #0]
	uint16_t addr = 0;
    bf98:	230a      	movs	r3, #10
    bf9a:	18fb      	adds	r3, r7, r3
    bf9c:	2200      	movs	r2, #0
    bf9e:	801a      	strh	r2, [r3, #0]

	// write the ecc zone one block at a time starting after address 0x04 (block 0, offset 4)
	offset = 4;
    bfa0:	239d      	movs	r3, #157	; 0x9d
    bfa2:	18fb      	adds	r3, r7, r3
    bfa4:	2204      	movs	r2, #4
    bfa6:	701a      	strb	r2, [r3, #0]
	do {
		if ((block == 0) || (block == 2)) {
    bfa8:	239e      	movs	r3, #158	; 0x9e
    bfaa:	18fb      	adds	r3, r7, r3
    bfac:	781b      	ldrb	r3, [r3, #0]
    bfae:	2b00      	cmp	r3, #0
    bfb0:	d005      	beq.n	bfbe <atcab_write_ecc_config_zone+0x66>
    bfb2:	239e      	movs	r3, #158	; 0x9e
    bfb4:	18fb      	adds	r3, r7, r3
    bfb6:	781b      	ldrb	r3, [r3, #0]
    bfb8:	2b02      	cmp	r3, #2
    bfba:	d000      	beq.n	bfbe <atcab_write_ecc_config_zone+0x66>
    bfbc:	e0fa      	b.n	c1b4 <atcab_write_ecc_config_zone+0x25c>

			if (offset <= 7) {
    bfbe:	239d      	movs	r3, #157	; 0x9d
    bfc0:	18fb      	adds	r3, r7, r3
    bfc2:	781b      	ldrb	r3, [r3, #0]
    bfc4:	2b07      	cmp	r3, #7
    bfc6:	d900      	bls.n	bfca <atcab_write_ecc_config_zone+0x72>
    bfc8:	e0e8      	b.n	c19c <atcab_write_ecc_config_zone+0x244>
				memset(packet.data, 0x00, 130);
    bfca:	230c      	movs	r3, #12
    bfcc:	18fb      	adds	r3, r7, r3
    bfce:	3306      	adds	r3, #6
    bfd0:	2282      	movs	r2, #130	; 0x82
    bfd2:	2100      	movs	r1, #0
    bfd4:	0018      	movs	r0, r3
    bfd6:	4be7      	ldr	r3, [pc, #924]	; (c374 <atcab_write_ecc_config_zone+0x41c>)
    bfd8:	4798      	blx	r3
				// read 4 bytes at once
				packet.param1 = ATCA_ZONE_CONFIG;
    bfda:	230c      	movs	r3, #12
    bfdc:	18fb      	adds	r3, r7, r3
    bfde:	2200      	movs	r2, #0
    bfe0:	70da      	strb	r2, [r3, #3]
				// build a write command (write from the start)
				if ( (status = atcab_get_addr(zone, slot, block, offset, &addr)) != ATCA_SUCCESS )
    bfe2:	239f      	movs	r3, #159	; 0x9f
    bfe4:	18fc      	adds	r4, r7, r3
    bfe6:	239d      	movs	r3, #157	; 0x9d
    bfe8:	18fb      	adds	r3, r7, r3
    bfea:	781d      	ldrb	r5, [r3, #0]
    bfec:	239e      	movs	r3, #158	; 0x9e
    bfee:	18fb      	adds	r3, r7, r3
    bff0:	781a      	ldrb	r2, [r3, #0]
    bff2:	2398      	movs	r3, #152	; 0x98
    bff4:	18fb      	adds	r3, r7, r3
    bff6:	7819      	ldrb	r1, [r3, #0]
    bff8:	2399      	movs	r3, #153	; 0x99
    bffa:	18fb      	adds	r3, r7, r3
    bffc:	7818      	ldrb	r0, [r3, #0]
    bffe:	230a      	movs	r3, #10
    c000:	18fb      	adds	r3, r7, r3
    c002:	9300      	str	r3, [sp, #0]
    c004:	002b      	movs	r3, r5
    c006:	4ddc      	ldr	r5, [pc, #880]	; (c378 <atcab_write_ecc_config_zone+0x420>)
    c008:	47a8      	blx	r5
    c00a:	0003      	movs	r3, r0
    c00c:	7023      	strb	r3, [r4, #0]
    c00e:	239f      	movs	r3, #159	; 0x9f
    c010:	18fb      	adds	r3, r7, r3
    c012:	781b      	ldrb	r3, [r3, #0]
    c014:	2b00      	cmp	r3, #0
    c016:	d000      	beq.n	c01a <atcab_write_ecc_config_zone+0xc2>
    c018:	e1a1      	b.n	c35e <atcab_write_ecc_config_zone+0x406>
					break;

				packet.param2 =  addr;
    c01a:	230a      	movs	r3, #10
    c01c:	18fb      	adds	r3, r7, r3
    c01e:	881a      	ldrh	r2, [r3, #0]
    c020:	230c      	movs	r3, #12
    c022:	18fb      	adds	r3, r7, r3
    c024:	809a      	strh	r2, [r3, #4]
				memcpy(&packet.data[0], &config_data[index + 16], ATCA_WORD_SIZE);
    c026:	239c      	movs	r3, #156	; 0x9c
    c028:	18fb      	adds	r3, r7, r3
    c02a:	781b      	ldrb	r3, [r3, #0]
    c02c:	3310      	adds	r3, #16
    c02e:	687a      	ldr	r2, [r7, #4]
    c030:	18d1      	adds	r1, r2, r3
    c032:	230c      	movs	r3, #12
    c034:	18fb      	adds	r3, r7, r3
    c036:	3306      	adds	r3, #6
    c038:	2204      	movs	r2, #4
    c03a:	0018      	movs	r0, r3
    c03c:	4bcf      	ldr	r3, [pc, #828]	; (c37c <atcab_write_ecc_config_zone+0x424>)
    c03e:	4798      	blx	r3
				index += ATCA_WORD_SIZE;
    c040:	239c      	movs	r3, #156	; 0x9c
    c042:	18fb      	adds	r3, r7, r3
    c044:	229c      	movs	r2, #156	; 0x9c
    c046:	18ba      	adds	r2, r7, r2
    c048:	7812      	ldrb	r2, [r2, #0]
    c04a:	3204      	adds	r2, #4
    c04c:	701a      	strb	r2, [r3, #0]
				status = atWrite(_gCommandObj, &packet);
    c04e:	4bcc      	ldr	r3, [pc, #816]	; (c380 <atcab_write_ecc_config_zone+0x428>)
    c050:	681b      	ldr	r3, [r3, #0]
    c052:	229f      	movs	r2, #159	; 0x9f
    c054:	18bc      	adds	r4, r7, r2
    c056:	220c      	movs	r2, #12
    c058:	18ba      	adds	r2, r7, r2
    c05a:	0011      	movs	r1, r2
    c05c:	0018      	movs	r0, r3
    c05e:	4bc9      	ldr	r3, [pc, #804]	; (c384 <atcab_write_ecc_config_zone+0x42c>)
    c060:	4798      	blx	r3
    c062:	0003      	movs	r3, r0
    c064:	7023      	strb	r3, [r4, #0]
				execution_time = atGetExecTime( _gCommandObj, CMD_WRITEMEM);
    c066:	4bc6      	ldr	r3, [pc, #792]	; (c380 <atcab_write_ecc_config_zone+0x428>)
    c068:	681b      	ldr	r3, [r3, #0]
    c06a:	229a      	movs	r2, #154	; 0x9a
    c06c:	18bc      	adds	r4, r7, r2
    c06e:	2114      	movs	r1, #20
    c070:	0018      	movs	r0, r3
    c072:	4bc5      	ldr	r3, [pc, #788]	; (c388 <atcab_write_ecc_config_zone+0x430>)
    c074:	4798      	blx	r3
    c076:	0003      	movs	r3, r0
    c078:	8023      	strh	r3, [r4, #0]

				if ( (status = atcab_wakeup()) != ATCA_SUCCESS ) break;
    c07a:	239f      	movs	r3, #159	; 0x9f
    c07c:	18fc      	adds	r4, r7, r3
    c07e:	4bc3      	ldr	r3, [pc, #780]	; (c38c <atcab_write_ecc_config_zone+0x434>)
    c080:	4798      	blx	r3
    c082:	0003      	movs	r3, r0
    c084:	7023      	strb	r3, [r4, #0]
    c086:	239f      	movs	r3, #159	; 0x9f
    c088:	18fb      	adds	r3, r7, r3
    c08a:	781b      	ldrb	r3, [r3, #0]
    c08c:	2b00      	cmp	r3, #0
    c08e:	d000      	beq.n	c092 <atcab_write_ecc_config_zone+0x13a>
    c090:	e167      	b.n	c362 <atcab_write_ecc_config_zone+0x40a>

				// send the command
				if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
    c092:	4bbf      	ldr	r3, [pc, #764]	; (c390 <atcab_write_ecc_config_zone+0x438>)
    c094:	6818      	ldr	r0, [r3, #0]
    c096:	230c      	movs	r3, #12
    c098:	18fb      	adds	r3, r7, r3
    c09a:	785b      	ldrb	r3, [r3, #1]
    c09c:	001a      	movs	r2, r3
    c09e:	239f      	movs	r3, #159	; 0x9f
    c0a0:	18fc      	adds	r4, r7, r3
    c0a2:	230c      	movs	r3, #12
    c0a4:	18fb      	adds	r3, r7, r3
    c0a6:	0019      	movs	r1, r3
    c0a8:	4bba      	ldr	r3, [pc, #744]	; (c394 <atcab_write_ecc_config_zone+0x43c>)
    c0aa:	4798      	blx	r3
    c0ac:	0003      	movs	r3, r0
    c0ae:	7023      	strb	r3, [r4, #0]
    c0b0:	239f      	movs	r3, #159	; 0x9f
    c0b2:	18fb      	adds	r3, r7, r3
    c0b4:	781b      	ldrb	r3, [r3, #0]
    c0b6:	2b00      	cmp	r3, #0
    c0b8:	d000      	beq.n	c0bc <atcab_write_ecc_config_zone+0x164>
    c0ba:	e154      	b.n	c366 <atcab_write_ecc_config_zone+0x40e>
					break;

				// delay the appropriate amount of time for command to execute
				atca_delay_ms(execution_time);
    c0bc:	239a      	movs	r3, #154	; 0x9a
    c0be:	18fb      	adds	r3, r7, r3
    c0c0:	881b      	ldrh	r3, [r3, #0]
    c0c2:	0018      	movs	r0, r3
    c0c4:	4bb4      	ldr	r3, [pc, #720]	; (c398 <atcab_write_ecc_config_zone+0x440>)
    c0c6:	4798      	blx	r3

				// receive the response
				if ( (status = atreceive( _gIface, packet.data, &packet.rxsize)) != ATCA_SUCCESS )
    c0c8:	4bb1      	ldr	r3, [pc, #708]	; (c390 <atcab_write_ecc_config_zone+0x438>)
    c0ca:	6818      	ldr	r0, [r3, #0]
    c0cc:	239f      	movs	r3, #159	; 0x9f
    c0ce:	18fc      	adds	r4, r7, r3
    c0d0:	230c      	movs	r3, #12
    c0d2:	18fb      	adds	r3, r7, r3
    c0d4:	338a      	adds	r3, #138	; 0x8a
    c0d6:	001a      	movs	r2, r3
    c0d8:	230c      	movs	r3, #12
    c0da:	18fb      	adds	r3, r7, r3
    c0dc:	3306      	adds	r3, #6
    c0de:	0019      	movs	r1, r3
    c0e0:	4bae      	ldr	r3, [pc, #696]	; (c39c <atcab_write_ecc_config_zone+0x444>)
    c0e2:	4798      	blx	r3
    c0e4:	0003      	movs	r3, r0
    c0e6:	7023      	strb	r3, [r4, #0]
    c0e8:	239f      	movs	r3, #159	; 0x9f
    c0ea:	18fb      	adds	r3, r7, r3
    c0ec:	781b      	ldrb	r3, [r3, #0]
    c0ee:	2b00      	cmp	r3, #0
    c0f0:	d000      	beq.n	c0f4 <atcab_write_ecc_config_zone+0x19c>
    c0f2:	e13a      	b.n	c36a <atcab_write_ecc_config_zone+0x412>
					break;

				// Check response size
				if (packet.rxsize < 4) {
    c0f4:	230c      	movs	r3, #12
    c0f6:	18fb      	adds	r3, r7, r3
    c0f8:	228a      	movs	r2, #138	; 0x8a
    c0fa:	5a9b      	ldrh	r3, [r3, r2]
    c0fc:	2b03      	cmp	r3, #3
    c0fe:	d80f      	bhi.n	c120 <atcab_write_ecc_config_zone+0x1c8>
					if (packet.rxsize > 0)
    c100:	230c      	movs	r3, #12
    c102:	18fb      	adds	r3, r7, r3
    c104:	228a      	movs	r2, #138	; 0x8a
    c106:	5a9b      	ldrh	r3, [r3, r2]
    c108:	2b00      	cmp	r3, #0
    c10a:	d004      	beq.n	c116 <atcab_write_ecc_config_zone+0x1be>
						status = ATCA_RX_FAIL;
    c10c:	239f      	movs	r3, #159	; 0x9f
    c10e:	18fb      	adds	r3, r7, r3
    c110:	22e6      	movs	r2, #230	; 0xe6
    c112:	701a      	strb	r2, [r3, #0]
					else
						status = ATCA_RX_NO_RESPONSE;
					break;
    c114:	e155      	b.n	c3c2 <atcab_write_ecc_config_zone+0x46a>
				// Check response size
				if (packet.rxsize < 4) {
					if (packet.rxsize > 0)
						status = ATCA_RX_FAIL;
					else
						status = ATCA_RX_NO_RESPONSE;
    c116:	239f      	movs	r3, #159	; 0x9f
    c118:	18fb      	adds	r3, r7, r3
    c11a:	22e7      	movs	r2, #231	; 0xe7
    c11c:	701a      	strb	r2, [r3, #0]
					break;
    c11e:	e150      	b.n	c3c2 <atcab_write_ecc_config_zone+0x46a>
				}

				if ( (status = atcab_idle()) != ATCA_SUCCESS ) break;
    c120:	239f      	movs	r3, #159	; 0x9f
    c122:	18fc      	adds	r4, r7, r3
    c124:	4b9e      	ldr	r3, [pc, #632]	; (c3a0 <atcab_write_ecc_config_zone+0x448>)
    c126:	4798      	blx	r3
    c128:	0003      	movs	r3, r0
    c12a:	7023      	strb	r3, [r4, #0]
    c12c:	239f      	movs	r3, #159	; 0x9f
    c12e:	18fb      	adds	r3, r7, r3
    c130:	781b      	ldrb	r3, [r3, #0]
    c132:	2b00      	cmp	r3, #0
    c134:	d000      	beq.n	c138 <atcab_write_ecc_config_zone+0x1e0>
    c136:	e11a      	b.n	c36e <atcab_write_ecc_config_zone+0x416>

				if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
    c138:	239f      	movs	r3, #159	; 0x9f
    c13a:	18fc      	adds	r4, r7, r3
    c13c:	230c      	movs	r3, #12
    c13e:	18fb      	adds	r3, r7, r3
    c140:	3306      	adds	r3, #6
    c142:	0018      	movs	r0, r3
    c144:	4b97      	ldr	r3, [pc, #604]	; (c3a4 <atcab_write_ecc_config_zone+0x44c>)
    c146:	4798      	blx	r3
    c148:	0003      	movs	r3, r0
    c14a:	7023      	strb	r3, [r4, #0]
    c14c:	239f      	movs	r3, #159	; 0x9f
    c14e:	18fb      	adds	r3, r7, r3
    c150:	781b      	ldrb	r3, [r3, #0]
    c152:	2b00      	cmp	r3, #0
    c154:	d000      	beq.n	c158 <atcab_write_ecc_config_zone+0x200>
    c156:	e127      	b.n	c3a8 <atcab_write_ecc_config_zone+0x450>
					break;

				// update the offset address after reading each block
				++offset;
    c158:	239d      	movs	r3, #157	; 0x9d
    c15a:	18fb      	adds	r3, r7, r3
    c15c:	229d      	movs	r2, #157	; 0x9d
    c15e:	18ba      	adds	r2, r7, r2
    c160:	7812      	ldrb	r2, [r2, #0]
    c162:	3201      	adds	r2, #1
    c164:	701a      	strb	r2, [r3, #0]
				if ((block == 2) && (offset == 5)) {
    c166:	239e      	movs	r3, #158	; 0x9e
    c168:	18fb      	adds	r3, r7, r3
    c16a:	781b      	ldrb	r3, [r3, #0]
    c16c:	2b02      	cmp	r3, #2
    c16e:	d000      	beq.n	c172 <atcab_write_ecc_config_zone+0x21a>
    c170:	e0ed      	b.n	c34e <atcab_write_ecc_config_zone+0x3f6>
    c172:	239d      	movs	r3, #157	; 0x9d
    c174:	18fb      	adds	r3, r7, r3
    c176:	781b      	ldrb	r3, [r3, #0]
    c178:	2b05      	cmp	r3, #5
    c17a:	d000      	beq.n	c17e <atcab_write_ecc_config_zone+0x226>
    c17c:	e0e7      	b.n	c34e <atcab_write_ecc_config_zone+0x3f6>
					// words above (block 2 offset 5 cant be written)
					++offset; index += ATCA_WORD_SIZE;
    c17e:	239d      	movs	r3, #157	; 0x9d
    c180:	18fb      	adds	r3, r7, r3
    c182:	229d      	movs	r2, #157	; 0x9d
    c184:	18ba      	adds	r2, r7, r2
    c186:	7812      	ldrb	r2, [r2, #0]
    c188:	3201      	adds	r2, #1
    c18a:	701a      	strb	r2, [r3, #0]
    c18c:	239c      	movs	r3, #156	; 0x9c
    c18e:	18fb      	adds	r3, r7, r3
    c190:	229c      	movs	r2, #156	; 0x9c
    c192:	18ba      	adds	r2, r7, r2
    c194:	7812      	ldrb	r2, [r2, #0]
    c196:	3204      	adds	r2, #4
    c198:	701a      	strb	r2, [r3, #0]
	// write the ecc zone one block at a time starting after address 0x04 (block 0, offset 4)
	offset = 4;
	do {
		if ((block == 0) || (block == 2)) {

			if (offset <= 7) {
    c19a:	e0d8      	b.n	c34e <atcab_write_ecc_config_zone+0x3f6>
					// words above (block 2 offset 5 cant be written)
					++offset; index += ATCA_WORD_SIZE;
				}
			}else {
				// update the word address after completely reading each block
				++block; offset = 0;
    c19c:	239e      	movs	r3, #158	; 0x9e
    c19e:	18fb      	adds	r3, r7, r3
    c1a0:	229e      	movs	r2, #158	; 0x9e
    c1a2:	18ba      	adds	r2, r7, r2
    c1a4:	7812      	ldrb	r2, [r2, #0]
    c1a6:	3201      	adds	r2, #1
    c1a8:	701a      	strb	r2, [r3, #0]
    c1aa:	239d      	movs	r3, #157	; 0x9d
    c1ac:	18fb      	adds	r3, r7, r3
    c1ae:	2200      	movs	r2, #0
    c1b0:	701a      	strb	r2, [r3, #0]
	// write the ecc zone one block at a time starting after address 0x04 (block 0, offset 4)
	offset = 4;
	do {
		if ((block == 0) || (block == 2)) {

			if (offset <= 7) {
    c1b2:	e0cc      	b.n	c34e <atcab_write_ecc_config_zone+0x3f6>
			}else {
				// update the word address after completely reading each block
				++block; offset = 0;
			}
		}else {
			memset(packet.data, 0x00, 130);
    c1b4:	230c      	movs	r3, #12
    c1b6:	18fb      	adds	r3, r7, r3
    c1b8:	3306      	adds	r3, #6
    c1ba:	2282      	movs	r2, #130	; 0x82
    c1bc:	2100      	movs	r1, #0
    c1be:	0018      	movs	r0, r3
    c1c0:	4b6c      	ldr	r3, [pc, #432]	; (c374 <atcab_write_ecc_config_zone+0x41c>)
    c1c2:	4798      	blx	r3
			// read 32 bytes at once
			packet.param1 = ATCA_ZONE_CONFIG | ATCA_ZONE_READWRITE_32;
    c1c4:	230c      	movs	r3, #12
    c1c6:	18fb      	adds	r3, r7, r3
    c1c8:	2280      	movs	r2, #128	; 0x80
    c1ca:	70da      	strb	r2, [r3, #3]
			// build a write command (write from the start)
			atcab_get_addr(zone, slot, block, offset, &addr);
    c1cc:	239d      	movs	r3, #157	; 0x9d
    c1ce:	18fb      	adds	r3, r7, r3
    c1d0:	781c      	ldrb	r4, [r3, #0]
    c1d2:	239e      	movs	r3, #158	; 0x9e
    c1d4:	18fb      	adds	r3, r7, r3
    c1d6:	781a      	ldrb	r2, [r3, #0]
    c1d8:	2398      	movs	r3, #152	; 0x98
    c1da:	18fb      	adds	r3, r7, r3
    c1dc:	7819      	ldrb	r1, [r3, #0]
    c1de:	2399      	movs	r3, #153	; 0x99
    c1e0:	18fb      	adds	r3, r7, r3
    c1e2:	7818      	ldrb	r0, [r3, #0]
    c1e4:	230a      	movs	r3, #10
    c1e6:	18fb      	adds	r3, r7, r3
    c1e8:	9300      	str	r3, [sp, #0]
    c1ea:	0023      	movs	r3, r4
    c1ec:	4c62      	ldr	r4, [pc, #392]	; (c378 <atcab_write_ecc_config_zone+0x420>)
    c1ee:	47a0      	blx	r4
			packet.param2 =  addr;
    c1f0:	230a      	movs	r3, #10
    c1f2:	18fb      	adds	r3, r7, r3
    c1f4:	881a      	ldrh	r2, [r3, #0]
    c1f6:	230c      	movs	r3, #12
    c1f8:	18fb      	adds	r3, r7, r3
    c1fa:	809a      	strh	r2, [r3, #4]
			memcpy(&packet.data[0], &config_data[index + 16], ATCA_BLOCK_SIZE);
    c1fc:	239c      	movs	r3, #156	; 0x9c
    c1fe:	18fb      	adds	r3, r7, r3
    c200:	781b      	ldrb	r3, [r3, #0]
    c202:	3310      	adds	r3, #16
    c204:	687a      	ldr	r2, [r7, #4]
    c206:	18d1      	adds	r1, r2, r3
    c208:	230c      	movs	r3, #12
    c20a:	18fb      	adds	r3, r7, r3
    c20c:	3306      	adds	r3, #6
    c20e:	2220      	movs	r2, #32
    c210:	0018      	movs	r0, r3
    c212:	4b5a      	ldr	r3, [pc, #360]	; (c37c <atcab_write_ecc_config_zone+0x424>)
    c214:	4798      	blx	r3
			index += ATCA_BLOCK_SIZE;
    c216:	239c      	movs	r3, #156	; 0x9c
    c218:	18fb      	adds	r3, r7, r3
    c21a:	229c      	movs	r2, #156	; 0x9c
    c21c:	18ba      	adds	r2, r7, r2
    c21e:	7812      	ldrb	r2, [r2, #0]
    c220:	3220      	adds	r2, #32
    c222:	701a      	strb	r2, [r3, #0]
			if ( (status = atWrite(_gCommandObj, &packet)) != ATCA_SUCCESS )
    c224:	4b56      	ldr	r3, [pc, #344]	; (c380 <atcab_write_ecc_config_zone+0x428>)
    c226:	681b      	ldr	r3, [r3, #0]
    c228:	229f      	movs	r2, #159	; 0x9f
    c22a:	18bc      	adds	r4, r7, r2
    c22c:	220c      	movs	r2, #12
    c22e:	18ba      	adds	r2, r7, r2
    c230:	0011      	movs	r1, r2
    c232:	0018      	movs	r0, r3
    c234:	4b53      	ldr	r3, [pc, #332]	; (c384 <atcab_write_ecc_config_zone+0x42c>)
    c236:	4798      	blx	r3
    c238:	0003      	movs	r3, r0
    c23a:	7023      	strb	r3, [r4, #0]
    c23c:	239f      	movs	r3, #159	; 0x9f
    c23e:	18fb      	adds	r3, r7, r3
    c240:	781b      	ldrb	r3, [r3, #0]
    c242:	2b00      	cmp	r3, #0
    c244:	d000      	beq.n	c248 <atcab_write_ecc_config_zone+0x2f0>
    c246:	e0b1      	b.n	c3ac <atcab_write_ecc_config_zone+0x454>
				break;

			execution_time = atGetExecTime( _gCommandObj, CMD_WRITEMEM);
    c248:	4b4d      	ldr	r3, [pc, #308]	; (c380 <atcab_write_ecc_config_zone+0x428>)
    c24a:	681b      	ldr	r3, [r3, #0]
    c24c:	229a      	movs	r2, #154	; 0x9a
    c24e:	18bc      	adds	r4, r7, r2
    c250:	2114      	movs	r1, #20
    c252:	0018      	movs	r0, r3
    c254:	4b4c      	ldr	r3, [pc, #304]	; (c388 <atcab_write_ecc_config_zone+0x430>)
    c256:	4798      	blx	r3
    c258:	0003      	movs	r3, r0
    c25a:	8023      	strh	r3, [r4, #0]

			if ( (status = atcab_wakeup()) != ATCA_SUCCESS ) break;
    c25c:	239f      	movs	r3, #159	; 0x9f
    c25e:	18fc      	adds	r4, r7, r3
    c260:	4b4a      	ldr	r3, [pc, #296]	; (c38c <atcab_write_ecc_config_zone+0x434>)
    c262:	4798      	blx	r3
    c264:	0003      	movs	r3, r0
    c266:	7023      	strb	r3, [r4, #0]
    c268:	239f      	movs	r3, #159	; 0x9f
    c26a:	18fb      	adds	r3, r7, r3
    c26c:	781b      	ldrb	r3, [r3, #0]
    c26e:	2b00      	cmp	r3, #0
    c270:	d000      	beq.n	c274 <atcab_write_ecc_config_zone+0x31c>
    c272:	e09d      	b.n	c3b0 <atcab_write_ecc_config_zone+0x458>

			// send the command
			if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
    c274:	4b46      	ldr	r3, [pc, #280]	; (c390 <atcab_write_ecc_config_zone+0x438>)
    c276:	6818      	ldr	r0, [r3, #0]
    c278:	230c      	movs	r3, #12
    c27a:	18fb      	adds	r3, r7, r3
    c27c:	785b      	ldrb	r3, [r3, #1]
    c27e:	001a      	movs	r2, r3
    c280:	239f      	movs	r3, #159	; 0x9f
    c282:	18fc      	adds	r4, r7, r3
    c284:	230c      	movs	r3, #12
    c286:	18fb      	adds	r3, r7, r3
    c288:	0019      	movs	r1, r3
    c28a:	4b42      	ldr	r3, [pc, #264]	; (c394 <atcab_write_ecc_config_zone+0x43c>)
    c28c:	4798      	blx	r3
    c28e:	0003      	movs	r3, r0
    c290:	7023      	strb	r3, [r4, #0]
    c292:	239f      	movs	r3, #159	; 0x9f
    c294:	18fb      	adds	r3, r7, r3
    c296:	781b      	ldrb	r3, [r3, #0]
    c298:	2b00      	cmp	r3, #0
    c29a:	d000      	beq.n	c29e <atcab_write_ecc_config_zone+0x346>
    c29c:	e08a      	b.n	c3b4 <atcab_write_ecc_config_zone+0x45c>
				break;

			// delay the appropriate amount of time for command to execute
			atca_delay_ms(execution_time);
    c29e:	239a      	movs	r3, #154	; 0x9a
    c2a0:	18fb      	adds	r3, r7, r3
    c2a2:	881b      	ldrh	r3, [r3, #0]
    c2a4:	0018      	movs	r0, r3
    c2a6:	4b3c      	ldr	r3, [pc, #240]	; (c398 <atcab_write_ecc_config_zone+0x440>)
    c2a8:	4798      	blx	r3

			// receive the response
			if ( (status = atreceive( _gIface, packet.data, &packet.rxsize)) != ATCA_SUCCESS )
    c2aa:	4b39      	ldr	r3, [pc, #228]	; (c390 <atcab_write_ecc_config_zone+0x438>)
    c2ac:	6818      	ldr	r0, [r3, #0]
    c2ae:	239f      	movs	r3, #159	; 0x9f
    c2b0:	18fc      	adds	r4, r7, r3
    c2b2:	230c      	movs	r3, #12
    c2b4:	18fb      	adds	r3, r7, r3
    c2b6:	338a      	adds	r3, #138	; 0x8a
    c2b8:	001a      	movs	r2, r3
    c2ba:	230c      	movs	r3, #12
    c2bc:	18fb      	adds	r3, r7, r3
    c2be:	3306      	adds	r3, #6
    c2c0:	0019      	movs	r1, r3
    c2c2:	4b36      	ldr	r3, [pc, #216]	; (c39c <atcab_write_ecc_config_zone+0x444>)
    c2c4:	4798      	blx	r3
    c2c6:	0003      	movs	r3, r0
    c2c8:	7023      	strb	r3, [r4, #0]
    c2ca:	239f      	movs	r3, #159	; 0x9f
    c2cc:	18fb      	adds	r3, r7, r3
    c2ce:	781b      	ldrb	r3, [r3, #0]
    c2d0:	2b00      	cmp	r3, #0
    c2d2:	d000      	beq.n	c2d6 <atcab_write_ecc_config_zone+0x37e>
    c2d4:	e070      	b.n	c3b8 <atcab_write_ecc_config_zone+0x460>
				break;

			// Check response size
			if (packet.rxsize < 4) {
    c2d6:	230c      	movs	r3, #12
    c2d8:	18fb      	adds	r3, r7, r3
    c2da:	228a      	movs	r2, #138	; 0x8a
    c2dc:	5a9b      	ldrh	r3, [r3, r2]
    c2de:	2b03      	cmp	r3, #3
    c2e0:	d80f      	bhi.n	c302 <atcab_write_ecc_config_zone+0x3aa>
				if (packet.rxsize > 0)
    c2e2:	230c      	movs	r3, #12
    c2e4:	18fb      	adds	r3, r7, r3
    c2e6:	228a      	movs	r2, #138	; 0x8a
    c2e8:	5a9b      	ldrh	r3, [r3, r2]
    c2ea:	2b00      	cmp	r3, #0
    c2ec:	d004      	beq.n	c2f8 <atcab_write_ecc_config_zone+0x3a0>
					status = ATCA_RX_FAIL;
    c2ee:	239f      	movs	r3, #159	; 0x9f
    c2f0:	18fb      	adds	r3, r7, r3
    c2f2:	22e6      	movs	r2, #230	; 0xe6
    c2f4:	701a      	strb	r2, [r3, #0]
				else
					status = ATCA_RX_NO_RESPONSE;
				break;
    c2f6:	e064      	b.n	c3c2 <atcab_write_ecc_config_zone+0x46a>
			// Check response size
			if (packet.rxsize < 4) {
				if (packet.rxsize > 0)
					status = ATCA_RX_FAIL;
				else
					status = ATCA_RX_NO_RESPONSE;
    c2f8:	239f      	movs	r3, #159	; 0x9f
    c2fa:	18fb      	adds	r3, r7, r3
    c2fc:	22e7      	movs	r2, #231	; 0xe7
    c2fe:	701a      	strb	r2, [r3, #0]
				break;
    c300:	e05f      	b.n	c3c2 <atcab_write_ecc_config_zone+0x46a>
			}

			if ( (status = atcab_idle()) != ATCA_SUCCESS ) break;
    c302:	239f      	movs	r3, #159	; 0x9f
    c304:	18fc      	adds	r4, r7, r3
    c306:	4b26      	ldr	r3, [pc, #152]	; (c3a0 <atcab_write_ecc_config_zone+0x448>)
    c308:	4798      	blx	r3
    c30a:	0003      	movs	r3, r0
    c30c:	7023      	strb	r3, [r4, #0]
    c30e:	239f      	movs	r3, #159	; 0x9f
    c310:	18fb      	adds	r3, r7, r3
    c312:	781b      	ldrb	r3, [r3, #0]
    c314:	2b00      	cmp	r3, #0
    c316:	d151      	bne.n	c3bc <atcab_write_ecc_config_zone+0x464>

			if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
    c318:	239f      	movs	r3, #159	; 0x9f
    c31a:	18fc      	adds	r4, r7, r3
    c31c:	230c      	movs	r3, #12
    c31e:	18fb      	adds	r3, r7, r3
    c320:	3306      	adds	r3, #6
    c322:	0018      	movs	r0, r3
    c324:	4b1f      	ldr	r3, [pc, #124]	; (c3a4 <atcab_write_ecc_config_zone+0x44c>)
    c326:	4798      	blx	r3
    c328:	0003      	movs	r3, r0
    c32a:	7023      	strb	r3, [r4, #0]
    c32c:	239f      	movs	r3, #159	; 0x9f
    c32e:	18fb      	adds	r3, r7, r3
    c330:	781b      	ldrb	r3, [r3, #0]
    c332:	2b00      	cmp	r3, #0
    c334:	d144      	bne.n	c3c0 <atcab_write_ecc_config_zone+0x468>
				break;

			// update the word address after completely reading each block
			++block; offset = 0;
    c336:	239e      	movs	r3, #158	; 0x9e
    c338:	18fb      	adds	r3, r7, r3
    c33a:	229e      	movs	r2, #158	; 0x9e
    c33c:	18ba      	adds	r2, r7, r2
    c33e:	7812      	ldrb	r2, [r2, #0]
    c340:	3201      	adds	r2, #1
    c342:	701a      	strb	r2, [r3, #0]
    c344:	239d      	movs	r3, #157	; 0x9d
    c346:	18fb      	adds	r3, r7, r3
    c348:	2200      	movs	r2, #0
    c34a:	701a      	strb	r2, [r3, #0]
    c34c:	e000      	b.n	c350 <atcab_write_ecc_config_zone+0x3f8>
	// write the ecc zone one block at a time starting after address 0x04 (block 0, offset 4)
	offset = 4;
	do {
		if ((block == 0) || (block == 2)) {

			if (offset <= 7) {
    c34e:	46c0      	nop			; (mov r8, r8)

			// update the word address after completely reading each block
			++block; offset = 0;
		}

	} while (block <= 3);
    c350:	239e      	movs	r3, #158	; 0x9e
    c352:	18fb      	adds	r3, r7, r3
    c354:	781b      	ldrb	r3, [r3, #0]
    c356:	2b03      	cmp	r3, #3
    c358:	d800      	bhi.n	c35c <atcab_write_ecc_config_zone+0x404>
    c35a:	e625      	b.n	bfa8 <atcab_write_ecc_config_zone+0x50>
    c35c:	e031      	b.n	c3c2 <atcab_write_ecc_config_zone+0x46a>
				memset(packet.data, 0x00, 130);
				// read 4 bytes at once
				packet.param1 = ATCA_ZONE_CONFIG;
				// build a write command (write from the start)
				if ( (status = atcab_get_addr(zone, slot, block, offset, &addr)) != ATCA_SUCCESS )
					break;
    c35e:	46c0      	nop			; (mov r8, r8)
    c360:	e02f      	b.n	c3c2 <atcab_write_ecc_config_zone+0x46a>
				memcpy(&packet.data[0], &config_data[index + 16], ATCA_WORD_SIZE);
				index += ATCA_WORD_SIZE;
				status = atWrite(_gCommandObj, &packet);
				execution_time = atGetExecTime( _gCommandObj, CMD_WRITEMEM);

				if ( (status = atcab_wakeup()) != ATCA_SUCCESS ) break;
    c362:	46c0      	nop			; (mov r8, r8)
    c364:	e02d      	b.n	c3c2 <atcab_write_ecc_config_zone+0x46a>

				// send the command
				if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
					break;
    c366:	46c0      	nop			; (mov r8, r8)
    c368:	e02b      	b.n	c3c2 <atcab_write_ecc_config_zone+0x46a>
				// delay the appropriate amount of time for command to execute
				atca_delay_ms(execution_time);

				// receive the response
				if ( (status = atreceive( _gIface, packet.data, &packet.rxsize)) != ATCA_SUCCESS )
					break;
    c36a:	46c0      	nop			; (mov r8, r8)
    c36c:	e029      	b.n	c3c2 <atcab_write_ecc_config_zone+0x46a>
					else
						status = ATCA_RX_NO_RESPONSE;
					break;
				}

				if ( (status = atcab_idle()) != ATCA_SUCCESS ) break;
    c36e:	46c0      	nop			; (mov r8, r8)
    c370:	e027      	b.n	c3c2 <atcab_write_ecc_config_zone+0x46a>
    c372:	46c0      	nop			; (mov r8, r8)
    c374:	00012823 	.word	0x00012823
    c378:	0000b975 	.word	0x0000b975
    c37c:	000127e7 	.word	0x000127e7
    c380:	200007e4 	.word	0x200007e4
    c384:	0000a6e1 	.word	0x0000a6e1
    c388:	0000a7f5 	.word	0x0000a7f5
    c38c:	0000ad9d 	.word	0x0000ad9d
    c390:	200007e8 	.word	0x200007e8
    c394:	0000ab85 	.word	0x0000ab85
    c398:	0000e3d5 	.word	0x0000e3d5
    c39c:	0000aba9 	.word	0x0000aba9
    c3a0:	0000adcd 	.word	0x0000adcd
    c3a4:	0000a955 	.word	0x0000a955

				if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
					break;
    c3a8:	46c0      	nop			; (mov r8, r8)
    c3aa:	e00a      	b.n	c3c2 <atcab_write_ecc_config_zone+0x46a>
			atcab_get_addr(zone, slot, block, offset, &addr);
			packet.param2 =  addr;
			memcpy(&packet.data[0], &config_data[index + 16], ATCA_BLOCK_SIZE);
			index += ATCA_BLOCK_SIZE;
			if ( (status = atWrite(_gCommandObj, &packet)) != ATCA_SUCCESS )
				break;
    c3ac:	46c0      	nop			; (mov r8, r8)
    c3ae:	e008      	b.n	c3c2 <atcab_write_ecc_config_zone+0x46a>

			execution_time = atGetExecTime( _gCommandObj, CMD_WRITEMEM);

			if ( (status = atcab_wakeup()) != ATCA_SUCCESS ) break;
    c3b0:	46c0      	nop			; (mov r8, r8)
    c3b2:	e006      	b.n	c3c2 <atcab_write_ecc_config_zone+0x46a>

			// send the command
			if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
				break;
    c3b4:	46c0      	nop			; (mov r8, r8)
    c3b6:	e004      	b.n	c3c2 <atcab_write_ecc_config_zone+0x46a>
			// delay the appropriate amount of time for command to execute
			atca_delay_ms(execution_time);

			// receive the response
			if ( (status = atreceive( _gIface, packet.data, &packet.rxsize)) != ATCA_SUCCESS )
				break;
    c3b8:	46c0      	nop			; (mov r8, r8)
    c3ba:	e002      	b.n	c3c2 <atcab_write_ecc_config_zone+0x46a>
				else
					status = ATCA_RX_NO_RESPONSE;
				break;
			}

			if ( (status = atcab_idle()) != ATCA_SUCCESS ) break;
    c3bc:	46c0      	nop			; (mov r8, r8)
    c3be:	e000      	b.n	c3c2 <atcab_write_ecc_config_zone+0x46a>

			if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
				break;
    c3c0:	46c0      	nop			; (mov r8, r8)
			++block; offset = 0;
		}

	} while (block <= 3);

	_atcab_exit();
    c3c2:	4b04      	ldr	r3, [pc, #16]	; (c3d4 <atcab_write_ecc_config_zone+0x47c>)
    c3c4:	4798      	blx	r3
	return status;
    c3c6:	239f      	movs	r3, #159	; 0x9f
    c3c8:	18fb      	adds	r3, r7, r3
    c3ca:	781b      	ldrb	r3, [r3, #0]
}
    c3cc:	0018      	movs	r0, r3
    c3ce:	46bd      	mov	sp, r7
    c3d0:	b028      	add	sp, #160	; 0xa0
    c3d2:	bdb0      	pop	{r4, r5, r7, pc}
    c3d4:	0000ae2d 	.word	0x0000ae2d

0000c3d8 <atcab_lock_config_zone>:
 *
 *  \param[in] lock_response
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_lock_config_zone(uint8_t* lock_response)
{
    c3d8:	b590      	push	{r4, r7, lr}
    c3da:	b0a7      	sub	sp, #156	; 0x9c
    c3dc:	af00      	add	r7, sp, #0
    c3de:	6078      	str	r0, [r7, #4]
	ATCA_STATUS status = ATCA_GEN_FAIL;
    c3e0:	2397      	movs	r3, #151	; 0x97
    c3e2:	18fb      	adds	r3, r7, r3
    c3e4:	22e1      	movs	r2, #225	; 0xe1
    c3e6:	701a      	strb	r2, [r3, #0]
	ATCAPacket packet;
	uint16_t execution_time = 0;
    c3e8:	2394      	movs	r3, #148	; 0x94
    c3ea:	18fb      	adds	r3, r7, r3
    c3ec:	2200      	movs	r2, #0
    c3ee:	801a      	strh	r2, [r3, #0]

	// build command for lock zone and send
	packet.param1 = LOCK_ZONE_NO_CRC | LOCK_ZONE_CONFIG;
    c3f0:	2308      	movs	r3, #8
    c3f2:	18fb      	adds	r3, r7, r3
    c3f4:	2280      	movs	r2, #128	; 0x80
    c3f6:	70da      	strb	r2, [r3, #3]

	do {
		if ( (status = atLock(_gCommandObj, &packet)) != ATCA_SUCCESS ) break;
    c3f8:	4b49      	ldr	r3, [pc, #292]	; (c520 <atcab_lock_config_zone+0x148>)
    c3fa:	681b      	ldr	r3, [r3, #0]
    c3fc:	2297      	movs	r2, #151	; 0x97
    c3fe:	18bc      	adds	r4, r7, r2
    c400:	2208      	movs	r2, #8
    c402:	18ba      	adds	r2, r7, r2
    c404:	0011      	movs	r1, r2
    c406:	0018      	movs	r0, r3
    c408:	4b46      	ldr	r3, [pc, #280]	; (c524 <atcab_lock_config_zone+0x14c>)
    c40a:	4798      	blx	r3
    c40c:	0003      	movs	r3, r0
    c40e:	7023      	strb	r3, [r4, #0]
    c410:	2397      	movs	r3, #151	; 0x97
    c412:	18fb      	adds	r3, r7, r3
    c414:	781b      	ldrb	r3, [r3, #0]
    c416:	2b00      	cmp	r3, #0
    c418:	d000      	beq.n	c41c <atcab_lock_config_zone+0x44>
    c41a:	e06e      	b.n	c4fa <atcab_lock_config_zone+0x122>

		execution_time = atGetExecTime( _gCommandObj, CMD_LOCK);
    c41c:	4b40      	ldr	r3, [pc, #256]	; (c520 <atcab_lock_config_zone+0x148>)
    c41e:	681b      	ldr	r3, [r3, #0]
    c420:	2294      	movs	r2, #148	; 0x94
    c422:	18bc      	adds	r4, r7, r2
    c424:	2109      	movs	r1, #9
    c426:	0018      	movs	r0, r3
    c428:	4b3f      	ldr	r3, [pc, #252]	; (c528 <atcab_lock_config_zone+0x150>)
    c42a:	4798      	blx	r3
    c42c:	0003      	movs	r3, r0
    c42e:	8023      	strh	r3, [r4, #0]

		if ( (status = atcab_wakeup()) != ATCA_SUCCESS ) break;
    c430:	2397      	movs	r3, #151	; 0x97
    c432:	18fc      	adds	r4, r7, r3
    c434:	4b3d      	ldr	r3, [pc, #244]	; (c52c <atcab_lock_config_zone+0x154>)
    c436:	4798      	blx	r3
    c438:	0003      	movs	r3, r0
    c43a:	7023      	strb	r3, [r4, #0]
    c43c:	2397      	movs	r3, #151	; 0x97
    c43e:	18fb      	adds	r3, r7, r3
    c440:	781b      	ldrb	r3, [r3, #0]
    c442:	2b00      	cmp	r3, #0
    c444:	d15b      	bne.n	c4fe <atcab_lock_config_zone+0x126>

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
    c446:	4b3a      	ldr	r3, [pc, #232]	; (c530 <atcab_lock_config_zone+0x158>)
    c448:	6818      	ldr	r0, [r3, #0]
    c44a:	2308      	movs	r3, #8
    c44c:	18fb      	adds	r3, r7, r3
    c44e:	785b      	ldrb	r3, [r3, #1]
    c450:	001a      	movs	r2, r3
    c452:	2397      	movs	r3, #151	; 0x97
    c454:	18fc      	adds	r4, r7, r3
    c456:	2308      	movs	r3, #8
    c458:	18fb      	adds	r3, r7, r3
    c45a:	0019      	movs	r1, r3
    c45c:	4b35      	ldr	r3, [pc, #212]	; (c534 <atcab_lock_config_zone+0x15c>)
    c45e:	4798      	blx	r3
    c460:	0003      	movs	r3, r0
    c462:	7023      	strb	r3, [r4, #0]
    c464:	2397      	movs	r3, #151	; 0x97
    c466:	18fb      	adds	r3, r7, r3
    c468:	781b      	ldrb	r3, [r3, #0]
    c46a:	2b00      	cmp	r3, #0
    c46c:	d149      	bne.n	c502 <atcab_lock_config_zone+0x12a>
			break;

		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);
    c46e:	2394      	movs	r3, #148	; 0x94
    c470:	18fb      	adds	r3, r7, r3
    c472:	881b      	ldrh	r3, [r3, #0]
    c474:	0018      	movs	r0, r3
    c476:	4b30      	ldr	r3, [pc, #192]	; (c538 <atcab_lock_config_zone+0x160>)
    c478:	4798      	blx	r3

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &packet.rxsize)) != ATCA_SUCCESS )
    c47a:	4b2d      	ldr	r3, [pc, #180]	; (c530 <atcab_lock_config_zone+0x158>)
    c47c:	6818      	ldr	r0, [r3, #0]
    c47e:	2397      	movs	r3, #151	; 0x97
    c480:	18fc      	adds	r4, r7, r3
    c482:	2308      	movs	r3, #8
    c484:	18fb      	adds	r3, r7, r3
    c486:	338a      	adds	r3, #138	; 0x8a
    c488:	001a      	movs	r2, r3
    c48a:	2308      	movs	r3, #8
    c48c:	18fb      	adds	r3, r7, r3
    c48e:	3306      	adds	r3, #6
    c490:	0019      	movs	r1, r3
    c492:	4b2a      	ldr	r3, [pc, #168]	; (c53c <atcab_lock_config_zone+0x164>)
    c494:	4798      	blx	r3
    c496:	0003      	movs	r3, r0
    c498:	7023      	strb	r3, [r4, #0]
    c49a:	2397      	movs	r3, #151	; 0x97
    c49c:	18fb      	adds	r3, r7, r3
    c49e:	781b      	ldrb	r3, [r3, #0]
    c4a0:	2b00      	cmp	r3, #0
    c4a2:	d130      	bne.n	c506 <atcab_lock_config_zone+0x12e>
			break;

		// Check response size
		if (packet.rxsize < 4) {
    c4a4:	2308      	movs	r3, #8
    c4a6:	18fb      	adds	r3, r7, r3
    c4a8:	228a      	movs	r2, #138	; 0x8a
    c4aa:	5a9b      	ldrh	r3, [r3, r2]
    c4ac:	2b03      	cmp	r3, #3
    c4ae:	d80f      	bhi.n	c4d0 <atcab_lock_config_zone+0xf8>
			if (packet.rxsize > 0)
    c4b0:	2308      	movs	r3, #8
    c4b2:	18fb      	adds	r3, r7, r3
    c4b4:	228a      	movs	r2, #138	; 0x8a
    c4b6:	5a9b      	ldrh	r3, [r3, r2]
    c4b8:	2b00      	cmp	r3, #0
    c4ba:	d004      	beq.n	c4c6 <atcab_lock_config_zone+0xee>
				status = ATCA_RX_FAIL;
    c4bc:	2397      	movs	r3, #151	; 0x97
    c4be:	18fb      	adds	r3, r7, r3
    c4c0:	22e6      	movs	r2, #230	; 0xe6
    c4c2:	701a      	strb	r2, [r3, #0]
			else
				status = ATCA_RX_NO_RESPONSE;
			break;
    c4c4:	e022      	b.n	c50c <atcab_lock_config_zone+0x134>
		// Check response size
		if (packet.rxsize < 4) {
			if (packet.rxsize > 0)
				status = ATCA_RX_FAIL;
			else
				status = ATCA_RX_NO_RESPONSE;
    c4c6:	2397      	movs	r3, #151	; 0x97
    c4c8:	18fb      	adds	r3, r7, r3
    c4ca:	22e7      	movs	r2, #231	; 0xe7
    c4cc:	701a      	strb	r2, [r3, #0]
			break;
    c4ce:	e01d      	b.n	c50c <atcab_lock_config_zone+0x134>
		}

		//check the response for error
		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
    c4d0:	2397      	movs	r3, #151	; 0x97
    c4d2:	18fc      	adds	r4, r7, r3
    c4d4:	2308      	movs	r3, #8
    c4d6:	18fb      	adds	r3, r7, r3
    c4d8:	3306      	adds	r3, #6
    c4da:	0018      	movs	r0, r3
    c4dc:	4b18      	ldr	r3, [pc, #96]	; (c540 <atcab_lock_config_zone+0x168>)
    c4de:	4798      	blx	r3
    c4e0:	0003      	movs	r3, r0
    c4e2:	7023      	strb	r3, [r4, #0]
    c4e4:	2397      	movs	r3, #151	; 0x97
    c4e6:	18fb      	adds	r3, r7, r3
    c4e8:	781b      	ldrb	r3, [r3, #0]
    c4ea:	2b00      	cmp	r3, #0
    c4ec:	d10d      	bne.n	c50a <atcab_lock_config_zone+0x132>
			break;

		memcpy(lock_response, &packet.data[1], 1);
    c4ee:	2308      	movs	r3, #8
    c4f0:	18fb      	adds	r3, r7, r3
    c4f2:	79da      	ldrb	r2, [r3, #7]
    c4f4:	687b      	ldr	r3, [r7, #4]
    c4f6:	701a      	strb	r2, [r3, #0]
    c4f8:	e008      	b.n	c50c <atcab_lock_config_zone+0x134>

	// build command for lock zone and send
	packet.param1 = LOCK_ZONE_NO_CRC | LOCK_ZONE_CONFIG;

	do {
		if ( (status = atLock(_gCommandObj, &packet)) != ATCA_SUCCESS ) break;
    c4fa:	46c0      	nop			; (mov r8, r8)
    c4fc:	e006      	b.n	c50c <atcab_lock_config_zone+0x134>

		execution_time = atGetExecTime( _gCommandObj, CMD_LOCK);

		if ( (status = atcab_wakeup()) != ATCA_SUCCESS ) break;
    c4fe:	46c0      	nop			; (mov r8, r8)
    c500:	e004      	b.n	c50c <atcab_lock_config_zone+0x134>

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
			break;
    c502:	46c0      	nop			; (mov r8, r8)
    c504:	e002      	b.n	c50c <atcab_lock_config_zone+0x134>
		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &packet.rxsize)) != ATCA_SUCCESS )
			break;
    c506:	46c0      	nop			; (mov r8, r8)
    c508:	e000      	b.n	c50c <atcab_lock_config_zone+0x134>
			break;
		}

		//check the response for error
		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
			break;
    c50a:	46c0      	nop			; (mov r8, r8)

		memcpy(lock_response, &packet.data[1], 1);
	} while (0);

	_atcab_exit();
    c50c:	4b0d      	ldr	r3, [pc, #52]	; (c544 <atcab_lock_config_zone+0x16c>)
    c50e:	4798      	blx	r3
	return status;
    c510:	2397      	movs	r3, #151	; 0x97
    c512:	18fb      	adds	r3, r7, r3
    c514:	781b      	ldrb	r3, [r3, #0]
}
    c516:	0018      	movs	r0, r3
    c518:	46bd      	mov	sp, r7
    c51a:	b027      	add	sp, #156	; 0x9c
    c51c:	bd90      	pop	{r4, r7, pc}
    c51e:	46c0      	nop			; (mov r8, r8)
    c520:	200007e4 	.word	0x200007e4
    c524:	0000a4f9 	.word	0x0000a4f9
    c528:	0000a7f5 	.word	0x0000a7f5
    c52c:	0000ad9d 	.word	0x0000ad9d
    c530:	200007e8 	.word	0x200007e8
    c534:	0000ab85 	.word	0x0000ab85
    c538:	0000e3d5 	.word	0x0000e3d5
    c53c:	0000aba9 	.word	0x0000aba9
    c540:	0000a955 	.word	0x0000a955
    c544:	0000ae2d 	.word	0x0000ae2d

0000c548 <atcab_lock_data_zone>:
 *
 *  \param[in] lock_response
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_lock_data_zone(uint8_t* lock_response)
{
    c548:	b590      	push	{r4, r7, lr}
    c54a:	b0a7      	sub	sp, #156	; 0x9c
    c54c:	af00      	add	r7, sp, #0
    c54e:	6078      	str	r0, [r7, #4]
	ATCA_STATUS status = ATCA_GEN_FAIL;
    c550:	2397      	movs	r3, #151	; 0x97
    c552:	18fb      	adds	r3, r7, r3
    c554:	22e1      	movs	r2, #225	; 0xe1
    c556:	701a      	strb	r2, [r3, #0]
	ATCAPacket packet;
	uint16_t execution_time = 0;
    c558:	2394      	movs	r3, #148	; 0x94
    c55a:	18fb      	adds	r3, r7, r3
    c55c:	2200      	movs	r2, #0
    c55e:	801a      	strh	r2, [r3, #0]

	// build command for lock zone and send
	packet.param1 = LOCK_ZONE_NO_CRC | LOCK_ZONE_DATA;
    c560:	2308      	movs	r3, #8
    c562:	18fb      	adds	r3, r7, r3
    c564:	2281      	movs	r2, #129	; 0x81
    c566:	70da      	strb	r2, [r3, #3]
	packet.param2 = 0x0000;
    c568:	2308      	movs	r3, #8
    c56a:	18fb      	adds	r3, r7, r3
    c56c:	2200      	movs	r2, #0
    c56e:	809a      	strh	r2, [r3, #4]

	do {
		status = atLock(_gCommandObj, &packet);
    c570:	4b45      	ldr	r3, [pc, #276]	; (c688 <atcab_lock_data_zone+0x140>)
    c572:	681b      	ldr	r3, [r3, #0]
    c574:	2297      	movs	r2, #151	; 0x97
    c576:	18bc      	adds	r4, r7, r2
    c578:	2208      	movs	r2, #8
    c57a:	18ba      	adds	r2, r7, r2
    c57c:	0011      	movs	r1, r2
    c57e:	0018      	movs	r0, r3
    c580:	4b42      	ldr	r3, [pc, #264]	; (c68c <atcab_lock_data_zone+0x144>)
    c582:	4798      	blx	r3
    c584:	0003      	movs	r3, r0
    c586:	7023      	strb	r3, [r4, #0]
		execution_time = atGetExecTime( _gCommandObj, CMD_LOCK);
    c588:	4b3f      	ldr	r3, [pc, #252]	; (c688 <atcab_lock_data_zone+0x140>)
    c58a:	681b      	ldr	r3, [r3, #0]
    c58c:	2294      	movs	r2, #148	; 0x94
    c58e:	18bc      	adds	r4, r7, r2
    c590:	2109      	movs	r1, #9
    c592:	0018      	movs	r0, r3
    c594:	4b3e      	ldr	r3, [pc, #248]	; (c690 <atcab_lock_data_zone+0x148>)
    c596:	4798      	blx	r3
    c598:	0003      	movs	r3, r0
    c59a:	8023      	strh	r3, [r4, #0]

		if ((status = atcab_wakeup()) != ATCA_SUCCESS ) break;
    c59c:	2397      	movs	r3, #151	; 0x97
    c59e:	18fc      	adds	r4, r7, r3
    c5a0:	4b3c      	ldr	r3, [pc, #240]	; (c694 <atcab_lock_data_zone+0x14c>)
    c5a2:	4798      	blx	r3
    c5a4:	0003      	movs	r3, r0
    c5a6:	7023      	strb	r3, [r4, #0]
    c5a8:	2397      	movs	r3, #151	; 0x97
    c5aa:	18fb      	adds	r3, r7, r3
    c5ac:	781b      	ldrb	r3, [r3, #0]
    c5ae:	2b00      	cmp	r3, #0
    c5b0:	d159      	bne.n	c666 <atcab_lock_data_zone+0x11e>

		// send the command
		if ((status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
    c5b2:	4b39      	ldr	r3, [pc, #228]	; (c698 <atcab_lock_data_zone+0x150>)
    c5b4:	6818      	ldr	r0, [r3, #0]
    c5b6:	2308      	movs	r3, #8
    c5b8:	18fb      	adds	r3, r7, r3
    c5ba:	785b      	ldrb	r3, [r3, #1]
    c5bc:	001a      	movs	r2, r3
    c5be:	2397      	movs	r3, #151	; 0x97
    c5c0:	18fc      	adds	r4, r7, r3
    c5c2:	2308      	movs	r3, #8
    c5c4:	18fb      	adds	r3, r7, r3
    c5c6:	0019      	movs	r1, r3
    c5c8:	4b34      	ldr	r3, [pc, #208]	; (c69c <atcab_lock_data_zone+0x154>)
    c5ca:	4798      	blx	r3
    c5cc:	0003      	movs	r3, r0
    c5ce:	7023      	strb	r3, [r4, #0]
    c5d0:	2397      	movs	r3, #151	; 0x97
    c5d2:	18fb      	adds	r3, r7, r3
    c5d4:	781b      	ldrb	r3, [r3, #0]
    c5d6:	2b00      	cmp	r3, #0
    c5d8:	d147      	bne.n	c66a <atcab_lock_data_zone+0x122>
			break;

		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);
    c5da:	2394      	movs	r3, #148	; 0x94
    c5dc:	18fb      	adds	r3, r7, r3
    c5de:	881b      	ldrh	r3, [r3, #0]
    c5e0:	0018      	movs	r0, r3
    c5e2:	4b2f      	ldr	r3, [pc, #188]	; (c6a0 <atcab_lock_data_zone+0x158>)
    c5e4:	4798      	blx	r3

		// receive the response
		if ((status = atreceive( _gIface, packet.data, &packet.rxsize)) != ATCA_SUCCESS )
    c5e6:	4b2c      	ldr	r3, [pc, #176]	; (c698 <atcab_lock_data_zone+0x150>)
    c5e8:	6818      	ldr	r0, [r3, #0]
    c5ea:	2397      	movs	r3, #151	; 0x97
    c5ec:	18fc      	adds	r4, r7, r3
    c5ee:	2308      	movs	r3, #8
    c5f0:	18fb      	adds	r3, r7, r3
    c5f2:	338a      	adds	r3, #138	; 0x8a
    c5f4:	001a      	movs	r2, r3
    c5f6:	2308      	movs	r3, #8
    c5f8:	18fb      	adds	r3, r7, r3
    c5fa:	3306      	adds	r3, #6
    c5fc:	0019      	movs	r1, r3
    c5fe:	4b29      	ldr	r3, [pc, #164]	; (c6a4 <atcab_lock_data_zone+0x15c>)
    c600:	4798      	blx	r3
    c602:	0003      	movs	r3, r0
    c604:	7023      	strb	r3, [r4, #0]
    c606:	2397      	movs	r3, #151	; 0x97
    c608:	18fb      	adds	r3, r7, r3
    c60a:	781b      	ldrb	r3, [r3, #0]
    c60c:	2b00      	cmp	r3, #0
    c60e:	d12e      	bne.n	c66e <atcab_lock_data_zone+0x126>
			break;

		// Check response size
		if (packet.rxsize < 4) {
    c610:	2308      	movs	r3, #8
    c612:	18fb      	adds	r3, r7, r3
    c614:	228a      	movs	r2, #138	; 0x8a
    c616:	5a9b      	ldrh	r3, [r3, r2]
    c618:	2b03      	cmp	r3, #3
    c61a:	d80f      	bhi.n	c63c <atcab_lock_data_zone+0xf4>
			if (packet.rxsize > 0)
    c61c:	2308      	movs	r3, #8
    c61e:	18fb      	adds	r3, r7, r3
    c620:	228a      	movs	r2, #138	; 0x8a
    c622:	5a9b      	ldrh	r3, [r3, r2]
    c624:	2b00      	cmp	r3, #0
    c626:	d004      	beq.n	c632 <atcab_lock_data_zone+0xea>
				status = ATCA_RX_FAIL;
    c628:	2397      	movs	r3, #151	; 0x97
    c62a:	18fb      	adds	r3, r7, r3
    c62c:	22e6      	movs	r2, #230	; 0xe6
    c62e:	701a      	strb	r2, [r3, #0]
			else
				status = ATCA_RX_NO_RESPONSE;
			break;
    c630:	e020      	b.n	c674 <atcab_lock_data_zone+0x12c>
		// Check response size
		if (packet.rxsize < 4) {
			if (packet.rxsize > 0)
				status = ATCA_RX_FAIL;
			else
				status = ATCA_RX_NO_RESPONSE;
    c632:	2397      	movs	r3, #151	; 0x97
    c634:	18fb      	adds	r3, r7, r3
    c636:	22e7      	movs	r2, #231	; 0xe7
    c638:	701a      	strb	r2, [r3, #0]
			break;
    c63a:	e01b      	b.n	c674 <atcab_lock_data_zone+0x12c>
		}

		//check the response for error
		if ((status = isATCAError(packet.data)) != ATCA_SUCCESS )
    c63c:	2397      	movs	r3, #151	; 0x97
    c63e:	18fc      	adds	r4, r7, r3
    c640:	2308      	movs	r3, #8
    c642:	18fb      	adds	r3, r7, r3
    c644:	3306      	adds	r3, #6
    c646:	0018      	movs	r0, r3
    c648:	4b17      	ldr	r3, [pc, #92]	; (c6a8 <atcab_lock_data_zone+0x160>)
    c64a:	4798      	blx	r3
    c64c:	0003      	movs	r3, r0
    c64e:	7023      	strb	r3, [r4, #0]
    c650:	2397      	movs	r3, #151	; 0x97
    c652:	18fb      	adds	r3, r7, r3
    c654:	781b      	ldrb	r3, [r3, #0]
    c656:	2b00      	cmp	r3, #0
    c658:	d10b      	bne.n	c672 <atcab_lock_data_zone+0x12a>
			break;

		memcpy(lock_response, &packet.data[1], 1);
    c65a:	2308      	movs	r3, #8
    c65c:	18fb      	adds	r3, r7, r3
    c65e:	79da      	ldrb	r2, [r3, #7]
    c660:	687b      	ldr	r3, [r7, #4]
    c662:	701a      	strb	r2, [r3, #0]
    c664:	e006      	b.n	c674 <atcab_lock_data_zone+0x12c>

	do {
		status = atLock(_gCommandObj, &packet);
		execution_time = atGetExecTime( _gCommandObj, CMD_LOCK);

		if ((status = atcab_wakeup()) != ATCA_SUCCESS ) break;
    c666:	46c0      	nop			; (mov r8, r8)
    c668:	e004      	b.n	c674 <atcab_lock_data_zone+0x12c>

		// send the command
		if ((status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
			break;
    c66a:	46c0      	nop			; (mov r8, r8)
    c66c:	e002      	b.n	c674 <atcab_lock_data_zone+0x12c>
		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);

		// receive the response
		if ((status = atreceive( _gIface, packet.data, &packet.rxsize)) != ATCA_SUCCESS )
			break;
    c66e:	46c0      	nop			; (mov r8, r8)
    c670:	e000      	b.n	c674 <atcab_lock_data_zone+0x12c>
			break;
		}

		//check the response for error
		if ((status = isATCAError(packet.data)) != ATCA_SUCCESS )
			break;
    c672:	46c0      	nop			; (mov r8, r8)

		memcpy(lock_response, &packet.data[1], 1);
	} while (0);

	_atcab_exit();
    c674:	4b0d      	ldr	r3, [pc, #52]	; (c6ac <atcab_lock_data_zone+0x164>)
    c676:	4798      	blx	r3
	return status;
    c678:	2397      	movs	r3, #151	; 0x97
    c67a:	18fb      	adds	r3, r7, r3
    c67c:	781b      	ldrb	r3, [r3, #0]
}
    c67e:	0018      	movs	r0, r3
    c680:	46bd      	mov	sp, r7
    c682:	b027      	add	sp, #156	; 0x9c
    c684:	bd90      	pop	{r4, r7, pc}
    c686:	46c0      	nop			; (mov r8, r8)
    c688:	200007e4 	.word	0x200007e4
    c68c:	0000a4f9 	.word	0x0000a4f9
    c690:	0000a7f5 	.word	0x0000a7f5
    c694:	0000ad9d 	.word	0x0000ad9d
    c698:	200007e8 	.word	0x200007e8
    c69c:	0000ab85 	.word	0x0000ab85
    c6a0:	0000e3d5 	.word	0x0000e3d5
    c6a4:	0000aba9 	.word	0x0000aba9
    c6a8:	0000a955 	.word	0x0000a955
    c6ac:	0000ae2d 	.word	0x0000ae2d

0000c6b0 <atcab_sign>:
 *  \param[in] msg should point to a 32 byte buffer
 *  \param[out] signature of msg. signature should point to buffer SIGN_RSP_SIZE big
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_sign(uint16_t slot, const uint8_t *msg, uint8_t *signature)
{
    c6b0:	b590      	push	{r4, r7, lr}
    c6b2:	b0b9      	sub	sp, #228	; 0xe4
    c6b4:	af00      	add	r7, sp, #0
    c6b6:	60b9      	str	r1, [r7, #8]
    c6b8:	607a      	str	r2, [r7, #4]
    c6ba:	230e      	movs	r3, #14
    c6bc:	18fb      	adds	r3, r7, r3
    c6be:	1c02      	adds	r2, r0, #0
    c6c0:	801a      	strh	r2, [r3, #0]
	ATCA_STATUS status = ATCA_GEN_FAIL;
    c6c2:	23df      	movs	r3, #223	; 0xdf
    c6c4:	18fb      	adds	r3, r7, r3
    c6c6:	22e1      	movs	r2, #225	; 0xe1
    c6c8:	701a      	strb	r2, [r3, #0]
	ATCAPacket packet;
	uint16_t execution_time = 0;
    c6ca:	23dc      	movs	r3, #220	; 0xdc
    c6cc:	18fb      	adds	r3, r7, r3
    c6ce:	2200      	movs	r2, #0
    c6d0:	801a      	strh	r2, [r3, #0]
	uint8_t randomnum[64];

	if ( !_gDevice )
    c6d2:	4b62      	ldr	r3, [pc, #392]	; (c85c <atcab_sign+0x1ac>)
    c6d4:	681b      	ldr	r3, [r3, #0]
    c6d6:	2b00      	cmp	r3, #0
    c6d8:	d101      	bne.n	c6de <atcab_sign+0x2e>
		return ATCA_GEN_FAIL;
    c6da:	23e1      	movs	r3, #225	; 0xe1
    c6dc:	e0ba      	b.n	c854 <atcab_sign+0x1a4>

	do {
		if ( (status = atcab_random(randomnum)) != ATCA_SUCCESS ) break;
    c6de:	23df      	movs	r3, #223	; 0xdf
    c6e0:	18fc      	adds	r4, r7, r3
    c6e2:	2310      	movs	r3, #16
    c6e4:	18fb      	adds	r3, r7, r3
    c6e6:	0018      	movs	r0, r3
    c6e8:	4b5d      	ldr	r3, [pc, #372]	; (c860 <atcab_sign+0x1b0>)
    c6ea:	4798      	blx	r3
    c6ec:	0003      	movs	r3, r0
    c6ee:	7023      	strb	r3, [r4, #0]
    c6f0:	23df      	movs	r3, #223	; 0xdf
    c6f2:	18fb      	adds	r3, r7, r3
    c6f4:	781b      	ldrb	r3, [r3, #0]
    c6f6:	2b00      	cmp	r3, #0
    c6f8:	d000      	beq.n	c6fc <atcab_sign+0x4c>
    c6fa:	e099      	b.n	c830 <atcab_sign+0x180>
		if ( (status = atcab_challenge( msg )) != ATCA_SUCCESS ) break;
    c6fc:	23df      	movs	r3, #223	; 0xdf
    c6fe:	18fc      	adds	r4, r7, r3
    c700:	68bb      	ldr	r3, [r7, #8]
    c702:	0018      	movs	r0, r3
    c704:	4b57      	ldr	r3, [pc, #348]	; (c864 <atcab_sign+0x1b4>)
    c706:	4798      	blx	r3
    c708:	0003      	movs	r3, r0
    c70a:	7023      	strb	r3, [r4, #0]
    c70c:	23df      	movs	r3, #223	; 0xdf
    c70e:	18fb      	adds	r3, r7, r3
    c710:	781b      	ldrb	r3, [r3, #0]
    c712:	2b00      	cmp	r3, #0
    c714:	d000      	beq.n	c718 <atcab_sign+0x68>
    c716:	e08d      	b.n	c834 <atcab_sign+0x184>

		// build sign command
		packet.param1 = SIGN_MODE_EXTERNAL;
    c718:	2350      	movs	r3, #80	; 0x50
    c71a:	18fb      	adds	r3, r7, r3
    c71c:	2280      	movs	r2, #128	; 0x80
    c71e:	70da      	strb	r2, [r3, #3]
		packet.param2 = slot;
    c720:	2350      	movs	r3, #80	; 0x50
    c722:	18fb      	adds	r3, r7, r3
    c724:	220e      	movs	r2, #14
    c726:	18ba      	adds	r2, r7, r2
    c728:	8812      	ldrh	r2, [r2, #0]
    c72a:	809a      	strh	r2, [r3, #4]
		if ( (status = atSign( _gCommandObj, &packet )) != ATCA_SUCCESS )
    c72c:	4b4e      	ldr	r3, [pc, #312]	; (c868 <atcab_sign+0x1b8>)
    c72e:	681b      	ldr	r3, [r3, #0]
    c730:	22df      	movs	r2, #223	; 0xdf
    c732:	18bc      	adds	r4, r7, r2
    c734:	2250      	movs	r2, #80	; 0x50
    c736:	18ba      	adds	r2, r7, r2
    c738:	0011      	movs	r1, r2
    c73a:	0018      	movs	r0, r3
    c73c:	4b4b      	ldr	r3, [pc, #300]	; (c86c <atcab_sign+0x1bc>)
    c73e:	4798      	blx	r3
    c740:	0003      	movs	r3, r0
    c742:	7023      	strb	r3, [r4, #0]
    c744:	23df      	movs	r3, #223	; 0xdf
    c746:	18fb      	adds	r3, r7, r3
    c748:	781b      	ldrb	r3, [r3, #0]
    c74a:	2b00      	cmp	r3, #0
    c74c:	d000      	beq.n	c750 <atcab_sign+0xa0>
    c74e:	e073      	b.n	c838 <atcab_sign+0x188>
			break;

		execution_time = atGetExecTime( _gCommandObj, CMD_SIGN);
    c750:	4b45      	ldr	r3, [pc, #276]	; (c868 <atcab_sign+0x1b8>)
    c752:	681b      	ldr	r3, [r3, #0]
    c754:	22dc      	movs	r2, #220	; 0xdc
    c756:	18bc      	adds	r4, r7, r2
    c758:	2111      	movs	r1, #17
    c75a:	0018      	movs	r0, r3
    c75c:	4b44      	ldr	r3, [pc, #272]	; (c870 <atcab_sign+0x1c0>)
    c75e:	4798      	blx	r3
    c760:	0003      	movs	r3, r0
    c762:	8023      	strh	r3, [r4, #0]

		if ( (status != atcab_wakeup()) != ATCA_SUCCESS ) break;
    c764:	4b43      	ldr	r3, [pc, #268]	; (c874 <atcab_sign+0x1c4>)
    c766:	4798      	blx	r3
    c768:	0003      	movs	r3, r0
    c76a:	001a      	movs	r2, r3
    c76c:	23df      	movs	r3, #223	; 0xdf
    c76e:	18fb      	adds	r3, r7, r3
    c770:	781b      	ldrb	r3, [r3, #0]
    c772:	4293      	cmp	r3, r2
    c774:	d162      	bne.n	c83c <atcab_sign+0x18c>

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
    c776:	4b40      	ldr	r3, [pc, #256]	; (c878 <atcab_sign+0x1c8>)
    c778:	6818      	ldr	r0, [r3, #0]
    c77a:	2350      	movs	r3, #80	; 0x50
    c77c:	18fb      	adds	r3, r7, r3
    c77e:	785b      	ldrb	r3, [r3, #1]
    c780:	001a      	movs	r2, r3
    c782:	23df      	movs	r3, #223	; 0xdf
    c784:	18fc      	adds	r4, r7, r3
    c786:	2350      	movs	r3, #80	; 0x50
    c788:	18fb      	adds	r3, r7, r3
    c78a:	0019      	movs	r1, r3
    c78c:	4b3b      	ldr	r3, [pc, #236]	; (c87c <atcab_sign+0x1cc>)
    c78e:	4798      	blx	r3
    c790:	0003      	movs	r3, r0
    c792:	7023      	strb	r3, [r4, #0]
    c794:	23df      	movs	r3, #223	; 0xdf
    c796:	18fb      	adds	r3, r7, r3
    c798:	781b      	ldrb	r3, [r3, #0]
    c79a:	2b00      	cmp	r3, #0
    c79c:	d150      	bne.n	c840 <atcab_sign+0x190>
			break;

		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);
    c79e:	23dc      	movs	r3, #220	; 0xdc
    c7a0:	18fb      	adds	r3, r7, r3
    c7a2:	881b      	ldrh	r3, [r3, #0]
    c7a4:	0018      	movs	r0, r3
    c7a6:	4b36      	ldr	r3, [pc, #216]	; (c880 <atcab_sign+0x1d0>)
    c7a8:	4798      	blx	r3

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &(packet.rxsize))) != ATCA_SUCCESS )
    c7aa:	4b33      	ldr	r3, [pc, #204]	; (c878 <atcab_sign+0x1c8>)
    c7ac:	6818      	ldr	r0, [r3, #0]
    c7ae:	23df      	movs	r3, #223	; 0xdf
    c7b0:	18fc      	adds	r4, r7, r3
    c7b2:	2350      	movs	r3, #80	; 0x50
    c7b4:	18fb      	adds	r3, r7, r3
    c7b6:	338a      	adds	r3, #138	; 0x8a
    c7b8:	001a      	movs	r2, r3
    c7ba:	2350      	movs	r3, #80	; 0x50
    c7bc:	18fb      	adds	r3, r7, r3
    c7be:	3306      	adds	r3, #6
    c7c0:	0019      	movs	r1, r3
    c7c2:	4b30      	ldr	r3, [pc, #192]	; (c884 <atcab_sign+0x1d4>)
    c7c4:	4798      	blx	r3
    c7c6:	0003      	movs	r3, r0
    c7c8:	7023      	strb	r3, [r4, #0]
    c7ca:	23df      	movs	r3, #223	; 0xdf
    c7cc:	18fb      	adds	r3, r7, r3
    c7ce:	781b      	ldrb	r3, [r3, #0]
    c7d0:	2b00      	cmp	r3, #0
    c7d2:	d137      	bne.n	c844 <atcab_sign+0x194>
			break;

		// Check response size
		if (packet.rxsize < 4) {
    c7d4:	2350      	movs	r3, #80	; 0x50
    c7d6:	18fb      	adds	r3, r7, r3
    c7d8:	228a      	movs	r2, #138	; 0x8a
    c7da:	5a9b      	ldrh	r3, [r3, r2]
    c7dc:	2b03      	cmp	r3, #3
    c7de:	d80f      	bhi.n	c800 <atcab_sign+0x150>
			if (packet.rxsize > 0)
    c7e0:	2350      	movs	r3, #80	; 0x50
    c7e2:	18fb      	adds	r3, r7, r3
    c7e4:	228a      	movs	r2, #138	; 0x8a
    c7e6:	5a9b      	ldrh	r3, [r3, r2]
    c7e8:	2b00      	cmp	r3, #0
    c7ea:	d004      	beq.n	c7f6 <atcab_sign+0x146>
				status = ATCA_RX_FAIL;
    c7ec:	23df      	movs	r3, #223	; 0xdf
    c7ee:	18fb      	adds	r3, r7, r3
    c7f0:	22e6      	movs	r2, #230	; 0xe6
    c7f2:	701a      	strb	r2, [r3, #0]
			else
				status = ATCA_RX_NO_RESPONSE;
			break;
    c7f4:	e029      	b.n	c84a <atcab_sign+0x19a>
		// Check response size
		if (packet.rxsize < 4) {
			if (packet.rxsize > 0)
				status = ATCA_RX_FAIL;
			else
				status = ATCA_RX_NO_RESPONSE;
    c7f6:	23df      	movs	r3, #223	; 0xdf
    c7f8:	18fb      	adds	r3, r7, r3
    c7fa:	22e7      	movs	r2, #231	; 0xe7
    c7fc:	701a      	strb	r2, [r3, #0]
			break;
    c7fe:	e024      	b.n	c84a <atcab_sign+0x19a>
		}

		// check for response
		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
    c800:	23df      	movs	r3, #223	; 0xdf
    c802:	18fc      	adds	r4, r7, r3
    c804:	2350      	movs	r3, #80	; 0x50
    c806:	18fb      	adds	r3, r7, r3
    c808:	3306      	adds	r3, #6
    c80a:	0018      	movs	r0, r3
    c80c:	4b1e      	ldr	r3, [pc, #120]	; (c888 <atcab_sign+0x1d8>)
    c80e:	4798      	blx	r3
    c810:	0003      	movs	r3, r0
    c812:	7023      	strb	r3, [r4, #0]
    c814:	23df      	movs	r3, #223	; 0xdf
    c816:	18fb      	adds	r3, r7, r3
    c818:	781b      	ldrb	r3, [r3, #0]
    c81a:	2b00      	cmp	r3, #0
    c81c:	d114      	bne.n	c848 <atcab_sign+0x198>
			break;

		memcpy( signature, &packet.data[1], ATCA_SIG_SIZE );
    c81e:	2350      	movs	r3, #80	; 0x50
    c820:	18fb      	adds	r3, r7, r3
    c822:	1dd9      	adds	r1, r3, #7
    c824:	687b      	ldr	r3, [r7, #4]
    c826:	2240      	movs	r2, #64	; 0x40
    c828:	0018      	movs	r0, r3
    c82a:	4b18      	ldr	r3, [pc, #96]	; (c88c <atcab_sign+0x1dc>)
    c82c:	4798      	blx	r3
    c82e:	e00c      	b.n	c84a <atcab_sign+0x19a>

	if ( !_gDevice )
		return ATCA_GEN_FAIL;

	do {
		if ( (status = atcab_random(randomnum)) != ATCA_SUCCESS ) break;
    c830:	46c0      	nop			; (mov r8, r8)
    c832:	e00a      	b.n	c84a <atcab_sign+0x19a>
		if ( (status = atcab_challenge( msg )) != ATCA_SUCCESS ) break;
    c834:	46c0      	nop			; (mov r8, r8)
    c836:	e008      	b.n	c84a <atcab_sign+0x19a>

		// build sign command
		packet.param1 = SIGN_MODE_EXTERNAL;
		packet.param2 = slot;
		if ( (status = atSign( _gCommandObj, &packet )) != ATCA_SUCCESS )
			break;
    c838:	46c0      	nop			; (mov r8, r8)
    c83a:	e006      	b.n	c84a <atcab_sign+0x19a>

		execution_time = atGetExecTime( _gCommandObj, CMD_SIGN);

		if ( (status != atcab_wakeup()) != ATCA_SUCCESS ) break;
    c83c:	46c0      	nop			; (mov r8, r8)
    c83e:	e004      	b.n	c84a <atcab_sign+0x19a>

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
			break;
    c840:	46c0      	nop			; (mov r8, r8)
    c842:	e002      	b.n	c84a <atcab_sign+0x19a>
		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &(packet.rxsize))) != ATCA_SUCCESS )
			break;
    c844:	46c0      	nop			; (mov r8, r8)
    c846:	e000      	b.n	c84a <atcab_sign+0x19a>
			break;
		}

		// check for response
		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
			break;
    c848:	46c0      	nop			; (mov r8, r8)

		memcpy( signature, &packet.data[1], ATCA_SIG_SIZE );
	} while (0);

	_atcab_exit();
    c84a:	4b11      	ldr	r3, [pc, #68]	; (c890 <atcab_sign+0x1e0>)
    c84c:	4798      	blx	r3
	return status;
    c84e:	23df      	movs	r3, #223	; 0xdf
    c850:	18fb      	adds	r3, r7, r3
    c852:	781b      	ldrb	r3, [r3, #0]
}
    c854:	0018      	movs	r0, r3
    c856:	46bd      	mov	sp, r7
    c858:	b039      	add	sp, #228	; 0xe4
    c85a:	bd90      	pop	{r4, r7, pc}
    c85c:	200007e0 	.word	0x200007e0
    c860:	0000afd5 	.word	0x0000afd5
    c864:	0000b2fd 	.word	0x0000b2fd
    c868:	200007e4 	.word	0x200007e4
    c86c:	0000a645 	.word	0x0000a645
    c870:	0000a7f5 	.word	0x0000a7f5
    c874:	0000ad9d 	.word	0x0000ad9d
    c878:	200007e8 	.word	0x200007e8
    c87c:	0000ab85 	.word	0x0000ab85
    c880:	0000e3d5 	.word	0x0000e3d5
    c884:	0000aba9 	.word	0x0000aba9
    c888:	0000a955 	.word	0x0000a955
    c88c:	000127e7 	.word	0x000127e7
    c890:	0000ae2d 	.word	0x0000ae2d

0000c894 <atcab_gendig_host>:
 *  \param[in] other_data - pointer to 4 or 32 bytes of data depending upon the mode
 *  \param[in] len - length of data
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_gendig_host(uint8_t zone, uint16_t key_id, uint8_t *other_data, uint8_t len)
{
    c894:	b590      	push	{r4, r7, lr}
    c896:	b0a7      	sub	sp, #156	; 0x9c
    c898:	af00      	add	r7, sp, #0
    c89a:	0004      	movs	r4, r0
    c89c:	0008      	movs	r0, r1
    c89e:	603a      	str	r2, [r7, #0]
    c8a0:	0019      	movs	r1, r3
    c8a2:	1dfb      	adds	r3, r7, #7
    c8a4:	1c22      	adds	r2, r4, #0
    c8a6:	701a      	strb	r2, [r3, #0]
    c8a8:	1d3b      	adds	r3, r7, #4
    c8aa:	1c02      	adds	r2, r0, #0
    c8ac:	801a      	strh	r2, [r3, #0]
    c8ae:	1dbb      	adds	r3, r7, #6
    c8b0:	1c0a      	adds	r2, r1, #0
    c8b2:	701a      	strb	r2, [r3, #0]
	ATCA_STATUS status = ATCA_GEN_FAIL;
    c8b4:	2397      	movs	r3, #151	; 0x97
    c8b6:	18fb      	adds	r3, r7, r3
    c8b8:	22e1      	movs	r2, #225	; 0xe1
    c8ba:	701a      	strb	r2, [r3, #0]
	ATCAPacket packet;
	uint16_t execution_time = 0;
    c8bc:	2394      	movs	r3, #148	; 0x94
    c8be:	18fb      	adds	r3, r7, r3
    c8c0:	2200      	movs	r2, #0
    c8c2:	801a      	strh	r2, [r3, #0]
	bool hasMACKey = 0;
    c8c4:	2396      	movs	r3, #150	; 0x96
    c8c6:	18fb      	adds	r3, r7, r3
    c8c8:	2200      	movs	r2, #0
    c8ca:	701a      	strb	r2, [r3, #0]

	if ( !_gDevice || other_data == NULL )
    c8cc:	4b5f      	ldr	r3, [pc, #380]	; (ca4c <atcab_gendig_host+0x1b8>)
    c8ce:	681b      	ldr	r3, [r3, #0]
    c8d0:	2b00      	cmp	r3, #0
    c8d2:	d002      	beq.n	c8da <atcab_gendig_host+0x46>
    c8d4:	683b      	ldr	r3, [r7, #0]
    c8d6:	2b00      	cmp	r3, #0
    c8d8:	d101      	bne.n	c8de <atcab_gendig_host+0x4a>
		return ATCA_GEN_FAIL;
    c8da:	23e1      	movs	r3, #225	; 0xe1
    c8dc:	e0b2      	b.n	ca44 <atcab_gendig_host+0x1b0>

	do {

		// build gendig command
		packet.param1 = zone;
    c8de:	2308      	movs	r3, #8
    c8e0:	18fb      	adds	r3, r7, r3
    c8e2:	1dfa      	adds	r2, r7, #7
    c8e4:	7812      	ldrb	r2, [r2, #0]
    c8e6:	70da      	strb	r2, [r3, #3]
		packet.param2 = key_id;
    c8e8:	2308      	movs	r3, #8
    c8ea:	18fb      	adds	r3, r7, r3
    c8ec:	1d3a      	adds	r2, r7, #4
    c8ee:	8812      	ldrh	r2, [r2, #0]
    c8f0:	809a      	strh	r2, [r3, #4]

		if ( packet.param1 == 0x03 && len == 0x20)
    c8f2:	2308      	movs	r3, #8
    c8f4:	18fb      	adds	r3, r7, r3
    c8f6:	78db      	ldrb	r3, [r3, #3]
    c8f8:	2b03      	cmp	r3, #3
    c8fa:	d10c      	bne.n	c916 <atcab_gendig_host+0x82>
    c8fc:	1dbb      	adds	r3, r7, #6
    c8fe:	781b      	ldrb	r3, [r3, #0]
    c900:	2b20      	cmp	r3, #32
    c902:	d108      	bne.n	c916 <atcab_gendig_host+0x82>
			memcpy(&packet.data[0], &other_data[0], ATCA_WORD_SIZE);
    c904:	6839      	ldr	r1, [r7, #0]
    c906:	2308      	movs	r3, #8
    c908:	18fb      	adds	r3, r7, r3
    c90a:	3306      	adds	r3, #6
    c90c:	2204      	movs	r2, #4
    c90e:	0018      	movs	r0, r3
    c910:	4b4f      	ldr	r3, [pc, #316]	; (ca50 <atcab_gendig_host+0x1bc>)
    c912:	4798      	blx	r3
    c914:	e014      	b.n	c940 <atcab_gendig_host+0xac>
		else if ( packet.param1 == 0x02 && len == 0x20) {
    c916:	2308      	movs	r3, #8
    c918:	18fb      	adds	r3, r7, r3
    c91a:	78db      	ldrb	r3, [r3, #3]
    c91c:	2b02      	cmp	r3, #2
    c91e:	d10f      	bne.n	c940 <atcab_gendig_host+0xac>
    c920:	1dbb      	adds	r3, r7, #6
    c922:	781b      	ldrb	r3, [r3, #0]
    c924:	2b20      	cmp	r3, #32
    c926:	d10b      	bne.n	c940 <atcab_gendig_host+0xac>
			memcpy(&packet.data[0], &other_data[0], ATCA_WORD_SIZE);
    c928:	6839      	ldr	r1, [r7, #0]
    c92a:	2308      	movs	r3, #8
    c92c:	18fb      	adds	r3, r7, r3
    c92e:	3306      	adds	r3, #6
    c930:	2204      	movs	r2, #4
    c932:	0018      	movs	r0, r3
    c934:	4b46      	ldr	r3, [pc, #280]	; (ca50 <atcab_gendig_host+0x1bc>)
    c936:	4798      	blx	r3
			hasMACKey = true;
    c938:	2396      	movs	r3, #150	; 0x96
    c93a:	18fb      	adds	r3, r7, r3
    c93c:	2201      	movs	r2, #1
    c93e:	701a      	strb	r2, [r3, #0]
		}

		if ( (status = atGenDig( _gCommandObj, &packet, hasMACKey)) != ATCA_SUCCESS )
    c940:	4b44      	ldr	r3, [pc, #272]	; (ca54 <atcab_gendig_host+0x1c0>)
    c942:	6818      	ldr	r0, [r3, #0]
    c944:	2397      	movs	r3, #151	; 0x97
    c946:	18fc      	adds	r4, r7, r3
    c948:	2396      	movs	r3, #150	; 0x96
    c94a:	18fb      	adds	r3, r7, r3
    c94c:	781a      	ldrb	r2, [r3, #0]
    c94e:	2308      	movs	r3, #8
    c950:	18fb      	adds	r3, r7, r3
    c952:	0019      	movs	r1, r3
    c954:	4b40      	ldr	r3, [pc, #256]	; (ca58 <atcab_gendig_host+0x1c4>)
    c956:	4798      	blx	r3
    c958:	0003      	movs	r3, r0
    c95a:	7023      	strb	r3, [r4, #0]
    c95c:	2397      	movs	r3, #151	; 0x97
    c95e:	18fb      	adds	r3, r7, r3
    c960:	781b      	ldrb	r3, [r3, #0]
    c962:	2b00      	cmp	r3, #0
    c964:	d162      	bne.n	ca2c <atcab_gendig_host+0x198>
			break;

		execution_time = atGetExecTime( _gCommandObj, CMD_GENDIG);
    c966:	4b3b      	ldr	r3, [pc, #236]	; (ca54 <atcab_gendig_host+0x1c0>)
    c968:	681b      	ldr	r3, [r3, #0]
    c96a:	2294      	movs	r2, #148	; 0x94
    c96c:	18bc      	adds	r4, r7, r2
    c96e:	2105      	movs	r1, #5
    c970:	0018      	movs	r0, r3
    c972:	4b3a      	ldr	r3, [pc, #232]	; (ca5c <atcab_gendig_host+0x1c8>)
    c974:	4798      	blx	r3
    c976:	0003      	movs	r3, r0
    c978:	8023      	strh	r3, [r4, #0]

		if ( (status != atcab_wakeup()) != ATCA_SUCCESS ) break;
    c97a:	4b39      	ldr	r3, [pc, #228]	; (ca60 <atcab_gendig_host+0x1cc>)
    c97c:	4798      	blx	r3
    c97e:	0003      	movs	r3, r0
    c980:	001a      	movs	r2, r3
    c982:	2397      	movs	r3, #151	; 0x97
    c984:	18fb      	adds	r3, r7, r3
    c986:	781b      	ldrb	r3, [r3, #0]
    c988:	4293      	cmp	r3, r2
    c98a:	d151      	bne.n	ca30 <atcab_gendig_host+0x19c>

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
    c98c:	4b35      	ldr	r3, [pc, #212]	; (ca64 <atcab_gendig_host+0x1d0>)
    c98e:	6818      	ldr	r0, [r3, #0]
    c990:	2308      	movs	r3, #8
    c992:	18fb      	adds	r3, r7, r3
    c994:	785b      	ldrb	r3, [r3, #1]
    c996:	001a      	movs	r2, r3
    c998:	2397      	movs	r3, #151	; 0x97
    c99a:	18fc      	adds	r4, r7, r3
    c99c:	2308      	movs	r3, #8
    c99e:	18fb      	adds	r3, r7, r3
    c9a0:	0019      	movs	r1, r3
    c9a2:	4b31      	ldr	r3, [pc, #196]	; (ca68 <atcab_gendig_host+0x1d4>)
    c9a4:	4798      	blx	r3
    c9a6:	0003      	movs	r3, r0
    c9a8:	7023      	strb	r3, [r4, #0]
    c9aa:	2397      	movs	r3, #151	; 0x97
    c9ac:	18fb      	adds	r3, r7, r3
    c9ae:	781b      	ldrb	r3, [r3, #0]
    c9b0:	2b00      	cmp	r3, #0
    c9b2:	d13f      	bne.n	ca34 <atcab_gendig_host+0x1a0>
			break;

		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);
    c9b4:	2394      	movs	r3, #148	; 0x94
    c9b6:	18fb      	adds	r3, r7, r3
    c9b8:	881b      	ldrh	r3, [r3, #0]
    c9ba:	0018      	movs	r0, r3
    c9bc:	4b2b      	ldr	r3, [pc, #172]	; (ca6c <atcab_gendig_host+0x1d8>)
    c9be:	4798      	blx	r3

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &(packet.rxsize))) != ATCA_SUCCESS )
    c9c0:	4b28      	ldr	r3, [pc, #160]	; (ca64 <atcab_gendig_host+0x1d0>)
    c9c2:	6818      	ldr	r0, [r3, #0]
    c9c4:	2397      	movs	r3, #151	; 0x97
    c9c6:	18fc      	adds	r4, r7, r3
    c9c8:	2308      	movs	r3, #8
    c9ca:	18fb      	adds	r3, r7, r3
    c9cc:	338a      	adds	r3, #138	; 0x8a
    c9ce:	001a      	movs	r2, r3
    c9d0:	2308      	movs	r3, #8
    c9d2:	18fb      	adds	r3, r7, r3
    c9d4:	3306      	adds	r3, #6
    c9d6:	0019      	movs	r1, r3
    c9d8:	4b25      	ldr	r3, [pc, #148]	; (ca70 <atcab_gendig_host+0x1dc>)
    c9da:	4798      	blx	r3
    c9dc:	0003      	movs	r3, r0
    c9de:	7023      	strb	r3, [r4, #0]
    c9e0:	2397      	movs	r3, #151	; 0x97
    c9e2:	18fb      	adds	r3, r7, r3
    c9e4:	781b      	ldrb	r3, [r3, #0]
    c9e6:	2b00      	cmp	r3, #0
    c9e8:	d126      	bne.n	ca38 <atcab_gendig_host+0x1a4>
			break;

		// Check response size
		if (packet.rxsize < 4) {
    c9ea:	2308      	movs	r3, #8
    c9ec:	18fb      	adds	r3, r7, r3
    c9ee:	228a      	movs	r2, #138	; 0x8a
    c9f0:	5a9b      	ldrh	r3, [r3, r2]
    c9f2:	2b03      	cmp	r3, #3
    c9f4:	d80f      	bhi.n	ca16 <atcab_gendig_host+0x182>
			if (packet.rxsize > 0)
    c9f6:	2308      	movs	r3, #8
    c9f8:	18fb      	adds	r3, r7, r3
    c9fa:	228a      	movs	r2, #138	; 0x8a
    c9fc:	5a9b      	ldrh	r3, [r3, r2]
    c9fe:	2b00      	cmp	r3, #0
    ca00:	d004      	beq.n	ca0c <atcab_gendig_host+0x178>
				status = ATCA_RX_FAIL;
    ca02:	2397      	movs	r3, #151	; 0x97
    ca04:	18fb      	adds	r3, r7, r3
    ca06:	22e6      	movs	r2, #230	; 0xe6
    ca08:	701a      	strb	r2, [r3, #0]
			else
				status = ATCA_RX_NO_RESPONSE;
			break;
    ca0a:	e016      	b.n	ca3a <atcab_gendig_host+0x1a6>
		// Check response size
		if (packet.rxsize < 4) {
			if (packet.rxsize > 0)
				status = ATCA_RX_FAIL;
			else
				status = ATCA_RX_NO_RESPONSE;
    ca0c:	2397      	movs	r3, #151	; 0x97
    ca0e:	18fb      	adds	r3, r7, r3
    ca10:	22e7      	movs	r2, #231	; 0xe7
    ca12:	701a      	strb	r2, [r3, #0]
			break;
    ca14:	e011      	b.n	ca3a <atcab_gendig_host+0x1a6>
		}

		// check for response
		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
    ca16:	2397      	movs	r3, #151	; 0x97
    ca18:	18fc      	adds	r4, r7, r3
    ca1a:	2308      	movs	r3, #8
    ca1c:	18fb      	adds	r3, r7, r3
    ca1e:	3306      	adds	r3, #6
    ca20:	0018      	movs	r0, r3
    ca22:	4b14      	ldr	r3, [pc, #80]	; (ca74 <atcab_gendig_host+0x1e0>)
    ca24:	4798      	blx	r3
    ca26:	0003      	movs	r3, r0
    ca28:	7023      	strb	r3, [r4, #0]
    ca2a:	e006      	b.n	ca3a <atcab_gendig_host+0x1a6>
			memcpy(&packet.data[0], &other_data[0], ATCA_WORD_SIZE);
			hasMACKey = true;
		}

		if ( (status = atGenDig( _gCommandObj, &packet, hasMACKey)) != ATCA_SUCCESS )
			break;
    ca2c:	46c0      	nop			; (mov r8, r8)
    ca2e:	e004      	b.n	ca3a <atcab_gendig_host+0x1a6>

		execution_time = atGetExecTime( _gCommandObj, CMD_GENDIG);

		if ( (status != atcab_wakeup()) != ATCA_SUCCESS ) break;
    ca30:	46c0      	nop			; (mov r8, r8)
    ca32:	e002      	b.n	ca3a <atcab_gendig_host+0x1a6>

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
			break;
    ca34:	46c0      	nop			; (mov r8, r8)
    ca36:	e000      	b.n	ca3a <atcab_gendig_host+0x1a6>
		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &(packet.rxsize))) != ATCA_SUCCESS )
			break;
    ca38:	46c0      	nop			; (mov r8, r8)
		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
			break;

	} while (0);

	_atcab_exit();
    ca3a:	4b0f      	ldr	r3, [pc, #60]	; (ca78 <atcab_gendig_host+0x1e4>)
    ca3c:	4798      	blx	r3
	return status;
    ca3e:	2397      	movs	r3, #151	; 0x97
    ca40:	18fb      	adds	r3, r7, r3
    ca42:	781b      	ldrb	r3, [r3, #0]
}
    ca44:	0018      	movs	r0, r3
    ca46:	46bd      	mov	sp, r7
    ca48:	b027      	add	sp, #156	; 0x9c
    ca4a:	bd90      	pop	{r4, r7, pc}
    ca4c:	200007e0 	.word	0x200007e0
    ca50:	000127e7 	.word	0x000127e7
    ca54:	200007e4 	.word	0x200007e4
    ca58:	0000a421 	.word	0x0000a421
    ca5c:	0000a7f5 	.word	0x0000a7f5
    ca60:	0000ad9d 	.word	0x0000ad9d
    ca64:	200007e8 	.word	0x200007e8
    ca68:	0000ab85 	.word	0x0000ab85
    ca6c:	0000e3d5 	.word	0x0000e3d5
    ca70:	0000aba9 	.word	0x0000aba9
    ca74:	0000a955 	.word	0x0000a955
    ca78:	0000ae2d 	.word	0x0000ae2d

0000ca7c <atcab_get_pubkey>:
 *  \param[in] privSlotId ID of the private key slot
 *  \param[out] pubkey - pointer to space receiving the contents of the public key that was generated
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_get_pubkey(uint8_t privSlotId, uint8_t *pubkey)
{
    ca7c:	b590      	push	{r4, r7, lr}
    ca7e:	b0a7      	sub	sp, #156	; 0x9c
    ca80:	af00      	add	r7, sp, #0
    ca82:	0002      	movs	r2, r0
    ca84:	6039      	str	r1, [r7, #0]
    ca86:	1dfb      	adds	r3, r7, #7
    ca88:	701a      	strb	r2, [r3, #0]
	ATCAPacket packet;
	uint16_t execution_time = 0;
    ca8a:	2394      	movs	r3, #148	; 0x94
    ca8c:	18fb      	adds	r3, r7, r3
    ca8e:	2200      	movs	r2, #0
    ca90:	801a      	strh	r2, [r3, #0]
	ATCA_STATUS status = ATCA_GEN_FAIL;
    ca92:	2397      	movs	r3, #151	; 0x97
    ca94:	18fb      	adds	r3, r7, r3
    ca96:	22e1      	movs	r2, #225	; 0xe1
    ca98:	701a      	strb	r2, [r3, #0]

	do {
		// build a genkey command
		packet.param1 = GENKEY_MODE_PUBLIC;
    ca9a:	2308      	movs	r3, #8
    ca9c:	18fb      	adds	r3, r7, r3
    ca9e:	2200      	movs	r2, #0
    caa0:	70da      	strb	r2, [r3, #3]
		packet.param2 = (uint16_t)(privSlotId);
    caa2:	1dfb      	adds	r3, r7, #7
    caa4:	781b      	ldrb	r3, [r3, #0]
    caa6:	b29a      	uxth	r2, r3
    caa8:	2308      	movs	r3, #8
    caaa:	18fb      	adds	r3, r7, r3
    caac:	809a      	strh	r2, [r3, #4]

		if ( (status = atGenKey( _gCommandObj, &packet, false )) != ATCA_SUCCESS ) break;
    caae:	4b4b      	ldr	r3, [pc, #300]	; (cbdc <atcab_get_pubkey+0x160>)
    cab0:	681b      	ldr	r3, [r3, #0]
    cab2:	2297      	movs	r2, #151	; 0x97
    cab4:	18bc      	adds	r4, r7, r2
    cab6:	2208      	movs	r2, #8
    cab8:	18b9      	adds	r1, r7, r2
    caba:	2200      	movs	r2, #0
    cabc:	0018      	movs	r0, r3
    cabe:	4b48      	ldr	r3, [pc, #288]	; (cbe0 <atcab_get_pubkey+0x164>)
    cac0:	4798      	blx	r3
    cac2:	0003      	movs	r3, r0
    cac4:	7023      	strb	r3, [r4, #0]
    cac6:	2397      	movs	r3, #151	; 0x97
    cac8:	18fb      	adds	r3, r7, r3
    caca:	781b      	ldrb	r3, [r3, #0]
    cacc:	2b00      	cmp	r3, #0
    cace:	d000      	beq.n	cad2 <atcab_get_pubkey+0x56>
    cad0:	e071      	b.n	cbb6 <atcab_get_pubkey+0x13a>

		execution_time = atGetExecTime( _gCommandObj, CMD_GENKEY);
    cad2:	4b42      	ldr	r3, [pc, #264]	; (cbdc <atcab_get_pubkey+0x160>)
    cad4:	681b      	ldr	r3, [r3, #0]
    cad6:	2294      	movs	r2, #148	; 0x94
    cad8:	18bc      	adds	r4, r7, r2
    cada:	2106      	movs	r1, #6
    cadc:	0018      	movs	r0, r3
    cade:	4b41      	ldr	r3, [pc, #260]	; (cbe4 <atcab_get_pubkey+0x168>)
    cae0:	4798      	blx	r3
    cae2:	0003      	movs	r3, r0
    cae4:	8023      	strh	r3, [r4, #0]

		if ( (status = atcab_wakeup()) != ATCA_SUCCESS ) break;
    cae6:	2397      	movs	r3, #151	; 0x97
    cae8:	18fc      	adds	r4, r7, r3
    caea:	4b3f      	ldr	r3, [pc, #252]	; (cbe8 <atcab_get_pubkey+0x16c>)
    caec:	4798      	blx	r3
    caee:	0003      	movs	r3, r0
    caf0:	7023      	strb	r3, [r4, #0]
    caf2:	2397      	movs	r3, #151	; 0x97
    caf4:	18fb      	adds	r3, r7, r3
    caf6:	781b      	ldrb	r3, [r3, #0]
    caf8:	2b00      	cmp	r3, #0
    cafa:	d15e      	bne.n	cbba <atcab_get_pubkey+0x13e>

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
    cafc:	4b3b      	ldr	r3, [pc, #236]	; (cbec <atcab_get_pubkey+0x170>)
    cafe:	6818      	ldr	r0, [r3, #0]
    cb00:	2308      	movs	r3, #8
    cb02:	18fb      	adds	r3, r7, r3
    cb04:	785b      	ldrb	r3, [r3, #1]
    cb06:	001a      	movs	r2, r3
    cb08:	2397      	movs	r3, #151	; 0x97
    cb0a:	18fc      	adds	r4, r7, r3
    cb0c:	2308      	movs	r3, #8
    cb0e:	18fb      	adds	r3, r7, r3
    cb10:	0019      	movs	r1, r3
    cb12:	4b37      	ldr	r3, [pc, #220]	; (cbf0 <atcab_get_pubkey+0x174>)
    cb14:	4798      	blx	r3
    cb16:	0003      	movs	r3, r0
    cb18:	7023      	strb	r3, [r4, #0]
    cb1a:	2397      	movs	r3, #151	; 0x97
    cb1c:	18fb      	adds	r3, r7, r3
    cb1e:	781b      	ldrb	r3, [r3, #0]
    cb20:	2b00      	cmp	r3, #0
    cb22:	d14c      	bne.n	cbbe <atcab_get_pubkey+0x142>
			break;

		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);
    cb24:	2394      	movs	r3, #148	; 0x94
    cb26:	18fb      	adds	r3, r7, r3
    cb28:	881b      	ldrh	r3, [r3, #0]
    cb2a:	0018      	movs	r0, r3
    cb2c:	4b31      	ldr	r3, [pc, #196]	; (cbf4 <atcab_get_pubkey+0x178>)
    cb2e:	4798      	blx	r3

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &(packet.rxsize) )) != ATCA_SUCCESS )
    cb30:	4b2e      	ldr	r3, [pc, #184]	; (cbec <atcab_get_pubkey+0x170>)
    cb32:	6818      	ldr	r0, [r3, #0]
    cb34:	2397      	movs	r3, #151	; 0x97
    cb36:	18fc      	adds	r4, r7, r3
    cb38:	2308      	movs	r3, #8
    cb3a:	18fb      	adds	r3, r7, r3
    cb3c:	338a      	adds	r3, #138	; 0x8a
    cb3e:	001a      	movs	r2, r3
    cb40:	2308      	movs	r3, #8
    cb42:	18fb      	adds	r3, r7, r3
    cb44:	3306      	adds	r3, #6
    cb46:	0019      	movs	r1, r3
    cb48:	4b2b      	ldr	r3, [pc, #172]	; (cbf8 <atcab_get_pubkey+0x17c>)
    cb4a:	4798      	blx	r3
    cb4c:	0003      	movs	r3, r0
    cb4e:	7023      	strb	r3, [r4, #0]
    cb50:	2397      	movs	r3, #151	; 0x97
    cb52:	18fb      	adds	r3, r7, r3
    cb54:	781b      	ldrb	r3, [r3, #0]
    cb56:	2b00      	cmp	r3, #0
    cb58:	d133      	bne.n	cbc2 <atcab_get_pubkey+0x146>
			break;

		// Check response size
		if (packet.rxsize < 4) {
    cb5a:	2308      	movs	r3, #8
    cb5c:	18fb      	adds	r3, r7, r3
    cb5e:	228a      	movs	r2, #138	; 0x8a
    cb60:	5a9b      	ldrh	r3, [r3, r2]
    cb62:	2b03      	cmp	r3, #3
    cb64:	d80f      	bhi.n	cb86 <atcab_get_pubkey+0x10a>
			if (packet.rxsize > 0)
    cb66:	2308      	movs	r3, #8
    cb68:	18fb      	adds	r3, r7, r3
    cb6a:	228a      	movs	r2, #138	; 0x8a
    cb6c:	5a9b      	ldrh	r3, [r3, r2]
    cb6e:	2b00      	cmp	r3, #0
    cb70:	d004      	beq.n	cb7c <atcab_get_pubkey+0x100>
				status = ATCA_RX_FAIL;
    cb72:	2397      	movs	r3, #151	; 0x97
    cb74:	18fb      	adds	r3, r7, r3
    cb76:	22e6      	movs	r2, #230	; 0xe6
    cb78:	701a      	strb	r2, [r3, #0]
			else
				status = ATCA_RX_NO_RESPONSE;
			break;
    cb7a:	e025      	b.n	cbc8 <atcab_get_pubkey+0x14c>
		// Check response size
		if (packet.rxsize < 4) {
			if (packet.rxsize > 0)
				status = ATCA_RX_FAIL;
			else
				status = ATCA_RX_NO_RESPONSE;
    cb7c:	2397      	movs	r3, #151	; 0x97
    cb7e:	18fb      	adds	r3, r7, r3
    cb80:	22e7      	movs	r2, #231	; 0xe7
    cb82:	701a      	strb	r2, [r3, #0]
			break;
    cb84:	e020      	b.n	cbc8 <atcab_get_pubkey+0x14c>
		}

		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
    cb86:	2397      	movs	r3, #151	; 0x97
    cb88:	18fc      	adds	r4, r7, r3
    cb8a:	2308      	movs	r3, #8
    cb8c:	18fb      	adds	r3, r7, r3
    cb8e:	3306      	adds	r3, #6
    cb90:	0018      	movs	r0, r3
    cb92:	4b1a      	ldr	r3, [pc, #104]	; (cbfc <atcab_get_pubkey+0x180>)
    cb94:	4798      	blx	r3
    cb96:	0003      	movs	r3, r0
    cb98:	7023      	strb	r3, [r4, #0]
    cb9a:	2397      	movs	r3, #151	; 0x97
    cb9c:	18fb      	adds	r3, r7, r3
    cb9e:	781b      	ldrb	r3, [r3, #0]
    cba0:	2b00      	cmp	r3, #0
    cba2:	d110      	bne.n	cbc6 <atcab_get_pubkey+0x14a>
			break;

		// copy the response public key data
		memcpy(pubkey, &packet.data[1], 64 );
    cba4:	2308      	movs	r3, #8
    cba6:	18fb      	adds	r3, r7, r3
    cba8:	1dd9      	adds	r1, r3, #7
    cbaa:	683b      	ldr	r3, [r7, #0]
    cbac:	2240      	movs	r2, #64	; 0x40
    cbae:	0018      	movs	r0, r3
    cbb0:	4b13      	ldr	r3, [pc, #76]	; (cc00 <atcab_get_pubkey+0x184>)
    cbb2:	4798      	blx	r3
    cbb4:	e008      	b.n	cbc8 <atcab_get_pubkey+0x14c>
	do {
		// build a genkey command
		packet.param1 = GENKEY_MODE_PUBLIC;
		packet.param2 = (uint16_t)(privSlotId);

		if ( (status = atGenKey( _gCommandObj, &packet, false )) != ATCA_SUCCESS ) break;
    cbb6:	46c0      	nop			; (mov r8, r8)
    cbb8:	e006      	b.n	cbc8 <atcab_get_pubkey+0x14c>

		execution_time = atGetExecTime( _gCommandObj, CMD_GENKEY);

		if ( (status = atcab_wakeup()) != ATCA_SUCCESS ) break;
    cbba:	46c0      	nop			; (mov r8, r8)
    cbbc:	e004      	b.n	cbc8 <atcab_get_pubkey+0x14c>

		// send the command
		if ( (status = atsend( _gIface, (uint8_t*)&packet, packet.txsize )) != ATCA_SUCCESS )
			break;
    cbbe:	46c0      	nop			; (mov r8, r8)
    cbc0:	e002      	b.n	cbc8 <atcab_get_pubkey+0x14c>
		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);

		// receive the response
		if ( (status = atreceive( _gIface, packet.data, &(packet.rxsize) )) != ATCA_SUCCESS )
			break;
    cbc2:	46c0      	nop			; (mov r8, r8)
    cbc4:	e000      	b.n	cbc8 <atcab_get_pubkey+0x14c>
				status = ATCA_RX_NO_RESPONSE;
			break;
		}

		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
			break;
    cbc6:	46c0      	nop			; (mov r8, r8)

		// copy the response public key data
		memcpy(pubkey, &packet.data[1], 64 );
	} while (0);

	_atcab_exit();
    cbc8:	4b0e      	ldr	r3, [pc, #56]	; (cc04 <atcab_get_pubkey+0x188>)
    cbca:	4798      	blx	r3
	return status;
    cbcc:	2397      	movs	r3, #151	; 0x97
    cbce:	18fb      	adds	r3, r7, r3
    cbd0:	781b      	ldrb	r3, [r3, #0]
}
    cbd2:	0018      	movs	r0, r3
    cbd4:	46bd      	mov	sp, r7
    cbd6:	b027      	add	sp, #156	; 0x9c
    cbd8:	bd90      	pop	{r4, r7, pc}
    cbda:	46c0      	nop			; (mov r8, r8)
    cbdc:	200007e4 	.word	0x200007e4
    cbe0:	0000a479 	.word	0x0000a479
    cbe4:	0000a7f5 	.word	0x0000a7f5
    cbe8:	0000ad9d 	.word	0x0000ad9d
    cbec:	200007e8 	.word	0x200007e8
    cbf0:	0000ab85 	.word	0x0000ab85
    cbf4:	0000e3d5 	.word	0x0000e3d5
    cbf8:	0000aba9 	.word	0x0000aba9
    cbfc:	0000a955 	.word	0x0000a955
    cc00:	000127e7 	.word	0x000127e7
    cc04:	0000ae2d 	.word	0x0000ae2d

0000cc08 <atcab_priv_write>:
 *  \param[in] write_key_slot slot to make a session key
 *  \param[in] write_key key to make a session key
 *  \return ATCA_STATUS
 */
ATCA_STATUS atcab_priv_write(uint8_t slot, const uint8_t priv_key[36], uint8_t write_key_slot, const uint8_t write_key[32])
{
    cc08:	b5b0      	push	{r4, r5, r7, lr}
    cc0a:	b0ee      	sub	sp, #440	; 0x1b8
    cc0c:	af00      	add	r7, sp, #0
    cc0e:	60b9      	str	r1, [r7, #8]
    cc10:	0011      	movs	r1, r2
    cc12:	607b      	str	r3, [r7, #4]
    cc14:	4b3d      	ldr	r3, [pc, #244]	; (cd0c <atcab_priv_write+0x104>)
    cc16:	22dc      	movs	r2, #220	; 0xdc
    cc18:	0052      	lsls	r2, r2, #1
    cc1a:	4694      	mov	ip, r2
    cc1c:	44bc      	add	ip, r7
    cc1e:	4463      	add	r3, ip
    cc20:	1c02      	adds	r2, r0, #0
    cc22:	701a      	strb	r2, [r3, #0]
    cc24:	4b3a      	ldr	r3, [pc, #232]	; (cd10 <atcab_priv_write+0x108>)
    cc26:	22dc      	movs	r2, #220	; 0xdc
    cc28:	0052      	lsls	r2, r2, #1
    cc2a:	4694      	mov	ip, r2
    cc2c:	44bc      	add	ip, r7
    cc2e:	4463      	add	r3, ip
    cc30:	1c0a      	adds	r2, r1, #0
    cc32:	701a      	strb	r2, [r3, #0]
	ATCA_STATUS status = ATCA_GEN_FAIL;
    cc34:	23b8      	movs	r3, #184	; 0xb8
    cc36:	33ff      	adds	r3, #255	; 0xff
    cc38:	18fb      	adds	r3, r7, r3
    cc3a:	22e1      	movs	r2, #225	; 0xe1
    cc3c:	701a      	strb	r2, [r3, #0]
	ATCAPacket packet;
	atca_nonce_in_out_t nonceParam;
	atca_gen_dig_in_out_t genDigParam;
	atca_write_mac_in_out_t hostMacParam;
	atca_temp_key_t tempkey;
	uint8_t numin[NONCE_NUMIN_SIZE] = { 0 };
    cc3e:	23bc      	movs	r3, #188	; 0xbc
    cc40:	18fb      	adds	r3, r7, r3
    cc42:	0018      	movs	r0, r3
    cc44:	2314      	movs	r3, #20
    cc46:	001a      	movs	r2, r3
    cc48:	2100      	movs	r1, #0
    cc4a:	4b32      	ldr	r3, [pc, #200]	; (cd14 <atcab_priv_write+0x10c>)
    cc4c:	4798      	blx	r3
	uint8_t randout[RANDOM_NUM_SIZE] = { 0 };
    cc4e:	4b32      	ldr	r3, [pc, #200]	; (cd18 <atcab_priv_write+0x110>)
    cc50:	22dc      	movs	r2, #220	; 0xdc
    cc52:	0052      	lsls	r2, r2, #1
    cc54:	4694      	mov	ip, r2
    cc56:	44bc      	add	ip, r7
    cc58:	4463      	add	r3, ip
    cc5a:	0018      	movs	r0, r3
    cc5c:	2320      	movs	r3, #32
    cc5e:	001a      	movs	r2, r3
    cc60:	2100      	movs	r1, #0
    cc62:	4b2c      	ldr	r3, [pc, #176]	; (cd14 <atcab_priv_write+0x10c>)
    cc64:	4798      	blx	r3
	uint8_t cipher_text[36] = { 0 };
    cc66:	4b2d      	ldr	r3, [pc, #180]	; (cd1c <atcab_priv_write+0x114>)
    cc68:	22dc      	movs	r2, #220	; 0xdc
    cc6a:	0052      	lsls	r2, r2, #1
    cc6c:	4694      	mov	ip, r2
    cc6e:	44bc      	add	ip, r7
    cc70:	4463      	add	r3, ip
    cc72:	0018      	movs	r0, r3
    cc74:	2324      	movs	r3, #36	; 0x24
    cc76:	001a      	movs	r2, r3
    cc78:	2100      	movs	r1, #0
    cc7a:	4b26      	ldr	r3, [pc, #152]	; (cd14 <atcab_priv_write+0x10c>)
    cc7c:	4798      	blx	r3
	uint8_t host_mac[MAC_SIZE] = { 0 };
    cc7e:	4b28      	ldr	r3, [pc, #160]	; (cd20 <atcab_priv_write+0x118>)
    cc80:	22dc      	movs	r2, #220	; 0xdc
    cc82:	0052      	lsls	r2, r2, #1
    cc84:	4694      	mov	ip, r2
    cc86:	44bc      	add	ip, r7
    cc88:	4463      	add	r3, ip
    cc8a:	0018      	movs	r0, r3
    cc8c:	2320      	movs	r3, #32
    cc8e:	001a      	movs	r2, r3
    cc90:	2100      	movs	r1, #0
    cc92:	4b20      	ldr	r3, [pc, #128]	; (cd14 <atcab_priv_write+0x10c>)
    cc94:	4798      	blx	r3
	uint16_t execution_time = 0;
    cc96:	23da      	movs	r3, #218	; 0xda
    cc98:	005b      	lsls	r3, r3, #1
    cc9a:	18fb      	adds	r3, r7, r3
    cc9c:	2200      	movs	r2, #0
    cc9e:	801a      	strh	r2, [r3, #0]
	uint8_t privKey[36];
	uint8_t writeKey[32];

	if (slot > 15 || priv_key == NULL)
    cca0:	4b1a      	ldr	r3, [pc, #104]	; (cd0c <atcab_priv_write+0x104>)
    cca2:	22dc      	movs	r2, #220	; 0xdc
    cca4:	0052      	lsls	r2, r2, #1
    cca6:	4694      	mov	ip, r2
    cca8:	44bc      	add	ip, r7
    ccaa:	4463      	add	r3, ip
    ccac:	781b      	ldrb	r3, [r3, #0]
    ccae:	2b0f      	cmp	r3, #15
    ccb0:	d802      	bhi.n	ccb8 <atcab_priv_write+0xb0>
    ccb2:	68bb      	ldr	r3, [r7, #8]
    ccb4:	2b00      	cmp	r3, #0
    ccb6:	d101      	bne.n	ccbc <atcab_priv_write+0xb4>
		return ATCA_BAD_PARAM;
    ccb8:	23e2      	movs	r3, #226	; 0xe2
    ccba:	e1df      	b.n	d07c <atcab_priv_write+0x474>

	do {

		if (write_key == NULL) {
    ccbc:	687b      	ldr	r3, [r7, #4]
    ccbe:	2b00      	cmp	r3, #0
    ccc0:	d132      	bne.n	cd28 <atcab_priv_write+0x120>
			// Caller requested an unencrypted PrivWrite, which is only allowed when the data zone is unlocked
			// build an PrivWrite command
			packet.param1 = 0x00;                   // Mode is unencrypted write
    ccc2:	2394      	movs	r3, #148	; 0x94
    ccc4:	005b      	lsls	r3, r3, #1
    ccc6:	18fb      	adds	r3, r7, r3
    ccc8:	2200      	movs	r2, #0
    ccca:	70da      	strb	r2, [r3, #3]
			packet.param2 = slot;                   // Key ID
    cccc:	4b0f      	ldr	r3, [pc, #60]	; (cd0c <atcab_priv_write+0x104>)
    ccce:	22dc      	movs	r2, #220	; 0xdc
    ccd0:	0052      	lsls	r2, r2, #1
    ccd2:	4694      	mov	ip, r2
    ccd4:	44bc      	add	ip, r7
    ccd6:	4463      	add	r3, ip
    ccd8:	781b      	ldrb	r3, [r3, #0]
    ccda:	b29a      	uxth	r2, r3
    ccdc:	2394      	movs	r3, #148	; 0x94
    ccde:	005b      	lsls	r3, r3, #1
    cce0:	18fb      	adds	r3, r7, r3
    cce2:	809a      	strh	r2, [r3, #4]
			memcpy(&packet.data[0], priv_key, 36);  // Private key
    cce4:	68b9      	ldr	r1, [r7, #8]
    cce6:	2394      	movs	r3, #148	; 0x94
    cce8:	005b      	lsls	r3, r3, #1
    ccea:	18fb      	adds	r3, r7, r3
    ccec:	3306      	adds	r3, #6
    ccee:	2224      	movs	r2, #36	; 0x24
    ccf0:	0018      	movs	r0, r3
    ccf2:	4b0c      	ldr	r3, [pc, #48]	; (cd24 <atcab_priv_write+0x11c>)
    ccf4:	4798      	blx	r3
			memset(&packet.data[36], 0, 32);        // MAC (ignored for unencrypted write)
    ccf6:	2394      	movs	r3, #148	; 0x94
    ccf8:	005b      	lsls	r3, r3, #1
    ccfa:	18fb      	adds	r3, r7, r3
    ccfc:	332a      	adds	r3, #42	; 0x2a
    ccfe:	2220      	movs	r2, #32
    cd00:	2100      	movs	r1, #0
    cd02:	0018      	movs	r0, r3
    cd04:	4b03      	ldr	r3, [pc, #12]	; (cd14 <atcab_priv_write+0x10c>)
    cd06:	4798      	blx	r3
    cd08:	e115      	b.n	cf36 <atcab_priv_write+0x32e>
    cd0a:	46c0      	nop			; (mov r8, r8)
    cd0c:	fffffe57 	.word	0xfffffe57
    cd10:	fffffe56 	.word	0xfffffe56
    cd14:	00012823 	.word	0x00012823
    cd18:	fffffee4 	.word	0xfffffee4
    cd1c:	fffffec0 	.word	0xfffffec0
    cd20:	fffffea0 	.word	0xfffffea0
    cd24:	000127e7 	.word	0x000127e7
		}else {
			// Copy the buffers to honor the const designation
			memcpy(privKey, priv_key, 36);
    cd28:	4bd6      	ldr	r3, [pc, #856]	; (d084 <atcab_priv_write+0x47c>)
    cd2a:	22dc      	movs	r2, #220	; 0xdc
    cd2c:	0052      	lsls	r2, r2, #1
    cd2e:	18ba      	adds	r2, r7, r2
    cd30:	18d2      	adds	r2, r2, r3
    cd32:	68bb      	ldr	r3, [r7, #8]
    cd34:	0010      	movs	r0, r2
    cd36:	0019      	movs	r1, r3
    cd38:	2324      	movs	r3, #36	; 0x24
    cd3a:	001a      	movs	r2, r3
    cd3c:	4bd2      	ldr	r3, [pc, #840]	; (d088 <atcab_priv_write+0x480>)
    cd3e:	4798      	blx	r3
			memcpy(writeKey, write_key, 32);
    cd40:	4bd2      	ldr	r3, [pc, #840]	; (d08c <atcab_priv_write+0x484>)
    cd42:	22dc      	movs	r2, #220	; 0xdc
    cd44:	0052      	lsls	r2, r2, #1
    cd46:	18ba      	adds	r2, r7, r2
    cd48:	18d2      	adds	r2, r2, r3
    cd4a:	687b      	ldr	r3, [r7, #4]
    cd4c:	0010      	movs	r0, r2
    cd4e:	0019      	movs	r1, r3
    cd50:	2320      	movs	r3, #32
    cd52:	001a      	movs	r2, r3
    cd54:	4bcc      	ldr	r3, [pc, #816]	; (d088 <atcab_priv_write+0x480>)
    cd56:	4798      	blx	r3

			// Send the random Nonce command
			if ((status = atcab_nonce_rand(numin, randout)) != ATCA_SUCCESS)
    cd58:	23b8      	movs	r3, #184	; 0xb8
    cd5a:	33ff      	adds	r3, #255	; 0xff
    cd5c:	18fc      	adds	r4, r7, r3
    cd5e:	239c      	movs	r3, #156	; 0x9c
    cd60:	18fa      	adds	r2, r7, r3
    cd62:	23bc      	movs	r3, #188	; 0xbc
    cd64:	18fb      	adds	r3, r7, r3
    cd66:	0011      	movs	r1, r2
    cd68:	0018      	movs	r0, r3
    cd6a:	4bc9      	ldr	r3, [pc, #804]	; (d090 <atcab_priv_write+0x488>)
    cd6c:	4798      	blx	r3
    cd6e:	0003      	movs	r3, r0
    cd70:	7023      	strb	r3, [r4, #0]
    cd72:	23b8      	movs	r3, #184	; 0xb8
    cd74:	33ff      	adds	r3, #255	; 0xff
    cd76:	18fb      	adds	r3, r7, r3
    cd78:	781b      	ldrb	r3, [r3, #0]
    cd7a:	2b00      	cmp	r3, #0
    cd7c:	d000      	beq.n	cd80 <atcab_priv_write+0x178>
    cd7e:	e166      	b.n	d04e <atcab_priv_write+0x446>
				break;

			// Calculate Tempkey
			nonceParam.mode = NONCE_MODE_SEED_UPDATE;
    cd80:	238c      	movs	r3, #140	; 0x8c
    cd82:	005b      	lsls	r3, r3, #1
    cd84:	18fb      	adds	r3, r7, r3
    cd86:	2200      	movs	r2, #0
    cd88:	701a      	strb	r2, [r3, #0]
			nonceParam.num_in = numin;
    cd8a:	238c      	movs	r3, #140	; 0x8c
    cd8c:	005b      	lsls	r3, r3, #1
    cd8e:	18fb      	adds	r3, r7, r3
    cd90:	22bc      	movs	r2, #188	; 0xbc
    cd92:	18ba      	adds	r2, r7, r2
    cd94:	605a      	str	r2, [r3, #4]
			nonceParam.rand_out = randout;
    cd96:	238c      	movs	r3, #140	; 0x8c
    cd98:	005b      	lsls	r3, r3, #1
    cd9a:	18fb      	adds	r3, r7, r3
    cd9c:	229c      	movs	r2, #156	; 0x9c
    cd9e:	18ba      	adds	r2, r7, r2
    cda0:	609a      	str	r2, [r3, #8]
			nonceParam.temp_key = &tempkey;
    cda2:	238c      	movs	r3, #140	; 0x8c
    cda4:	005b      	lsls	r3, r3, #1
    cda6:	18fb      	adds	r3, r7, r3
    cda8:	22d0      	movs	r2, #208	; 0xd0
    cdaa:	18ba      	adds	r2, r7, r2
    cdac:	60da      	str	r2, [r3, #12]
			if ((status = atcah_nonce(&nonceParam)) != ATCA_SUCCESS)
    cdae:	23b8      	movs	r3, #184	; 0xb8
    cdb0:	33ff      	adds	r3, #255	; 0xff
    cdb2:	18fc      	adds	r4, r7, r3
    cdb4:	238c      	movs	r3, #140	; 0x8c
    cdb6:	005b      	lsls	r3, r3, #1
    cdb8:	18fb      	adds	r3, r7, r3
    cdba:	0018      	movs	r0, r3
    cdbc:	4bb5      	ldr	r3, [pc, #724]	; (d094 <atcab_priv_write+0x48c>)
    cdbe:	4798      	blx	r3
    cdc0:	0003      	movs	r3, r0
    cdc2:	7023      	strb	r3, [r4, #0]
    cdc4:	23b8      	movs	r3, #184	; 0xb8
    cdc6:	33ff      	adds	r3, #255	; 0xff
    cdc8:	18fb      	adds	r3, r7, r3
    cdca:	781b      	ldrb	r3, [r3, #0]
    cdcc:	2b00      	cmp	r3, #0
    cdce:	d000      	beq.n	cdd2 <atcab_priv_write+0x1ca>
    cdd0:	e13f      	b.n	d052 <atcab_priv_write+0x44a>
				break;

			// Send the GenDig command
			if ((status = atcab_gendig_host(GENDIG_ZONE_DATA, write_key_slot, tempkey.value, 32)) != ATCA_SUCCESS)
    cdd2:	4bb1      	ldr	r3, [pc, #708]	; (d098 <atcab_priv_write+0x490>)
    cdd4:	22dc      	movs	r2, #220	; 0xdc
    cdd6:	0052      	lsls	r2, r2, #1
    cdd8:	4694      	mov	ip, r2
    cdda:	44bc      	add	ip, r7
    cddc:	4463      	add	r3, ip
    cdde:	781b      	ldrb	r3, [r3, #0]
    cde0:	b299      	uxth	r1, r3
    cde2:	23b8      	movs	r3, #184	; 0xb8
    cde4:	33ff      	adds	r3, #255	; 0xff
    cde6:	18fc      	adds	r4, r7, r3
    cde8:	23d0      	movs	r3, #208	; 0xd0
    cdea:	18fa      	adds	r2, r7, r3
    cdec:	2320      	movs	r3, #32
    cdee:	2002      	movs	r0, #2
    cdf0:	4daa      	ldr	r5, [pc, #680]	; (d09c <atcab_priv_write+0x494>)
    cdf2:	47a8      	blx	r5
    cdf4:	0003      	movs	r3, r0
    cdf6:	7023      	strb	r3, [r4, #0]
    cdf8:	23b8      	movs	r3, #184	; 0xb8
    cdfa:	33ff      	adds	r3, #255	; 0xff
    cdfc:	18fb      	adds	r3, r7, r3
    cdfe:	781b      	ldrb	r3, [r3, #0]
    ce00:	2b00      	cmp	r3, #0
    ce02:	d000      	beq.n	ce06 <atcab_priv_write+0x1fe>
    ce04:	e127      	b.n	d056 <atcab_priv_write+0x44e>
				break;

			// Calculate Tempkey
			genDigParam.zone = GENDIG_ZONE_DATA;
    ce06:	2386      	movs	r3, #134	; 0x86
    ce08:	005b      	lsls	r3, r3, #1
    ce0a:	18fb      	adds	r3, r7, r3
    ce0c:	2202      	movs	r2, #2
    ce0e:	701a      	strb	r2, [r3, #0]
			genDigParam.key_id = write_key_slot;
    ce10:	4ba1      	ldr	r3, [pc, #644]	; (d098 <atcab_priv_write+0x490>)
    ce12:	22dc      	movs	r2, #220	; 0xdc
    ce14:	0052      	lsls	r2, r2, #1
    ce16:	4694      	mov	ip, r2
    ce18:	44bc      	add	ip, r7
    ce1a:	4463      	add	r3, ip
    ce1c:	781b      	ldrb	r3, [r3, #0]
    ce1e:	b29a      	uxth	r2, r3
    ce20:	2386      	movs	r3, #134	; 0x86
    ce22:	005b      	lsls	r3, r3, #1
    ce24:	18fb      	adds	r3, r7, r3
    ce26:	805a      	strh	r2, [r3, #2]
			genDigParam.stored_value = writeKey;
    ce28:	2386      	movs	r3, #134	; 0x86
    ce2a:	005b      	lsls	r3, r3, #1
    ce2c:	18fb      	adds	r3, r7, r3
    ce2e:	2214      	movs	r2, #20
    ce30:	18ba      	adds	r2, r7, r2
    ce32:	605a      	str	r2, [r3, #4]
			genDigParam.temp_key = &tempkey;
    ce34:	2386      	movs	r3, #134	; 0x86
    ce36:	005b      	lsls	r3, r3, #1
    ce38:	18fb      	adds	r3, r7, r3
    ce3a:	22d0      	movs	r2, #208	; 0xd0
    ce3c:	18ba      	adds	r2, r7, r2
    ce3e:	609a      	str	r2, [r3, #8]
			if ((status = atcah_gen_dig(&genDigParam)) != ATCA_SUCCESS)
    ce40:	23b8      	movs	r3, #184	; 0xb8
    ce42:	33ff      	adds	r3, #255	; 0xff
    ce44:	18fc      	adds	r4, r7, r3
    ce46:	2386      	movs	r3, #134	; 0x86
    ce48:	005b      	lsls	r3, r3, #1
    ce4a:	18fb      	adds	r3, r7, r3
    ce4c:	0018      	movs	r0, r3
    ce4e:	4b94      	ldr	r3, [pc, #592]	; (d0a0 <atcab_priv_write+0x498>)
    ce50:	4798      	blx	r3
    ce52:	0003      	movs	r3, r0
    ce54:	7023      	strb	r3, [r4, #0]
    ce56:	23b8      	movs	r3, #184	; 0xb8
    ce58:	33ff      	adds	r3, #255	; 0xff
    ce5a:	18fb      	adds	r3, r7, r3
    ce5c:	781b      	ldrb	r3, [r3, #0]
    ce5e:	2b00      	cmp	r3, #0
    ce60:	d000      	beq.n	ce64 <atcab_priv_write+0x25c>
    ce62:	e0fa      	b.n	d05a <atcab_priv_write+0x452>
				break;

			// Calculate Auth MAC and cipher text
			hostMacParam.zone = PRIVWRITE_MODE_ENCRYPT;
    ce64:	23f4      	movs	r3, #244	; 0xf4
    ce66:	18fb      	adds	r3, r7, r3
    ce68:	2240      	movs	r2, #64	; 0x40
    ce6a:	701a      	strb	r2, [r3, #0]
			hostMacParam.key_id = slot;
    ce6c:	4b8d      	ldr	r3, [pc, #564]	; (d0a4 <atcab_priv_write+0x49c>)
    ce6e:	22dc      	movs	r2, #220	; 0xdc
    ce70:	0052      	lsls	r2, r2, #1
    ce72:	4694      	mov	ip, r2
    ce74:	44bc      	add	ip, r7
    ce76:	4463      	add	r3, ip
    ce78:	781b      	ldrb	r3, [r3, #0]
    ce7a:	b29a      	uxth	r2, r3
    ce7c:	23f4      	movs	r3, #244	; 0xf4
    ce7e:	18fb      	adds	r3, r7, r3
    ce80:	805a      	strh	r2, [r3, #2]
			hostMacParam.encryption_key = &privKey[4];
    ce82:	23f4      	movs	r3, #244	; 0xf4
    ce84:	18fb      	adds	r3, r7, r3
    ce86:	2234      	movs	r2, #52	; 0x34
    ce88:	18ba      	adds	r2, r7, r2
    ce8a:	3204      	adds	r2, #4
    ce8c:	605a      	str	r2, [r3, #4]
			hostMacParam.input_data = privKey;
    ce8e:	23f4      	movs	r3, #244	; 0xf4
    ce90:	18fb      	adds	r3, r7, r3
    ce92:	2234      	movs	r2, #52	; 0x34
    ce94:	18ba      	adds	r2, r7, r2
    ce96:	609a      	str	r2, [r3, #8]
			hostMacParam.encrypted_data = cipher_text;
    ce98:	23f4      	movs	r3, #244	; 0xf4
    ce9a:	18fb      	adds	r3, r7, r3
    ce9c:	2278      	movs	r2, #120	; 0x78
    ce9e:	18ba      	adds	r2, r7, r2
    cea0:	60da      	str	r2, [r3, #12]
			hostMacParam.auth_mac = host_mac;
    cea2:	23f4      	movs	r3, #244	; 0xf4
    cea4:	18fb      	adds	r3, r7, r3
    cea6:	2258      	movs	r2, #88	; 0x58
    cea8:	18ba      	adds	r2, r7, r2
    ceaa:	611a      	str	r2, [r3, #16]
			hostMacParam.temp_key = &tempkey;
    ceac:	23f4      	movs	r3, #244	; 0xf4
    ceae:	18fb      	adds	r3, r7, r3
    ceb0:	22d0      	movs	r2, #208	; 0xd0
    ceb2:	18ba      	adds	r2, r7, r2
    ceb4:	615a      	str	r2, [r3, #20]
			if ((status = atcah_privwrite_auth_mac(&hostMacParam)) != ATCA_SUCCESS)
    ceb6:	23b8      	movs	r3, #184	; 0xb8
    ceb8:	33ff      	adds	r3, #255	; 0xff
    ceba:	18fc      	adds	r4, r7, r3
    cebc:	23f4      	movs	r3, #244	; 0xf4
    cebe:	18fb      	adds	r3, r7, r3
    cec0:	0018      	movs	r0, r3
    cec2:	4b79      	ldr	r3, [pc, #484]	; (d0a8 <atcab_priv_write+0x4a0>)
    cec4:	4798      	blx	r3
    cec6:	0003      	movs	r3, r0
    cec8:	7023      	strb	r3, [r4, #0]
    ceca:	23b8      	movs	r3, #184	; 0xb8
    cecc:	33ff      	adds	r3, #255	; 0xff
    cece:	18fb      	adds	r3, r7, r3
    ced0:	781b      	ldrb	r3, [r3, #0]
    ced2:	2b00      	cmp	r3, #0
    ced4:	d000      	beq.n	ced8 <atcab_priv_write+0x2d0>
    ced6:	e0c2      	b.n	d05e <atcab_priv_write+0x456>
				break;

			// build a write command for encrypted writes
			packet.param1 = PRIVWRITE_MODE_ENCRYPT; // Mode is encrypted write
    ced8:	2394      	movs	r3, #148	; 0x94
    ceda:	005b      	lsls	r3, r3, #1
    cedc:	18fb      	adds	r3, r7, r3
    cede:	2240      	movs	r2, #64	; 0x40
    cee0:	70da      	strb	r2, [r3, #3]
			packet.param2 = slot;                   // Key ID
    cee2:	4b70      	ldr	r3, [pc, #448]	; (d0a4 <atcab_priv_write+0x49c>)
    cee4:	22dc      	movs	r2, #220	; 0xdc
    cee6:	0052      	lsls	r2, r2, #1
    cee8:	4694      	mov	ip, r2
    ceea:	44bc      	add	ip, r7
    ceec:	4463      	add	r3, ip
    ceee:	781b      	ldrb	r3, [r3, #0]
    cef0:	b29a      	uxth	r2, r3
    cef2:	2394      	movs	r3, #148	; 0x94
    cef4:	005b      	lsls	r3, r3, #1
    cef6:	18fb      	adds	r3, r7, r3
    cef8:	809a      	strh	r2, [r3, #4]
			memcpy(&packet.data[0], cipher_text, sizeof(cipher_text));
    cefa:	2394      	movs	r3, #148	; 0x94
    cefc:	005b      	lsls	r3, r3, #1
    cefe:	18fb      	adds	r3, r7, r3
    cf00:	2206      	movs	r2, #6
    cf02:	496a      	ldr	r1, [pc, #424]	; (d0ac <atcab_priv_write+0x4a4>)
    cf04:	20dc      	movs	r0, #220	; 0xdc
    cf06:	0040      	lsls	r0, r0, #1
    cf08:	4684      	mov	ip, r0
    cf0a:	44bc      	add	ip, r7
    cf0c:	4461      	add	r1, ip
    cf0e:	189b      	adds	r3, r3, r2
    cf10:	2224      	movs	r2, #36	; 0x24
    cf12:	0018      	movs	r0, r3
    cf14:	4b5c      	ldr	r3, [pc, #368]	; (d088 <atcab_priv_write+0x480>)
    cf16:	4798      	blx	r3
			memcpy(&packet.data[36], host_mac, sizeof(host_mac));
    cf18:	2394      	movs	r3, #148	; 0x94
    cf1a:	005b      	lsls	r3, r3, #1
    cf1c:	18fb      	adds	r3, r7, r3
    cf1e:	222a      	movs	r2, #42	; 0x2a
    cf20:	4963      	ldr	r1, [pc, #396]	; (d0b0 <atcab_priv_write+0x4a8>)
    cf22:	20dc      	movs	r0, #220	; 0xdc
    cf24:	0040      	lsls	r0, r0, #1
    cf26:	4684      	mov	ip, r0
    cf28:	44bc      	add	ip, r7
    cf2a:	4461      	add	r1, ip
    cf2c:	189b      	adds	r3, r3, r2
    cf2e:	2220      	movs	r2, #32
    cf30:	0018      	movs	r0, r3
    cf32:	4b55      	ldr	r3, [pc, #340]	; (d088 <atcab_priv_write+0x480>)
    cf34:	4798      	blx	r3
		}

		if ((status = atPrivWrite(_gCommandObj, &packet)) != ATCA_SUCCESS)
    cf36:	4b5f      	ldr	r3, [pc, #380]	; (d0b4 <atcab_priv_write+0x4ac>)
    cf38:	681b      	ldr	r3, [r3, #0]
    cf3a:	22b8      	movs	r2, #184	; 0xb8
    cf3c:	32ff      	adds	r2, #255	; 0xff
    cf3e:	18bc      	adds	r4, r7, r2
    cf40:	2294      	movs	r2, #148	; 0x94
    cf42:	0052      	lsls	r2, r2, #1
    cf44:	18ba      	adds	r2, r7, r2
    cf46:	0011      	movs	r1, r2
    cf48:	0018      	movs	r0, r3
    cf4a:	4b5b      	ldr	r3, [pc, #364]	; (d0b8 <atcab_priv_write+0x4b0>)
    cf4c:	4798      	blx	r3
    cf4e:	0003      	movs	r3, r0
    cf50:	7023      	strb	r3, [r4, #0]
    cf52:	23b8      	movs	r3, #184	; 0xb8
    cf54:	33ff      	adds	r3, #255	; 0xff
    cf56:	18fb      	adds	r3, r7, r3
    cf58:	781b      	ldrb	r3, [r3, #0]
    cf5a:	2b00      	cmp	r3, #0
    cf5c:	d000      	beq.n	cf60 <atcab_priv_write+0x358>
    cf5e:	e080      	b.n	d062 <atcab_priv_write+0x45a>
			break;

		execution_time = atGetExecTime(_gCommandObj, CMD_PRIVWRITE);
    cf60:	4b54      	ldr	r3, [pc, #336]	; (d0b4 <atcab_priv_write+0x4ac>)
    cf62:	681b      	ldr	r3, [r3, #0]
    cf64:	22da      	movs	r2, #218	; 0xda
    cf66:	0052      	lsls	r2, r2, #1
    cf68:	18bc      	adds	r4, r7, r2
    cf6a:	210d      	movs	r1, #13
    cf6c:	0018      	movs	r0, r3
    cf6e:	4b53      	ldr	r3, [pc, #332]	; (d0bc <atcab_priv_write+0x4b4>)
    cf70:	4798      	blx	r3
    cf72:	0003      	movs	r3, r0
    cf74:	8023      	strh	r3, [r4, #0]

		if ( (status = atcab_wakeup()) != ATCA_SUCCESS ) break;
    cf76:	23b8      	movs	r3, #184	; 0xb8
    cf78:	33ff      	adds	r3, #255	; 0xff
    cf7a:	18fc      	adds	r4, r7, r3
    cf7c:	4b50      	ldr	r3, [pc, #320]	; (d0c0 <atcab_priv_write+0x4b8>)
    cf7e:	4798      	blx	r3
    cf80:	0003      	movs	r3, r0
    cf82:	7023      	strb	r3, [r4, #0]
    cf84:	23b8      	movs	r3, #184	; 0xb8
    cf86:	33ff      	adds	r3, #255	; 0xff
    cf88:	18fb      	adds	r3, r7, r3
    cf8a:	781b      	ldrb	r3, [r3, #0]
    cf8c:	2b00      	cmp	r3, #0
    cf8e:	d16a      	bne.n	d066 <atcab_priv_write+0x45e>

		// send the command
		if ((status = atsend(_gIface, (uint8_t*)&packet, packet.txsize)) != ATCA_SUCCESS)
    cf90:	4b4c      	ldr	r3, [pc, #304]	; (d0c4 <atcab_priv_write+0x4bc>)
    cf92:	6818      	ldr	r0, [r3, #0]
    cf94:	2394      	movs	r3, #148	; 0x94
    cf96:	005b      	lsls	r3, r3, #1
    cf98:	18fb      	adds	r3, r7, r3
    cf9a:	785b      	ldrb	r3, [r3, #1]
    cf9c:	001a      	movs	r2, r3
    cf9e:	23b8      	movs	r3, #184	; 0xb8
    cfa0:	33ff      	adds	r3, #255	; 0xff
    cfa2:	18fc      	adds	r4, r7, r3
    cfa4:	2394      	movs	r3, #148	; 0x94
    cfa6:	005b      	lsls	r3, r3, #1
    cfa8:	18fb      	adds	r3, r7, r3
    cfaa:	0019      	movs	r1, r3
    cfac:	4b46      	ldr	r3, [pc, #280]	; (d0c8 <atcab_priv_write+0x4c0>)
    cfae:	4798      	blx	r3
    cfb0:	0003      	movs	r3, r0
    cfb2:	7023      	strb	r3, [r4, #0]
    cfb4:	23b8      	movs	r3, #184	; 0xb8
    cfb6:	33ff      	adds	r3, #255	; 0xff
    cfb8:	18fb      	adds	r3, r7, r3
    cfba:	781b      	ldrb	r3, [r3, #0]
    cfbc:	2b00      	cmp	r3, #0
    cfbe:	d154      	bne.n	d06a <atcab_priv_write+0x462>
			break;

		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);
    cfc0:	23da      	movs	r3, #218	; 0xda
    cfc2:	005b      	lsls	r3, r3, #1
    cfc4:	18fb      	adds	r3, r7, r3
    cfc6:	881b      	ldrh	r3, [r3, #0]
    cfc8:	0018      	movs	r0, r3
    cfca:	4b40      	ldr	r3, [pc, #256]	; (d0cc <atcab_priv_write+0x4c4>)
    cfcc:	4798      	blx	r3

		// receive the response
		if ((status = atreceive(_gIface, packet.data, &packet.rxsize)) != ATCA_SUCCESS)
    cfce:	4b3d      	ldr	r3, [pc, #244]	; (d0c4 <atcab_priv_write+0x4bc>)
    cfd0:	6818      	ldr	r0, [r3, #0]
    cfd2:	23b8      	movs	r3, #184	; 0xb8
    cfd4:	33ff      	adds	r3, #255	; 0xff
    cfd6:	18fc      	adds	r4, r7, r3
    cfd8:	2394      	movs	r3, #148	; 0x94
    cfda:	005b      	lsls	r3, r3, #1
    cfdc:	18fb      	adds	r3, r7, r3
    cfde:	338a      	adds	r3, #138	; 0x8a
    cfe0:	001a      	movs	r2, r3
    cfe2:	2394      	movs	r3, #148	; 0x94
    cfe4:	005b      	lsls	r3, r3, #1
    cfe6:	18fb      	adds	r3, r7, r3
    cfe8:	3306      	adds	r3, #6
    cfea:	0019      	movs	r1, r3
    cfec:	4b38      	ldr	r3, [pc, #224]	; (d0d0 <atcab_priv_write+0x4c8>)
    cfee:	4798      	blx	r3
    cff0:	0003      	movs	r3, r0
    cff2:	7023      	strb	r3, [r4, #0]
    cff4:	23b8      	movs	r3, #184	; 0xb8
    cff6:	33ff      	adds	r3, #255	; 0xff
    cff8:	18fb      	adds	r3, r7, r3
    cffa:	781b      	ldrb	r3, [r3, #0]
    cffc:	2b00      	cmp	r3, #0
    cffe:	d136      	bne.n	d06e <atcab_priv_write+0x466>
			break;

		// Check response size
		if (packet.rxsize < 4) {
    d000:	2394      	movs	r3, #148	; 0x94
    d002:	005b      	lsls	r3, r3, #1
    d004:	18fb      	adds	r3, r7, r3
    d006:	228a      	movs	r2, #138	; 0x8a
    d008:	5a9b      	ldrh	r3, [r3, r2]
    d00a:	2b03      	cmp	r3, #3
    d00c:	d812      	bhi.n	d034 <atcab_priv_write+0x42c>
			if (packet.rxsize > 0)
    d00e:	2394      	movs	r3, #148	; 0x94
    d010:	005b      	lsls	r3, r3, #1
    d012:	18fb      	adds	r3, r7, r3
    d014:	228a      	movs	r2, #138	; 0x8a
    d016:	5a9b      	ldrh	r3, [r3, r2]
    d018:	2b00      	cmp	r3, #0
    d01a:	d005      	beq.n	d028 <atcab_priv_write+0x420>
				status = ATCA_RX_FAIL;
    d01c:	23b8      	movs	r3, #184	; 0xb8
    d01e:	33ff      	adds	r3, #255	; 0xff
    d020:	18fb      	adds	r3, r7, r3
    d022:	22e6      	movs	r2, #230	; 0xe6
    d024:	701a      	strb	r2, [r3, #0]
			else
				status = ATCA_RX_NO_RESPONSE;
			break;
    d026:	e023      	b.n	d070 <atcab_priv_write+0x468>
		// Check response size
		if (packet.rxsize < 4) {
			if (packet.rxsize > 0)
				status = ATCA_RX_FAIL;
			else
				status = ATCA_RX_NO_RESPONSE;
    d028:	23b8      	movs	r3, #184	; 0xb8
    d02a:	33ff      	adds	r3, #255	; 0xff
    d02c:	18fb      	adds	r3, r7, r3
    d02e:	22e7      	movs	r2, #231	; 0xe7
    d030:	701a      	strb	r2, [r3, #0]
			break;
    d032:	e01d      	b.n	d070 <atcab_priv_write+0x468>
		}

		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
    d034:	23b8      	movs	r3, #184	; 0xb8
    d036:	33ff      	adds	r3, #255	; 0xff
    d038:	18fc      	adds	r4, r7, r3
    d03a:	2394      	movs	r3, #148	; 0x94
    d03c:	005b      	lsls	r3, r3, #1
    d03e:	18fb      	adds	r3, r7, r3
    d040:	3306      	adds	r3, #6
    d042:	0018      	movs	r0, r3
    d044:	4b23      	ldr	r3, [pc, #140]	; (d0d4 <atcab_priv_write+0x4cc>)
    d046:	4798      	blx	r3
    d048:	0003      	movs	r3, r0
    d04a:	7023      	strb	r3, [r4, #0]
    d04c:	e010      	b.n	d070 <atcab_priv_write+0x468>
			memcpy(privKey, priv_key, 36);
			memcpy(writeKey, write_key, 32);

			// Send the random Nonce command
			if ((status = atcab_nonce_rand(numin, randout)) != ATCA_SUCCESS)
				break;
    d04e:	46c0      	nop			; (mov r8, r8)
    d050:	e00e      	b.n	d070 <atcab_priv_write+0x468>
			nonceParam.mode = NONCE_MODE_SEED_UPDATE;
			nonceParam.num_in = numin;
			nonceParam.rand_out = randout;
			nonceParam.temp_key = &tempkey;
			if ((status = atcah_nonce(&nonceParam)) != ATCA_SUCCESS)
				break;
    d052:	46c0      	nop			; (mov r8, r8)
    d054:	e00c      	b.n	d070 <atcab_priv_write+0x468>

			// Send the GenDig command
			if ((status = atcab_gendig_host(GENDIG_ZONE_DATA, write_key_slot, tempkey.value, 32)) != ATCA_SUCCESS)
				break;
    d056:	46c0      	nop			; (mov r8, r8)
    d058:	e00a      	b.n	d070 <atcab_priv_write+0x468>
			genDigParam.zone = GENDIG_ZONE_DATA;
			genDigParam.key_id = write_key_slot;
			genDigParam.stored_value = writeKey;
			genDigParam.temp_key = &tempkey;
			if ((status = atcah_gen_dig(&genDigParam)) != ATCA_SUCCESS)
				break;
    d05a:	46c0      	nop			; (mov r8, r8)
    d05c:	e008      	b.n	d070 <atcab_priv_write+0x468>
			hostMacParam.input_data = privKey;
			hostMacParam.encrypted_data = cipher_text;
			hostMacParam.auth_mac = host_mac;
			hostMacParam.temp_key = &tempkey;
			if ((status = atcah_privwrite_auth_mac(&hostMacParam)) != ATCA_SUCCESS)
				break;
    d05e:	46c0      	nop			; (mov r8, r8)
    d060:	e006      	b.n	d070 <atcab_priv_write+0x468>
			memcpy(&packet.data[0], cipher_text, sizeof(cipher_text));
			memcpy(&packet.data[36], host_mac, sizeof(host_mac));
		}

		if ((status = atPrivWrite(_gCommandObj, &packet)) != ATCA_SUCCESS)
			break;
    d062:	46c0      	nop			; (mov r8, r8)
    d064:	e004      	b.n	d070 <atcab_priv_write+0x468>

		execution_time = atGetExecTime(_gCommandObj, CMD_PRIVWRITE);

		if ( (status = atcab_wakeup()) != ATCA_SUCCESS ) break;
    d066:	46c0      	nop			; (mov r8, r8)
    d068:	e002      	b.n	d070 <atcab_priv_write+0x468>

		// send the command
		if ((status = atsend(_gIface, (uint8_t*)&packet, packet.txsize)) != ATCA_SUCCESS)
			break;
    d06a:	46c0      	nop			; (mov r8, r8)
    d06c:	e000      	b.n	d070 <atcab_priv_write+0x468>
		// delay the appropriate amount of time for command to execute
		atca_delay_ms(execution_time);

		// receive the response
		if ((status = atreceive(_gIface, packet.data, &packet.rxsize)) != ATCA_SUCCESS)
			break;
    d06e:	46c0      	nop			; (mov r8, r8)
		if ( (status = isATCAError(packet.data)) != ATCA_SUCCESS )
			break;

	} while (0);

	_atcab_exit();
    d070:	4b19      	ldr	r3, [pc, #100]	; (d0d8 <atcab_priv_write+0x4d0>)
    d072:	4798      	blx	r3
	return status;
    d074:	23b8      	movs	r3, #184	; 0xb8
    d076:	33ff      	adds	r3, #255	; 0xff
    d078:	18fb      	adds	r3, r7, r3
    d07a:	781b      	ldrb	r3, [r3, #0]
}
    d07c:	0018      	movs	r0, r3
    d07e:	46bd      	mov	sp, r7
    d080:	b06e      	add	sp, #440	; 0x1b8
    d082:	bdb0      	pop	{r4, r5, r7, pc}
    d084:	fffffe7c 	.word	0xfffffe7c
    d088:	000127e7 	.word	0x000127e7
    d08c:	fffffe5c 	.word	0xfffffe5c
    d090:	0000b2d9 	.word	0x0000b2d9
    d094:	0000e445 	.word	0x0000e445
    d098:	fffffe56 	.word	0xfffffe56
    d09c:	0000c895 	.word	0x0000c895
    d0a0:	0000e57d 	.word	0x0000e57d
    d0a4:	fffffe57 	.word	0xfffffe57
    d0a8:	0000e715 	.word	0x0000e715
    d0ac:	fffffec0 	.word	0xfffffec0
    d0b0:	fffffea0 	.word	0xfffffea0
    d0b4:	200007e4 	.word	0x200007e4
    d0b8:	0000a595 	.word	0x0000a595
    d0bc:	0000a7f5 	.word	0x0000a7f5
    d0c0:	0000ad9d 	.word	0x0000ad9d
    d0c4:	200007e8 	.word	0x200007e8
    d0c8:	0000ab85 	.word	0x0000ab85
    d0cc:	0000e3d5 	.word	0x0000e3d5
    d0d0:	0000aba9 	.word	0x0000aba9
    d0d4:	0000a955 	.word	0x0000a955
    d0d8:	0000ae2d 	.word	0x0000ae2d

0000d0dc <atcab_bin2hex>:
 *  \param[out] asciihex buffer that receives hex string
 *  \param[out] hexlen the length of the asciihex buffer
 * \return ATCA_STATUS
 */
ATCA_STATUS atcab_bin2hex(const uint8_t* binary, int binLen, char* asciihex, int* asciihexlen)
{
    d0dc:	b590      	push	{r4, r7, lr}
    d0de:	b087      	sub	sp, #28
    d0e0:	af02      	add	r7, sp, #8
    d0e2:	60f8      	str	r0, [r7, #12]
    d0e4:	60b9      	str	r1, [r7, #8]
    d0e6:	607a      	str	r2, [r7, #4]
    d0e8:	603b      	str	r3, [r7, #0]
	return atcab_bin2hex_(binary, binLen, asciihex, asciihexlen, true);
    d0ea:	683c      	ldr	r4, [r7, #0]
    d0ec:	687a      	ldr	r2, [r7, #4]
    d0ee:	68b9      	ldr	r1, [r7, #8]
    d0f0:	68f8      	ldr	r0, [r7, #12]
    d0f2:	2301      	movs	r3, #1
    d0f4:	9300      	str	r3, [sp, #0]
    d0f6:	0023      	movs	r3, r4
    d0f8:	4c03      	ldr	r4, [pc, #12]	; (d108 <atcab_bin2hex+0x2c>)
    d0fa:	47a0      	blx	r4
    d0fc:	0003      	movs	r3, r0
}
    d0fe:	0018      	movs	r0, r3
    d100:	46bd      	mov	sp, r7
    d102:	b005      	add	sp, #20
    d104:	bd90      	pop	{r4, r7, pc}
    d106:	46c0      	nop			; (mov r8, r8)
    d108:	0000d10d 	.word	0x0000d10d

0000d10c <atcab_bin2hex_>:
 *  \param[inout] asciihexlen the length of the asciihex buffer
 *  \param[inout] addspace indicates whether spaces and returns should be added for pretty printing
 * \return ATCA_STATUS
 */
ATCA_STATUS atcab_bin2hex_(const uint8_t* binary, int binLen, char* asciihex, int* asciihexlen, bool addspace)
{
    d10c:	b580      	push	{r7, lr}
    d10e:	b086      	sub	sp, #24
    d110:	af00      	add	r7, sp, #0
    d112:	60f8      	str	r0, [r7, #12]
    d114:	60b9      	str	r1, [r7, #8]
    d116:	607a      	str	r2, [r7, #4]
    d118:	603b      	str	r3, [r7, #0]
	int i;
	int hexlen = 0;
    d11a:	2300      	movs	r3, #0
    d11c:	613b      	str	r3, [r7, #16]

	// Verify the inputs
	if ((binary == NULL) || (asciihex == NULL) || (asciihexlen == NULL))
    d11e:	68fb      	ldr	r3, [r7, #12]
    d120:	2b00      	cmp	r3, #0
    d122:	d005      	beq.n	d130 <atcab_bin2hex_+0x24>
    d124:	687b      	ldr	r3, [r7, #4]
    d126:	2b00      	cmp	r3, #0
    d128:	d002      	beq.n	d130 <atcab_bin2hex_+0x24>
    d12a:	683b      	ldr	r3, [r7, #0]
    d12c:	2b00      	cmp	r3, #0
    d12e:	d101      	bne.n	d134 <atcab_bin2hex_+0x28>
		return ATCA_BAD_PARAM;
    d130:	23e2      	movs	r3, #226	; 0xe2
    d132:	e05e      	b.n	d1f2 <atcab_bin2hex_+0xe6>

	// Initialize the return bytes to all 0s
	memset(asciihex, 0, *asciihexlen);
    d134:	683b      	ldr	r3, [r7, #0]
    d136:	681b      	ldr	r3, [r3, #0]
    d138:	001a      	movs	r2, r3
    d13a:	687b      	ldr	r3, [r7, #4]
    d13c:	2100      	movs	r1, #0
    d13e:	0018      	movs	r0, r3
    d140:	4b2e      	ldr	r3, [pc, #184]	; (d1fc <atcab_bin2hex_+0xf0>)
    d142:	4798      	blx	r3

	// Convert one byte at a time
	for (i = 0; i < binLen; i++) {
    d144:	2300      	movs	r3, #0
    d146:	617b      	str	r3, [r7, #20]
    d148:	e044      	b.n	d1d4 <atcab_bin2hex_+0xc8>
		if (hexlen > *asciihexlen) break;
    d14a:	683b      	ldr	r3, [r7, #0]
    d14c:	681a      	ldr	r2, [r3, #0]
    d14e:	693b      	ldr	r3, [r7, #16]
    d150:	429a      	cmp	r2, r3
    d152:	db44      	blt.n	d1de <atcab_bin2hex_+0xd2>
		if ((i % 16 == 0 && i != 0) && addspace) {
    d154:	697b      	ldr	r3, [r7, #20]
    d156:	220f      	movs	r2, #15
    d158:	4013      	ands	r3, r2
    d15a:	d114      	bne.n	d186 <atcab_bin2hex_+0x7a>
    d15c:	697b      	ldr	r3, [r7, #20]
    d15e:	2b00      	cmp	r3, #0
    d160:	d011      	beq.n	d186 <atcab_bin2hex_+0x7a>
    d162:	2320      	movs	r3, #32
    d164:	18fb      	adds	r3, r7, r3
    d166:	781b      	ldrb	r3, [r3, #0]
    d168:	2b00      	cmp	r3, #0
    d16a:	d00c      	beq.n	d186 <atcab_bin2hex_+0x7a>
			sprintf(&asciihex[hexlen], "\r\n");
    d16c:	693b      	ldr	r3, [r7, #16]
    d16e:	687a      	ldr	r2, [r7, #4]
    d170:	18d2      	adds	r2, r2, r3
    d172:	4b23      	ldr	r3, [pc, #140]	; (d200 <atcab_bin2hex_+0xf4>)
    d174:	0010      	movs	r0, r2
    d176:	0019      	movs	r1, r3
    d178:	2303      	movs	r3, #3
    d17a:	001a      	movs	r2, r3
    d17c:	4b21      	ldr	r3, [pc, #132]	; (d204 <atcab_bin2hex_+0xf8>)
    d17e:	4798      	blx	r3
			hexlen += 2;
    d180:	693b      	ldr	r3, [r7, #16]
    d182:	3302      	adds	r3, #2
    d184:	613b      	str	r3, [r7, #16]
		}
		if (addspace) {
    d186:	2320      	movs	r3, #32
    d188:	18fb      	adds	r3, r7, r3
    d18a:	781b      	ldrb	r3, [r3, #0]
    d18c:	2b00      	cmp	r3, #0
    d18e:	d00f      	beq.n	d1b0 <atcab_bin2hex_+0xa4>
			sprintf(&asciihex[hexlen], "%02X ", *binary++);
    d190:	693b      	ldr	r3, [r7, #16]
    d192:	687a      	ldr	r2, [r7, #4]
    d194:	18d0      	adds	r0, r2, r3
    d196:	68fb      	ldr	r3, [r7, #12]
    d198:	1c5a      	adds	r2, r3, #1
    d19a:	60fa      	str	r2, [r7, #12]
    d19c:	781b      	ldrb	r3, [r3, #0]
    d19e:	001a      	movs	r2, r3
    d1a0:	4b19      	ldr	r3, [pc, #100]	; (d208 <atcab_bin2hex_+0xfc>)
    d1a2:	0019      	movs	r1, r3
    d1a4:	4b19      	ldr	r3, [pc, #100]	; (d20c <atcab_bin2hex_+0x100>)
    d1a6:	4798      	blx	r3
			hexlen += 3;
    d1a8:	693b      	ldr	r3, [r7, #16]
    d1aa:	3303      	adds	r3, #3
    d1ac:	613b      	str	r3, [r7, #16]
    d1ae:	e00e      	b.n	d1ce <atcab_bin2hex_+0xc2>
		}else {
			sprintf(&asciihex[hexlen], "%02X", *binary++);
    d1b0:	693b      	ldr	r3, [r7, #16]
    d1b2:	687a      	ldr	r2, [r7, #4]
    d1b4:	18d0      	adds	r0, r2, r3
    d1b6:	68fb      	ldr	r3, [r7, #12]
    d1b8:	1c5a      	adds	r2, r3, #1
    d1ba:	60fa      	str	r2, [r7, #12]
    d1bc:	781b      	ldrb	r3, [r3, #0]
    d1be:	001a      	movs	r2, r3
    d1c0:	4b13      	ldr	r3, [pc, #76]	; (d210 <atcab_bin2hex_+0x104>)
    d1c2:	0019      	movs	r1, r3
    d1c4:	4b11      	ldr	r3, [pc, #68]	; (d20c <atcab_bin2hex_+0x100>)
    d1c6:	4798      	blx	r3
			hexlen += 2;
    d1c8:	693b      	ldr	r3, [r7, #16]
    d1ca:	3302      	adds	r3, #2
    d1cc:	613b      	str	r3, [r7, #16]

	// Initialize the return bytes to all 0s
	memset(asciihex, 0, *asciihexlen);

	// Convert one byte at a time
	for (i = 0; i < binLen; i++) {
    d1ce:	697b      	ldr	r3, [r7, #20]
    d1d0:	3301      	adds	r3, #1
    d1d2:	617b      	str	r3, [r7, #20]
    d1d4:	697a      	ldr	r2, [r7, #20]
    d1d6:	68bb      	ldr	r3, [r7, #8]
    d1d8:	429a      	cmp	r2, r3
    d1da:	dbb6      	blt.n	d14a <atcab_bin2hex_+0x3e>
    d1dc:	e000      	b.n	d1e0 <atcab_bin2hex_+0xd4>
		if (hexlen > *asciihexlen) break;
    d1de:	46c0      	nop			; (mov r8, r8)
		}else {
			sprintf(&asciihex[hexlen], "%02X", *binary++);
			hexlen += 2;
		}
	}
	*asciihexlen = (int)strlen(asciihex);
    d1e0:	687b      	ldr	r3, [r7, #4]
    d1e2:	0018      	movs	r0, r3
    d1e4:	4b0b      	ldr	r3, [pc, #44]	; (d214 <atcab_bin2hex_+0x108>)
    d1e6:	4798      	blx	r3
    d1e8:	0003      	movs	r3, r0
    d1ea:	001a      	movs	r2, r3
    d1ec:	683b      	ldr	r3, [r7, #0]
    d1ee:	601a      	str	r2, [r3, #0]

	return ATCA_SUCCESS;
    d1f0:	2300      	movs	r3, #0
}
    d1f2:	0018      	movs	r0, r3
    d1f4:	46bd      	mov	sp, r7
    d1f6:	b006      	add	sp, #24
    d1f8:	bd80      	pop	{r7, pc}
    d1fa:	46c0      	nop			; (mov r8, r8)
    d1fc:	00012823 	.word	0x00012823
    d200:	000152d8 	.word	0x000152d8
    d204:	000127e7 	.word	0x000127e7
    d208:	000152dc 	.word	0x000152dc
    d20c:	00012c6d 	.word	0x00012c6d
    d210:	000152e4 	.word	0x000152e4
    d214:	00012d49 	.word	0x00012d49

0000d218 <atcac_sw_sha1_init>:

#include "atca_crypto_sw_sha1.h"
#include "hashes/sha1_routines.h"

int atcac_sw_sha1_init(atcac_sha1_ctx* ctx)
{
    d218:	b580      	push	{r7, lr}
    d21a:	b082      	sub	sp, #8
    d21c:	af00      	add	r7, sp, #0
    d21e:	6078      	str	r0, [r7, #4]
	if (sizeof(CL_HashContext) > sizeof(atcac_sha1_ctx))
		return ATCA_ASSERT_FAILURE; // atcac_sha1_ctx isn't large enough for this implementation
	CL_hashInit((CL_HashContext*)ctx);
    d220:	687b      	ldr	r3, [r7, #4]
    d222:	0018      	movs	r0, r3
    d224:	4b03      	ldr	r3, [pc, #12]	; (d234 <atcac_sw_sha1_init+0x1c>)
    d226:	4798      	blx	r3

	return ATCA_SUCCESS;
    d228:	2300      	movs	r3, #0
}
    d22a:	0018      	movs	r0, r3
    d22c:	46bd      	mov	sp, r7
    d22e:	b002      	add	sp, #8
    d230:	bd80      	pop	{r7, pc}
    d232:	46c0      	nop			; (mov r8, r8)
    d234:	0000d421 	.word	0x0000d421

0000d238 <atcac_sw_sha1_update>:

int atcac_sw_sha1_update(atcac_sha1_ctx* ctx, const uint8_t* data, size_t data_size)
{
    d238:	b580      	push	{r7, lr}
    d23a:	b084      	sub	sp, #16
    d23c:	af00      	add	r7, sp, #0
    d23e:	60f8      	str	r0, [r7, #12]
    d240:	60b9      	str	r1, [r7, #8]
    d242:	607a      	str	r2, [r7, #4]
	CL_hashUpdate((CL_HashContext*)ctx, data, (int)data_size);
    d244:	687a      	ldr	r2, [r7, #4]
    d246:	68b9      	ldr	r1, [r7, #8]
    d248:	68fb      	ldr	r3, [r7, #12]
    d24a:	0018      	movs	r0, r3
    d24c:	4b03      	ldr	r3, [pc, #12]	; (d25c <atcac_sw_sha1_update+0x24>)
    d24e:	4798      	blx	r3

	return ATCA_SUCCESS;
    d250:	2300      	movs	r3, #0
}
    d252:	0018      	movs	r0, r3
    d254:	46bd      	mov	sp, r7
    d256:	b004      	add	sp, #16
    d258:	bd80      	pop	{r7, pc}
    d25a:	46c0      	nop			; (mov r8, r8)
    d25c:	0000d459 	.word	0x0000d459

0000d260 <atcac_sw_sha1_finish>:

int atcac_sw_sha1_finish(atcac_sha1_ctx* ctx, uint8_t digest[ATCA_SHA1_DIGEST_SIZE])
{
    d260:	b580      	push	{r7, lr}
    d262:	b082      	sub	sp, #8
    d264:	af00      	add	r7, sp, #0
    d266:	6078      	str	r0, [r7, #4]
    d268:	6039      	str	r1, [r7, #0]
	CL_hashFinal((CL_HashContext*)ctx, digest);
    d26a:	683a      	ldr	r2, [r7, #0]
    d26c:	687b      	ldr	r3, [r7, #4]
    d26e:	0011      	movs	r1, r2
    d270:	0018      	movs	r0, r3
    d272:	4b03      	ldr	r3, [pc, #12]	; (d280 <atcac_sw_sha1_finish+0x20>)
    d274:	4798      	blx	r3

	return ATCA_SUCCESS;
    d276:	2300      	movs	r3, #0
}
    d278:	0018      	movs	r0, r3
    d27a:	46bd      	mov	sp, r7
    d27c:	b002      	add	sp, #8
    d27e:	bd80      	pop	{r7, pc}
    d280:	0000d579 	.word	0x0000d579

0000d284 <atcac_sw_sha1>:

int atcac_sw_sha1(const uint8_t* data, size_t data_size, uint8_t digest[ATCA_SHA1_DIGEST_SIZE])
{
    d284:	b580      	push	{r7, lr}
    d286:	b0a6      	sub	sp, #152	; 0x98
    d288:	af00      	add	r7, sp, #0
    d28a:	60f8      	str	r0, [r7, #12]
    d28c:	60b9      	str	r1, [r7, #8]
    d28e:	607a      	str	r2, [r7, #4]
	int ret;
	atcac_sha1_ctx ctx;

	ret = atcac_sw_sha1_init(&ctx);
    d290:	2314      	movs	r3, #20
    d292:	18fb      	adds	r3, r7, r3
    d294:	0018      	movs	r0, r3
    d296:	4b1e      	ldr	r3, [pc, #120]	; (d310 <atcac_sw_sha1+0x8c>)
    d298:	4798      	blx	r3
    d29a:	0003      	movs	r3, r0
    d29c:	2294      	movs	r2, #148	; 0x94
    d29e:	18ba      	adds	r2, r7, r2
    d2a0:	6013      	str	r3, [r2, #0]
	if (ret != ATCA_SUCCESS)
    d2a2:	2394      	movs	r3, #148	; 0x94
    d2a4:	18fb      	adds	r3, r7, r3
    d2a6:	681b      	ldr	r3, [r3, #0]
    d2a8:	2b00      	cmp	r3, #0
    d2aa:	d003      	beq.n	d2b4 <atcac_sw_sha1+0x30>
		return ret;
    d2ac:	2394      	movs	r3, #148	; 0x94
    d2ae:	18fb      	adds	r3, r7, r3
    d2b0:	681b      	ldr	r3, [r3, #0]
    d2b2:	e028      	b.n	d306 <atcac_sw_sha1+0x82>

	ret = atcac_sw_sha1_update(&ctx, data, data_size);
    d2b4:	68ba      	ldr	r2, [r7, #8]
    d2b6:	68f9      	ldr	r1, [r7, #12]
    d2b8:	2314      	movs	r3, #20
    d2ba:	18fb      	adds	r3, r7, r3
    d2bc:	0018      	movs	r0, r3
    d2be:	4b15      	ldr	r3, [pc, #84]	; (d314 <atcac_sw_sha1+0x90>)
    d2c0:	4798      	blx	r3
    d2c2:	0003      	movs	r3, r0
    d2c4:	2294      	movs	r2, #148	; 0x94
    d2c6:	18ba      	adds	r2, r7, r2
    d2c8:	6013      	str	r3, [r2, #0]
	if (ret != ATCA_SUCCESS)
    d2ca:	2394      	movs	r3, #148	; 0x94
    d2cc:	18fb      	adds	r3, r7, r3
    d2ce:	681b      	ldr	r3, [r3, #0]
    d2d0:	2b00      	cmp	r3, #0
    d2d2:	d003      	beq.n	d2dc <atcac_sw_sha1+0x58>
		return ret;
    d2d4:	2394      	movs	r3, #148	; 0x94
    d2d6:	18fb      	adds	r3, r7, r3
    d2d8:	681b      	ldr	r3, [r3, #0]
    d2da:	e014      	b.n	d306 <atcac_sw_sha1+0x82>

	ret = atcac_sw_sha1_finish(&ctx, digest);
    d2dc:	687a      	ldr	r2, [r7, #4]
    d2de:	2314      	movs	r3, #20
    d2e0:	18fb      	adds	r3, r7, r3
    d2e2:	0011      	movs	r1, r2
    d2e4:	0018      	movs	r0, r3
    d2e6:	4b0c      	ldr	r3, [pc, #48]	; (d318 <atcac_sw_sha1+0x94>)
    d2e8:	4798      	blx	r3
    d2ea:	0003      	movs	r3, r0
    d2ec:	2294      	movs	r2, #148	; 0x94
    d2ee:	18ba      	adds	r2, r7, r2
    d2f0:	6013      	str	r3, [r2, #0]
	if (ret != ATCA_SUCCESS)
    d2f2:	2394      	movs	r3, #148	; 0x94
    d2f4:	18fb      	adds	r3, r7, r3
    d2f6:	681b      	ldr	r3, [r3, #0]
    d2f8:	2b00      	cmp	r3, #0
    d2fa:	d003      	beq.n	d304 <atcac_sw_sha1+0x80>
		return ret;
    d2fc:	2394      	movs	r3, #148	; 0x94
    d2fe:	18fb      	adds	r3, r7, r3
    d300:	681b      	ldr	r3, [r3, #0]
    d302:	e000      	b.n	d306 <atcac_sw_sha1+0x82>

	return ATCA_SUCCESS;
    d304:	2300      	movs	r3, #0
    d306:	0018      	movs	r0, r3
    d308:	46bd      	mov	sp, r7
    d30a:	b026      	add	sp, #152	; 0x98
    d30c:	bd80      	pop	{r7, pc}
    d30e:	46c0      	nop			; (mov r8, r8)
    d310:	0000d219 	.word	0x0000d219
    d314:	0000d239 	.word	0x0000d239
    d318:	0000d261 	.word	0x0000d261

0000d31c <atcac_sw_sha2_256_init>:
 * \param[in] ctx  ptr to context data structure
 * \return ATCA_STATUS value
 */

int atcac_sw_sha2_256_init(atcac_sha2_256_ctx* ctx)
{
    d31c:	b580      	push	{r7, lr}
    d31e:	b082      	sub	sp, #8
    d320:	af00      	add	r7, sp, #0
    d322:	6078      	str	r0, [r7, #4]
	if (sizeof(sw_sha256_ctx) > sizeof(atcac_sha2_256_ctx))
		return ATCA_ASSERT_FAILURE; // atcac_sha1_ctx isn't large enough for this implementation
	sw_sha256_init((sw_sha256_ctx*)ctx);
    d324:	687b      	ldr	r3, [r7, #4]
    d326:	0018      	movs	r0, r3
    d328:	4b03      	ldr	r3, [pc, #12]	; (d338 <atcac_sw_sha2_256_init+0x1c>)
    d32a:	4798      	blx	r3

	return ATCA_SUCCESS;
    d32c:	2300      	movs	r3, #0
}
    d32e:	0018      	movs	r0, r3
    d330:	46bd      	mov	sp, r7
    d332:	b002      	add	sp, #8
    d334:	bd80      	pop	{r7, pc}
    d336:	46c0      	nop			; (mov r8, r8)
    d338:	0000071d 	.word	0x0000071d

0000d33c <atcac_sw_sha2_256_update>:
    \param[in] data_size  size amount of data to hash in the given block, in bytes
    \return ATCA_STATUS
 */

int atcac_sw_sha2_256_update(atcac_sha2_256_ctx* ctx, const uint8_t* data, size_t data_size)
{
    d33c:	b580      	push	{r7, lr}
    d33e:	b084      	sub	sp, #16
    d340:	af00      	add	r7, sp, #0
    d342:	60f8      	str	r0, [r7, #12]
    d344:	60b9      	str	r1, [r7, #8]
    d346:	607a      	str	r2, [r7, #4]
	sw_sha256_update((sw_sha256_ctx*)ctx, data, (uint32_t)data_size);
    d348:	687a      	ldr	r2, [r7, #4]
    d34a:	68b9      	ldr	r1, [r7, #8]
    d34c:	68fb      	ldr	r3, [r7, #12]
    d34e:	0018      	movs	r0, r3
    d350:	4b03      	ldr	r3, [pc, #12]	; (d360 <atcac_sw_sha2_256_update+0x24>)
    d352:	4798      	blx	r3

	return ATCA_SUCCESS;
    d354:	2300      	movs	r3, #0
}
    d356:	0018      	movs	r0, r3
    d358:	46bd      	mov	sp, r7
    d35a:	b004      	add	sp, #16
    d35c:	bd80      	pop	{r7, pc}
    d35e:	46c0      	nop			; (mov r8, r8)
    d360:	00000765 	.word	0x00000765

0000d364 <atcac_sw_sha2_256_finish>:
 * \param[out] digest  receives the computed digest of the SHA 256 has
 * \return ATCA_STATUS
 */

int atcac_sw_sha2_256_finish(atcac_sha2_256_ctx* ctx, uint8_t digest[ATCA_SHA2_256_DIGEST_SIZE])
{
    d364:	b580      	push	{r7, lr}
    d366:	b082      	sub	sp, #8
    d368:	af00      	add	r7, sp, #0
    d36a:	6078      	str	r0, [r7, #4]
    d36c:	6039      	str	r1, [r7, #0]
	sw_sha256_final((sw_sha256_ctx*)ctx, digest);
    d36e:	683a      	ldr	r2, [r7, #0]
    d370:	687b      	ldr	r3, [r7, #4]
    d372:	0011      	movs	r1, r2
    d374:	0018      	movs	r0, r3
    d376:	4b03      	ldr	r3, [pc, #12]	; (d384 <atcac_sw_sha2_256_finish+0x20>)
    d378:	4798      	blx	r3

	return ATCA_SUCCESS;
    d37a:	2300      	movs	r3, #0
}
    d37c:	0018      	movs	r0, r3
    d37e:	46bd      	mov	sp, r7
    d380:	b002      	add	sp, #8
    d382:	bd80      	pop	{r7, pc}
    d384:	00000829 	.word	0x00000829

0000d388 <atcac_sw_sha2_256>:
 * \param[out] digest     result
 * \return ATCA_STATUS
 */

int atcac_sw_sha2_256(const uint8_t* data, size_t data_size, uint8_t digest[ATCA_SHA2_256_DIGEST_SIZE])
{
    d388:	b580      	push	{r7, lr}
    d38a:	b0b6      	sub	sp, #216	; 0xd8
    d38c:	af00      	add	r7, sp, #0
    d38e:	60f8      	str	r0, [r7, #12]
    d390:	60b9      	str	r1, [r7, #8]
    d392:	607a      	str	r2, [r7, #4]
	int ret;
	atcac_sha2_256_ctx ctx;

	ret = atcac_sw_sha2_256_init(&ctx);
    d394:	2314      	movs	r3, #20
    d396:	18fb      	adds	r3, r7, r3
    d398:	0018      	movs	r0, r3
    d39a:	4b1e      	ldr	r3, [pc, #120]	; (d414 <atcac_sw_sha2_256+0x8c>)
    d39c:	4798      	blx	r3
    d39e:	0003      	movs	r3, r0
    d3a0:	22d4      	movs	r2, #212	; 0xd4
    d3a2:	18ba      	adds	r2, r7, r2
    d3a4:	6013      	str	r3, [r2, #0]
	if (ret != ATCA_SUCCESS)
    d3a6:	23d4      	movs	r3, #212	; 0xd4
    d3a8:	18fb      	adds	r3, r7, r3
    d3aa:	681b      	ldr	r3, [r3, #0]
    d3ac:	2b00      	cmp	r3, #0
    d3ae:	d003      	beq.n	d3b8 <atcac_sw_sha2_256+0x30>
		return ret;
    d3b0:	23d4      	movs	r3, #212	; 0xd4
    d3b2:	18fb      	adds	r3, r7, r3
    d3b4:	681b      	ldr	r3, [r3, #0]
    d3b6:	e028      	b.n	d40a <atcac_sw_sha2_256+0x82>

	ret = atcac_sw_sha2_256_update(&ctx, data, data_size);
    d3b8:	68ba      	ldr	r2, [r7, #8]
    d3ba:	68f9      	ldr	r1, [r7, #12]
    d3bc:	2314      	movs	r3, #20
    d3be:	18fb      	adds	r3, r7, r3
    d3c0:	0018      	movs	r0, r3
    d3c2:	4b15      	ldr	r3, [pc, #84]	; (d418 <atcac_sw_sha2_256+0x90>)
    d3c4:	4798      	blx	r3
    d3c6:	0003      	movs	r3, r0
    d3c8:	22d4      	movs	r2, #212	; 0xd4
    d3ca:	18ba      	adds	r2, r7, r2
    d3cc:	6013      	str	r3, [r2, #0]
	if (ret != ATCA_SUCCESS)
    d3ce:	23d4      	movs	r3, #212	; 0xd4
    d3d0:	18fb      	adds	r3, r7, r3
    d3d2:	681b      	ldr	r3, [r3, #0]
    d3d4:	2b00      	cmp	r3, #0
    d3d6:	d003      	beq.n	d3e0 <atcac_sw_sha2_256+0x58>
		return ret;
    d3d8:	23d4      	movs	r3, #212	; 0xd4
    d3da:	18fb      	adds	r3, r7, r3
    d3dc:	681b      	ldr	r3, [r3, #0]
    d3de:	e014      	b.n	d40a <atcac_sw_sha2_256+0x82>

	ret = atcac_sw_sha2_256_finish(&ctx, digest);
    d3e0:	687a      	ldr	r2, [r7, #4]
    d3e2:	2314      	movs	r3, #20
    d3e4:	18fb      	adds	r3, r7, r3
    d3e6:	0011      	movs	r1, r2
    d3e8:	0018      	movs	r0, r3
    d3ea:	4b0c      	ldr	r3, [pc, #48]	; (d41c <atcac_sw_sha2_256+0x94>)
    d3ec:	4798      	blx	r3
    d3ee:	0003      	movs	r3, r0
    d3f0:	22d4      	movs	r2, #212	; 0xd4
    d3f2:	18ba      	adds	r2, r7, r2
    d3f4:	6013      	str	r3, [r2, #0]
	if (ret != ATCA_SUCCESS)
    d3f6:	23d4      	movs	r3, #212	; 0xd4
    d3f8:	18fb      	adds	r3, r7, r3
    d3fa:	681b      	ldr	r3, [r3, #0]
    d3fc:	2b00      	cmp	r3, #0
    d3fe:	d003      	beq.n	d408 <atcac_sw_sha2_256+0x80>
		return ret;
    d400:	23d4      	movs	r3, #212	; 0xd4
    d402:	18fb      	adds	r3, r7, r3
    d404:	681b      	ldr	r3, [r3, #0]
    d406:	e000      	b.n	d40a <atcac_sw_sha2_256+0x82>

	return ATCA_SUCCESS;
    d408:	2300      	movs	r3, #0
    d40a:	0018      	movs	r0, r3
    d40c:	46bd      	mov	sp, r7
    d40e:	b036      	add	sp, #216	; 0xd8
    d410:	bd80      	pop	{r7, pc}
    d412:	46c0      	nop			; (mov r8, r8)
    d414:	0000d31d 	.word	0x0000d31d
    d418:	0000d33d 	.word	0x0000d33d
    d41c:	0000d365 	.word	0x0000d365

0000d420 <CL_hashInit>:

#include "sha1_routines.h"
#include <string.h>

void CL_hashInit(CL_HashContext *ctx)
{
    d420:	b580      	push	{r7, lr}
    d422:	b082      	sub	sp, #8
    d424:	af00      	add	r7, sp, #0
    d426:	6078      	str	r0, [r7, #4]
		0x10325476,
		0xc3d2e1f0
	};

	// Initialize context
	memset(ctx, 0, sizeof(*ctx));
    d428:	687b      	ldr	r3, [r7, #4]
    d42a:	225c      	movs	r2, #92	; 0x5c
    d42c:	2100      	movs	r1, #0
    d42e:	0018      	movs	r0, r3
    d430:	4b06      	ldr	r3, [pc, #24]	; (d44c <CL_hashInit+0x2c>)
    d432:	4798      	blx	r3
	memcpy_P(ctx->h, hashContext_h_init, sizeof(ctx->h));
    d434:	687a      	ldr	r2, [r7, #4]
    d436:	4b06      	ldr	r3, [pc, #24]	; (d450 <CL_hashInit+0x30>)
    d438:	0010      	movs	r0, r2
    d43a:	0019      	movs	r1, r3
    d43c:	2314      	movs	r3, #20
    d43e:	001a      	movs	r2, r3
    d440:	4b04      	ldr	r3, [pc, #16]	; (d454 <CL_hashInit+0x34>)
    d442:	4798      	blx	r3
}
    d444:	46c0      	nop			; (mov r8, r8)
    d446:	46bd      	mov	sp, r7
    d448:	b002      	add	sp, #8
    d44a:	bd80      	pop	{r7, pc}
    d44c:	00012823 	.word	0x00012823
    d450:	000152f0 	.word	0x000152f0
    d454:	000127e7 	.word	0x000127e7

0000d458 <CL_hashUpdate>:

void CL_hashUpdate(CL_HashContext *ctx, const U8 *src, int nbytes)
{
    d458:	b580      	push	{r7, lr}
    d45a:	b086      	sub	sp, #24
    d45c:	af00      	add	r7, sp, #0
    d45e:	60f8      	str	r0, [r7, #12]
    d460:	60b9      	str	r1, [r7, #8]
    d462:	607a      	str	r2, [r7, #4]
	// assert may not be active in release versions.
	//
	//assert(sizeof(Buf64) == 64);

	// Get number of free bytes in the buf
	freeBytes = (U8)(ctx->byteCount);
    d464:	68fb      	ldr	r3, [r7, #12]
    d466:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    d468:	2316      	movs	r3, #22
    d46a:	18fb      	adds	r3, r7, r3
    d46c:	701a      	strb	r2, [r3, #0]
	freeBytes &= 63;
    d46e:	2316      	movs	r3, #22
    d470:	18fb      	adds	r3, r7, r3
    d472:	2216      	movs	r2, #22
    d474:	18ba      	adds	r2, r7, r2
    d476:	7812      	ldrb	r2, [r2, #0]
    d478:	213f      	movs	r1, #63	; 0x3f
    d47a:	400a      	ands	r2, r1
    d47c:	701a      	strb	r2, [r3, #0]
	freeBytes = (U8)(64 - freeBytes);
    d47e:	2316      	movs	r3, #22
    d480:	18fb      	adds	r3, r7, r3
    d482:	2216      	movs	r2, #22
    d484:	18ba      	adds	r2, r7, r2
    d486:	7812      	ldrb	r2, [r2, #0]
    d488:	2140      	movs	r1, #64	; 0x40
    d48a:	1a8a      	subs	r2, r1, r2
    d48c:	701a      	strb	r2, [r3, #0]

	while (nbytes > 0) {
    d48e:	e068      	b.n	d562 <CL_hashUpdate+0x10a>

		// Get i, number of bytes to transfer from src
		i = freeBytes;
    d490:	2317      	movs	r3, #23
    d492:	18fb      	adds	r3, r7, r3
    d494:	2216      	movs	r2, #22
    d496:	18ba      	adds	r2, r7, r2
    d498:	7812      	ldrb	r2, [r2, #0]
    d49a:	701a      	strb	r2, [r3, #0]
		if (nbytes < i) i = (U8)nbytes;
    d49c:	2317      	movs	r3, #23
    d49e:	18fb      	adds	r3, r7, r3
    d4a0:	781a      	ldrb	r2, [r3, #0]
    d4a2:	687b      	ldr	r3, [r7, #4]
    d4a4:	429a      	cmp	r2, r3
    d4a6:	dd03      	ble.n	d4b0 <CL_hashUpdate+0x58>
    d4a8:	2317      	movs	r3, #23
    d4aa:	18fb      	adds	r3, r7, r3
    d4ac:	687a      	ldr	r2, [r7, #4]
    d4ae:	701a      	strb	r2, [r3, #0]

		// Copy src bytes to buf
		if (i == 64)
    d4b0:	2317      	movs	r3, #23
    d4b2:	18fb      	adds	r3, r7, r3
    d4b4:	781b      	ldrb	r3, [r3, #0]
    d4b6:	2b40      	cmp	r3, #64	; 0x40
    d4b8:	d10a      	bne.n	d4d0 <CL_hashUpdate+0x78>
			// This seems to be much faster on IAR than memcpy().
			*(Buf64*)(ctx->buf) = *(Buf64*)src;
    d4ba:	68fb      	ldr	r3, [r7, #12]
    d4bc:	3314      	adds	r3, #20
    d4be:	001a      	movs	r2, r3
    d4c0:	68bb      	ldr	r3, [r7, #8]
    d4c2:	0010      	movs	r0, r2
    d4c4:	0019      	movs	r1, r3
    d4c6:	2340      	movs	r3, #64	; 0x40
    d4c8:	001a      	movs	r2, r3
    d4ca:	4b29      	ldr	r3, [pc, #164]	; (d570 <CL_hashUpdate+0x118>)
    d4cc:	4798      	blx	r3
    d4ce:	e00f      	b.n	d4f0 <CL_hashUpdate+0x98>
		else
			// Have to use memcpy, size is other than 64 bytes.
			memcpy(((U8*)ctx->buf) + 64 - freeBytes, src, i);
    d4d0:	68fb      	ldr	r3, [r7, #12]
    d4d2:	3314      	adds	r3, #20
    d4d4:	001a      	movs	r2, r3
    d4d6:	2316      	movs	r3, #22
    d4d8:	18fb      	adds	r3, r7, r3
    d4da:	781b      	ldrb	r3, [r3, #0]
    d4dc:	2140      	movs	r1, #64	; 0x40
    d4de:	1acb      	subs	r3, r1, r3
    d4e0:	18d0      	adds	r0, r2, r3
    d4e2:	2317      	movs	r3, #23
    d4e4:	18fb      	adds	r3, r7, r3
    d4e6:	781a      	ldrb	r2, [r3, #0]
    d4e8:	68bb      	ldr	r3, [r7, #8]
    d4ea:	0019      	movs	r1, r3
    d4ec:	4b20      	ldr	r3, [pc, #128]	; (d570 <CL_hashUpdate+0x118>)
    d4ee:	4798      	blx	r3

		// Adjust for transferred bytes
		src += i;
    d4f0:	2317      	movs	r3, #23
    d4f2:	18fb      	adds	r3, r7, r3
    d4f4:	781b      	ldrb	r3, [r3, #0]
    d4f6:	68ba      	ldr	r2, [r7, #8]
    d4f8:	18d3      	adds	r3, r2, r3
    d4fa:	60bb      	str	r3, [r7, #8]
		nbytes -= i;
    d4fc:	2317      	movs	r3, #23
    d4fe:	18fb      	adds	r3, r7, r3
    d500:	781b      	ldrb	r3, [r3, #0]
    d502:	687a      	ldr	r2, [r7, #4]
    d504:	1ad3      	subs	r3, r2, r3
    d506:	607b      	str	r3, [r7, #4]
		freeBytes -= i;
    d508:	2316      	movs	r3, #22
    d50a:	18fb      	adds	r3, r7, r3
    d50c:	2216      	movs	r2, #22
    d50e:	18b9      	adds	r1, r7, r2
    d510:	2217      	movs	r2, #23
    d512:	18ba      	adds	r2, r7, r2
    d514:	7809      	ldrb	r1, [r1, #0]
    d516:	7812      	ldrb	r2, [r2, #0]
    d518:	1a8a      	subs	r2, r1, r2
    d51a:	701a      	strb	r2, [r3, #0]

		// Do SHA crunch if buf is full
		if (freeBytes == 0)
    d51c:	2316      	movs	r3, #22
    d51e:	18fb      	adds	r3, r7, r3
    d520:	781b      	ldrb	r3, [r3, #0]
    d522:	2b00      	cmp	r3, #0
    d524:	d106      	bne.n	d534 <CL_hashUpdate+0xdc>
			shaEngine(ctx->buf, ctx->h);
    d526:	68fb      	ldr	r3, [r7, #12]
    d528:	3314      	adds	r3, #20
    d52a:	68fa      	ldr	r2, [r7, #12]
    d52c:	0011      	movs	r1, r2
    d52e:	0018      	movs	r0, r3
    d530:	4b10      	ldr	r3, [pc, #64]	; (d574 <CL_hashUpdate+0x11c>)
    d532:	4798      	blx	r3

		// Update 64-bit byte count
		temp32 = (ctx->byteCount += i);
    d534:	68fb      	ldr	r3, [r7, #12]
    d536:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    d538:	2317      	movs	r3, #23
    d53a:	18fb      	adds	r3, r7, r3
    d53c:	781b      	ldrb	r3, [r3, #0]
    d53e:	18d2      	adds	r2, r2, r3
    d540:	68fb      	ldr	r3, [r7, #12]
    d542:	655a      	str	r2, [r3, #84]	; 0x54
    d544:	68fb      	ldr	r3, [r7, #12]
    d546:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    d548:	613b      	str	r3, [r7, #16]
		if (temp32 == 0) ++ctx->byteCountHi;
    d54a:	693b      	ldr	r3, [r7, #16]
    d54c:	2b00      	cmp	r3, #0
    d54e:	d104      	bne.n	d55a <CL_hashUpdate+0x102>
    d550:	68fb      	ldr	r3, [r7, #12]
    d552:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    d554:	1c5a      	adds	r2, r3, #1
    d556:	68fb      	ldr	r3, [r7, #12]
    d558:	659a      	str	r2, [r3, #88]	; 0x58

		// Set up for next iteration
		freeBytes = 64;
    d55a:	2316      	movs	r3, #22
    d55c:	18fb      	adds	r3, r7, r3
    d55e:	2240      	movs	r2, #64	; 0x40
    d560:	701a      	strb	r2, [r3, #0]
	// Get number of free bytes in the buf
	freeBytes = (U8)(ctx->byteCount);
	freeBytes &= 63;
	freeBytes = (U8)(64 - freeBytes);

	while (nbytes > 0) {
    d562:	687b      	ldr	r3, [r7, #4]
    d564:	2b00      	cmp	r3, #0
    d566:	dc93      	bgt.n	d490 <CL_hashUpdate+0x38>
		if (temp32 == 0) ++ctx->byteCountHi;

		// Set up for next iteration
		freeBytes = 64;
	}
}
    d568:	46c0      	nop			; (mov r8, r8)
    d56a:	46bd      	mov	sp, r7
    d56c:	b006      	add	sp, #24
    d56e:	bd80      	pop	{r7, pc}
    d570:	000127e7 	.word	0x000127e7
    d574:	0000d761 	.word	0x0000d761

0000d578 <CL_hashFinal>:

void CL_hashFinal(CL_HashContext *ctx, U8 *dest)
{
    d578:	b580      	push	{r7, lr}
    d57a:	b086      	sub	sp, #24
    d57c:	af00      	add	r7, sp, #0
    d57e:	6078      	str	r0, [r7, #4]
    d580:	6039      	str	r1, [r7, #0]
	U8 nbytes;
	U32 temp;
	U8 *ptr;

	/* Append pad byte, clear trailing bytes */
	nbytes = (U8)(ctx->byteCount) & 63;
    d582:	687b      	ldr	r3, [r7, #4]
    d584:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    d586:	b2da      	uxtb	r2, r3
    d588:	230b      	movs	r3, #11
    d58a:	18fb      	adds	r3, r7, r3
    d58c:	213f      	movs	r1, #63	; 0x3f
    d58e:	400a      	ands	r2, r1
    d590:	701a      	strb	r2, [r3, #0]
	((U8*)ctx->buf)[nbytes] = 0x80;
    d592:	687b      	ldr	r3, [r7, #4]
    d594:	3314      	adds	r3, #20
    d596:	001a      	movs	r2, r3
    d598:	230b      	movs	r3, #11
    d59a:	18fb      	adds	r3, r7, r3
    d59c:	781b      	ldrb	r3, [r3, #0]
    d59e:	18d3      	adds	r3, r2, r3
    d5a0:	2280      	movs	r2, #128	; 0x80
    d5a2:	701a      	strb	r2, [r3, #0]
	for (i = (nbytes + 1); i < 64; i++) ((U8*)ctx->buf)[i] = 0;
    d5a4:	2317      	movs	r3, #23
    d5a6:	18fb      	adds	r3, r7, r3
    d5a8:	220b      	movs	r2, #11
    d5aa:	18ba      	adds	r2, r7, r2
    d5ac:	7812      	ldrb	r2, [r2, #0]
    d5ae:	3201      	adds	r2, #1
    d5b0:	701a      	strb	r2, [r3, #0]
    d5b2:	e00f      	b.n	d5d4 <CL_hashFinal+0x5c>
    d5b4:	687b      	ldr	r3, [r7, #4]
    d5b6:	3314      	adds	r3, #20
    d5b8:	001a      	movs	r2, r3
    d5ba:	2317      	movs	r3, #23
    d5bc:	18fb      	adds	r3, r7, r3
    d5be:	781b      	ldrb	r3, [r3, #0]
    d5c0:	18d3      	adds	r3, r2, r3
    d5c2:	2200      	movs	r2, #0
    d5c4:	701a      	strb	r2, [r3, #0]
    d5c6:	2317      	movs	r3, #23
    d5c8:	18fb      	adds	r3, r7, r3
    d5ca:	781a      	ldrb	r2, [r3, #0]
    d5cc:	2317      	movs	r3, #23
    d5ce:	18fb      	adds	r3, r7, r3
    d5d0:	3201      	adds	r2, #1
    d5d2:	701a      	strb	r2, [r3, #0]
    d5d4:	2317      	movs	r3, #23
    d5d6:	18fb      	adds	r3, r7, r3
    d5d8:	781b      	ldrb	r3, [r3, #0]
    d5da:	2b3f      	cmp	r3, #63	; 0x3f
    d5dc:	d9ea      	bls.n	d5b4 <CL_hashFinal+0x3c>

	/*
	   If no room for an 8-byte count at end of buf, digest the buf,
	   then clear it
	 */
	if (nbytes > (64 - 9)) {
    d5de:	230b      	movs	r3, #11
    d5e0:	18fb      	adds	r3, r7, r3
    d5e2:	781b      	ldrb	r3, [r3, #0]
    d5e4:	2b37      	cmp	r3, #55	; 0x37
    d5e6:	d90d      	bls.n	d604 <CL_hashFinal+0x8c>
		shaEngine(ctx->buf, ctx->h);
    d5e8:	687b      	ldr	r3, [r7, #4]
    d5ea:	3314      	adds	r3, #20
    d5ec:	687a      	ldr	r2, [r7, #4]
    d5ee:	0011      	movs	r1, r2
    d5f0:	0018      	movs	r0, r3
    d5f2:	4b58      	ldr	r3, [pc, #352]	; (d754 <CL_hashFinal+0x1dc>)
    d5f4:	4798      	blx	r3
		memset(ctx->buf, 0, 64);
    d5f6:	687b      	ldr	r3, [r7, #4]
    d5f8:	3314      	adds	r3, #20
    d5fa:	2240      	movs	r2, #64	; 0x40
    d5fc:	2100      	movs	r1, #0
    d5fe:	0018      	movs	r0, r3
    d600:	4b55      	ldr	r3, [pc, #340]	; (d758 <CL_hashFinal+0x1e0>)
    d602:	4798      	blx	r3
	/*
	   Put the 8-byte bit count at end of buf.  We have been tracking
	   bytes, not bits, so we left-shift our byte count by 3 as we do
	   this.
	 */
	temp = ctx->byteCount << 3; // low 4 bytes of bit count
    d604:	687b      	ldr	r3, [r7, #4]
    d606:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    d608:	00db      	lsls	r3, r3, #3
    d60a:	613b      	str	r3, [r7, #16]
	ptr = &((U8*)ctx->buf)[63]; // point to low byte of bit count
    d60c:	687b      	ldr	r3, [r7, #4]
    d60e:	3314      	adds	r3, #20
    d610:	333f      	adds	r3, #63	; 0x3f
    d612:	60fb      	str	r3, [r7, #12]
	for (i = 0; i < 4; i++) {
    d614:	2317      	movs	r3, #23
    d616:	18fb      	adds	r3, r7, r3
    d618:	2200      	movs	r2, #0
    d61a:	701a      	strb	r2, [r3, #0]
    d61c:	e00f      	b.n	d63e <CL_hashFinal+0xc6>
		*ptr-- = (U8)temp;
    d61e:	68fb      	ldr	r3, [r7, #12]
    d620:	1e5a      	subs	r2, r3, #1
    d622:	60fa      	str	r2, [r7, #12]
    d624:	693a      	ldr	r2, [r7, #16]
    d626:	b2d2      	uxtb	r2, r2
    d628:	701a      	strb	r2, [r3, #0]
		temp >>= 8;
    d62a:	693b      	ldr	r3, [r7, #16]
    d62c:	0a1b      	lsrs	r3, r3, #8
    d62e:	613b      	str	r3, [r7, #16]
	   bytes, not bits, so we left-shift our byte count by 3 as we do
	   this.
	 */
	temp = ctx->byteCount << 3; // low 4 bytes of bit count
	ptr = &((U8*)ctx->buf)[63]; // point to low byte of bit count
	for (i = 0; i < 4; i++) {
    d630:	2317      	movs	r3, #23
    d632:	18fb      	adds	r3, r7, r3
    d634:	781a      	ldrb	r2, [r3, #0]
    d636:	2317      	movs	r3, #23
    d638:	18fb      	adds	r3, r7, r3
    d63a:	3201      	adds	r2, #1
    d63c:	701a      	strb	r2, [r3, #0]
    d63e:	2317      	movs	r3, #23
    d640:	18fb      	adds	r3, r7, r3
    d642:	781b      	ldrb	r3, [r3, #0]
    d644:	2b03      	cmp	r3, #3
    d646:	d9ea      	bls.n	d61e <CL_hashFinal+0xa6>
		*ptr-- = (U8)temp;
		temp >>= 8;
	}
	//
	temp = ctx->byteCountHi << 3;
    d648:	687b      	ldr	r3, [r7, #4]
    d64a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    d64c:	00db      	lsls	r3, r3, #3
    d64e:	613b      	str	r3, [r7, #16]
	temp |= ctx->byteCount >> (32 - 3); // high 4 bytes of bit count
    d650:	687b      	ldr	r3, [r7, #4]
    d652:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    d654:	0f5b      	lsrs	r3, r3, #29
    d656:	693a      	ldr	r2, [r7, #16]
    d658:	4313      	orrs	r3, r2
    d65a:	613b      	str	r3, [r7, #16]
	for (i = 0; i < 4; i++) {
    d65c:	2317      	movs	r3, #23
    d65e:	18fb      	adds	r3, r7, r3
    d660:	2200      	movs	r2, #0
    d662:	701a      	strb	r2, [r3, #0]
    d664:	e00f      	b.n	d686 <CL_hashFinal+0x10e>
		*ptr-- = (U8)temp;
    d666:	68fb      	ldr	r3, [r7, #12]
    d668:	1e5a      	subs	r2, r3, #1
    d66a:	60fa      	str	r2, [r7, #12]
    d66c:	693a      	ldr	r2, [r7, #16]
    d66e:	b2d2      	uxtb	r2, r2
    d670:	701a      	strb	r2, [r3, #0]
		temp >>= 8;
    d672:	693b      	ldr	r3, [r7, #16]
    d674:	0a1b      	lsrs	r3, r3, #8
    d676:	613b      	str	r3, [r7, #16]
		temp >>= 8;
	}
	//
	temp = ctx->byteCountHi << 3;
	temp |= ctx->byteCount >> (32 - 3); // high 4 bytes of bit count
	for (i = 0; i < 4; i++) {
    d678:	2317      	movs	r3, #23
    d67a:	18fb      	adds	r3, r7, r3
    d67c:	781a      	ldrb	r2, [r3, #0]
    d67e:	2317      	movs	r3, #23
    d680:	18fb      	adds	r3, r7, r3
    d682:	3201      	adds	r2, #1
    d684:	701a      	strb	r2, [r3, #0]
    d686:	2317      	movs	r3, #23
    d688:	18fb      	adds	r3, r7, r3
    d68a:	781b      	ldrb	r3, [r3, #0]
    d68c:	2b03      	cmp	r3, #3
    d68e:	d9ea      	bls.n	d666 <CL_hashFinal+0xee>
		temp >>= 8;
	}
	//show("final SHA crunch", ctx->buf, 64);

	/* Final digestion */
	shaEngine(ctx->buf, ctx->h);
    d690:	687b      	ldr	r3, [r7, #4]
    d692:	3314      	adds	r3, #20
    d694:	687a      	ldr	r2, [r7, #4]
    d696:	0011      	movs	r1, r2
    d698:	0018      	movs	r0, r3
    d69a:	4b2e      	ldr	r3, [pc, #184]	; (d754 <CL_hashFinal+0x1dc>)
    d69c:	4798      	blx	r3

	/* Unpack chaining variables to dest bytes. */
	memcpy(dest, ctx->h, 20);
    d69e:	6879      	ldr	r1, [r7, #4]
    d6a0:	683b      	ldr	r3, [r7, #0]
    d6a2:	2214      	movs	r2, #20
    d6a4:	0018      	movs	r0, r3
    d6a6:	4b2d      	ldr	r3, [pc, #180]	; (d75c <CL_hashFinal+0x1e4>)
    d6a8:	4798      	blx	r3
	for (i = 0; i < 5; i++) {
    d6aa:	2317      	movs	r3, #23
    d6ac:	18fb      	adds	r3, r7, r3
    d6ae:	2200      	movs	r2, #0
    d6b0:	701a      	strb	r2, [r3, #0]
    d6b2:	e045      	b.n	d740 <CL_hashFinal+0x1c8>
		dest[i * 4 + 0] = (ctx->h[i] >> 24) & 0xFF;
    d6b4:	2317      	movs	r3, #23
    d6b6:	18fb      	adds	r3, r7, r3
    d6b8:	781b      	ldrb	r3, [r3, #0]
    d6ba:	009b      	lsls	r3, r3, #2
    d6bc:	001a      	movs	r2, r3
    d6be:	683b      	ldr	r3, [r7, #0]
    d6c0:	189b      	adds	r3, r3, r2
    d6c2:	2217      	movs	r2, #23
    d6c4:	18ba      	adds	r2, r7, r2
    d6c6:	7811      	ldrb	r1, [r2, #0]
    d6c8:	687a      	ldr	r2, [r7, #4]
    d6ca:	0089      	lsls	r1, r1, #2
    d6cc:	588a      	ldr	r2, [r1, r2]
    d6ce:	0e12      	lsrs	r2, r2, #24
    d6d0:	b2d2      	uxtb	r2, r2
    d6d2:	701a      	strb	r2, [r3, #0]
		dest[i * 4 + 1] = (ctx->h[i] >> 16) & 0xFF;
    d6d4:	2317      	movs	r3, #23
    d6d6:	18fb      	adds	r3, r7, r3
    d6d8:	781b      	ldrb	r3, [r3, #0]
    d6da:	009b      	lsls	r3, r3, #2
    d6dc:	3301      	adds	r3, #1
    d6de:	683a      	ldr	r2, [r7, #0]
    d6e0:	18d3      	adds	r3, r2, r3
    d6e2:	2217      	movs	r2, #23
    d6e4:	18ba      	adds	r2, r7, r2
    d6e6:	7811      	ldrb	r1, [r2, #0]
    d6e8:	687a      	ldr	r2, [r7, #4]
    d6ea:	0089      	lsls	r1, r1, #2
    d6ec:	588a      	ldr	r2, [r1, r2]
    d6ee:	0c12      	lsrs	r2, r2, #16
    d6f0:	b2d2      	uxtb	r2, r2
    d6f2:	701a      	strb	r2, [r3, #0]
		dest[i * 4 + 2] = (ctx->h[i] >>  8) & 0xFF;
    d6f4:	2317      	movs	r3, #23
    d6f6:	18fb      	adds	r3, r7, r3
    d6f8:	781b      	ldrb	r3, [r3, #0]
    d6fa:	009b      	lsls	r3, r3, #2
    d6fc:	3302      	adds	r3, #2
    d6fe:	683a      	ldr	r2, [r7, #0]
    d700:	18d3      	adds	r3, r2, r3
    d702:	2217      	movs	r2, #23
    d704:	18ba      	adds	r2, r7, r2
    d706:	7811      	ldrb	r1, [r2, #0]
    d708:	687a      	ldr	r2, [r7, #4]
    d70a:	0089      	lsls	r1, r1, #2
    d70c:	588a      	ldr	r2, [r1, r2]
    d70e:	0a12      	lsrs	r2, r2, #8
    d710:	b2d2      	uxtb	r2, r2
    d712:	701a      	strb	r2, [r3, #0]
		dest[i * 4 + 3] = (ctx->h[i] >>  0) & 0xFF;
    d714:	2317      	movs	r3, #23
    d716:	18fb      	adds	r3, r7, r3
    d718:	781b      	ldrb	r3, [r3, #0]
    d71a:	009b      	lsls	r3, r3, #2
    d71c:	3303      	adds	r3, #3
    d71e:	683a      	ldr	r2, [r7, #0]
    d720:	18d3      	adds	r3, r2, r3
    d722:	2217      	movs	r2, #23
    d724:	18ba      	adds	r2, r7, r2
    d726:	7811      	ldrb	r1, [r2, #0]
    d728:	687a      	ldr	r2, [r7, #4]
    d72a:	0089      	lsls	r1, r1, #2
    d72c:	588a      	ldr	r2, [r1, r2]
    d72e:	b2d2      	uxtb	r2, r2
    d730:	701a      	strb	r2, [r3, #0]
	/* Final digestion */
	shaEngine(ctx->buf, ctx->h);

	/* Unpack chaining variables to dest bytes. */
	memcpy(dest, ctx->h, 20);
	for (i = 0; i < 5; i++) {
    d732:	2317      	movs	r3, #23
    d734:	18fb      	adds	r3, r7, r3
    d736:	781a      	ldrb	r2, [r3, #0]
    d738:	2317      	movs	r3, #23
    d73a:	18fb      	adds	r3, r7, r3
    d73c:	3201      	adds	r2, #1
    d73e:	701a      	strb	r2, [r3, #0]
    d740:	2317      	movs	r3, #23
    d742:	18fb      	adds	r3, r7, r3
    d744:	781b      	ldrb	r3, [r3, #0]
    d746:	2b04      	cmp	r3, #4
    d748:	d9b4      	bls.n	d6b4 <CL_hashFinal+0x13c>
		dest[i * 4 + 0] = (ctx->h[i] >> 24) & 0xFF;
		dest[i * 4 + 1] = (ctx->h[i] >> 16) & 0xFF;
		dest[i * 4 + 2] = (ctx->h[i] >>  8) & 0xFF;
		dest[i * 4 + 3] = (ctx->h[i] >>  0) & 0xFF;
	}
}
    d74a:	46c0      	nop			; (mov r8, r8)
    d74c:	46bd      	mov	sp, r7
    d74e:	b006      	add	sp, #24
    d750:	bd80      	pop	{r7, pc}
    d752:	46c0      	nop			; (mov r8, r8)
    d754:	0000d761 	.word	0x0000d761
    d758:	00012823 	.word	0x00012823
    d75c:	000127e7 	.word	0x000127e7

0000d760 <shaEngine>:
	CL_hashUpdate(&ctx, msg, msgBytes);
	CL_hashFinal(&ctx, dest);
}

void shaEngine(U32 *buf, U32 *h)
{
    d760:	b580      	push	{r7, lr}
    d762:	b08c      	sub	sp, #48	; 0x30
    d764:	af00      	add	r7, sp, #0
    d766:	6078      	str	r0, [r7, #4]
    d768:	6039      	str	r1, [r7, #0]
	   hardware SHA engine.
	 */

	U8 t;
	U32 a, b, c, d, e;
	U32 temp = 0;
    d76a:	2300      	movs	r3, #0
    d76c:	617b      	str	r3, [r7, #20]
	U8 *p;
	U32 *w = (U32*)buf;
    d76e:	687b      	ldr	r3, [r7, #4]
    d770:	60fb      	str	r3, [r7, #12]
	/*
	   Pack first 64 bytes of buf into w[0,...,15].  Within a word,
	   bytes are big-endian.  Do this in place -- buf[0,...,63]
	   overlays w[0,...,15].
	 */
	p = (U8*)w;
    d772:	68fb      	ldr	r3, [r7, #12]
    d774:	613b      	str	r3, [r7, #16]
	for (t = 0; t < 16; t++) {
    d776:	232f      	movs	r3, #47	; 0x2f
    d778:	18fb      	adds	r3, r7, r3
    d77a:	2200      	movs	r2, #0
    d77c:	701a      	strb	r2, [r3, #0]
    d77e:	e02e      	b.n	d7de <shaEngine+0x7e>
		temp = (temp << 8) | *p++;
    d780:	697b      	ldr	r3, [r7, #20]
    d782:	021a      	lsls	r2, r3, #8
    d784:	693b      	ldr	r3, [r7, #16]
    d786:	1c59      	adds	r1, r3, #1
    d788:	6139      	str	r1, [r7, #16]
    d78a:	781b      	ldrb	r3, [r3, #0]
    d78c:	4313      	orrs	r3, r2
    d78e:	617b      	str	r3, [r7, #20]
		temp = (temp << 8) | *p++;
    d790:	697b      	ldr	r3, [r7, #20]
    d792:	021a      	lsls	r2, r3, #8
    d794:	693b      	ldr	r3, [r7, #16]
    d796:	1c59      	adds	r1, r3, #1
    d798:	6139      	str	r1, [r7, #16]
    d79a:	781b      	ldrb	r3, [r3, #0]
    d79c:	4313      	orrs	r3, r2
    d79e:	617b      	str	r3, [r7, #20]
		temp = (temp << 8) | *p++;
    d7a0:	697b      	ldr	r3, [r7, #20]
    d7a2:	021a      	lsls	r2, r3, #8
    d7a4:	693b      	ldr	r3, [r7, #16]
    d7a6:	1c59      	adds	r1, r3, #1
    d7a8:	6139      	str	r1, [r7, #16]
    d7aa:	781b      	ldrb	r3, [r3, #0]
    d7ac:	4313      	orrs	r3, r2
    d7ae:	617b      	str	r3, [r7, #20]
		temp = (temp << 8) | *p++;
    d7b0:	697b      	ldr	r3, [r7, #20]
    d7b2:	021a      	lsls	r2, r3, #8
    d7b4:	693b      	ldr	r3, [r7, #16]
    d7b6:	1c59      	adds	r1, r3, #1
    d7b8:	6139      	str	r1, [r7, #16]
    d7ba:	781b      	ldrb	r3, [r3, #0]
    d7bc:	4313      	orrs	r3, r2
    d7be:	617b      	str	r3, [r7, #20]
		w[t] = temp;
    d7c0:	232f      	movs	r3, #47	; 0x2f
    d7c2:	18fb      	adds	r3, r7, r3
    d7c4:	781b      	ldrb	r3, [r3, #0]
    d7c6:	009b      	lsls	r3, r3, #2
    d7c8:	68fa      	ldr	r2, [r7, #12]
    d7ca:	18d3      	adds	r3, r2, r3
    d7cc:	697a      	ldr	r2, [r7, #20]
    d7ce:	601a      	str	r2, [r3, #0]
	   Pack first 64 bytes of buf into w[0,...,15].  Within a word,
	   bytes are big-endian.  Do this in place -- buf[0,...,63]
	   overlays w[0,...,15].
	 */
	p = (U8*)w;
	for (t = 0; t < 16; t++) {
    d7d0:	232f      	movs	r3, #47	; 0x2f
    d7d2:	18fb      	adds	r3, r7, r3
    d7d4:	781a      	ldrb	r2, [r3, #0]
    d7d6:	232f      	movs	r3, #47	; 0x2f
    d7d8:	18fb      	adds	r3, r7, r3
    d7da:	3201      	adds	r2, #1
    d7dc:	701a      	strb	r2, [r3, #0]
    d7de:	232f      	movs	r3, #47	; 0x2f
    d7e0:	18fb      	adds	r3, r7, r3
    d7e2:	781b      	ldrb	r3, [r3, #0]
    d7e4:	2b0f      	cmp	r3, #15
    d7e6:	d9cb      	bls.n	d780 <shaEngine+0x20>
	//temp = (temp << 8) | *p++;
	//h[t] = temp;
	//}

	/* Copy the chaining variables to a, b, c, d, e */
	a = h[0];
    d7e8:	683b      	ldr	r3, [r7, #0]
    d7ea:	681b      	ldr	r3, [r3, #0]
    d7ec:	62bb      	str	r3, [r7, #40]	; 0x28
	b = h[1];
    d7ee:	683b      	ldr	r3, [r7, #0]
    d7f0:	685b      	ldr	r3, [r3, #4]
    d7f2:	627b      	str	r3, [r7, #36]	; 0x24
	c = h[2];
    d7f4:	683b      	ldr	r3, [r7, #0]
    d7f6:	689b      	ldr	r3, [r3, #8]
    d7f8:	623b      	str	r3, [r7, #32]
	d = h[3];
    d7fa:	683b      	ldr	r3, [r7, #0]
    d7fc:	68db      	ldr	r3, [r3, #12]
    d7fe:	61fb      	str	r3, [r7, #28]
	e = h[4];
    d800:	683b      	ldr	r3, [r7, #0]
    d802:	691b      	ldr	r3, [r3, #16]
    d804:	61bb      	str	r3, [r7, #24]

	/* Now do the 80 rounds */
	for (t = 0; t < 80; t++) {
    d806:	232f      	movs	r3, #47	; 0x2f
    d808:	18fb      	adds	r3, r7, r3
    d80a:	2200      	movs	r2, #0
    d80c:	701a      	strb	r2, [r3, #0]
    d80e:	e0b3      	b.n	d978 <shaEngine+0x218>

		temp = a;
    d810:	6abb      	ldr	r3, [r7, #40]	; 0x28
    d812:	617b      	str	r3, [r7, #20]
		leftRotate(temp, 5);
    d814:	697b      	ldr	r3, [r7, #20]
    d816:	221b      	movs	r2, #27
    d818:	41d3      	rors	r3, r2
    d81a:	617b      	str	r3, [r7, #20]
		temp += e;
    d81c:	697a      	ldr	r2, [r7, #20]
    d81e:	69bb      	ldr	r3, [r7, #24]
    d820:	18d3      	adds	r3, r2, r3
    d822:	617b      	str	r3, [r7, #20]
		temp += w[t & 0xf];
    d824:	232f      	movs	r3, #47	; 0x2f
    d826:	18fb      	adds	r3, r7, r3
    d828:	781b      	ldrb	r3, [r3, #0]
    d82a:	220f      	movs	r2, #15
    d82c:	4013      	ands	r3, r2
    d82e:	009b      	lsls	r3, r3, #2
    d830:	68fa      	ldr	r2, [r7, #12]
    d832:	18d3      	adds	r3, r2, r3
    d834:	681b      	ldr	r3, [r3, #0]
    d836:	697a      	ldr	r2, [r7, #20]
    d838:	18d3      	adds	r3, r2, r3
    d83a:	617b      	str	r3, [r7, #20]

		if (t < 20) {
    d83c:	232f      	movs	r3, #47	; 0x2f
    d83e:	18fb      	adds	r3, r7, r3
    d840:	781b      	ldrb	r3, [r3, #0]
    d842:	2b13      	cmp	r3, #19
    d844:	d810      	bhi.n	d868 <shaEngine+0x108>
			temp += (b & c) | (~b & d);
    d846:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d848:	6a3a      	ldr	r2, [r7, #32]
    d84a:	401a      	ands	r2, r3
    d84c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d84e:	43db      	mvns	r3, r3
    d850:	69f9      	ldr	r1, [r7, #28]
    d852:	400b      	ands	r3, r1
    d854:	4313      	orrs	r3, r2
    d856:	697a      	ldr	r2, [r7, #20]
    d858:	18d3      	adds	r3, r2, r3
    d85a:	617b      	str	r3, [r7, #20]
			temp += 0x5a827999L;
    d85c:	697b      	ldr	r3, [r7, #20]
    d85e:	4a5e      	ldr	r2, [pc, #376]	; (d9d8 <shaEngine+0x278>)
    d860:	4694      	mov	ip, r2
    d862:	4463      	add	r3, ip
    d864:	617b      	str	r3, [r7, #20]
    d866:	e036      	b.n	d8d6 <shaEngine+0x176>
		}else if (t < 40) {
    d868:	232f      	movs	r3, #47	; 0x2f
    d86a:	18fb      	adds	r3, r7, r3
    d86c:	781b      	ldrb	r3, [r3, #0]
    d86e:	2b27      	cmp	r3, #39	; 0x27
    d870:	d80d      	bhi.n	d88e <shaEngine+0x12e>
			temp += b ^ c ^ d;
    d872:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    d874:	6a3b      	ldr	r3, [r7, #32]
    d876:	405a      	eors	r2, r3
    d878:	69fb      	ldr	r3, [r7, #28]
    d87a:	4053      	eors	r3, r2
    d87c:	697a      	ldr	r2, [r7, #20]
    d87e:	18d3      	adds	r3, r2, r3
    d880:	617b      	str	r3, [r7, #20]
			temp += 0x6ed9eba1L;
    d882:	697b      	ldr	r3, [r7, #20]
    d884:	4a55      	ldr	r2, [pc, #340]	; (d9dc <shaEngine+0x27c>)
    d886:	4694      	mov	ip, r2
    d888:	4463      	add	r3, ip
    d88a:	617b      	str	r3, [r7, #20]
    d88c:	e023      	b.n	d8d6 <shaEngine+0x176>
		}else if (t < 60) {
    d88e:	232f      	movs	r3, #47	; 0x2f
    d890:	18fb      	adds	r3, r7, r3
    d892:	781b      	ldrb	r3, [r3, #0]
    d894:	2b3b      	cmp	r3, #59	; 0x3b
    d896:	d811      	bhi.n	d8bc <shaEngine+0x15c>
			temp += (b & c) | (b & d) | (c & d);
    d898:	6a3a      	ldr	r2, [r7, #32]
    d89a:	69fb      	ldr	r3, [r7, #28]
    d89c:	4313      	orrs	r3, r2
    d89e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    d8a0:	401a      	ands	r2, r3
    d8a2:	6a3b      	ldr	r3, [r7, #32]
    d8a4:	69f9      	ldr	r1, [r7, #28]
    d8a6:	400b      	ands	r3, r1
    d8a8:	4313      	orrs	r3, r2
    d8aa:	697a      	ldr	r2, [r7, #20]
    d8ac:	18d3      	adds	r3, r2, r3
    d8ae:	617b      	str	r3, [r7, #20]
			temp += 0x8f1bbcdcL;
    d8b0:	697b      	ldr	r3, [r7, #20]
    d8b2:	4a4b      	ldr	r2, [pc, #300]	; (d9e0 <shaEngine+0x280>)
    d8b4:	4694      	mov	ip, r2
    d8b6:	4463      	add	r3, ip
    d8b8:	617b      	str	r3, [r7, #20]
    d8ba:	e00c      	b.n	d8d6 <shaEngine+0x176>
		}else {
			temp += b ^ c ^ d;
    d8bc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    d8be:	6a3b      	ldr	r3, [r7, #32]
    d8c0:	405a      	eors	r2, r3
    d8c2:	69fb      	ldr	r3, [r7, #28]
    d8c4:	4053      	eors	r3, r2
    d8c6:	697a      	ldr	r2, [r7, #20]
    d8c8:	18d3      	adds	r3, r2, r3
    d8ca:	617b      	str	r3, [r7, #20]
			temp += 0xca62c1d6L;
    d8cc:	697b      	ldr	r3, [r7, #20]
    d8ce:	4a45      	ldr	r2, [pc, #276]	; (d9e4 <shaEngine+0x284>)
    d8d0:	4694      	mov	ip, r2
    d8d2:	4463      	add	r3, ip
    d8d4:	617b      	str	r3, [r7, #20]
		}

		e = d;
    d8d6:	69fb      	ldr	r3, [r7, #28]
    d8d8:	61bb      	str	r3, [r7, #24]
		d = c;
    d8da:	6a3b      	ldr	r3, [r7, #32]
    d8dc:	61fb      	str	r3, [r7, #28]
		c = b; leftRotate(c, 30);
    d8de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d8e0:	623b      	str	r3, [r7, #32]
    d8e2:	6a3b      	ldr	r3, [r7, #32]
    d8e4:	2202      	movs	r2, #2
    d8e6:	41d3      	rors	r3, r2
    d8e8:	623b      	str	r3, [r7, #32]
		b = a;
    d8ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
    d8ec:	627b      	str	r3, [r7, #36]	; 0x24
		a = temp;
    d8ee:	697b      	ldr	r3, [r7, #20]
    d8f0:	62bb      	str	r3, [r7, #40]	; 0x28

		temp = w[t & 0xf] ^ w[(t - 3) & 0xf] ^ w[(t - 8) & 0xf] ^ w[(t - 14) & 0xf];
    d8f2:	232f      	movs	r3, #47	; 0x2f
    d8f4:	18fb      	adds	r3, r7, r3
    d8f6:	781b      	ldrb	r3, [r3, #0]
    d8f8:	220f      	movs	r2, #15
    d8fa:	4013      	ands	r3, r2
    d8fc:	009b      	lsls	r3, r3, #2
    d8fe:	68fa      	ldr	r2, [r7, #12]
    d900:	18d3      	adds	r3, r2, r3
    d902:	681a      	ldr	r2, [r3, #0]
    d904:	232f      	movs	r3, #47	; 0x2f
    d906:	18fb      	adds	r3, r7, r3
    d908:	781b      	ldrb	r3, [r3, #0]
    d90a:	3b03      	subs	r3, #3
    d90c:	0019      	movs	r1, r3
    d90e:	230f      	movs	r3, #15
    d910:	400b      	ands	r3, r1
    d912:	009b      	lsls	r3, r3, #2
    d914:	68f9      	ldr	r1, [r7, #12]
    d916:	18cb      	adds	r3, r1, r3
    d918:	681b      	ldr	r3, [r3, #0]
    d91a:	405a      	eors	r2, r3
    d91c:	232f      	movs	r3, #47	; 0x2f
    d91e:	18fb      	adds	r3, r7, r3
    d920:	781b      	ldrb	r3, [r3, #0]
    d922:	3b08      	subs	r3, #8
    d924:	0019      	movs	r1, r3
    d926:	230f      	movs	r3, #15
    d928:	400b      	ands	r3, r1
    d92a:	009b      	lsls	r3, r3, #2
    d92c:	68f9      	ldr	r1, [r7, #12]
    d92e:	18cb      	adds	r3, r1, r3
    d930:	681b      	ldr	r3, [r3, #0]
    d932:	405a      	eors	r2, r3
    d934:	232f      	movs	r3, #47	; 0x2f
    d936:	18fb      	adds	r3, r7, r3
    d938:	781b      	ldrb	r3, [r3, #0]
    d93a:	3b0e      	subs	r3, #14
    d93c:	0019      	movs	r1, r3
    d93e:	230f      	movs	r3, #15
    d940:	400b      	ands	r3, r1
    d942:	009b      	lsls	r3, r3, #2
    d944:	68f9      	ldr	r1, [r7, #12]
    d946:	18cb      	adds	r3, r1, r3
    d948:	681b      	ldr	r3, [r3, #0]
    d94a:	4053      	eors	r3, r2
    d94c:	617b      	str	r3, [r7, #20]
		leftRotate(temp, 1);
    d94e:	697b      	ldr	r3, [r7, #20]
    d950:	221f      	movs	r2, #31
    d952:	41d3      	rors	r3, r2
    d954:	617b      	str	r3, [r7, #20]
		w[t & 0xf] = temp;
    d956:	232f      	movs	r3, #47	; 0x2f
    d958:	18fb      	adds	r3, r7, r3
    d95a:	781b      	ldrb	r3, [r3, #0]
    d95c:	220f      	movs	r2, #15
    d95e:	4013      	ands	r3, r2
    d960:	009b      	lsls	r3, r3, #2
    d962:	68fa      	ldr	r2, [r7, #12]
    d964:	18d3      	adds	r3, r2, r3
    d966:	697a      	ldr	r2, [r7, #20]
    d968:	601a      	str	r2, [r3, #0]
	c = h[2];
	d = h[3];
	e = h[4];

	/* Now do the 80 rounds */
	for (t = 0; t < 80; t++) {
    d96a:	232f      	movs	r3, #47	; 0x2f
    d96c:	18fb      	adds	r3, r7, r3
    d96e:	781a      	ldrb	r2, [r3, #0]
    d970:	232f      	movs	r3, #47	; 0x2f
    d972:	18fb      	adds	r3, r7, r3
    d974:	3201      	adds	r2, #1
    d976:	701a      	strb	r2, [r3, #0]
    d978:	232f      	movs	r3, #47	; 0x2f
    d97a:	18fb      	adds	r3, r7, r3
    d97c:	781b      	ldrb	r3, [r3, #0]
    d97e:	2b4f      	cmp	r3, #79	; 0x4f
    d980:	d800      	bhi.n	d984 <shaEngine+0x224>
    d982:	e745      	b.n	d810 <shaEngine+0xb0>
		w[t & 0xf] = temp;

	}

	/* Update the chaining variables */
	h[0] += a;
    d984:	683b      	ldr	r3, [r7, #0]
    d986:	681a      	ldr	r2, [r3, #0]
    d988:	6abb      	ldr	r3, [r7, #40]	; 0x28
    d98a:	18d2      	adds	r2, r2, r3
    d98c:	683b      	ldr	r3, [r7, #0]
    d98e:	601a      	str	r2, [r3, #0]
	h[1] += b;
    d990:	683b      	ldr	r3, [r7, #0]
    d992:	3304      	adds	r3, #4
    d994:	683a      	ldr	r2, [r7, #0]
    d996:	3204      	adds	r2, #4
    d998:	6811      	ldr	r1, [r2, #0]
    d99a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    d99c:	188a      	adds	r2, r1, r2
    d99e:	601a      	str	r2, [r3, #0]
	h[2] += c;
    d9a0:	683b      	ldr	r3, [r7, #0]
    d9a2:	3308      	adds	r3, #8
    d9a4:	683a      	ldr	r2, [r7, #0]
    d9a6:	3208      	adds	r2, #8
    d9a8:	6811      	ldr	r1, [r2, #0]
    d9aa:	6a3a      	ldr	r2, [r7, #32]
    d9ac:	188a      	adds	r2, r1, r2
    d9ae:	601a      	str	r2, [r3, #0]
	h[3] += d;
    d9b0:	683b      	ldr	r3, [r7, #0]
    d9b2:	330c      	adds	r3, #12
    d9b4:	683a      	ldr	r2, [r7, #0]
    d9b6:	320c      	adds	r2, #12
    d9b8:	6811      	ldr	r1, [r2, #0]
    d9ba:	69fa      	ldr	r2, [r7, #28]
    d9bc:	188a      	adds	r2, r1, r2
    d9be:	601a      	str	r2, [r3, #0]
	h[4] += e;
    d9c0:	683b      	ldr	r3, [r7, #0]
    d9c2:	3310      	adds	r3, #16
    d9c4:	683a      	ldr	r2, [r7, #0]
    d9c6:	3210      	adds	r2, #16
    d9c8:	6811      	ldr	r1, [r2, #0]
    d9ca:	69ba      	ldr	r2, [r7, #24]
    d9cc:	188a      	adds	r2, r1, r2
    d9ce:	601a      	str	r2, [r3, #0]
	//p[1] = (U8)temp; temp >>= 8;
	//p[0] = (U8)temp;
	//p += 4;
	//}

    d9d0:	46c0      	nop			; (mov r8, r8)
    d9d2:	46bd      	mov	sp, r7
    d9d4:	b00c      	add	sp, #48	; 0x30
    d9d6:	bd80      	pop	{r7, pc}
    d9d8:	5a827999 	.word	0x5a827999
    d9dc:	6ed9eba1 	.word	0x6ed9eba1
    d9e0:	8f1bbcdc 	.word	0x8f1bbcdc
    d9e4:	ca62c1d6 	.word	0xca62c1d6

0000d9e8 <hal_iface_init>:
 * \param[in] cfg pointer to ATCAIfaceCfg object
 * \param[in] hal pointer to ATCAHAL_t intermediate datastructure
 */

ATCA_STATUS hal_iface_init( ATCAIfaceCfg *cfg, ATCAHAL_t *hal )
{
    d9e8:	b580      	push	{r7, lr}
    d9ea:	b084      	sub	sp, #16
    d9ec:	af00      	add	r7, sp, #0
    d9ee:	6078      	str	r0, [r7, #4]
    d9f0:	6039      	str	r1, [r7, #0]
	// Because C isn't a real object oriented language or dynamically typed, some switch in the overall system is unavoidable
	// The key here is to provide the flexibility to include just the types of interfaces you want/need without breaking the
	// object model.  The former is needed so in an embedded, constrained memory environment, you don't have to pay the price
	// (in terms of memory) for interfaces you don't use in your application.
	ATCA_STATUS status = ATCA_COMM_FAIL;
    d9f2:	230f      	movs	r3, #15
    d9f4:	18fb      	adds	r3, r7, r3
    d9f6:	22f0      	movs	r2, #240	; 0xf0
    d9f8:	701a      	strb	r2, [r3, #0]

	switch (cfg->iface_type) {
    d9fa:	687b      	ldr	r3, [r7, #4]
    d9fc:	781b      	ldrb	r3, [r3, #0]
    d9fe:	2b04      	cmp	r3, #4
    da00:	d825      	bhi.n	da4e <hal_iface_init+0x66>
    da02:	009a      	lsls	r2, r3, #2
    da04:	4b15      	ldr	r3, [pc, #84]	; (da5c <hal_iface_init+0x74>)
    da06:	18d3      	adds	r3, r2, r3
    da08:	681b      	ldr	r3, [r3, #0]
    da0a:	469f      	mov	pc, r3
	case ATCA_I2C_IFACE:
		#ifdef ATCA_HAL_I2C
		hal->halinit = &hal_i2c_init;
    da0c:	683b      	ldr	r3, [r7, #0]
    da0e:	4a14      	ldr	r2, [pc, #80]	; (da60 <hal_iface_init+0x78>)
    da10:	601a      	str	r2, [r3, #0]
		hal->halpostinit = &hal_i2c_post_init;
    da12:	683b      	ldr	r3, [r7, #0]
    da14:	4a13      	ldr	r2, [pc, #76]	; (da64 <hal_iface_init+0x7c>)
    da16:	605a      	str	r2, [r3, #4]
		hal->halreceive = &hal_i2c_receive;
    da18:	683b      	ldr	r3, [r7, #0]
    da1a:	4a13      	ldr	r2, [pc, #76]	; (da68 <hal_iface_init+0x80>)
    da1c:	60da      	str	r2, [r3, #12]
		hal->halsend = &hal_i2c_send;
    da1e:	683b      	ldr	r3, [r7, #0]
    da20:	4a12      	ldr	r2, [pc, #72]	; (da6c <hal_iface_init+0x84>)
    da22:	609a      	str	r2, [r3, #8]
		hal->halsleep = &hal_i2c_sleep;
    da24:	683b      	ldr	r3, [r7, #0]
    da26:	4a12      	ldr	r2, [pc, #72]	; (da70 <hal_iface_init+0x88>)
    da28:	619a      	str	r2, [r3, #24]
		hal->halwake = &hal_i2c_wake;
    da2a:	683b      	ldr	r3, [r7, #0]
    da2c:	4a11      	ldr	r2, [pc, #68]	; (da74 <hal_iface_init+0x8c>)
    da2e:	611a      	str	r2, [r3, #16]
		hal->halidle = &hal_i2c_idle;
    da30:	683b      	ldr	r3, [r7, #0]
    da32:	4a11      	ldr	r2, [pc, #68]	; (da78 <hal_iface_init+0x90>)
    da34:	615a      	str	r2, [r3, #20]
		hal->halrelease = &hal_i2c_release;
    da36:	683b      	ldr	r3, [r7, #0]
    da38:	4a10      	ldr	r2, [pc, #64]	; (da7c <hal_iface_init+0x94>)
    da3a:	61da      	str	r2, [r3, #28]
		hal->hal_data = NULL;
    da3c:	683b      	ldr	r3, [r7, #0]
    da3e:	2200      	movs	r2, #0
    da40:	621a      	str	r2, [r3, #32]

		status = ATCA_SUCCESS;
    da42:	230f      	movs	r3, #15
    da44:	18fb      	adds	r3, r7, r3
    da46:	2200      	movs	r2, #0
    da48:	701a      	strb	r2, [r3, #0]
		#endif
		break;
    da4a:	e000      	b.n	da4e <hal_iface_init+0x66>
		hal->halrelease = &hal_kit_hid_release;
		hal->hal_data = NULL;

		status = ATCA_SUCCESS;
		#endif
		break;
    da4c:	46c0      	nop			; (mov r8, r8)
	}
	return status;
    da4e:	230f      	movs	r3, #15
    da50:	18fb      	adds	r3, r7, r3
    da52:	781b      	ldrb	r3, [r3, #0]
}
    da54:	0018      	movs	r0, r3
    da56:	46bd      	mov	sp, r7
    da58:	b004      	add	sp, #16
    da5a:	bd80      	pop	{r7, pc}
    da5c:	00015304 	.word	0x00015304
    da60:	0000dc2d 	.word	0x0000dc2d
    da64:	0000dddd 	.word	0x0000dddd
    da68:	0000de95 	.word	0x0000de95
    da6c:	0000ddf1 	.word	0x0000ddf1
    da70:	0000e259 	.word	0x0000e259
    da74:	0000e071 	.word	0x0000e071
    da78:	0000e1c9 	.word	0x0000e1c9
    da7c:	0000e2e9 	.word	0x0000e2e9

0000da80 <hal_iface_release>:
 * \param[in] ifacetype - the type of physical interface to release
 * \param[in] hal_data - pointer to opaque hal data maintained by HAL implementation for this interface type
 */

ATCA_STATUS hal_iface_release( ATCAIfaceType ifacetype, void *hal_data )
{
    da80:	b590      	push	{r4, r7, lr}
    da82:	b085      	sub	sp, #20
    da84:	af00      	add	r7, sp, #0
    da86:	0002      	movs	r2, r0
    da88:	6039      	str	r1, [r7, #0]
    da8a:	1dfb      	adds	r3, r7, #7
    da8c:	701a      	strb	r2, [r3, #0]
	ATCA_STATUS status = ATCA_GEN_FAIL;
    da8e:	230f      	movs	r3, #15
    da90:	18fb      	adds	r3, r7, r3
    da92:	22e1      	movs	r2, #225	; 0xe1
    da94:	701a      	strb	r2, [r3, #0]

	switch (ifacetype) {
    da96:	1dfb      	adds	r3, r7, #7
    da98:	781b      	ldrb	r3, [r3, #0]
    da9a:	2b04      	cmp	r3, #4
    da9c:	d80e      	bhi.n	dabc <hal_iface_release+0x3c>
    da9e:	009a      	lsls	r2, r3, #2
    daa0:	4b0a      	ldr	r3, [pc, #40]	; (dacc <hal_iface_release+0x4c>)
    daa2:	18d3      	adds	r3, r2, r3
    daa4:	681b      	ldr	r3, [r3, #0]
    daa6:	469f      	mov	pc, r3
	case ATCA_I2C_IFACE:
			#ifdef ATCA_HAL_I2C
		status = hal_i2c_release(hal_data);
    daa8:	230f      	movs	r3, #15
    daaa:	18fc      	adds	r4, r7, r3
    daac:	683b      	ldr	r3, [r7, #0]
    daae:	0018      	movs	r0, r3
    dab0:	4b07      	ldr	r3, [pc, #28]	; (dad0 <hal_iface_release+0x50>)
    dab2:	4798      	blx	r3
    dab4:	0003      	movs	r3, r0
    dab6:	7023      	strb	r3, [r4, #0]
			#endif
		break;
    dab8:	e000      	b.n	dabc <hal_iface_release+0x3c>
		break;
	case ATCA_HID_IFACE:
			#ifdef ATCA_HAL_KIT_HID
		status = hal_kit_hid_release(hal_data);
			#endif
		break;
    daba:	46c0      	nop			; (mov r8, r8)
	}

	return status;
    dabc:	230f      	movs	r3, #15
    dabe:	18fb      	adds	r3, r7, r3
    dac0:	781b      	ldrb	r3, [r3, #0]
}
    dac2:	0018      	movs	r0, r3
    dac4:	46bd      	mov	sp, r7
    dac6:	b005      	add	sp, #20
    dac8:	bd90      	pop	{r4, r7, pc}
    daca:	46c0      	nop			; (mov r8, r8)
    dacc:	00015318 	.word	0x00015318
    dad0:	0000e2e9 	.word	0x0000e2e9

0000dad4 <i2c_master_is_syncing>:
 * \retval true   Module is busy synchronizing
 * \retval false  Module is not synchronizing
 */
static inline bool i2c_master_is_syncing (
		const struct i2c_master_module *const module)
{
    dad4:	b580      	push	{r7, lr}
    dad6:	b084      	sub	sp, #16
    dad8:	af00      	add	r7, sp, #0
    dada:	6078      	str	r0, [r7, #4]
	/* Sanity check. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_hw = &(module->hw->I2CM);
    dadc:	687b      	ldr	r3, [r7, #4]
    dade:	681b      	ldr	r3, [r3, #0]
    dae0:	60fb      	str	r3, [r7, #12]

#if defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_1)
	return (i2c_hw->STATUS.reg & SERCOM_I2CM_STATUS_SYNCBUSY);
#elif defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_2)
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
    dae2:	68fb      	ldr	r3, [r7, #12]
    dae4:	69db      	ldr	r3, [r3, #28]
    dae6:	2207      	movs	r2, #7
    dae8:	4013      	ands	r3, r2
    daea:	1e5a      	subs	r2, r3, #1
    daec:	4193      	sbcs	r3, r2
    daee:	b2db      	uxtb	r3, r3
#else
#  error Unknown SERCOM SYNCBUSY scheme!
#endif
}
    daf0:	0018      	movs	r0, r3
    daf2:	46bd      	mov	sp, r7
    daf4:	b004      	add	sp, #16
    daf6:	bd80      	pop	{r7, pc}

0000daf8 <_i2c_master_wait_for_sync>:
 *
 * \param[in]  module  Pointer to software module structure
 */
static void _i2c_master_wait_for_sync(
		const struct i2c_master_module *const module)
{
    daf8:	b580      	push	{r7, lr}
    dafa:	b082      	sub	sp, #8
    dafc:	af00      	add	r7, sp, #0
    dafe:	6078      	str	r0, [r7, #4]
	/* Sanity check. */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
    db00:	46c0      	nop			; (mov r8, r8)
    db02:	687b      	ldr	r3, [r7, #4]
    db04:	0018      	movs	r0, r3
    db06:	4b04      	ldr	r3, [pc, #16]	; (db18 <_i2c_master_wait_for_sync+0x20>)
    db08:	4798      	blx	r3
    db0a:	1e03      	subs	r3, r0, #0
    db0c:	d1f9      	bne.n	db02 <_i2c_master_wait_for_sync+0xa>
		/* Wait for I2C module to sync. */
	}
}
    db0e:	46c0      	nop			; (mov r8, r8)
    db10:	46bd      	mov	sp, r7
    db12:	b002      	add	sp, #8
    db14:	bd80      	pop	{r7, pc}
    db16:	46c0      	nop			; (mov r8, r8)
    db18:	0000dad5 	.word	0x0000dad5

0000db1c <i2c_master_get_config_defaults>:
 *
 * \param[out] config  Pointer to configuration structure to be initiated
 */
static inline void i2c_master_get_config_defaults(
		struct i2c_master_config *const config)
{
    db1c:	b580      	push	{r7, lr}
    db1e:	b082      	sub	sp, #8
    db20:	af00      	add	r7, sp, #0
    db22:	6078      	str	r0, [r7, #4]
	/*Sanity check argument. */
	Assert(config);
	config->baud_rate        = I2C_MASTER_BAUD_RATE_100KHZ;
    db24:	687b      	ldr	r3, [r7, #4]
    db26:	2264      	movs	r2, #100	; 0x64
    db28:	601a      	str	r2, [r3, #0]
#ifdef FEATURE_I2C_FAST_MODE_PLUS_AND_HIGH_SPEED
	config->baud_rate_high_speed = I2C_MASTER_BAUD_RATE_3400KHZ;
    db2a:	687b      	ldr	r3, [r7, #4]
    db2c:	4a1b      	ldr	r2, [pc, #108]	; (db9c <i2c_master_get_config_defaults+0x80>)
    db2e:	605a      	str	r2, [r3, #4]
	config->transfer_speed       = I2C_MASTER_SPEED_STANDARD_AND_FAST;
    db30:	687b      	ldr	r3, [r7, #4]
    db32:	2200      	movs	r2, #0
    db34:	609a      	str	r2, [r3, #8]
#endif
	config->generator_source = GCLK_GENERATOR_0;
    db36:	687b      	ldr	r3, [r7, #4]
    db38:	2200      	movs	r2, #0
    db3a:	731a      	strb	r2, [r3, #12]
	config->run_in_standby   = false;
    db3c:	687b      	ldr	r3, [r7, #4]
    db3e:	2200      	movs	r2, #0
    db40:	761a      	strb	r2, [r3, #24]
	config->start_hold_time  = I2C_MASTER_START_HOLD_TIME_300NS_600NS;
    db42:	687b      	ldr	r3, [r7, #4]
    db44:	2280      	movs	r2, #128	; 0x80
    db46:	0392      	lsls	r2, r2, #14
    db48:	611a      	str	r2, [r3, #16]
	config->buffer_timeout   = 65535;
    db4a:	687b      	ldr	r3, [r7, #4]
    db4c:	2201      	movs	r2, #1
    db4e:	4252      	negs	r2, r2
    db50:	82da      	strh	r2, [r3, #22]
	config->unknown_bus_state_timeout = 65535;
    db52:	687b      	ldr	r3, [r7, #4]
    db54:	2201      	movs	r2, #1
    db56:	4252      	negs	r2, r2
    db58:	829a      	strh	r2, [r3, #20]
	config->pinmux_pad0      = PINMUX_DEFAULT;
    db5a:	687b      	ldr	r3, [r7, #4]
    db5c:	2200      	movs	r2, #0
    db5e:	61da      	str	r2, [r3, #28]
	config->pinmux_pad1      = PINMUX_DEFAULT;
    db60:	687b      	ldr	r3, [r7, #4]
    db62:	2200      	movs	r2, #0
    db64:	621a      	str	r2, [r3, #32]
	config->scl_low_timeout  = false;
    db66:	687b      	ldr	r3, [r7, #4]
    db68:	2224      	movs	r2, #36	; 0x24
    db6a:	2100      	movs	r1, #0
    db6c:	5499      	strb	r1, [r3, r2]
	config->inactive_timeout = I2C_MASTER_INACTIVE_TIMEOUT_DISABLED;
    db6e:	687b      	ldr	r3, [r7, #4]
    db70:	2200      	movs	r2, #0
    db72:	629a      	str	r2, [r3, #40]	; 0x28
#ifdef FEATURE_I2C_SCL_STRETCH_MODE
	config->scl_stretch_only_after_ack_bit = false;
    db74:	687b      	ldr	r3, [r7, #4]
    db76:	222c      	movs	r2, #44	; 0x2c
    db78:	2100      	movs	r1, #0
    db7a:	5499      	strb	r1, [r3, r2]
#endif
#ifdef FEATURE_I2C_SCL_EXTEND_TIMEOUT
	config->slave_scl_low_extend_timeout   = false;
    db7c:	687b      	ldr	r3, [r7, #4]
    db7e:	222d      	movs	r2, #45	; 0x2d
    db80:	2100      	movs	r1, #0
    db82:	5499      	strb	r1, [r3, r2]
	config->master_scl_low_extend_timeout  = false;
    db84:	687b      	ldr	r3, [r7, #4]
    db86:	222e      	movs	r2, #46	; 0x2e
    db88:	2100      	movs	r1, #0
    db8a:	5499      	strb	r1, [r3, r2]
#endif
	/* The typical value is 215ns */
	config->sda_scl_rise_time_ns = 215;
    db8c:	687b      	ldr	r3, [r7, #4]
    db8e:	22d7      	movs	r2, #215	; 0xd7
    db90:	861a      	strh	r2, [r3, #48]	; 0x30
}
    db92:	46c0      	nop			; (mov r8, r8)
    db94:	46bd      	mov	sp, r7
    db96:	b002      	add	sp, #8
    db98:	bd80      	pop	{r7, pc}
    db9a:	46c0      	nop			; (mov r8, r8)
    db9c:	00000d48 	.word	0x00000d48

0000dba0 <i2c_master_enable>:
 *
 * \param[in]  module  Pointer to the software module struct
 */
static inline void i2c_master_enable(
		const struct i2c_master_module *const module)
{
    dba0:	b580      	push	{r7, lr}
    dba2:	b084      	sub	sp, #16
    dba4:	af00      	add	r7, sp, #0
    dba6:	6078      	str	r0, [r7, #4]
	/* Sanity check of arguments. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    dba8:	687b      	ldr	r3, [r7, #4]
    dbaa:	681b      	ldr	r3, [r3, #0]
    dbac:	60bb      	str	r3, [r7, #8]

	/* Timeout counter used to force bus state. */
	uint32_t timeout_counter = 0;
    dbae:	2300      	movs	r3, #0
    dbb0:	60fb      	str	r3, [r7, #12]

	/* Wait for module to sync. */
	_i2c_master_wait_for_sync(module);
    dbb2:	687b      	ldr	r3, [r7, #4]
    dbb4:	0018      	movs	r0, r3
    dbb6:	4b10      	ldr	r3, [pc, #64]	; (dbf8 <i2c_master_enable+0x58>)
    dbb8:	4798      	blx	r3

	/* Enable module. */
	i2c_module->CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
    dbba:	68bb      	ldr	r3, [r7, #8]
    dbbc:	681b      	ldr	r3, [r3, #0]
    dbbe:	2202      	movs	r2, #2
    dbc0:	431a      	orrs	r2, r3
    dbc2:	68bb      	ldr	r3, [r7, #8]
    dbc4:	601a      	str	r2, [r3, #0]
#if I2C_MASTER_CALLBACK_MODE == true
	/* Enable module interrupts */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#endif
	/* Start timeout if bus state is unknown. */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
    dbc6:	e00c      	b.n	dbe2 <i2c_master_enable+0x42>
		timeout_counter++;
    dbc8:	68fb      	ldr	r3, [r7, #12]
    dbca:	3301      	adds	r3, #1
    dbcc:	60fb      	str	r3, [r7, #12]
		if(timeout_counter >= (module->unknown_bus_state_timeout)) {
    dbce:	687b      	ldr	r3, [r7, #4]
    dbd0:	88db      	ldrh	r3, [r3, #6]
    dbd2:	1e1a      	subs	r2, r3, #0
    dbd4:	68fb      	ldr	r3, [r7, #12]
    dbd6:	429a      	cmp	r2, r3
    dbd8:	d803      	bhi.n	dbe2 <i2c_master_enable+0x42>
			/* Timeout, force bus state to idle. */
			i2c_module->STATUS.reg = SERCOM_I2CM_STATUS_BUSSTATE(1);
    dbda:	68bb      	ldr	r3, [r7, #8]
    dbdc:	2210      	movs	r2, #16
    dbde:	835a      	strh	r2, [r3, #26]
			/* Workaround #1 */
			return;
    dbe0:	e006      	b.n	dbf0 <i2c_master_enable+0x50>
#if I2C_MASTER_CALLBACK_MODE == true
	/* Enable module interrupts */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#endif
	/* Start timeout if bus state is unknown. */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
    dbe2:	68bb      	ldr	r3, [r7, #8]
    dbe4:	8b5b      	ldrh	r3, [r3, #26]
    dbe6:	b29b      	uxth	r3, r3
    dbe8:	001a      	movs	r2, r3
    dbea:	2310      	movs	r3, #16
    dbec:	4013      	ands	r3, r2
    dbee:	d0eb      	beq.n	dbc8 <i2c_master_enable+0x28>
			i2c_module->STATUS.reg = SERCOM_I2CM_STATUS_BUSSTATE(1);
			/* Workaround #1 */
			return;
		}
	}
}
    dbf0:	46bd      	mov	sp, r7
    dbf2:	b004      	add	sp, #16
    dbf4:	bd80      	pop	{r7, pc}
    dbf6:	46c0      	nop			; (mov r8, r8)
    dbf8:	0000daf9 	.word	0x0000daf9

0000dbfc <i2c_master_disable>:
 *
 * \param[in]  module  Pointer to the software module struct
 */
static inline void i2c_master_disable(
		const struct i2c_master_module *const module)
{
    dbfc:	b580      	push	{r7, lr}
    dbfe:	b084      	sub	sp, #16
    dc00:	af00      	add	r7, sp, #0
    dc02:	6078      	str	r0, [r7, #4]
	/* Sanity check of arguments. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    dc04:	687b      	ldr	r3, [r7, #4]
    dc06:	681b      	ldr	r3, [r3, #0]
    dc08:	60fb      	str	r3, [r7, #12]

	/* Wait for module to sync. */
	_i2c_master_wait_for_sync(module);
    dc0a:	687b      	ldr	r3, [r7, #4]
    dc0c:	0018      	movs	r0, r3
    dc0e:	4b06      	ldr	r3, [pc, #24]	; (dc28 <i2c_master_disable+0x2c>)
    dc10:	4798      	blx	r3

	/* Disable module. */
	i2c_module->CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
    dc12:	68fb      	ldr	r3, [r7, #12]
    dc14:	681b      	ldr	r3, [r3, #0]
    dc16:	2202      	movs	r2, #2
    dc18:	4393      	bics	r3, r2
    dc1a:	001a      	movs	r2, r3
    dc1c:	68fb      	ldr	r3, [r7, #12]
    dc1e:	601a      	str	r2, [r3, #0]

#if I2C_MASTER_CALLBACK_MODE == true
	/* Disable module interrupts */
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
#endif
}
    dc20:	46c0      	nop			; (mov r8, r8)
    dc22:	46bd      	mov	sp, r7
    dc24:	b004      	add	sp, #16
    dc26:	bd80      	pop	{r7, pc}
    dc28:	0000daf9 	.word	0x0000daf9

0000dc2c <hal_i2c_init>:
/** \brief initialize an I2C interface using given config
 * \param[in] hal - opaque ptr to HAL data
 * \param[in] cfg - interface configuration
 */
ATCA_STATUS hal_i2c_init(void *hal, ATCAIfaceCfg *cfg)
{
    dc2c:	b580      	push	{r7, lr}
    dc2e:	b086      	sub	sp, #24
    dc30:	af00      	add	r7, sp, #0
    dc32:	6078      	str	r0, [r7, #4]
    dc34:	6039      	str	r1, [r7, #0]
	int bus = cfg->atcai2c.bus;   // 0-based logical bus number
    dc36:	683b      	ldr	r3, [r7, #0]
    dc38:	795b      	ldrb	r3, [r3, #5]
    dc3a:	613b      	str	r3, [r7, #16]
	ATCAHAL_t *phal = (ATCAHAL_t*)hal;
    dc3c:	687b      	ldr	r3, [r7, #4]
    dc3e:	60fb      	str	r3, [r7, #12]

	if ( i2c_bus_ref_ct == 0 )     // power up state, no i2c buses will have been used
    dc40:	4b57      	ldr	r3, [pc, #348]	; (dda0 <hal_i2c_init+0x174>)
    dc42:	681b      	ldr	r3, [r3, #0]
    dc44:	2b00      	cmp	r3, #0
    dc46:	d10d      	bne.n	dc64 <hal_i2c_init+0x38>
		for ( int i = 0; i < MAX_I2C_BUSES; i++ )
    dc48:	2300      	movs	r3, #0
    dc4a:	617b      	str	r3, [r7, #20]
    dc4c:	e007      	b.n	dc5e <hal_i2c_init+0x32>
			i2c_hal_data[i] = NULL;
    dc4e:	4b55      	ldr	r3, [pc, #340]	; (dda4 <hal_i2c_init+0x178>)
    dc50:	697a      	ldr	r2, [r7, #20]
    dc52:	0092      	lsls	r2, r2, #2
    dc54:	2100      	movs	r1, #0
    dc56:	50d1      	str	r1, [r2, r3]
{
	int bus = cfg->atcai2c.bus;   // 0-based logical bus number
	ATCAHAL_t *phal = (ATCAHAL_t*)hal;

	if ( i2c_bus_ref_ct == 0 )     // power up state, no i2c buses will have been used
		for ( int i = 0; i < MAX_I2C_BUSES; i++ )
    dc58:	697b      	ldr	r3, [r7, #20]
    dc5a:	3301      	adds	r3, #1
    dc5c:	617b      	str	r3, [r7, #20]
    dc5e:	697b      	ldr	r3, [r7, #20]
    dc60:	2b05      	cmp	r3, #5
    dc62:	ddf4      	ble.n	dc4e <hal_i2c_init+0x22>
			i2c_hal_data[i] = NULL;

	i2c_bus_ref_ct++;  // total across buses
    dc64:	4b4e      	ldr	r3, [pc, #312]	; (dda0 <hal_i2c_init+0x174>)
    dc66:	681b      	ldr	r3, [r3, #0]
    dc68:	1c5a      	adds	r2, r3, #1
    dc6a:	4b4d      	ldr	r3, [pc, #308]	; (dda0 <hal_i2c_init+0x174>)
    dc6c:	601a      	str	r2, [r3, #0]

	if ( bus >= 0 && bus < MAX_I2C_BUSES ) {
    dc6e:	693b      	ldr	r3, [r7, #16]
    dc70:	2b00      	cmp	r3, #0
    dc72:	da00      	bge.n	dc76 <hal_i2c_init+0x4a>
    dc74:	e08e      	b.n	dd94 <hal_i2c_init+0x168>
    dc76:	693b      	ldr	r3, [r7, #16]
    dc78:	2b05      	cmp	r3, #5
    dc7a:	dd00      	ble.n	dc7e <hal_i2c_init+0x52>
    dc7c:	e08a      	b.n	dd94 <hal_i2c_init+0x168>
		// if this is the first time this bus and interface has been created, do the physical work of enabling it
		if ( i2c_hal_data[bus] == NULL ) {
    dc7e:	4b49      	ldr	r3, [pc, #292]	; (dda4 <hal_i2c_init+0x178>)
    dc80:	693a      	ldr	r2, [r7, #16]
    dc82:	0092      	lsls	r2, r2, #2
    dc84:	58d3      	ldr	r3, [r2, r3]
    dc86:	2b00      	cmp	r3, #0
    dc88:	d175      	bne.n	dd76 <hal_i2c_init+0x14a>
			i2c_hal_data[bus] = malloc( sizeof(ATCAI2CMaster_t) );
    dc8a:	2014      	movs	r0, #20
    dc8c:	4b46      	ldr	r3, [pc, #280]	; (dda8 <hal_i2c_init+0x17c>)
    dc8e:	4798      	blx	r3
    dc90:	0003      	movs	r3, r0
    dc92:	0019      	movs	r1, r3
    dc94:	4b43      	ldr	r3, [pc, #268]	; (dda4 <hal_i2c_init+0x178>)
    dc96:	693a      	ldr	r2, [r7, #16]
    dc98:	0092      	lsls	r2, r2, #2
    dc9a:	50d1      	str	r1, [r2, r3]
			i2c_hal_data[bus]->ref_ct = 1;  // buses are shared, this is the first instance
    dc9c:	4b41      	ldr	r3, [pc, #260]	; (dda4 <hal_i2c_init+0x178>)
    dc9e:	693a      	ldr	r2, [r7, #16]
    dca0:	0092      	lsls	r2, r2, #2
    dca2:	58d3      	ldr	r3, [r2, r3]
    dca4:	2201      	movs	r2, #1
    dca6:	60da      	str	r2, [r3, #12]
			i2c_master_get_config_defaults(&config_i2c_master);
    dca8:	4b40      	ldr	r3, [pc, #256]	; (ddac <hal_i2c_init+0x180>)
    dcaa:	0018      	movs	r0, r3
    dcac:	4b40      	ldr	r3, [pc, #256]	; (ddb0 <hal_i2c_init+0x184>)
    dcae:	4798      	blx	r3
			config_i2c_master.pinmux_pad0 = PINMUX_PA16C_SERCOM1_PAD0;
			config_i2c_master.pinmux_pad1 = PINMUX_PA17C_SERCOM1_PAD1;
#endif

			// config_i2c_master.buffer_timeout = 10000;
			config_i2c_master.baud_rate = cfg->atcai2c.baud / 1000;
    dcb0:	683b      	ldr	r3, [r7, #0]
    dcb2:	6898      	ldr	r0, [r3, #8]
    dcb4:	4b3f      	ldr	r3, [pc, #252]	; (ddb4 <hal_i2c_init+0x188>)
    dcb6:	22fa      	movs	r2, #250	; 0xfa
    dcb8:	0091      	lsls	r1, r2, #2
    dcba:	4798      	blx	r3
    dcbc:	0003      	movs	r3, r0
    dcbe:	001a      	movs	r2, r3
    dcc0:	4b3a      	ldr	r3, [pc, #232]	; (ddac <hal_i2c_init+0x180>)
    dcc2:	601a      	str	r2, [r3, #0]

			switch (bus) {
    dcc4:	693b      	ldr	r3, [r7, #16]
    dcc6:	2b05      	cmp	r3, #5
    dcc8:	d847      	bhi.n	dd5a <hal_i2c_init+0x12e>
    dcca:	693b      	ldr	r3, [r7, #16]
    dccc:	009a      	lsls	r2, r3, #2
    dcce:	4b3a      	ldr	r3, [pc, #232]	; (ddb8 <hal_i2c_init+0x18c>)
    dcd0:	18d3      	adds	r3, r2, r3
    dcd2:	681b      	ldr	r3, [r3, #0]
    dcd4:	469f      	mov	pc, r3
			case 0: i2c_master_init( &(i2c_hal_data[bus]->i2c_master_instance), SERCOM0, &config_i2c_master); break;
    dcd6:	4b33      	ldr	r3, [pc, #204]	; (dda4 <hal_i2c_init+0x178>)
    dcd8:	693a      	ldr	r2, [r7, #16]
    dcda:	0092      	lsls	r2, r2, #2
    dcdc:	58d3      	ldr	r3, [r2, r3]
    dcde:	0018      	movs	r0, r3
    dce0:	4b32      	ldr	r3, [pc, #200]	; (ddac <hal_i2c_init+0x180>)
    dce2:	4936      	ldr	r1, [pc, #216]	; (ddbc <hal_i2c_init+0x190>)
    dce4:	001a      	movs	r2, r3
    dce6:	4b36      	ldr	r3, [pc, #216]	; (ddc0 <hal_i2c_init+0x194>)
    dce8:	4798      	blx	r3
    dcea:	e036      	b.n	dd5a <hal_i2c_init+0x12e>
			case 1: i2c_master_init( &(i2c_hal_data[bus]->i2c_master_instance), SERCOM1, &config_i2c_master); break;
    dcec:	4b2d      	ldr	r3, [pc, #180]	; (dda4 <hal_i2c_init+0x178>)
    dcee:	693a      	ldr	r2, [r7, #16]
    dcf0:	0092      	lsls	r2, r2, #2
    dcf2:	58d3      	ldr	r3, [r2, r3]
    dcf4:	0018      	movs	r0, r3
    dcf6:	4b2d      	ldr	r3, [pc, #180]	; (ddac <hal_i2c_init+0x180>)
    dcf8:	4932      	ldr	r1, [pc, #200]	; (ddc4 <hal_i2c_init+0x198>)
    dcfa:	001a      	movs	r2, r3
    dcfc:	4b30      	ldr	r3, [pc, #192]	; (ddc0 <hal_i2c_init+0x194>)
    dcfe:	4798      	blx	r3
    dd00:	e02b      	b.n	dd5a <hal_i2c_init+0x12e>
			case 2: i2c_master_init( &(i2c_hal_data[bus]->i2c_master_instance), SERCOM2, &config_i2c_master); break;
    dd02:	4b28      	ldr	r3, [pc, #160]	; (dda4 <hal_i2c_init+0x178>)
    dd04:	693a      	ldr	r2, [r7, #16]
    dd06:	0092      	lsls	r2, r2, #2
    dd08:	58d3      	ldr	r3, [r2, r3]
    dd0a:	0018      	movs	r0, r3
    dd0c:	4b27      	ldr	r3, [pc, #156]	; (ddac <hal_i2c_init+0x180>)
    dd0e:	492e      	ldr	r1, [pc, #184]	; (ddc8 <hal_i2c_init+0x19c>)
    dd10:	001a      	movs	r2, r3
    dd12:	4b2b      	ldr	r3, [pc, #172]	; (ddc0 <hal_i2c_init+0x194>)
    dd14:	4798      	blx	r3
    dd16:	e020      	b.n	dd5a <hal_i2c_init+0x12e>
			case 3: i2c_master_init( &(i2c_hal_data[bus]->i2c_master_instance), SERCOM3, &config_i2c_master); break;
    dd18:	4b22      	ldr	r3, [pc, #136]	; (dda4 <hal_i2c_init+0x178>)
    dd1a:	693a      	ldr	r2, [r7, #16]
    dd1c:	0092      	lsls	r2, r2, #2
    dd1e:	58d3      	ldr	r3, [r2, r3]
    dd20:	0018      	movs	r0, r3
    dd22:	4b22      	ldr	r3, [pc, #136]	; (ddac <hal_i2c_init+0x180>)
    dd24:	4929      	ldr	r1, [pc, #164]	; (ddcc <hal_i2c_init+0x1a0>)
    dd26:	001a      	movs	r2, r3
    dd28:	4b25      	ldr	r3, [pc, #148]	; (ddc0 <hal_i2c_init+0x194>)
    dd2a:	4798      	blx	r3
    dd2c:	e015      	b.n	dd5a <hal_i2c_init+0x12e>
			case 4: i2c_master_init( &(i2c_hal_data[bus]->i2c_master_instance), SERCOM4, &config_i2c_master); break;
    dd2e:	4b1d      	ldr	r3, [pc, #116]	; (dda4 <hal_i2c_init+0x178>)
    dd30:	693a      	ldr	r2, [r7, #16]
    dd32:	0092      	lsls	r2, r2, #2
    dd34:	58d3      	ldr	r3, [r2, r3]
    dd36:	0018      	movs	r0, r3
    dd38:	4b1c      	ldr	r3, [pc, #112]	; (ddac <hal_i2c_init+0x180>)
    dd3a:	4925      	ldr	r1, [pc, #148]	; (ddd0 <hal_i2c_init+0x1a4>)
    dd3c:	001a      	movs	r2, r3
    dd3e:	4b20      	ldr	r3, [pc, #128]	; (ddc0 <hal_i2c_init+0x194>)
    dd40:	4798      	blx	r3
    dd42:	e00a      	b.n	dd5a <hal_i2c_init+0x12e>
			case 5: i2c_master_init( &(i2c_hal_data[bus]->i2c_master_instance), SERCOM5, &config_i2c_master); break;
    dd44:	4b17      	ldr	r3, [pc, #92]	; (dda4 <hal_i2c_init+0x178>)
    dd46:	693a      	ldr	r2, [r7, #16]
    dd48:	0092      	lsls	r2, r2, #2
    dd4a:	58d3      	ldr	r3, [r2, r3]
    dd4c:	0018      	movs	r0, r3
    dd4e:	4b17      	ldr	r3, [pc, #92]	; (ddac <hal_i2c_init+0x180>)
    dd50:	4920      	ldr	r1, [pc, #128]	; (ddd4 <hal_i2c_init+0x1a8>)
    dd52:	001a      	movs	r2, r3
    dd54:	4b1a      	ldr	r3, [pc, #104]	; (ddc0 <hal_i2c_init+0x194>)
    dd56:	4798      	blx	r3
    dd58:	46c0      	nop			; (mov r8, r8)
			}

			// store this for use during the release phase
			i2c_hal_data[bus]->bus_index = bus;
    dd5a:	4b12      	ldr	r3, [pc, #72]	; (dda4 <hal_i2c_init+0x178>)
    dd5c:	693a      	ldr	r2, [r7, #16]
    dd5e:	0092      	lsls	r2, r2, #2
    dd60:	58d3      	ldr	r3, [r2, r3]
    dd62:	693a      	ldr	r2, [r7, #16]
    dd64:	611a      	str	r2, [r3, #16]
			i2c_master_enable(&(i2c_hal_data[bus]->i2c_master_instance));
    dd66:	4b0f      	ldr	r3, [pc, #60]	; (dda4 <hal_i2c_init+0x178>)
    dd68:	693a      	ldr	r2, [r7, #16]
    dd6a:	0092      	lsls	r2, r2, #2
    dd6c:	58d3      	ldr	r3, [r2, r3]
    dd6e:	0018      	movs	r0, r3
    dd70:	4b19      	ldr	r3, [pc, #100]	; (ddd8 <hal_i2c_init+0x1ac>)
    dd72:	4798      	blx	r3
    dd74:	e006      	b.n	dd84 <hal_i2c_init+0x158>
		}  else{
			// otherwise, another interface already initialized the bus, so this interface will share it and any different
			// cfg parameters will be ignored...first one to initialize this sets the configuration
			i2c_hal_data[bus]->ref_ct++;
    dd76:	4b0b      	ldr	r3, [pc, #44]	; (dda4 <hal_i2c_init+0x178>)
    dd78:	693a      	ldr	r2, [r7, #16]
    dd7a:	0092      	lsls	r2, r2, #2
    dd7c:	58d3      	ldr	r3, [r2, r3]
    dd7e:	68da      	ldr	r2, [r3, #12]
    dd80:	3201      	adds	r2, #1
    dd82:	60da      	str	r2, [r3, #12]
		}

		phal->hal_data = i2c_hal_data[bus];
    dd84:	4b07      	ldr	r3, [pc, #28]	; (dda4 <hal_i2c_init+0x178>)
    dd86:	693a      	ldr	r2, [r7, #16]
    dd88:	0092      	lsls	r2, r2, #2
    dd8a:	58d2      	ldr	r2, [r2, r3]
    dd8c:	68fb      	ldr	r3, [r7, #12]
    dd8e:	621a      	str	r2, [r3, #32]

		return ATCA_SUCCESS;
    dd90:	2300      	movs	r3, #0
    dd92:	e000      	b.n	dd96 <hal_i2c_init+0x16a>
	}

	return ATCA_COMM_FAIL;
    dd94:	23f0      	movs	r3, #240	; 0xf0
}
    dd96:	0018      	movs	r0, r3
    dd98:	46bd      	mov	sp, r7
    dd9a:	b006      	add	sp, #24
    dd9c:	bd80      	pop	{r7, pc}
    dd9e:	46c0      	nop			; (mov r8, r8)
    dda0:	200007ec 	.word	0x200007ec
    dda4:	200014e0 	.word	0x200014e0
    dda8:	000127a1 	.word	0x000127a1
    ddac:	200007f0 	.word	0x200007f0
    ddb0:	0000db1d 	.word	0x0000db1d
    ddb4:	000121bd 	.word	0x000121bd
    ddb8:	00015368 	.word	0x00015368
    ddbc:	42000800 	.word	0x42000800
    ddc0:	00003a6d 	.word	0x00003a6d
    ddc4:	42000c00 	.word	0x42000c00
    ddc8:	42001000 	.word	0x42001000
    ddcc:	42001400 	.word	0x42001400
    ddd0:	42001800 	.word	0x42001800
    ddd4:	42001c00 	.word	0x42001c00
    ddd8:	0000dba1 	.word	0x0000dba1

0000dddc <hal_i2c_post_init>:
/** \brief HAL implementation of I2C post init
 * \param[in] iface  instance
 * \return ATCA_STATUS
 */
ATCA_STATUS hal_i2c_post_init(ATCAIface iface)
{
    dddc:	b580      	push	{r7, lr}
    ddde:	b082      	sub	sp, #8
    dde0:	af00      	add	r7, sp, #0
    dde2:	6078      	str	r0, [r7, #4]
	return ATCA_SUCCESS;
    dde4:	2300      	movs	r3, #0
}
    dde6:	0018      	movs	r0, r3
    dde8:	46bd      	mov	sp, r7
    ddea:	b002      	add	sp, #8
    ddec:	bd80      	pop	{r7, pc}
    ddee:	46c0      	nop			; (mov r8, r8)

0000ddf0 <hal_i2c_send>:
 * \param[in] txlength  number of bytes to send
 * \return ATCA_STATUS
 */

ATCA_STATUS hal_i2c_send(ATCAIface iface, uint8_t *txdata, int txlength)
{
    ddf0:	b580      	push	{r7, lr}
    ddf2:	b08a      	sub	sp, #40	; 0x28
    ddf4:	af00      	add	r7, sp, #0
    ddf6:	60f8      	str	r0, [r7, #12]
    ddf8:	60b9      	str	r1, [r7, #8]
    ddfa:	607a      	str	r2, [r7, #4]
	ATCAIfaceCfg *cfg = atgetifacecfg(iface);
    ddfc:	68fb      	ldr	r3, [r7, #12]
    ddfe:	0018      	movs	r0, r3
    de00:	4b21      	ldr	r3, [pc, #132]	; (de88 <hal_i2c_send+0x98>)
    de02:	4798      	blx	r3
    de04:	0003      	movs	r3, r0
    de06:	627b      	str	r3, [r7, #36]	; 0x24
	int bus = cfg->atcai2c.bus;
    de08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    de0a:	795b      	ldrb	r3, [r3, #5]
    de0c:	623b      	str	r3, [r7, #32]

	struct i2c_master_packet packet = {
		.address			= cfg->atcai2c.slave_address >> 1,
    de0e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    de10:	791b      	ldrb	r3, [r3, #4]
ATCA_STATUS hal_i2c_send(ATCAIface iface, uint8_t *txdata, int txlength)
{
	ATCAIfaceCfg *cfg = atgetifacecfg(iface);
	int bus = cfg->atcai2c.bus;

	struct i2c_master_packet packet = {
    de12:	085b      	lsrs	r3, r3, #1
    de14:	b2db      	uxtb	r3, r3
    de16:	b29a      	uxth	r2, r3
    de18:	2314      	movs	r3, #20
    de1a:	18fb      	adds	r3, r7, r3
    de1c:	801a      	strh	r2, [r3, #0]
    de1e:	687b      	ldr	r3, [r7, #4]
    de20:	b29a      	uxth	r2, r3
    de22:	2314      	movs	r3, #20
    de24:	18fb      	adds	r3, r7, r3
    de26:	805a      	strh	r2, [r3, #2]
    de28:	2314      	movs	r3, #20
    de2a:	18fb      	adds	r3, r7, r3
    de2c:	68ba      	ldr	r2, [r7, #8]
    de2e:	605a      	str	r2, [r3, #4]
    de30:	2314      	movs	r3, #20
    de32:	18fb      	adds	r3, r7, r3
    de34:	2200      	movs	r2, #0
    de36:	721a      	strb	r2, [r3, #8]
    de38:	2314      	movs	r3, #20
    de3a:	18fb      	adds	r3, r7, r3
    de3c:	2200      	movs	r2, #0
    de3e:	725a      	strb	r2, [r3, #9]
    de40:	2314      	movs	r3, #20
    de42:	18fb      	adds	r3, r7, r3
    de44:	2200      	movs	r2, #0
    de46:	729a      	strb	r2, [r3, #10]
	// for this implementation of I2C with CryptoAuth chips, txdata is assumed to have ATCAPacket format

	// other device types that don't require i/o tokens on the front end of a command need a different hal_i2c_send and wire it up instead of this one
	// this covers devices such as ATSHA204A and ATECCx08A that require a word address value pre-pended to the packet
	// txdata[0] is using _reserved byte of the ATCAPacket
	txdata[0] = 0x03;   // insert the Word Address Value, Command token
    de48:	68bb      	ldr	r3, [r7, #8]
    de4a:	2203      	movs	r2, #3
    de4c:	701a      	strb	r2, [r3, #0]
	txlength++;         // account for word address value byte.
    de4e:	687b      	ldr	r3, [r7, #4]
    de50:	3301      	adds	r3, #1
    de52:	607b      	str	r3, [r7, #4]
	packet.data_length = txlength;
    de54:	687b      	ldr	r3, [r7, #4]
    de56:	b29a      	uxth	r2, r3
    de58:	2314      	movs	r3, #20
    de5a:	18fb      	adds	r3, r7, r3
    de5c:	805a      	strh	r2, [r3, #2]

	//	statusCode = i2c_master_write_packet_wait(&i2c_master_instance, &packet);
	//if ( i2c_master_write_packet_wait_no_stop( &(i2c_hal_data[bus]->i2c_master_instance), &packet) != STATUS_OK)
	if ( i2c_master_write_packet_wait(&(i2c_hal_data[bus]->i2c_master_instance), &packet) != STATUS_OK )
    de5e:	4b0b      	ldr	r3, [pc, #44]	; (de8c <hal_i2c_send+0x9c>)
    de60:	6a3a      	ldr	r2, [r7, #32]
    de62:	0092      	lsls	r2, r2, #2
    de64:	58d3      	ldr	r3, [r2, r3]
    de66:	001a      	movs	r2, r3
    de68:	2314      	movs	r3, #20
    de6a:	18fb      	adds	r3, r7, r3
    de6c:	0019      	movs	r1, r3
    de6e:	0010      	movs	r0, r2
    de70:	4b07      	ldr	r3, [pc, #28]	; (de90 <hal_i2c_send+0xa0>)
    de72:	4798      	blx	r3
    de74:	1e03      	subs	r3, r0, #0
    de76:	d001      	beq.n	de7c <hal_i2c_send+0x8c>
		return ATCA_COMM_FAIL;
    de78:	23f0      	movs	r3, #240	; 0xf0
    de7a:	e000      	b.n	de7e <hal_i2c_send+0x8e>

	return ATCA_SUCCESS;
    de7c:	2300      	movs	r3, #0
}
    de7e:	0018      	movs	r0, r3
    de80:	46bd      	mov	sp, r7
    de82:	b00a      	add	sp, #40	; 0x28
    de84:	bd80      	pop	{r7, pc}
    de86:	46c0      	nop			; (mov r8, r8)
    de88:	0000ac39 	.word	0x0000ac39
    de8c:	200014e0 	.word	0x200014e0
    de90:	00004085 	.word	0x00004085

0000de94 <hal_i2c_receive>:
 * \param[in] rxlength  ptr to expected number of receive bytes to request
 * \return ATCA_STATUS
 */

ATCA_STATUS hal_i2c_receive( ATCAIface iface, uint8_t *rxdata, uint16_t *rxlength)
{
    de94:	b580      	push	{r7, lr}
    de96:	b08c      	sub	sp, #48	; 0x30
    de98:	af00      	add	r7, sp, #0
    de9a:	60f8      	str	r0, [r7, #12]
    de9c:	60b9      	str	r1, [r7, #8]
    de9e:	607a      	str	r2, [r7, #4]
	ATCAIfaceCfg *cfg = atgetifacecfg(iface);
    dea0:	68fb      	ldr	r3, [r7, #12]
    dea2:	0018      	movs	r0, r3
    dea4:	4b24      	ldr	r3, [pc, #144]	; (df38 <hal_i2c_receive+0xa4>)
    dea6:	4798      	blx	r3
    dea8:	0003      	movs	r3, r0
    deaa:	627b      	str	r3, [r7, #36]	; 0x24
	int bus = cfg->atcai2c.bus;
    deac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    deae:	795b      	ldrb	r3, [r3, #5]
    deb0:	623b      	str	r3, [r7, #32]
	int retries = cfg->rx_retries;
    deb2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    deb4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    deb6:	62fb      	str	r3, [r7, #44]	; 0x2c
	int status = !STATUS_OK;
    deb8:	2301      	movs	r3, #1
    deba:	62bb      	str	r3, [r7, #40]	; 0x28

	struct i2c_master_packet packet = {
		.address			= cfg->atcai2c.slave_address >> 1,
    debc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    debe:	791b      	ldrb	r3, [r3, #4]
	ATCAIfaceCfg *cfg = atgetifacecfg(iface);
	int bus = cfg->atcai2c.bus;
	int retries = cfg->rx_retries;
	int status = !STATUS_OK;

	struct i2c_master_packet packet = {
    dec0:	085b      	lsrs	r3, r3, #1
    dec2:	b2db      	uxtb	r3, r3
    dec4:	b29a      	uxth	r2, r3
    dec6:	2314      	movs	r3, #20
    dec8:	18fb      	adds	r3, r7, r3
    deca:	801a      	strh	r2, [r3, #0]
		.address			= cfg->atcai2c.slave_address >> 1,
		.data_length		= *rxlength,
    decc:	687b      	ldr	r3, [r7, #4]
    dece:	881a      	ldrh	r2, [r3, #0]
	ATCAIfaceCfg *cfg = atgetifacecfg(iface);
	int bus = cfg->atcai2c.bus;
	int retries = cfg->rx_retries;
	int status = !STATUS_OK;

	struct i2c_master_packet packet = {
    ded0:	2314      	movs	r3, #20
    ded2:	18fb      	adds	r3, r7, r3
    ded4:	805a      	strh	r2, [r3, #2]
    ded6:	2314      	movs	r3, #20
    ded8:	18fb      	adds	r3, r7, r3
    deda:	68ba      	ldr	r2, [r7, #8]
    dedc:	605a      	str	r2, [r3, #4]
    dede:	2314      	movs	r3, #20
    dee0:	18fb      	adds	r3, r7, r3
    dee2:	2200      	movs	r2, #0
    dee4:	721a      	strb	r2, [r3, #8]
    dee6:	2314      	movs	r3, #20
    dee8:	18fb      	adds	r3, r7, r3
    deea:	2200      	movs	r2, #0
    deec:	725a      	strb	r2, [r3, #9]
    deee:	2314      	movs	r3, #20
    def0:	18fb      	adds	r3, r7, r3
    def2:	2200      	movs	r2, #0
    def4:	729a      	strb	r2, [r3, #10]
		.ten_bit_address	= false,
		.high_speed			= false,
		.hs_master_code		= 0x0,
	};

	while ( retries-- > 0 && status != STATUS_OK )
    def6:	e00c      	b.n	df12 <hal_i2c_receive+0x7e>
		status = i2c_master_read_packet_wait( &(i2c_hal_data[bus]->i2c_master_instance), &packet);
    def8:	4b10      	ldr	r3, [pc, #64]	; (df3c <hal_i2c_receive+0xa8>)
    defa:	6a3a      	ldr	r2, [r7, #32]
    defc:	0092      	lsls	r2, r2, #2
    defe:	58d3      	ldr	r3, [r2, r3]
    df00:	001a      	movs	r2, r3
    df02:	2314      	movs	r3, #20
    df04:	18fb      	adds	r3, r7, r3
    df06:	0019      	movs	r1, r3
    df08:	0010      	movs	r0, r2
    df0a:	4b0d      	ldr	r3, [pc, #52]	; (df40 <hal_i2c_receive+0xac>)
    df0c:	4798      	blx	r3
    df0e:	0003      	movs	r3, r0
    df10:	62bb      	str	r3, [r7, #40]	; 0x28
		.ten_bit_address	= false,
		.high_speed			= false,
		.hs_master_code		= 0x0,
	};

	while ( retries-- > 0 && status != STATUS_OK )
    df12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    df14:	1e5a      	subs	r2, r3, #1
    df16:	62fa      	str	r2, [r7, #44]	; 0x2c
    df18:	2b00      	cmp	r3, #0
    df1a:	dd02      	ble.n	df22 <hal_i2c_receive+0x8e>
    df1c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    df1e:	2b00      	cmp	r3, #0
    df20:	d1ea      	bne.n	def8 <hal_i2c_receive+0x64>
		status = i2c_master_read_packet_wait( &(i2c_hal_data[bus]->i2c_master_instance), &packet);

	if ( status != STATUS_OK )
    df22:	6abb      	ldr	r3, [r7, #40]	; 0x28
    df24:	2b00      	cmp	r3, #0
    df26:	d001      	beq.n	df2c <hal_i2c_receive+0x98>
		return ATCA_COMM_FAIL;
    df28:	23f0      	movs	r3, #240	; 0xf0
    df2a:	e000      	b.n	df2e <hal_i2c_receive+0x9a>

	return ATCA_SUCCESS;
    df2c:	2300      	movs	r3, #0
}
    df2e:	0018      	movs	r0, r3
    df30:	46bd      	mov	sp, r7
    df32:	b00c      	add	sp, #48	; 0x30
    df34:	bd80      	pop	{r7, pc}
    df36:	46c0      	nop			; (mov r8, r8)
    df38:	0000ac39 	.word	0x0000ac39
    df3c:	200014e0 	.word	0x200014e0
    df40:	00003edd 	.word	0x00003edd

0000df44 <change_i2c_speed>:
 * \param[in] iface  interface on which to change bus speed
 * \param[in] speed  baud rate (typically 100000 or 400000)
 */

void change_i2c_speed( ATCAIface iface, uint32_t speed )
{
    df44:	b580      	push	{r7, lr}
    df46:	b084      	sub	sp, #16
    df48:	af00      	add	r7, sp, #0
    df4a:	6078      	str	r0, [r7, #4]
    df4c:	6039      	str	r1, [r7, #0]
	ATCAIfaceCfg *cfg = atgetifacecfg(iface);
    df4e:	687b      	ldr	r3, [r7, #4]
    df50:	0018      	movs	r0, r3
    df52:	4b38      	ldr	r3, [pc, #224]	; (e034 <change_i2c_speed+0xf0>)
    df54:	4798      	blx	r3
    df56:	0003      	movs	r3, r0
    df58:	60fb      	str	r3, [r7, #12]
	int bus = cfg->atcai2c.bus;
    df5a:	68fb      	ldr	r3, [r7, #12]
    df5c:	795b      	ldrb	r3, [r3, #5]
    df5e:	60bb      	str	r3, [r7, #8]

	config_i2c_master.buffer_timeout = 10000;
    df60:	4b35      	ldr	r3, [pc, #212]	; (e038 <change_i2c_speed+0xf4>)
    df62:	4a36      	ldr	r2, [pc, #216]	; (e03c <change_i2c_speed+0xf8>)
    df64:	82da      	strh	r2, [r3, #22]
	config_i2c_master.baud_rate = speed / 1000;
    df66:	6838      	ldr	r0, [r7, #0]
    df68:	4b35      	ldr	r3, [pc, #212]	; (e040 <change_i2c_speed+0xfc>)
    df6a:	22fa      	movs	r2, #250	; 0xfa
    df6c:	0091      	lsls	r1, r2, #2
    df6e:	4798      	blx	r3
    df70:	0003      	movs	r3, r0
    df72:	001a      	movs	r2, r3
    df74:	4b30      	ldr	r3, [pc, #192]	; (e038 <change_i2c_speed+0xf4>)
    df76:	601a      	str	r2, [r3, #0]

	i2c_master_disable(&(i2c_hal_data[bus]->i2c_master_instance));
    df78:	4b32      	ldr	r3, [pc, #200]	; (e044 <change_i2c_speed+0x100>)
    df7a:	68ba      	ldr	r2, [r7, #8]
    df7c:	0092      	lsls	r2, r2, #2
    df7e:	58d3      	ldr	r3, [r2, r3]
    df80:	0018      	movs	r0, r3
    df82:	4b31      	ldr	r3, [pc, #196]	; (e048 <change_i2c_speed+0x104>)
    df84:	4798      	blx	r3

	switch (bus) {
    df86:	68bb      	ldr	r3, [r7, #8]
    df88:	2b05      	cmp	r3, #5
    df8a:	d847      	bhi.n	e01c <change_i2c_speed+0xd8>
    df8c:	68bb      	ldr	r3, [r7, #8]
    df8e:	009a      	lsls	r2, r3, #2
    df90:	4b2e      	ldr	r3, [pc, #184]	; (e04c <change_i2c_speed+0x108>)
    df92:	18d3      	adds	r3, r2, r3
    df94:	681b      	ldr	r3, [r3, #0]
    df96:	469f      	mov	pc, r3
	case 0: i2c_master_init(  &(i2c_hal_data[bus]->i2c_master_instance), SERCOM0, &config_i2c_master); break;
    df98:	4b2a      	ldr	r3, [pc, #168]	; (e044 <change_i2c_speed+0x100>)
    df9a:	68ba      	ldr	r2, [r7, #8]
    df9c:	0092      	lsls	r2, r2, #2
    df9e:	58d3      	ldr	r3, [r2, r3]
    dfa0:	0018      	movs	r0, r3
    dfa2:	4b25      	ldr	r3, [pc, #148]	; (e038 <change_i2c_speed+0xf4>)
    dfa4:	492a      	ldr	r1, [pc, #168]	; (e050 <change_i2c_speed+0x10c>)
    dfa6:	001a      	movs	r2, r3
    dfa8:	4b2a      	ldr	r3, [pc, #168]	; (e054 <change_i2c_speed+0x110>)
    dfaa:	4798      	blx	r3
    dfac:	e036      	b.n	e01c <change_i2c_speed+0xd8>
	case 1: i2c_master_init(  &(i2c_hal_data[bus]->i2c_master_instance), SERCOM1, &config_i2c_master); break;
    dfae:	4b25      	ldr	r3, [pc, #148]	; (e044 <change_i2c_speed+0x100>)
    dfb0:	68ba      	ldr	r2, [r7, #8]
    dfb2:	0092      	lsls	r2, r2, #2
    dfb4:	58d3      	ldr	r3, [r2, r3]
    dfb6:	0018      	movs	r0, r3
    dfb8:	4b1f      	ldr	r3, [pc, #124]	; (e038 <change_i2c_speed+0xf4>)
    dfba:	4927      	ldr	r1, [pc, #156]	; (e058 <change_i2c_speed+0x114>)
    dfbc:	001a      	movs	r2, r3
    dfbe:	4b25      	ldr	r3, [pc, #148]	; (e054 <change_i2c_speed+0x110>)
    dfc0:	4798      	blx	r3
    dfc2:	e02b      	b.n	e01c <change_i2c_speed+0xd8>
	case 2: i2c_master_init(  &(i2c_hal_data[bus]->i2c_master_instance), SERCOM2, &config_i2c_master); break;
    dfc4:	4b1f      	ldr	r3, [pc, #124]	; (e044 <change_i2c_speed+0x100>)
    dfc6:	68ba      	ldr	r2, [r7, #8]
    dfc8:	0092      	lsls	r2, r2, #2
    dfca:	58d3      	ldr	r3, [r2, r3]
    dfcc:	0018      	movs	r0, r3
    dfce:	4b1a      	ldr	r3, [pc, #104]	; (e038 <change_i2c_speed+0xf4>)
    dfd0:	4922      	ldr	r1, [pc, #136]	; (e05c <change_i2c_speed+0x118>)
    dfd2:	001a      	movs	r2, r3
    dfd4:	4b1f      	ldr	r3, [pc, #124]	; (e054 <change_i2c_speed+0x110>)
    dfd6:	4798      	blx	r3
    dfd8:	e020      	b.n	e01c <change_i2c_speed+0xd8>
	case 3: i2c_master_init(  &(i2c_hal_data[bus]->i2c_master_instance), SERCOM3, &config_i2c_master); break;
    dfda:	4b1a      	ldr	r3, [pc, #104]	; (e044 <change_i2c_speed+0x100>)
    dfdc:	68ba      	ldr	r2, [r7, #8]
    dfde:	0092      	lsls	r2, r2, #2
    dfe0:	58d3      	ldr	r3, [r2, r3]
    dfe2:	0018      	movs	r0, r3
    dfe4:	4b14      	ldr	r3, [pc, #80]	; (e038 <change_i2c_speed+0xf4>)
    dfe6:	491e      	ldr	r1, [pc, #120]	; (e060 <change_i2c_speed+0x11c>)
    dfe8:	001a      	movs	r2, r3
    dfea:	4b1a      	ldr	r3, [pc, #104]	; (e054 <change_i2c_speed+0x110>)
    dfec:	4798      	blx	r3
    dfee:	e015      	b.n	e01c <change_i2c_speed+0xd8>
	case 4: i2c_master_init(  &(i2c_hal_data[bus]->i2c_master_instance), SERCOM4, &config_i2c_master); break;
    dff0:	4b14      	ldr	r3, [pc, #80]	; (e044 <change_i2c_speed+0x100>)
    dff2:	68ba      	ldr	r2, [r7, #8]
    dff4:	0092      	lsls	r2, r2, #2
    dff6:	58d3      	ldr	r3, [r2, r3]
    dff8:	0018      	movs	r0, r3
    dffa:	4b0f      	ldr	r3, [pc, #60]	; (e038 <change_i2c_speed+0xf4>)
    dffc:	4919      	ldr	r1, [pc, #100]	; (e064 <change_i2c_speed+0x120>)
    dffe:	001a      	movs	r2, r3
    e000:	4b14      	ldr	r3, [pc, #80]	; (e054 <change_i2c_speed+0x110>)
    e002:	4798      	blx	r3
    e004:	e00a      	b.n	e01c <change_i2c_speed+0xd8>
	case 5: i2c_master_init(  &(i2c_hal_data[bus]->i2c_master_instance), SERCOM5, &config_i2c_master); break;
    e006:	4b0f      	ldr	r3, [pc, #60]	; (e044 <change_i2c_speed+0x100>)
    e008:	68ba      	ldr	r2, [r7, #8]
    e00a:	0092      	lsls	r2, r2, #2
    e00c:	58d3      	ldr	r3, [r2, r3]
    e00e:	0018      	movs	r0, r3
    e010:	4b09      	ldr	r3, [pc, #36]	; (e038 <change_i2c_speed+0xf4>)
    e012:	4915      	ldr	r1, [pc, #84]	; (e068 <change_i2c_speed+0x124>)
    e014:	001a      	movs	r2, r3
    e016:	4b0f      	ldr	r3, [pc, #60]	; (e054 <change_i2c_speed+0x110>)
    e018:	4798      	blx	r3
    e01a:	46c0      	nop			; (mov r8, r8)
	}

	i2c_master_enable(&(i2c_hal_data[bus]->i2c_master_instance));
    e01c:	4b09      	ldr	r3, [pc, #36]	; (e044 <change_i2c_speed+0x100>)
    e01e:	68ba      	ldr	r2, [r7, #8]
    e020:	0092      	lsls	r2, r2, #2
    e022:	58d3      	ldr	r3, [r2, r3]
    e024:	0018      	movs	r0, r3
    e026:	4b11      	ldr	r3, [pc, #68]	; (e06c <change_i2c_speed+0x128>)
    e028:	4798      	blx	r3
}
    e02a:	46c0      	nop			; (mov r8, r8)
    e02c:	46bd      	mov	sp, r7
    e02e:	b004      	add	sp, #16
    e030:	bd80      	pop	{r7, pc}
    e032:	46c0      	nop			; (mov r8, r8)
    e034:	0000ac39 	.word	0x0000ac39
    e038:	200007f0 	.word	0x200007f0
    e03c:	00002710 	.word	0x00002710
    e040:	000121bd 	.word	0x000121bd
    e044:	200014e0 	.word	0x200014e0
    e048:	0000dbfd 	.word	0x0000dbfd
    e04c:	00015380 	.word	0x00015380
    e050:	42000800 	.word	0x42000800
    e054:	00003a6d 	.word	0x00003a6d
    e058:	42000c00 	.word	0x42000c00
    e05c:	42001000 	.word	0x42001000
    e060:	42001400 	.word	0x42001400
    e064:	42001800 	.word	0x42001800
    e068:	42001c00 	.word	0x42001c00
    e06c:	0000dba1 	.word	0x0000dba1

0000e070 <hal_i2c_wake>:
/** \brief wake up CryptoAuth device using I2C bus
 * \param[in] iface  interface to logical device to wakeup
 */

ATCA_STATUS hal_i2c_wake(ATCAIface iface)
{
    e070:	b580      	push	{r7, lr}
    e072:	b08c      	sub	sp, #48	; 0x30
    e074:	af00      	add	r7, sp, #0
    e076:	6078      	str	r0, [r7, #4]
	ATCAIfaceCfg *cfg = atgetifacecfg(iface);
    e078:	687b      	ldr	r3, [r7, #4]
    e07a:	0018      	movs	r0, r3
    e07c:	4b48      	ldr	r3, [pc, #288]	; (e1a0 <hal_i2c_wake+0x130>)
    e07e:	4798      	blx	r3
    e080:	0003      	movs	r3, r0
    e082:	627b      	str	r3, [r7, #36]	; 0x24
	int bus = cfg->atcai2c.bus;
    e084:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    e086:	795b      	ldrb	r3, [r3, #5]
    e088:	623b      	str	r3, [r7, #32]
	int retries = cfg->rx_retries;
    e08a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    e08c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    e08e:	62fb      	str	r3, [r7, #44]	; 0x2c
	uint32_t bdrt = cfg->atcai2c.baud;
    e090:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    e092:	689b      	ldr	r3, [r3, #8]
    e094:	61fb      	str	r3, [r7, #28]
	int status = !STATUS_OK;
    e096:	2301      	movs	r3, #1
    e098:	62bb      	str	r3, [r7, #40]	; 0x28
	uint8_t data[4], expected[4] = { 0x04, 0x11, 0x33, 0x43 };
    e09a:	2314      	movs	r3, #20
    e09c:	18fa      	adds	r2, r7, r3
    e09e:	4b41      	ldr	r3, [pc, #260]	; (e1a4 <hal_i2c_wake+0x134>)
    e0a0:	0010      	movs	r0, r2
    e0a2:	0019      	movs	r1, r3
    e0a4:	2304      	movs	r3, #4
    e0a6:	001a      	movs	r2, r3
    e0a8:	4b3f      	ldr	r3, [pc, #252]	; (e1a8 <hal_i2c_wake+0x138>)
    e0aa:	4798      	blx	r3

	if ( bdrt != 100000 )  // if not already at 100KHz, change it
    e0ac:	69fb      	ldr	r3, [r7, #28]
    e0ae:	4a3f      	ldr	r2, [pc, #252]	; (e1ac <hal_i2c_wake+0x13c>)
    e0b0:	4293      	cmp	r3, r2
    e0b2:	d005      	beq.n	e0c0 <hal_i2c_wake+0x50>
		change_i2c_speed( iface, 100000 );
    e0b4:	4a3d      	ldr	r2, [pc, #244]	; (e1ac <hal_i2c_wake+0x13c>)
    e0b6:	687b      	ldr	r3, [r7, #4]
    e0b8:	0011      	movs	r1, r2
    e0ba:	0018      	movs	r0, r3
    e0bc:	4b3c      	ldr	r3, [pc, #240]	; (e1b0 <hal_i2c_wake+0x140>)
    e0be:	4798      	blx	r3

	// Send the wake by writing to an address of 0x00
	struct i2c_master_packet packet = {
    e0c0:	2308      	movs	r3, #8
    e0c2:	18fb      	adds	r3, r7, r3
    e0c4:	2200      	movs	r2, #0
    e0c6:	801a      	strh	r2, [r3, #0]
    e0c8:	2308      	movs	r3, #8
    e0ca:	18fb      	adds	r3, r7, r3
    e0cc:	2200      	movs	r2, #0
    e0ce:	805a      	strh	r2, [r3, #2]
    e0d0:	2308      	movs	r3, #8
    e0d2:	18fb      	adds	r3, r7, r3
    e0d4:	2218      	movs	r2, #24
    e0d6:	18ba      	adds	r2, r7, r2
    e0d8:	605a      	str	r2, [r3, #4]
    e0da:	2308      	movs	r3, #8
    e0dc:	18fb      	adds	r3, r7, r3
    e0de:	2200      	movs	r2, #0
    e0e0:	721a      	strb	r2, [r3, #8]
    e0e2:	2308      	movs	r3, #8
    e0e4:	18fb      	adds	r3, r7, r3
    e0e6:	2200      	movs	r2, #0
    e0e8:	725a      	strb	r2, [r3, #9]
    e0ea:	2308      	movs	r3, #8
    e0ec:	18fb      	adds	r3, r7, r3
    e0ee:	2200      	movs	r2, #0
    e0f0:	729a      	strb	r2, [r3, #10]
		.high_speed			= false,
		.hs_master_code		= 0x0,
	};

	// Send the 00 address as the wake pulse
	i2c_master_write_packet_wait(  &(i2c_hal_data[bus]->i2c_master_instance), &packet );    // part will NACK, so don't check for status
    e0f2:	4b30      	ldr	r3, [pc, #192]	; (e1b4 <hal_i2c_wake+0x144>)
    e0f4:	6a3a      	ldr	r2, [r7, #32]
    e0f6:	0092      	lsls	r2, r2, #2
    e0f8:	58d3      	ldr	r3, [r2, r3]
    e0fa:	001a      	movs	r2, r3
    e0fc:	2308      	movs	r3, #8
    e0fe:	18fb      	adds	r3, r7, r3
    e100:	0019      	movs	r1, r3
    e102:	0010      	movs	r0, r2
    e104:	4b2c      	ldr	r3, [pc, #176]	; (e1b8 <hal_i2c_wake+0x148>)
    e106:	4798      	blx	r3

	atca_delay_us(cfg->wake_delay);                                                         // wait tWHI + tWLO which is configured based on device type and configuration structure
    e108:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    e10a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    e10c:	0018      	movs	r0, r3
    e10e:	4b2b      	ldr	r3, [pc, #172]	; (e1bc <hal_i2c_wake+0x14c>)
    e110:	4798      	blx	r3

	packet.address = cfg->atcai2c.slave_address >> 1;
    e112:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    e114:	791b      	ldrb	r3, [r3, #4]
    e116:	085b      	lsrs	r3, r3, #1
    e118:	b2db      	uxtb	r3, r3
    e11a:	b29a      	uxth	r2, r3
    e11c:	2308      	movs	r3, #8
    e11e:	18fb      	adds	r3, r7, r3
    e120:	801a      	strh	r2, [r3, #0]
	packet.data_length = 4;
    e122:	2308      	movs	r3, #8
    e124:	18fb      	adds	r3, r7, r3
    e126:	2204      	movs	r2, #4
    e128:	805a      	strh	r2, [r3, #2]
	packet.data = data;
    e12a:	2308      	movs	r3, #8
    e12c:	18fb      	adds	r3, r7, r3
    e12e:	2218      	movs	r2, #24
    e130:	18ba      	adds	r2, r7, r2
    e132:	605a      	str	r2, [r3, #4]

	while ( retries-- > 0 && status != STATUS_OK )
    e134:	e00c      	b.n	e150 <hal_i2c_wake+0xe0>
		status = i2c_master_read_packet_wait( &(i2c_hal_data[bus]->i2c_master_instance), &packet);
    e136:	4b1f      	ldr	r3, [pc, #124]	; (e1b4 <hal_i2c_wake+0x144>)
    e138:	6a3a      	ldr	r2, [r7, #32]
    e13a:	0092      	lsls	r2, r2, #2
    e13c:	58d3      	ldr	r3, [r2, r3]
    e13e:	001a      	movs	r2, r3
    e140:	2308      	movs	r3, #8
    e142:	18fb      	adds	r3, r7, r3
    e144:	0019      	movs	r1, r3
    e146:	0010      	movs	r0, r2
    e148:	4b1d      	ldr	r3, [pc, #116]	; (e1c0 <hal_i2c_wake+0x150>)
    e14a:	4798      	blx	r3
    e14c:	0003      	movs	r3, r0
    e14e:	62bb      	str	r3, [r7, #40]	; 0x28

	packet.address = cfg->atcai2c.slave_address >> 1;
	packet.data_length = 4;
	packet.data = data;

	while ( retries-- > 0 && status != STATUS_OK )
    e150:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    e152:	1e5a      	subs	r2, r3, #1
    e154:	62fa      	str	r2, [r7, #44]	; 0x2c
    e156:	2b00      	cmp	r3, #0
    e158:	dd02      	ble.n	e160 <hal_i2c_wake+0xf0>
    e15a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    e15c:	2b00      	cmp	r3, #0
    e15e:	d1ea      	bne.n	e136 <hal_i2c_wake+0xc6>
		status = i2c_master_read_packet_wait( &(i2c_hal_data[bus]->i2c_master_instance), &packet);

	// if necessary, revert baud rate to what came in.
	if ( bdrt != 100000 )
    e160:	69fb      	ldr	r3, [r7, #28]
    e162:	4a12      	ldr	r2, [pc, #72]	; (e1ac <hal_i2c_wake+0x13c>)
    e164:	4293      	cmp	r3, r2
    e166:	d005      	beq.n	e174 <hal_i2c_wake+0x104>
		change_i2c_speed( iface, bdrt );
    e168:	69fa      	ldr	r2, [r7, #28]
    e16a:	687b      	ldr	r3, [r7, #4]
    e16c:	0011      	movs	r1, r2
    e16e:	0018      	movs	r0, r3
    e170:	4b0f      	ldr	r3, [pc, #60]	; (e1b0 <hal_i2c_wake+0x140>)
    e172:	4798      	blx	r3

	if ( status != STATUS_OK )
    e174:	6abb      	ldr	r3, [r7, #40]	; 0x28
    e176:	2b00      	cmp	r3, #0
    e178:	d001      	beq.n	e17e <hal_i2c_wake+0x10e>
		return ATCA_COMM_FAIL;
    e17a:	23f0      	movs	r3, #240	; 0xf0
    e17c:	e00c      	b.n	e198 <hal_i2c_wake+0x128>

	if ( memcmp( data, expected, 4 ) == 0 )
    e17e:	2314      	movs	r3, #20
    e180:	18f9      	adds	r1, r7, r3
    e182:	2318      	movs	r3, #24
    e184:	18fb      	adds	r3, r7, r3
    e186:	2204      	movs	r2, #4
    e188:	0018      	movs	r0, r3
    e18a:	4b0e      	ldr	r3, [pc, #56]	; (e1c4 <hal_i2c_wake+0x154>)
    e18c:	4798      	blx	r3
    e18e:	1e03      	subs	r3, r0, #0
    e190:	d101      	bne.n	e196 <hal_i2c_wake+0x126>
		return ATCA_SUCCESS;
    e192:	2300      	movs	r3, #0
    e194:	e000      	b.n	e198 <hal_i2c_wake+0x128>

	return ATCA_COMM_FAIL;
    e196:	23f0      	movs	r3, #240	; 0xf0
}
    e198:	0018      	movs	r0, r3
    e19a:	46bd      	mov	sp, r7
    e19c:	b00c      	add	sp, #48	; 0x30
    e19e:	bd80      	pop	{r7, pc}
    e1a0:	0000ac39 	.word	0x0000ac39
    e1a4:	00015364 	.word	0x00015364
    e1a8:	000127e7 	.word	0x000127e7
    e1ac:	000186a0 	.word	0x000186a0
    e1b0:	0000df45 	.word	0x0000df45
    e1b4:	200014e0 	.word	0x200014e0
    e1b8:	00004085 	.word	0x00004085
    e1bc:	0000e365 	.word	0x0000e365
    e1c0:	00003edd 	.word	0x00003edd
    e1c4:	000127c9 	.word	0x000127c9

0000e1c8 <hal_i2c_idle>:
/** \brief idle CryptoAuth device using I2C bus
 * \param[in] iface  interface to logical device to idle
 */

ATCA_STATUS hal_i2c_idle(ATCAIface iface)
{
    e1c8:	b580      	push	{r7, lr}
    e1ca:	b088      	sub	sp, #32
    e1cc:	af00      	add	r7, sp, #0
    e1ce:	6078      	str	r0, [r7, #4]
	ATCAIfaceCfg *cfg = atgetifacecfg(iface);
    e1d0:	687b      	ldr	r3, [r7, #4]
    e1d2:	0018      	movs	r0, r3
    e1d4:	4b1d      	ldr	r3, [pc, #116]	; (e24c <hal_i2c_idle+0x84>)
    e1d6:	4798      	blx	r3
    e1d8:	0003      	movs	r3, r0
    e1da:	61fb      	str	r3, [r7, #28]
	int bus = cfg->atcai2c.bus;
    e1dc:	69fb      	ldr	r3, [r7, #28]
    e1de:	795b      	ldrb	r3, [r3, #5]
    e1e0:	61bb      	str	r3, [r7, #24]
	uint8_t data[4];

	struct i2c_master_packet packet = {
		.address			= cfg->atcai2c.slave_address >> 1,
    e1e2:	69fb      	ldr	r3, [r7, #28]
    e1e4:	791b      	ldrb	r3, [r3, #4]
{
	ATCAIfaceCfg *cfg = atgetifacecfg(iface);
	int bus = cfg->atcai2c.bus;
	uint8_t data[4];

	struct i2c_master_packet packet = {
    e1e6:	085b      	lsrs	r3, r3, #1
    e1e8:	b2db      	uxtb	r3, r3
    e1ea:	b29a      	uxth	r2, r3
    e1ec:	2308      	movs	r3, #8
    e1ee:	18fb      	adds	r3, r7, r3
    e1f0:	801a      	strh	r2, [r3, #0]
    e1f2:	2308      	movs	r3, #8
    e1f4:	18fb      	adds	r3, r7, r3
    e1f6:	2201      	movs	r2, #1
    e1f8:	805a      	strh	r2, [r3, #2]
    e1fa:	2308      	movs	r3, #8
    e1fc:	18fb      	adds	r3, r7, r3
    e1fe:	2214      	movs	r2, #20
    e200:	18ba      	adds	r2, r7, r2
    e202:	605a      	str	r2, [r3, #4]
    e204:	2308      	movs	r3, #8
    e206:	18fb      	adds	r3, r7, r3
    e208:	2200      	movs	r2, #0
    e20a:	721a      	strb	r2, [r3, #8]
    e20c:	2308      	movs	r3, #8
    e20e:	18fb      	adds	r3, r7, r3
    e210:	2200      	movs	r2, #0
    e212:	725a      	strb	r2, [r3, #9]
    e214:	2308      	movs	r3, #8
    e216:	18fb      	adds	r3, r7, r3
    e218:	2200      	movs	r2, #0
    e21a:	729a      	strb	r2, [r3, #10]
		.ten_bit_address	= false,
		.high_speed			= false,
		.hs_master_code		= 0x0,
	};

	data[0] = 0x02;  // idle word address value
    e21c:	2314      	movs	r3, #20
    e21e:	18fb      	adds	r3, r7, r3
    e220:	2202      	movs	r2, #2
    e222:	701a      	strb	r2, [r3, #0]
	if ( i2c_master_write_packet_wait(&(i2c_hal_data[bus]->i2c_master_instance), &packet) != STATUS_OK )
    e224:	4b0a      	ldr	r3, [pc, #40]	; (e250 <hal_i2c_idle+0x88>)
    e226:	69ba      	ldr	r2, [r7, #24]
    e228:	0092      	lsls	r2, r2, #2
    e22a:	58d3      	ldr	r3, [r2, r3]
    e22c:	001a      	movs	r2, r3
    e22e:	2308      	movs	r3, #8
    e230:	18fb      	adds	r3, r7, r3
    e232:	0019      	movs	r1, r3
    e234:	0010      	movs	r0, r2
    e236:	4b07      	ldr	r3, [pc, #28]	; (e254 <hal_i2c_idle+0x8c>)
    e238:	4798      	blx	r3
    e23a:	1e03      	subs	r3, r0, #0
    e23c:	d001      	beq.n	e242 <hal_i2c_idle+0x7a>
		return ATCA_COMM_FAIL;
    e23e:	23f0      	movs	r3, #240	; 0xf0
    e240:	e000      	b.n	e244 <hal_i2c_idle+0x7c>

	return ATCA_SUCCESS;
    e242:	2300      	movs	r3, #0

}
    e244:	0018      	movs	r0, r3
    e246:	46bd      	mov	sp, r7
    e248:	b008      	add	sp, #32
    e24a:	bd80      	pop	{r7, pc}
    e24c:	0000ac39 	.word	0x0000ac39
    e250:	200014e0 	.word	0x200014e0
    e254:	00004085 	.word	0x00004085

0000e258 <hal_i2c_sleep>:
/** \brief sleep CryptoAuth device using I2C bus
 * \param[in] iface  interface to logical device to sleep
 */

ATCA_STATUS hal_i2c_sleep(ATCAIface iface)
{
    e258:	b580      	push	{r7, lr}
    e25a:	b088      	sub	sp, #32
    e25c:	af00      	add	r7, sp, #0
    e25e:	6078      	str	r0, [r7, #4]
	ATCAIfaceCfg *cfg = atgetifacecfg(iface);
    e260:	687b      	ldr	r3, [r7, #4]
    e262:	0018      	movs	r0, r3
    e264:	4b1d      	ldr	r3, [pc, #116]	; (e2dc <hal_i2c_sleep+0x84>)
    e266:	4798      	blx	r3
    e268:	0003      	movs	r3, r0
    e26a:	61fb      	str	r3, [r7, #28]
	int bus = cfg->atcai2c.bus;
    e26c:	69fb      	ldr	r3, [r7, #28]
    e26e:	795b      	ldrb	r3, [r3, #5]
    e270:	61bb      	str	r3, [r7, #24]
	uint8_t data[4];

	struct i2c_master_packet packet = {
		.address			= cfg->atcai2c.slave_address >> 1,
    e272:	69fb      	ldr	r3, [r7, #28]
    e274:	791b      	ldrb	r3, [r3, #4]
{
	ATCAIfaceCfg *cfg = atgetifacecfg(iface);
	int bus = cfg->atcai2c.bus;
	uint8_t data[4];

	struct i2c_master_packet packet = {
    e276:	085b      	lsrs	r3, r3, #1
    e278:	b2db      	uxtb	r3, r3
    e27a:	b29a      	uxth	r2, r3
    e27c:	2308      	movs	r3, #8
    e27e:	18fb      	adds	r3, r7, r3
    e280:	801a      	strh	r2, [r3, #0]
    e282:	2308      	movs	r3, #8
    e284:	18fb      	adds	r3, r7, r3
    e286:	2201      	movs	r2, #1
    e288:	805a      	strh	r2, [r3, #2]
    e28a:	2308      	movs	r3, #8
    e28c:	18fb      	adds	r3, r7, r3
    e28e:	2214      	movs	r2, #20
    e290:	18ba      	adds	r2, r7, r2
    e292:	605a      	str	r2, [r3, #4]
    e294:	2308      	movs	r3, #8
    e296:	18fb      	adds	r3, r7, r3
    e298:	2200      	movs	r2, #0
    e29a:	721a      	strb	r2, [r3, #8]
    e29c:	2308      	movs	r3, #8
    e29e:	18fb      	adds	r3, r7, r3
    e2a0:	2200      	movs	r2, #0
    e2a2:	725a      	strb	r2, [r3, #9]
    e2a4:	2308      	movs	r3, #8
    e2a6:	18fb      	adds	r3, r7, r3
    e2a8:	2200      	movs	r2, #0
    e2aa:	729a      	strb	r2, [r3, #10]
		.ten_bit_address	= false,
		.high_speed			= false,
		.hs_master_code		= 0x0,
	};

	data[0] = 0x01;  // sleep word address value
    e2ac:	2314      	movs	r3, #20
    e2ae:	18fb      	adds	r3, r7, r3
    e2b0:	2201      	movs	r2, #1
    e2b2:	701a      	strb	r2, [r3, #0]
	if ( i2c_master_write_packet_wait(&(i2c_hal_data[bus]->i2c_master_instance), &packet) != STATUS_OK )
    e2b4:	4b0a      	ldr	r3, [pc, #40]	; (e2e0 <hal_i2c_sleep+0x88>)
    e2b6:	69ba      	ldr	r2, [r7, #24]
    e2b8:	0092      	lsls	r2, r2, #2
    e2ba:	58d3      	ldr	r3, [r2, r3]
    e2bc:	001a      	movs	r2, r3
    e2be:	2308      	movs	r3, #8
    e2c0:	18fb      	adds	r3, r7, r3
    e2c2:	0019      	movs	r1, r3
    e2c4:	0010      	movs	r0, r2
    e2c6:	4b07      	ldr	r3, [pc, #28]	; (e2e4 <hal_i2c_sleep+0x8c>)
    e2c8:	4798      	blx	r3
    e2ca:	1e03      	subs	r3, r0, #0
    e2cc:	d001      	beq.n	e2d2 <hal_i2c_sleep+0x7a>
		return ATCA_COMM_FAIL;
    e2ce:	23f0      	movs	r3, #240	; 0xf0
    e2d0:	e000      	b.n	e2d4 <hal_i2c_sleep+0x7c>

	return ATCA_SUCCESS;
    e2d2:	2300      	movs	r3, #0
}
    e2d4:	0018      	movs	r0, r3
    e2d6:	46bd      	mov	sp, r7
    e2d8:	b008      	add	sp, #32
    e2da:	bd80      	pop	{r7, pc}
    e2dc:	0000ac39 	.word	0x0000ac39
    e2e0:	200014e0 	.word	0x200014e0
    e2e4:	00004085 	.word	0x00004085

0000e2e8 <hal_i2c_release>:
/** \brief manages reference count on given bus and releases resource if no more refences exist
 * \param[in] hal_data - opaque pointer to hal data structure - known only to the HAL implementation
 */

ATCA_STATUS hal_i2c_release( void *hal_data )
{
    e2e8:	b580      	push	{r7, lr}
    e2ea:	b084      	sub	sp, #16
    e2ec:	af00      	add	r7, sp, #0
    e2ee:	6078      	str	r0, [r7, #4]
	ATCAI2CMaster_t *hal = (ATCAI2CMaster_t*)hal_data;
    e2f0:	687b      	ldr	r3, [r7, #4]
    e2f2:	60fb      	str	r3, [r7, #12]

	i2c_bus_ref_ct--;  // track total i2c bus interface instances for consistency checking and debugging
    e2f4:	4b17      	ldr	r3, [pc, #92]	; (e354 <hal_i2c_release+0x6c>)
    e2f6:	681b      	ldr	r3, [r3, #0]
    e2f8:	1e5a      	subs	r2, r3, #1
    e2fa:	4b16      	ldr	r3, [pc, #88]	; (e354 <hal_i2c_release+0x6c>)
    e2fc:	601a      	str	r2, [r3, #0]

	// if the use count for this bus has gone to 0 references, disable it.  protect against an unbracketed release
	if ( hal && --(hal->ref_ct) <= 0 && i2c_hal_data[hal->bus_index] != NULL ) {
    e2fe:	68fb      	ldr	r3, [r7, #12]
    e300:	2b00      	cmp	r3, #0
    e302:	d021      	beq.n	e348 <hal_i2c_release+0x60>
    e304:	68fb      	ldr	r3, [r7, #12]
    e306:	68db      	ldr	r3, [r3, #12]
    e308:	1e5a      	subs	r2, r3, #1
    e30a:	68fb      	ldr	r3, [r7, #12]
    e30c:	60da      	str	r2, [r3, #12]
    e30e:	68fb      	ldr	r3, [r7, #12]
    e310:	68db      	ldr	r3, [r3, #12]
    e312:	2b00      	cmp	r3, #0
    e314:	dc18      	bgt.n	e348 <hal_i2c_release+0x60>
    e316:	68fb      	ldr	r3, [r7, #12]
    e318:	691a      	ldr	r2, [r3, #16]
    e31a:	4b0f      	ldr	r3, [pc, #60]	; (e358 <hal_i2c_release+0x70>)
    e31c:	0092      	lsls	r2, r2, #2
    e31e:	58d3      	ldr	r3, [r2, r3]
    e320:	2b00      	cmp	r3, #0
    e322:	d011      	beq.n	e348 <hal_i2c_release+0x60>
		i2c_master_reset(&(hal->i2c_master_instance));
    e324:	68fb      	ldr	r3, [r7, #12]
    e326:	0018      	movs	r0, r3
    e328:	4b0c      	ldr	r3, [pc, #48]	; (e35c <hal_i2c_release+0x74>)
    e32a:	4798      	blx	r3
		free(i2c_hal_data[hal->bus_index]);
    e32c:	68fb      	ldr	r3, [r7, #12]
    e32e:	691a      	ldr	r2, [r3, #16]
    e330:	4b09      	ldr	r3, [pc, #36]	; (e358 <hal_i2c_release+0x70>)
    e332:	0092      	lsls	r2, r2, #2
    e334:	58d3      	ldr	r3, [r2, r3]
    e336:	0018      	movs	r0, r3
    e338:	4b09      	ldr	r3, [pc, #36]	; (e360 <hal_i2c_release+0x78>)
    e33a:	4798      	blx	r3
		i2c_hal_data[hal->bus_index] = NULL;
    e33c:	68fb      	ldr	r3, [r7, #12]
    e33e:	691a      	ldr	r2, [r3, #16]
    e340:	4b05      	ldr	r3, [pc, #20]	; (e358 <hal_i2c_release+0x70>)
    e342:	0092      	lsls	r2, r2, #2
    e344:	2100      	movs	r1, #0
    e346:	50d1      	str	r1, [r2, r3]
	}

	return ATCA_SUCCESS;
    e348:	2300      	movs	r3, #0
}
    e34a:	0018      	movs	r0, r3
    e34c:	46bd      	mov	sp, r7
    e34e:	b004      	add	sp, #16
    e350:	bd80      	pop	{r7, pc}
    e352:	46c0      	nop			; (mov r8, r8)
    e354:	200007ec 	.word	0x200007ec
    e358:	200014e0 	.word	0x200014e0
    e35c:	00003b3d 	.word	0x00003b3d
    e360:	000127b5 	.word	0x000127b5

0000e364 <atca_delay_us>:
 * These methods define the hardware abstraction layer for communicating with a CryptoAuth device
 *
   @{ */

void atca_delay_us(uint32_t delay)
{
    e364:	b5f0      	push	{r4, r5, r6, r7, lr}
    e366:	b085      	sub	sp, #20
    e368:	af00      	add	r7, sp, #0
    e36a:	60f8      	str	r0, [r7, #12]
	// use ASF supplied delay
	delay_us(delay);
    e36c:	68fb      	ldr	r3, [r7, #12]
    e36e:	001d      	movs	r5, r3
    e370:	2300      	movs	r3, #0
    e372:	001e      	movs	r6, r3
    e374:	2000      	movs	r0, #0
    e376:	4b11      	ldr	r3, [pc, #68]	; (e3bc <atca_delay_us+0x58>)
    e378:	4798      	blx	r3
    e37a:	0003      	movs	r3, r0
    e37c:	603b      	str	r3, [r7, #0]
    e37e:	2300      	movs	r3, #0
    e380:	607b      	str	r3, [r7, #4]
    e382:	4c0f      	ldr	r4, [pc, #60]	; (e3c0 <atca_delay_us+0x5c>)
    e384:	683a      	ldr	r2, [r7, #0]
    e386:	687b      	ldr	r3, [r7, #4]
    e388:	0028      	movs	r0, r5
    e38a:	0031      	movs	r1, r6
    e38c:	47a0      	blx	r4
    e38e:	0003      	movs	r3, r0
    e390:	000c      	movs	r4, r1
    e392:	0019      	movs	r1, r3
    e394:	0022      	movs	r2, r4
    e396:	4b0b      	ldr	r3, [pc, #44]	; (e3c4 <atca_delay_us+0x60>)
    e398:	2400      	movs	r4, #0
    e39a:	18c9      	adds	r1, r1, r3
    e39c:	4162      	adcs	r2, r4
    e39e:	0008      	movs	r0, r1
    e3a0:	0011      	movs	r1, r2
    e3a2:	4c09      	ldr	r4, [pc, #36]	; (e3c8 <atca_delay_us+0x64>)
    e3a4:	4a09      	ldr	r2, [pc, #36]	; (e3cc <atca_delay_us+0x68>)
    e3a6:	2300      	movs	r3, #0
    e3a8:	47a0      	blx	r4
    e3aa:	0003      	movs	r3, r0
    e3ac:	000c      	movs	r4, r1
    e3ae:	0018      	movs	r0, r3
    e3b0:	4b07      	ldr	r3, [pc, #28]	; (e3d0 <atca_delay_us+0x6c>)
    e3b2:	4798      	blx	r3
}
    e3b4:	46c0      	nop			; (mov r8, r8)
    e3b6:	46bd      	mov	sp, r7
    e3b8:	b005      	add	sp, #20
    e3ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e3bc:	00011b2d 	.word	0x00011b2d
    e3c0:	00012565 	.word	0x00012565
    e3c4:	006acfbf 	.word	0x006acfbf
    e3c8:	00012525 	.word	0x00012525
    e3cc:	006acfc0 	.word	0x006acfc0
    e3d0:	20000001 	.word	0x20000001

0000e3d4 <atca_delay_ms>:
 * \param[in] delay number of milliseconds to delay
 */

/* ASF already has delay_ms - see delay.h */
void atca_delay_ms(uint32_t delay)
{
    e3d4:	b5f0      	push	{r4, r5, r6, r7, lr}
    e3d6:	b085      	sub	sp, #20
    e3d8:	af00      	add	r7, sp, #0
    e3da:	60f8      	str	r0, [r7, #12]
	// use ASF supplied delay
	delay_ms(delay);
    e3dc:	68fb      	ldr	r3, [r7, #12]
    e3de:	001d      	movs	r5, r3
    e3e0:	2300      	movs	r3, #0
    e3e2:	001e      	movs	r6, r3
    e3e4:	2000      	movs	r0, #0
    e3e6:	4b11      	ldr	r3, [pc, #68]	; (e42c <atca_delay_ms+0x58>)
    e3e8:	4798      	blx	r3
    e3ea:	0003      	movs	r3, r0
    e3ec:	603b      	str	r3, [r7, #0]
    e3ee:	2300      	movs	r3, #0
    e3f0:	607b      	str	r3, [r7, #4]
    e3f2:	4c0f      	ldr	r4, [pc, #60]	; (e430 <atca_delay_ms+0x5c>)
    e3f4:	683a      	ldr	r2, [r7, #0]
    e3f6:	687b      	ldr	r3, [r7, #4]
    e3f8:	0028      	movs	r0, r5
    e3fa:	0031      	movs	r1, r6
    e3fc:	47a0      	blx	r4
    e3fe:	0003      	movs	r3, r0
    e400:	000c      	movs	r4, r1
    e402:	0019      	movs	r1, r3
    e404:	0022      	movs	r2, r4
    e406:	4b0b      	ldr	r3, [pc, #44]	; (e434 <atca_delay_ms+0x60>)
    e408:	2400      	movs	r4, #0
    e40a:	18c9      	adds	r1, r1, r3
    e40c:	4162      	adcs	r2, r4
    e40e:	0008      	movs	r0, r1
    e410:	0011      	movs	r1, r2
    e412:	4c09      	ldr	r4, [pc, #36]	; (e438 <atca_delay_ms+0x64>)
    e414:	4a09      	ldr	r2, [pc, #36]	; (e43c <atca_delay_ms+0x68>)
    e416:	2300      	movs	r3, #0
    e418:	47a0      	blx	r4
    e41a:	0003      	movs	r3, r0
    e41c:	000c      	movs	r4, r1
    e41e:	0018      	movs	r0, r3
    e420:	4b07      	ldr	r3, [pc, #28]	; (e440 <atca_delay_ms+0x6c>)
    e422:	4798      	blx	r3
}
    e424:	46c0      	nop			; (mov r8, r8)
    e426:	46bd      	mov	sp, r7
    e428:	b005      	add	sp, #20
    e42a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e42c:	00011b2d 	.word	0x00011b2d
    e430:	00012565 	.word	0x00012565
    e434:	00001b57 	.word	0x00001b57
    e438:	00012525 	.word	0x00012525
    e43c:	00001b58 	.word	0x00001b58
    e440:	20000001 	.word	0x20000001

0000e444 <atcah_nonce>:
   This function can also be used to fill in the nonce directly to TempKey (pass-through mode). The flags will automatically be set according to the mode used.
    \param[in, out] param pointer to parameter structure
    \return status of the operation
 */
ATCA_STATUS atcah_nonce(struct atca_nonce_in_out *param)
{
    e444:	b580      	push	{r7, lr}
    e446:	b092      	sub	sp, #72	; 0x48
    e448:	af00      	add	r7, sp, #0
    e44a:	6078      	str	r0, [r7, #4]
	uint8_t temporary[ATCA_MSG_SIZE_NONCE];
	uint8_t *p_temp;

	// Check parameters
	if (!param->temp_key || !param->num_in || (param->mode > NONCE_MODE_PASSTHROUGH) || (param->mode == NONCE_MODE_INVALID)
    e44c:	687b      	ldr	r3, [r7, #4]
    e44e:	68db      	ldr	r3, [r3, #12]
    e450:	2b00      	cmp	r3, #0
    e452:	d017      	beq.n	e484 <atcah_nonce+0x40>
    e454:	687b      	ldr	r3, [r7, #4]
    e456:	685b      	ldr	r3, [r3, #4]
    e458:	2b00      	cmp	r3, #0
    e45a:	d013      	beq.n	e484 <atcah_nonce+0x40>
    e45c:	687b      	ldr	r3, [r7, #4]
    e45e:	781b      	ldrb	r3, [r3, #0]
    e460:	2b03      	cmp	r3, #3
    e462:	d80f      	bhi.n	e484 <atcah_nonce+0x40>
    e464:	687b      	ldr	r3, [r7, #4]
    e466:	781b      	ldrb	r3, [r3, #0]
    e468:	2b02      	cmp	r3, #2
    e46a:	d00b      	beq.n	e484 <atcah_nonce+0x40>
	    || (((param->mode == NONCE_MODE_SEED_UPDATE || (param->mode == NONCE_MODE_NO_SEED_UPDATE)) && !param->rand_out)))
    e46c:	687b      	ldr	r3, [r7, #4]
    e46e:	781b      	ldrb	r3, [r3, #0]
    e470:	2b00      	cmp	r3, #0
    e472:	d003      	beq.n	e47c <atcah_nonce+0x38>
    e474:	687b      	ldr	r3, [r7, #4]
    e476:	781b      	ldrb	r3, [r3, #0]
    e478:	2b01      	cmp	r3, #1
    e47a:	d105      	bne.n	e488 <atcah_nonce+0x44>
    e47c:	687b      	ldr	r3, [r7, #4]
    e47e:	689b      	ldr	r3, [r3, #8]
    e480:	2b00      	cmp	r3, #0
    e482:	d101      	bne.n	e488 <atcah_nonce+0x44>
		return ATCA_BAD_PARAM;
    e484:	23e2      	movs	r3, #226	; 0xe2
    e486:	e071      	b.n	e56c <atcah_nonce+0x128>

	// Calculate or pass-through the nonce to TempKey->Value
	if ((param->mode == NONCE_MODE_SEED_UPDATE) || (param->mode == NONCE_MODE_NO_SEED_UPDATE)) {
    e488:	687b      	ldr	r3, [r7, #4]
    e48a:	781b      	ldrb	r3, [r3, #0]
    e48c:	2b00      	cmp	r3, #0
    e48e:	d003      	beq.n	e498 <atcah_nonce+0x54>
    e490:	687b      	ldr	r3, [r7, #4]
    e492:	781b      	ldrb	r3, [r3, #0]
    e494:	2b01      	cmp	r3, #1
    e496:	d137      	bne.n	e508 <atcah_nonce+0xc4>
		// Calculate nonce using SHA-256 (refer to data sheet)
		p_temp = temporary;
    e498:	230c      	movs	r3, #12
    e49a:	18fb      	adds	r3, r7, r3
    e49c:	647b      	str	r3, [r7, #68]	; 0x44

		memcpy(p_temp, param->rand_out, NONCE_RSP_SIZE_LONG - ATCA_PACKET_OVERHEAD);
    e49e:	687b      	ldr	r3, [r7, #4]
    e4a0:	6899      	ldr	r1, [r3, #8]
    e4a2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    e4a4:	2220      	movs	r2, #32
    e4a6:	0018      	movs	r0, r3
    e4a8:	4b32      	ldr	r3, [pc, #200]	; (e574 <atcah_nonce+0x130>)
    e4aa:	4798      	blx	r3
		p_temp += NONCE_RSP_SIZE_LONG - ATCA_PACKET_OVERHEAD;
    e4ac:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    e4ae:	3320      	adds	r3, #32
    e4b0:	647b      	str	r3, [r7, #68]	; 0x44

		memcpy(p_temp, param->num_in, NONCE_NUMIN_SIZE);
    e4b2:	687b      	ldr	r3, [r7, #4]
    e4b4:	6859      	ldr	r1, [r3, #4]
    e4b6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    e4b8:	2214      	movs	r2, #20
    e4ba:	0018      	movs	r0, r3
    e4bc:	4b2d      	ldr	r3, [pc, #180]	; (e574 <atcah_nonce+0x130>)
    e4be:	4798      	blx	r3
		p_temp += NONCE_NUMIN_SIZE;
    e4c0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    e4c2:	3314      	adds	r3, #20
    e4c4:	647b      	str	r3, [r7, #68]	; 0x44

		*p_temp++ = ATCA_NONCE;
    e4c6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    e4c8:	1c5a      	adds	r2, r3, #1
    e4ca:	647a      	str	r2, [r7, #68]	; 0x44
    e4cc:	2216      	movs	r2, #22
    e4ce:	701a      	strb	r2, [r3, #0]
		*p_temp++ = param->mode;
    e4d0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    e4d2:	1c5a      	adds	r2, r3, #1
    e4d4:	647a      	str	r2, [r7, #68]	; 0x44
    e4d6:	687a      	ldr	r2, [r7, #4]
    e4d8:	7812      	ldrb	r2, [r2, #0]
    e4da:	701a      	strb	r2, [r3, #0]
		*p_temp++ = 0x00;
    e4dc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    e4de:	1c5a      	adds	r2, r3, #1
    e4e0:	647a      	str	r2, [r7, #68]	; 0x44
    e4e2:	2200      	movs	r2, #0
    e4e4:	701a      	strb	r2, [r3, #0]

		// Calculate SHA256 to get the nonce
		atcah_sha256(ATCA_MSG_SIZE_NONCE, temporary, param->temp_key->value);
    e4e6:	687b      	ldr	r3, [r7, #4]
    e4e8:	68db      	ldr	r3, [r3, #12]
    e4ea:	001a      	movs	r2, r3
    e4ec:	230c      	movs	r3, #12
    e4ee:	18fb      	adds	r3, r7, r3
    e4f0:	0019      	movs	r1, r3
    e4f2:	2037      	movs	r0, #55	; 0x37
    e4f4:	4b20      	ldr	r3, [pc, #128]	; (e578 <atcah_nonce+0x134>)
    e4f6:	4798      	blx	r3

		// Update TempKey->SourceFlag to 0 (random)
		param->temp_key->source_flag = 0;
    e4f8:	687b      	ldr	r3, [r7, #4]
    e4fa:	68db      	ldr	r3, [r3, #12]
    e4fc:	2220      	movs	r2, #32
    e4fe:	5c99      	ldrb	r1, [r3, r2]
    e500:	2010      	movs	r0, #16
    e502:	4381      	bics	r1, r0
    e504:	5499      	strb	r1, [r3, r2]
    e506:	e013      	b.n	e530 <atcah_nonce+0xec>
	}else if (param->mode == NONCE_MODE_PASSTHROUGH) {
    e508:	687b      	ldr	r3, [r7, #4]
    e50a:	781b      	ldrb	r3, [r3, #0]
    e50c:	2b03      	cmp	r3, #3
    e50e:	d10f      	bne.n	e530 <atcah_nonce+0xec>
		// Pass-through mode
		memcpy(param->temp_key->value, param->num_in, NONCE_NUMIN_SIZE_PASSTHROUGH);
    e510:	687b      	ldr	r3, [r7, #4]
    e512:	68db      	ldr	r3, [r3, #12]
    e514:	0018      	movs	r0, r3
    e516:	687b      	ldr	r3, [r7, #4]
    e518:	685b      	ldr	r3, [r3, #4]
    e51a:	2220      	movs	r2, #32
    e51c:	0019      	movs	r1, r3
    e51e:	4b15      	ldr	r3, [pc, #84]	; (e574 <atcah_nonce+0x130>)
    e520:	4798      	blx	r3

		// Update TempKey->SourceFlag to 1 (not random)
		param->temp_key->source_flag = 1;
    e522:	687b      	ldr	r3, [r7, #4]
    e524:	68db      	ldr	r3, [r3, #12]
    e526:	2220      	movs	r2, #32
    e528:	5c99      	ldrb	r1, [r3, r2]
    e52a:	2010      	movs	r0, #16
    e52c:	4301      	orrs	r1, r0
    e52e:	5499      	strb	r1, [r3, r2]
	}

	// Update TempKey fields
	param->temp_key->key_id = 0;
    e530:	687b      	ldr	r3, [r7, #4]
    e532:	68db      	ldr	r3, [r3, #12]
    e534:	2220      	movs	r2, #32
    e536:	5c99      	ldrb	r1, [r3, r2]
    e538:	200f      	movs	r0, #15
    e53a:	4381      	bics	r1, r0
    e53c:	5499      	strb	r1, [r3, r2]
	param->temp_key->gen_data = 0;
    e53e:	687b      	ldr	r3, [r7, #4]
    e540:	68db      	ldr	r3, [r3, #12]
    e542:	2220      	movs	r2, #32
    e544:	5c99      	ldrb	r1, [r3, r2]
    e546:	2020      	movs	r0, #32
    e548:	4381      	bics	r1, r0
    e54a:	5499      	strb	r1, [r3, r2]
	param->temp_key->check_flag = 0;
    e54c:	687b      	ldr	r3, [r7, #4]
    e54e:	68db      	ldr	r3, [r3, #12]
    e550:	2220      	movs	r2, #32
    e552:	5c99      	ldrb	r1, [r3, r2]
    e554:	2040      	movs	r0, #64	; 0x40
    e556:	4381      	bics	r1, r0
    e558:	5499      	strb	r1, [r3, r2]
	param->temp_key->valid = 1;
    e55a:	687b      	ldr	r3, [r7, #4]
    e55c:	68db      	ldr	r3, [r3, #12]
    e55e:	2220      	movs	r2, #32
    e560:	5c99      	ldrb	r1, [r3, r2]
    e562:	2080      	movs	r0, #128	; 0x80
    e564:	4240      	negs	r0, r0
    e566:	4301      	orrs	r1, r0
    e568:	5499      	strb	r1, [r3, r2]

	return ATCA_SUCCESS;
    e56a:	2300      	movs	r3, #0
}
    e56c:	0018      	movs	r0, r3
    e56e:	46bd      	mov	sp, r7
    e570:	b012      	add	sp, #72	; 0x48
    e572:	bd80      	pop	{r7, pc}
    e574:	000127e7 	.word	0x000127e7
    e578:	0000e97d 	.word	0x0000e97d

0000e57c <atcah_gen_dig>:

 * \param[in, out] param pointer to parameter structure
 * \return status of the operation
 */
ATCA_STATUS atcah_gen_dig(struct atca_gen_dig_in_out *param)
{
    e57c:	b590      	push	{r4, r7, lr}
    e57e:	b09d      	sub	sp, #116	; 0x74
    e580:	af00      	add	r7, sp, #0
    e582:	6078      	str	r0, [r7, #4]
	uint8_t temporary[ATCA_MSG_SIZE_GEN_DIG];
	uint8_t *p_temp;

	// Check parameters
	if (!param->stored_value || !param->temp_key
    e584:	687b      	ldr	r3, [r7, #4]
    e586:	685b      	ldr	r3, [r3, #4]
    e588:	2b00      	cmp	r3, #0
    e58a:	d00f      	beq.n	e5ac <atcah_gen_dig+0x30>
    e58c:	687b      	ldr	r3, [r7, #4]
    e58e:	689b      	ldr	r3, [r3, #8]
    e590:	2b00      	cmp	r3, #0
    e592:	d00b      	beq.n	e5ac <atcah_gen_dig+0x30>
	    || ((param->zone != GENDIG_ZONE_OTP)
    e594:	687b      	ldr	r3, [r7, #4]
    e596:	781b      	ldrb	r3, [r3, #0]
    e598:	2b01      	cmp	r3, #1
    e59a:	d009      	beq.n	e5b0 <atcah_gen_dig+0x34>
	        && (param->zone != GENDIG_ZONE_DATA)
    e59c:	687b      	ldr	r3, [r7, #4]
    e59e:	781b      	ldrb	r3, [r3, #0]
    e5a0:	2b02      	cmp	r3, #2
    e5a2:	d005      	beq.n	e5b0 <atcah_gen_dig+0x34>
	        && (param->zone != GENDIG_ZONE_CONFIG))
    e5a4:	687b      	ldr	r3, [r7, #4]
    e5a6:	781b      	ldrb	r3, [r3, #0]
    e5a8:	2b00      	cmp	r3, #0
    e5aa:	d001      	beq.n	e5b0 <atcah_gen_dig+0x34>
	    )
		return ATCA_BAD_PARAM;
    e5ac:	23e2      	movs	r3, #226	; 0xe2
    e5ae:	e0a6      	b.n	e6fe <atcah_gen_dig+0x182>

	// Check TempKey fields validity (TempKey is always used)
	if ( // TempKey.CheckFlag must be 0 and TempKey.Valid must be 1
	    param->temp_key->check_flag || (param->temp_key->valid != 1)
    e5b0:	687b      	ldr	r3, [r7, #4]
    e5b2:	689b      	ldr	r3, [r3, #8]
    e5b4:	2220      	movs	r2, #32
    e5b6:	5c9b      	ldrb	r3, [r3, r2]
    e5b8:	2240      	movs	r2, #64	; 0x40
    e5ba:	4013      	ands	r3, r2
    e5bc:	b2db      	uxtb	r3, r3
	        && (param->zone != GENDIG_ZONE_CONFIG))
	    )
		return ATCA_BAD_PARAM;

	// Check TempKey fields validity (TempKey is always used)
	if ( // TempKey.CheckFlag must be 0 and TempKey.Valid must be 1
    e5be:	2b00      	cmp	r3, #0
    e5c0:	d108      	bne.n	e5d4 <atcah_gen_dig+0x58>
	    param->temp_key->check_flag || (param->temp_key->valid != 1)
    e5c2:	687b      	ldr	r3, [r7, #4]
    e5c4:	689b      	ldr	r3, [r3, #8]
    e5c6:	2220      	movs	r2, #32
    e5c8:	5c9b      	ldrb	r3, [r3, r2]
    e5ca:	227f      	movs	r2, #127	; 0x7f
    e5cc:	4393      	bics	r3, r2
    e5ce:	b2db      	uxtb	r3, r3
    e5d0:	2b00      	cmp	r3, #0
    e5d2:	d108      	bne.n	e5e6 <atcah_gen_dig+0x6a>
	    ) {
		// Invalidate TempKey, then return
		param->temp_key->valid = 0;
    e5d4:	687b      	ldr	r3, [r7, #4]
    e5d6:	689b      	ldr	r3, [r3, #8]
    e5d8:	2220      	movs	r2, #32
    e5da:	5c99      	ldrb	r1, [r3, r2]
    e5dc:	207f      	movs	r0, #127	; 0x7f
    e5de:	4001      	ands	r1, r0
    e5e0:	5499      	strb	r1, [r3, r2]
		return ATCA_EXECUTION_ERROR;
    e5e2:	23f4      	movs	r3, #244	; 0xf4
    e5e4:	e08b      	b.n	e6fe <atcah_gen_dig+0x182>
	}

	// Start calculation
	p_temp = temporary;
    e5e6:	230c      	movs	r3, #12
    e5e8:	18fb      	adds	r3, r7, r3
    e5ea:	66fb      	str	r3, [r7, #108]	; 0x6c

	// (1) 32 bytes inputKey
	//     (Config[KeyID] or OTP[KeyID] or Data.slot[KeyID] or TransportKey[KeyID])
	memcpy(p_temp, param->stored_value, ATCA_KEY_SIZE);
    e5ec:	687b      	ldr	r3, [r7, #4]
    e5ee:	6859      	ldr	r1, [r3, #4]
    e5f0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    e5f2:	2220      	movs	r2, #32
    e5f4:	0018      	movs	r0, r3
    e5f6:	4b44      	ldr	r3, [pc, #272]	; (e708 <atcah_gen_dig+0x18c>)
    e5f8:	4798      	blx	r3
	p_temp += ATCA_KEY_SIZE;
    e5fa:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    e5fc:	3320      	adds	r3, #32
    e5fe:	66fb      	str	r3, [r7, #108]	; 0x6c

	// (2) 1 byte Opcode
	*p_temp++ = ATCA_GENDIG;
    e600:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    e602:	1c5a      	adds	r2, r3, #1
    e604:	66fa      	str	r2, [r7, #108]	; 0x6c
    e606:	2215      	movs	r2, #21
    e608:	701a      	strb	r2, [r3, #0]

	// (3) 1 byte Param1 (zone)
	*p_temp++ = param->zone;
    e60a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    e60c:	1c5a      	adds	r2, r3, #1
    e60e:	66fa      	str	r2, [r7, #108]	; 0x6c
    e610:	687a      	ldr	r2, [r7, #4]
    e612:	7812      	ldrb	r2, [r2, #0]
    e614:	701a      	strb	r2, [r3, #0]

	// (4) 2 bytes Param2 (keyID)
	*p_temp++ = param->key_id & 0xFF;
    e616:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    e618:	1c5a      	adds	r2, r3, #1
    e61a:	66fa      	str	r2, [r7, #108]	; 0x6c
    e61c:	687a      	ldr	r2, [r7, #4]
    e61e:	8852      	ldrh	r2, [r2, #2]
    e620:	b2d2      	uxtb	r2, r2
    e622:	701a      	strb	r2, [r3, #0]
	*p_temp++ = (param->key_id >> 8) & 0xFF;
    e624:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    e626:	1c5a      	adds	r2, r3, #1
    e628:	66fa      	str	r2, [r7, #108]	; 0x6c
    e62a:	687a      	ldr	r2, [r7, #4]
    e62c:	8852      	ldrh	r2, [r2, #2]
    e62e:	0a12      	lsrs	r2, r2, #8
    e630:	b292      	uxth	r2, r2
    e632:	b2d2      	uxtb	r2, r2
    e634:	701a      	strb	r2, [r3, #0]

	// (5) 1 byte SN[8] = 0xEE
	*p_temp++ = ATCA_SN_8;
    e636:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    e638:	1c5a      	adds	r2, r3, #1
    e63a:	66fa      	str	r2, [r7, #108]	; 0x6c
    e63c:	22ee      	movs	r2, #238	; 0xee
    e63e:	701a      	strb	r2, [r3, #0]

	// (6) 2 bytes SN[0:1] = 0x0123
	*p_temp++ = ATCA_SN_0;
    e640:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    e642:	1c5a      	adds	r2, r3, #1
    e644:	66fa      	str	r2, [r7, #108]	; 0x6c
    e646:	2201      	movs	r2, #1
    e648:	701a      	strb	r2, [r3, #0]
	*p_temp++ = ATCA_SN_1;
    e64a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    e64c:	1c5a      	adds	r2, r3, #1
    e64e:	66fa      	str	r2, [r7, #108]	; 0x6c
    e650:	2223      	movs	r2, #35	; 0x23
    e652:	701a      	strb	r2, [r3, #0]

	// (7) 25 zeros
	memset(p_temp, 0, ATCA_GENDIG_ZEROS_SIZE);
    e654:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    e656:	2219      	movs	r2, #25
    e658:	2100      	movs	r1, #0
    e65a:	0018      	movs	r0, r3
    e65c:	4b2b      	ldr	r3, [pc, #172]	; (e70c <atcah_gen_dig+0x190>)
    e65e:	4798      	blx	r3
	p_temp += ATCA_GENDIG_ZEROS_SIZE;
    e660:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    e662:	3319      	adds	r3, #25
    e664:	66fb      	str	r3, [r7, #108]	; 0x6c

	// (8) 32 bytes TempKey
	memcpy(p_temp, param->temp_key->value, ATCA_KEY_SIZE);
    e666:	687b      	ldr	r3, [r7, #4]
    e668:	689b      	ldr	r3, [r3, #8]
    e66a:	0019      	movs	r1, r3
    e66c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    e66e:	2220      	movs	r2, #32
    e670:	0018      	movs	r0, r3
    e672:	4b25      	ldr	r3, [pc, #148]	; (e708 <atcah_gen_dig+0x18c>)
    e674:	4798      	blx	r3

	// Calculate SHA256 to get the new TempKey
	atcah_sha256(ATCA_MSG_SIZE_GEN_DIG, temporary, param->temp_key->value);
    e676:	687b      	ldr	r3, [r7, #4]
    e678:	689b      	ldr	r3, [r3, #8]
    e67a:	001a      	movs	r2, r3
    e67c:	230c      	movs	r3, #12
    e67e:	18fb      	adds	r3, r7, r3
    e680:	0019      	movs	r1, r3
    e682:	2060      	movs	r0, #96	; 0x60
    e684:	4b22      	ldr	r3, [pc, #136]	; (e710 <atcah_gen_dig+0x194>)
    e686:	4798      	blx	r3

	// Update TempKey fields
	param->temp_key->valid = 1;
    e688:	687b      	ldr	r3, [r7, #4]
    e68a:	689b      	ldr	r3, [r3, #8]
    e68c:	2220      	movs	r2, #32
    e68e:	5c99      	ldrb	r1, [r3, r2]
    e690:	2080      	movs	r0, #128	; 0x80
    e692:	4240      	negs	r0, r0
    e694:	4301      	orrs	r1, r0
    e696:	5499      	strb	r1, [r3, r2]

	if ((param->zone == GENDIG_ZONE_DATA) && (param->key_id <= 15)) {
    e698:	687b      	ldr	r3, [r7, #4]
    e69a:	781b      	ldrb	r3, [r3, #0]
    e69c:	2b02      	cmp	r3, #2
    e69e:	d11f      	bne.n	e6e0 <atcah_gen_dig+0x164>
    e6a0:	687b      	ldr	r3, [r7, #4]
    e6a2:	885b      	ldrh	r3, [r3, #2]
    e6a4:	2b0f      	cmp	r3, #15
    e6a6:	d81b      	bhi.n	e6e0 <atcah_gen_dig+0x164>
		param->temp_key->gen_data = 1;
    e6a8:	687b      	ldr	r3, [r7, #4]
    e6aa:	689b      	ldr	r3, [r3, #8]
    e6ac:	2220      	movs	r2, #32
    e6ae:	5c99      	ldrb	r1, [r3, r2]
    e6b0:	2020      	movs	r0, #32
    e6b2:	4301      	orrs	r1, r0
    e6b4:	5499      	strb	r1, [r3, r2]
		param->temp_key->key_id = (param->key_id & 0xF);    // mask lower 4-bit only
    e6b6:	687b      	ldr	r3, [r7, #4]
    e6b8:	689b      	ldr	r3, [r3, #8]
    e6ba:	687a      	ldr	r2, [r7, #4]
    e6bc:	8852      	ldrh	r2, [r2, #2]
    e6be:	b2d2      	uxtb	r2, r2
    e6c0:	1c11      	adds	r1, r2, #0
    e6c2:	220f      	movs	r2, #15
    e6c4:	400a      	ands	r2, r1
    e6c6:	b2d1      	uxtb	r1, r2
    e6c8:	2220      	movs	r2, #32
    e6ca:	200f      	movs	r0, #15
    e6cc:	4001      	ands	r1, r0
    e6ce:	000c      	movs	r4, r1
    e6d0:	5c99      	ldrb	r1, [r3, r2]
    e6d2:	200f      	movs	r0, #15
    e6d4:	4381      	bics	r1, r0
    e6d6:	1c08      	adds	r0, r1, #0
    e6d8:	1c21      	adds	r1, r4, #0
    e6da:	4301      	orrs	r1, r0
    e6dc:	5499      	strb	r1, [r3, r2]
    e6de:	e00d      	b.n	e6fc <atcah_gen_dig+0x180>
	}else {
		param->temp_key->gen_data = 0;
    e6e0:	687b      	ldr	r3, [r7, #4]
    e6e2:	689b      	ldr	r3, [r3, #8]
    e6e4:	2220      	movs	r2, #32
    e6e6:	5c99      	ldrb	r1, [r3, r2]
    e6e8:	2020      	movs	r0, #32
    e6ea:	4381      	bics	r1, r0
    e6ec:	5499      	strb	r1, [r3, r2]
		param->temp_key->key_id = 0;
    e6ee:	687b      	ldr	r3, [r7, #4]
    e6f0:	689b      	ldr	r3, [r3, #8]
    e6f2:	2220      	movs	r2, #32
    e6f4:	5c99      	ldrb	r1, [r3, r2]
    e6f6:	200f      	movs	r0, #15
    e6f8:	4381      	bics	r1, r0
    e6fa:	5499      	strb	r1, [r3, r2]
	}

	return ATCA_SUCCESS;
    e6fc:	2300      	movs	r3, #0
}
    e6fe:	0018      	movs	r0, r3
    e700:	46bd      	mov	sp, r7
    e702:	b01d      	add	sp, #116	; 0x74
    e704:	bd90      	pop	{r4, r7, pc}
    e706:	46c0      	nop			; (mov r8, r8)
    e708:	000127e7 	.word	0x000127e7
    e70c:	00012823 	.word	0x00012823
    e710:	0000e97d 	.word	0x0000e97d

0000e714 <atcah_privwrite_auth_mac>:

 * \param[in, out] param pointer to parameter structure
 * \return status of the operation
 */
ATCA_STATUS atcah_privwrite_auth_mac(struct atca_write_mac_in_out *param)
{
    e714:	b580      	push	{r7, lr}
    e716:	b0a4      	sub	sp, #144	; 0x90
    e718:	af00      	add	r7, sp, #0
    e71a:	6078      	str	r0, [r7, #4]
	uint8_t i;
	uint8_t *p_temp;
	uint8_t session_key2[32];

	// Check parameters
	if (!param->input_data || !param->temp_key)
    e71c:	687b      	ldr	r3, [r7, #4]
    e71e:	689b      	ldr	r3, [r3, #8]
    e720:	2b00      	cmp	r3, #0
    e722:	d003      	beq.n	e72c <atcah_privwrite_auth_mac+0x18>
    e724:	687b      	ldr	r3, [r7, #4]
    e726:	695b      	ldr	r3, [r3, #20]
    e728:	2b00      	cmp	r3, #0
    e72a:	d101      	bne.n	e730 <atcah_privwrite_auth_mac+0x1c>
		return ATCA_BAD_PARAM;
    e72c:	23e2      	movs	r3, #226	; 0xe2
    e72e:	e11b      	b.n	e968 <atcah_privwrite_auth_mac+0x254>

	// Check TempKey fields validity (TempKey is always used)
	if ( // TempKey.CheckFlag must be 0 and TempKey.Valid must be 1
	    param->temp_key->check_flag || (param->temp_key->valid != 1)
    e730:	687b      	ldr	r3, [r7, #4]
    e732:	695b      	ldr	r3, [r3, #20]
    e734:	2220      	movs	r2, #32
    e736:	5c9b      	ldrb	r3, [r3, r2]
    e738:	2240      	movs	r2, #64	; 0x40
    e73a:	4013      	ands	r3, r2
    e73c:	b2db      	uxtb	r3, r3
	// Check parameters
	if (!param->input_data || !param->temp_key)
		return ATCA_BAD_PARAM;

	// Check TempKey fields validity (TempKey is always used)
	if ( // TempKey.CheckFlag must be 0 and TempKey.Valid must be 1
    e73e:	2b00      	cmp	r3, #0
    e740:	d108      	bne.n	e754 <atcah_privwrite_auth_mac+0x40>
	    param->temp_key->check_flag || (param->temp_key->valid != 1)
    e742:	687b      	ldr	r3, [r7, #4]
    e744:	695b      	ldr	r3, [r3, #20]
    e746:	2220      	movs	r2, #32
    e748:	5c9b      	ldrb	r3, [r3, r2]
    e74a:	227f      	movs	r2, #127	; 0x7f
    e74c:	4393      	bics	r3, r2
    e74e:	b2db      	uxtb	r3, r3
    e750:	2b00      	cmp	r3, #0
    e752:	d108      	bne.n	e766 <atcah_privwrite_auth_mac+0x52>
	    ) {
		// Invalidate TempKey, then return
		param->temp_key->valid = 0;
    e754:	687b      	ldr	r3, [r7, #4]
    e756:	695b      	ldr	r3, [r3, #20]
    e758:	2220      	movs	r2, #32
    e75a:	5c99      	ldrb	r1, [r3, r2]
    e75c:	207f      	movs	r0, #127	; 0x7f
    e75e:	4001      	ands	r1, r0
    e760:	5499      	strb	r1, [r3, r2]
		return ATCA_EXECUTION_ERROR;
    e762:	23f4      	movs	r3, #244	; 0xf4
    e764:	e100      	b.n	e968 <atcah_privwrite_auth_mac+0x254>

	/* Encrypt by XOR-ing Data with the TempKey
	 */

	// Encrypt the first 4 bytes of the cipher text, which should be 0s
	for (i = 0; i < 4; i++)
    e766:	238f      	movs	r3, #143	; 0x8f
    e768:	18fb      	adds	r3, r7, r3
    e76a:	2200      	movs	r2, #0
    e76c:	701a      	strb	r2, [r3, #0]
    e76e:	e013      	b.n	e798 <atcah_privwrite_auth_mac+0x84>
		param->encrypted_data[i] = 0 ^ param->temp_key->value[i];
    e770:	687b      	ldr	r3, [r7, #4]
    e772:	68da      	ldr	r2, [r3, #12]
    e774:	238f      	movs	r3, #143	; 0x8f
    e776:	18fb      	adds	r3, r7, r3
    e778:	781b      	ldrb	r3, [r3, #0]
    e77a:	18d2      	adds	r2, r2, r3
    e77c:	687b      	ldr	r3, [r7, #4]
    e77e:	6959      	ldr	r1, [r3, #20]
    e780:	238f      	movs	r3, #143	; 0x8f
    e782:	18fb      	adds	r3, r7, r3
    e784:	781b      	ldrb	r3, [r3, #0]
    e786:	5ccb      	ldrb	r3, [r1, r3]
    e788:	7013      	strb	r3, [r2, #0]

	/* Encrypt by XOR-ing Data with the TempKey
	 */

	// Encrypt the first 4 bytes of the cipher text, which should be 0s
	for (i = 0; i < 4; i++)
    e78a:	238f      	movs	r3, #143	; 0x8f
    e78c:	18fb      	adds	r3, r7, r3
    e78e:	781a      	ldrb	r2, [r3, #0]
    e790:	238f      	movs	r3, #143	; 0x8f
    e792:	18fb      	adds	r3, r7, r3
    e794:	3201      	adds	r2, #1
    e796:	701a      	strb	r2, [r3, #0]
    e798:	238f      	movs	r3, #143	; 0x8f
    e79a:	18fb      	adds	r3, r7, r3
    e79c:	781b      	ldrb	r3, [r3, #0]
    e79e:	2b03      	cmp	r3, #3
    e7a0:	d9e6      	bls.n	e770 <atcah_privwrite_auth_mac+0x5c>
		param->encrypted_data[i] = 0 ^ param->temp_key->value[i];

	// Encrypt the next 28 bytes of the cipher text, which is the first part of the private key.
	for (i = 4; i < 32; i++)
    e7a2:	238f      	movs	r3, #143	; 0x8f
    e7a4:	18fb      	adds	r3, r7, r3
    e7a6:	2204      	movs	r2, #4
    e7a8:	701a      	strb	r2, [r3, #0]
    e7aa:	e01d      	b.n	e7e8 <atcah_privwrite_auth_mac+0xd4>
		param->encrypted_data[i] = param->encryption_key[i - 4] ^ param->temp_key->value[i];
    e7ac:	687b      	ldr	r3, [r7, #4]
    e7ae:	68da      	ldr	r2, [r3, #12]
    e7b0:	238f      	movs	r3, #143	; 0x8f
    e7b2:	18fb      	adds	r3, r7, r3
    e7b4:	781b      	ldrb	r3, [r3, #0]
    e7b6:	18d2      	adds	r2, r2, r3
    e7b8:	687b      	ldr	r3, [r7, #4]
    e7ba:	6859      	ldr	r1, [r3, #4]
    e7bc:	238f      	movs	r3, #143	; 0x8f
    e7be:	18fb      	adds	r3, r7, r3
    e7c0:	781b      	ldrb	r3, [r3, #0]
    e7c2:	3b04      	subs	r3, #4
    e7c4:	18cb      	adds	r3, r1, r3
    e7c6:	7819      	ldrb	r1, [r3, #0]
    e7c8:	687b      	ldr	r3, [r7, #4]
    e7ca:	6958      	ldr	r0, [r3, #20]
    e7cc:	238f      	movs	r3, #143	; 0x8f
    e7ce:	18fb      	adds	r3, r7, r3
    e7d0:	781b      	ldrb	r3, [r3, #0]
    e7d2:	5cc3      	ldrb	r3, [r0, r3]
    e7d4:	404b      	eors	r3, r1
    e7d6:	b2db      	uxtb	r3, r3
    e7d8:	7013      	strb	r3, [r2, #0]
	// Encrypt the first 4 bytes of the cipher text, which should be 0s
	for (i = 0; i < 4; i++)
		param->encrypted_data[i] = 0 ^ param->temp_key->value[i];

	// Encrypt the next 28 bytes of the cipher text, which is the first part of the private key.
	for (i = 4; i < 32; i++)
    e7da:	238f      	movs	r3, #143	; 0x8f
    e7dc:	18fb      	adds	r3, r7, r3
    e7de:	781a      	ldrb	r2, [r3, #0]
    e7e0:	238f      	movs	r3, #143	; 0x8f
    e7e2:	18fb      	adds	r3, r7, r3
    e7e4:	3201      	adds	r2, #1
    e7e6:	701a      	strb	r2, [r3, #0]
    e7e8:	238f      	movs	r3, #143	; 0x8f
    e7ea:	18fb      	adds	r3, r7, r3
    e7ec:	781b      	ldrb	r3, [r3, #0]
    e7ee:	2b1f      	cmp	r3, #31
    e7f0:	d9dc      	bls.n	e7ac <atcah_privwrite_auth_mac+0x98>
		param->encrypted_data[i] = param->encryption_key[i - 4] ^ param->temp_key->value[i];

	// Calculate the new key for the last 4 bytes of the cipher text
	atcah_sha256(32, param->temp_key->value, session_key2);
    e7f2:	687b      	ldr	r3, [r7, #4]
    e7f4:	695b      	ldr	r3, [r3, #20]
    e7f6:	0019      	movs	r1, r3
    e7f8:	2308      	movs	r3, #8
    e7fa:	18fb      	adds	r3, r7, r3
    e7fc:	001a      	movs	r2, r3
    e7fe:	2020      	movs	r0, #32
    e800:	4b5b      	ldr	r3, [pc, #364]	; (e970 <atcah_privwrite_auth_mac+0x25c>)
    e802:	4798      	blx	r3

	// Encrypt the last 4 bytes of the cipher text, which is the remaining part of the private key
	for (i = 32; i < 36; i++)
    e804:	238f      	movs	r3, #143	; 0x8f
    e806:	18fb      	adds	r3, r7, r3
    e808:	2220      	movs	r2, #32
    e80a:	701a      	strb	r2, [r3, #0]
    e80c:	e01e      	b.n	e84c <atcah_privwrite_auth_mac+0x138>
		param->encrypted_data[i] = param->encryption_key[i - 4] ^ session_key2[i - 32];
    e80e:	687b      	ldr	r3, [r7, #4]
    e810:	68da      	ldr	r2, [r3, #12]
    e812:	238f      	movs	r3, #143	; 0x8f
    e814:	18fb      	adds	r3, r7, r3
    e816:	781b      	ldrb	r3, [r3, #0]
    e818:	18d2      	adds	r2, r2, r3
    e81a:	687b      	ldr	r3, [r7, #4]
    e81c:	6859      	ldr	r1, [r3, #4]
    e81e:	238f      	movs	r3, #143	; 0x8f
    e820:	18fb      	adds	r3, r7, r3
    e822:	781b      	ldrb	r3, [r3, #0]
    e824:	3b04      	subs	r3, #4
    e826:	18cb      	adds	r3, r1, r3
    e828:	7819      	ldrb	r1, [r3, #0]
    e82a:	238f      	movs	r3, #143	; 0x8f
    e82c:	18fb      	adds	r3, r7, r3
    e82e:	781b      	ldrb	r3, [r3, #0]
    e830:	3b20      	subs	r3, #32
    e832:	2008      	movs	r0, #8
    e834:	1838      	adds	r0, r7, r0
    e836:	5cc3      	ldrb	r3, [r0, r3]
    e838:	404b      	eors	r3, r1
    e83a:	b2db      	uxtb	r3, r3
    e83c:	7013      	strb	r3, [r2, #0]

	// Calculate the new key for the last 4 bytes of the cipher text
	atcah_sha256(32, param->temp_key->value, session_key2);

	// Encrypt the last 4 bytes of the cipher text, which is the remaining part of the private key
	for (i = 32; i < 36; i++)
    e83e:	238f      	movs	r3, #143	; 0x8f
    e840:	18fb      	adds	r3, r7, r3
    e842:	781a      	ldrb	r2, [r3, #0]
    e844:	238f      	movs	r3, #143	; 0x8f
    e846:	18fb      	adds	r3, r7, r3
    e848:	3201      	adds	r2, #1
    e84a:	701a      	strb	r2, [r3, #0]
    e84c:	238f      	movs	r3, #143	; 0x8f
    e84e:	18fb      	adds	r3, r7, r3
    e850:	781b      	ldrb	r3, [r3, #0]
    e852:	2b23      	cmp	r3, #35	; 0x23
    e854:	d9db      	bls.n	e80e <atcah_privwrite_auth_mac+0xfa>
		param->encrypted_data[i] = param->encryption_key[i - 4] ^ session_key2[i - 32];

	// If the pointer *mac is provided by the caller then calculate input MAC
	if (param->auth_mac) {
    e856:	687b      	ldr	r3, [r7, #4]
    e858:	691b      	ldr	r3, [r3, #16]
    e85a:	2b00      	cmp	r3, #0
    e85c:	d07b      	beq.n	e956 <atcah_privwrite_auth_mac+0x242>
		// Start calculation
		p_temp = temporary;
    e85e:	2328      	movs	r3, #40	; 0x28
    e860:	18fb      	adds	r3, r7, r3
    e862:	2288      	movs	r2, #136	; 0x88
    e864:	18ba      	adds	r2, r7, r2
    e866:	6013      	str	r3, [r2, #0]

		// (1) 32 bytes TempKey
		memcpy(p_temp, param->temp_key->value, ATCA_KEY_SIZE);
    e868:	687b      	ldr	r3, [r7, #4]
    e86a:	695b      	ldr	r3, [r3, #20]
    e86c:	0019      	movs	r1, r3
    e86e:	2388      	movs	r3, #136	; 0x88
    e870:	18fb      	adds	r3, r7, r3
    e872:	681b      	ldr	r3, [r3, #0]
    e874:	2220      	movs	r2, #32
    e876:	0018      	movs	r0, r3
    e878:	4b3e      	ldr	r3, [pc, #248]	; (e974 <atcah_privwrite_auth_mac+0x260>)
    e87a:	4798      	blx	r3
		p_temp += ATCA_KEY_SIZE;
    e87c:	2388      	movs	r3, #136	; 0x88
    e87e:	18fb      	adds	r3, r7, r3
    e880:	681b      	ldr	r3, [r3, #0]
    e882:	3320      	adds	r3, #32
    e884:	2288      	movs	r2, #136	; 0x88
    e886:	18ba      	adds	r2, r7, r2
    e888:	6013      	str	r3, [r2, #0]

		// (2) 1 byte Opcode
		*p_temp++ = ATCA_PRIVWRITE;
    e88a:	2388      	movs	r3, #136	; 0x88
    e88c:	18fb      	adds	r3, r7, r3
    e88e:	681b      	ldr	r3, [r3, #0]
    e890:	1c5a      	adds	r2, r3, #1
    e892:	2188      	movs	r1, #136	; 0x88
    e894:	1879      	adds	r1, r7, r1
    e896:	600a      	str	r2, [r1, #0]
    e898:	2246      	movs	r2, #70	; 0x46
    e89a:	701a      	strb	r2, [r3, #0]

		// (3) 1 byte Param1 (zone)
		*p_temp++ = param->zone;
    e89c:	2388      	movs	r3, #136	; 0x88
    e89e:	18fb      	adds	r3, r7, r3
    e8a0:	681b      	ldr	r3, [r3, #0]
    e8a2:	1c5a      	adds	r2, r3, #1
    e8a4:	2188      	movs	r1, #136	; 0x88
    e8a6:	1879      	adds	r1, r7, r1
    e8a8:	600a      	str	r2, [r1, #0]
    e8aa:	687a      	ldr	r2, [r7, #4]
    e8ac:	7812      	ldrb	r2, [r2, #0]
    e8ae:	701a      	strb	r2, [r3, #0]

		// (4) 2 bytes Param2 (keyID)
		*p_temp++ = param->key_id & 0xFF;
    e8b0:	2388      	movs	r3, #136	; 0x88
    e8b2:	18fb      	adds	r3, r7, r3
    e8b4:	681b      	ldr	r3, [r3, #0]
    e8b6:	1c5a      	adds	r2, r3, #1
    e8b8:	2188      	movs	r1, #136	; 0x88
    e8ba:	1879      	adds	r1, r7, r1
    e8bc:	600a      	str	r2, [r1, #0]
    e8be:	687a      	ldr	r2, [r7, #4]
    e8c0:	8852      	ldrh	r2, [r2, #2]
    e8c2:	b2d2      	uxtb	r2, r2
    e8c4:	701a      	strb	r2, [r3, #0]
		*p_temp++ = (param->key_id >> 8) & 0xFF;
    e8c6:	2388      	movs	r3, #136	; 0x88
    e8c8:	18fb      	adds	r3, r7, r3
    e8ca:	681b      	ldr	r3, [r3, #0]
    e8cc:	1c5a      	adds	r2, r3, #1
    e8ce:	2188      	movs	r1, #136	; 0x88
    e8d0:	1879      	adds	r1, r7, r1
    e8d2:	600a      	str	r2, [r1, #0]
    e8d4:	687a      	ldr	r2, [r7, #4]
    e8d6:	8852      	ldrh	r2, [r2, #2]
    e8d8:	0a12      	lsrs	r2, r2, #8
    e8da:	b292      	uxth	r2, r2
    e8dc:	b2d2      	uxtb	r2, r2
    e8de:	701a      	strb	r2, [r3, #0]

		// (5) 1 byte SN[8] = 0xEE
		*p_temp++ = ATCA_SN_8;
    e8e0:	2388      	movs	r3, #136	; 0x88
    e8e2:	18fb      	adds	r3, r7, r3
    e8e4:	681b      	ldr	r3, [r3, #0]
    e8e6:	1c5a      	adds	r2, r3, #1
    e8e8:	2188      	movs	r1, #136	; 0x88
    e8ea:	1879      	adds	r1, r7, r1
    e8ec:	600a      	str	r2, [r1, #0]
    e8ee:	22ee      	movs	r2, #238	; 0xee
    e8f0:	701a      	strb	r2, [r3, #0]

		// (6) 2 bytes SN[0:1] = 0x0123
		*p_temp++ = ATCA_SN_0;
    e8f2:	2388      	movs	r3, #136	; 0x88
    e8f4:	18fb      	adds	r3, r7, r3
    e8f6:	681b      	ldr	r3, [r3, #0]
    e8f8:	1c5a      	adds	r2, r3, #1
    e8fa:	2188      	movs	r1, #136	; 0x88
    e8fc:	1879      	adds	r1, r7, r1
    e8fe:	600a      	str	r2, [r1, #0]
    e900:	2201      	movs	r2, #1
    e902:	701a      	strb	r2, [r3, #0]
		*p_temp++ = ATCA_SN_1;
    e904:	2388      	movs	r3, #136	; 0x88
    e906:	18fb      	adds	r3, r7, r3
    e908:	681b      	ldr	r3, [r3, #0]
    e90a:	1c5a      	adds	r2, r3, #1
    e90c:	2188      	movs	r1, #136	; 0x88
    e90e:	1879      	adds	r1, r7, r1
    e910:	600a      	str	r2, [r1, #0]
    e912:	2223      	movs	r2, #35	; 0x23
    e914:	701a      	strb	r2, [r3, #0]

		// (7) 21 zeros
		memset(p_temp, 0, ATCA_PRIVWRITE_MAC_ZEROS_SIZE);
    e916:	2388      	movs	r3, #136	; 0x88
    e918:	18fb      	adds	r3, r7, r3
    e91a:	681b      	ldr	r3, [r3, #0]
    e91c:	2215      	movs	r2, #21
    e91e:	2100      	movs	r1, #0
    e920:	0018      	movs	r0, r3
    e922:	4b15      	ldr	r3, [pc, #84]	; (e978 <atcah_privwrite_auth_mac+0x264>)
    e924:	4798      	blx	r3
		p_temp += ATCA_PRIVWRITE_MAC_ZEROS_SIZE;
    e926:	2388      	movs	r3, #136	; 0x88
    e928:	18fb      	adds	r3, r7, r3
    e92a:	681b      	ldr	r3, [r3, #0]
    e92c:	3315      	adds	r3, #21
    e92e:	2288      	movs	r2, #136	; 0x88
    e930:	18ba      	adds	r2, r7, r2
    e932:	6013      	str	r3, [r2, #0]

		// (8) 36 bytes PlainText : 0 0 0 0 (4bytes) | private_key (32bytes)
		memcpy(p_temp, param->input_data, ATCA_PLAIN_TEXT_SIZE);
    e934:	687b      	ldr	r3, [r7, #4]
    e936:	6899      	ldr	r1, [r3, #8]
    e938:	2388      	movs	r3, #136	; 0x88
    e93a:	18fb      	adds	r3, r7, r3
    e93c:	681b      	ldr	r3, [r3, #0]
    e93e:	2224      	movs	r2, #36	; 0x24
    e940:	0018      	movs	r0, r3
    e942:	4b0c      	ldr	r3, [pc, #48]	; (e974 <atcah_privwrite_auth_mac+0x260>)
    e944:	4798      	blx	r3

		// Calculate SHA256 to get the new TempKey
		atcah_sha256(ATCA_MSG_SIZE_PRIVWRITE_MAC, temporary, param->auth_mac);
    e946:	687b      	ldr	r3, [r7, #4]
    e948:	691a      	ldr	r2, [r3, #16]
    e94a:	2328      	movs	r3, #40	; 0x28
    e94c:	18fb      	adds	r3, r7, r3
    e94e:	0019      	movs	r1, r3
    e950:	2060      	movs	r0, #96	; 0x60
    e952:	4b07      	ldr	r3, [pc, #28]	; (e970 <atcah_privwrite_auth_mac+0x25c>)
    e954:	4798      	blx	r3
	}

	// Update TempKey fields
	param->temp_key->valid = 1;
    e956:	687b      	ldr	r3, [r7, #4]
    e958:	695b      	ldr	r3, [r3, #20]
    e95a:	2220      	movs	r2, #32
    e95c:	5c99      	ldrb	r1, [r3, r2]
    e95e:	2080      	movs	r0, #128	; 0x80
    e960:	4240      	negs	r0, r0
    e962:	4301      	orrs	r1, r0
    e964:	5499      	strb	r1, [r3, r2]

	return ATCA_SUCCESS;
    e966:	2300      	movs	r3, #0
}
    e968:	0018      	movs	r0, r3
    e96a:	46bd      	mov	sp, r7
    e96c:	b024      	add	sp, #144	; 0x90
    e96e:	bd80      	pop	{r7, pc}
    e970:	0000e97d 	.word	0x0000e97d
    e974:	000127e7 	.word	0x000127e7
    e978:	00012823 	.word	0x00012823

0000e97c <atcah_sha256>:
 * \param[in] len byte length of message
 * \param[in] message pointer to message
 * \param[out] digest SHA256 of message
 */
ATCA_STATUS atcah_sha256(int32_t len, const uint8_t *message, uint8_t *digest)
{
    e97c:	b580      	push	{r7, lr}
    e97e:	b084      	sub	sp, #16
    e980:	af00      	add	r7, sp, #0
    e982:	60f8      	str	r0, [r7, #12]
    e984:	60b9      	str	r1, [r7, #8]
    e986:	607a      	str	r2, [r7, #4]
	return atcac_sw_sha2_256(message, len, digest);
    e988:	68f9      	ldr	r1, [r7, #12]
    e98a:	687a      	ldr	r2, [r7, #4]
    e98c:	68bb      	ldr	r3, [r7, #8]
    e98e:	0018      	movs	r0, r3
    e990:	4b03      	ldr	r3, [pc, #12]	; (e9a0 <atcah_sha256+0x24>)
    e992:	4798      	blx	r3
    e994:	0003      	movs	r3, r0
    e996:	b2db      	uxtb	r3, r3
}
    e998:	0018      	movs	r0, r3
    e99a:	46bd      	mov	sp, r7
    e99c:	b004      	add	sp, #16
    e99e:	bd80      	pop	{r7, pc}
    e9a0:	0000d389 	.word	0x0000d389

0000e9a4 <help>:
/** \brief help method prints out the console menu commands to the console
	\return ATCA_STATUS
 */

int help(void)
{
    e9a4:	b580      	push	{r7, lr}
    e9a6:	af00      	add	r7, sp, #0
	printf("\r\nUsage:\r\n");
    e9a8:	4b1f      	ldr	r3, [pc, #124]	; (ea28 <help+0x84>)
    e9aa:	0018      	movs	r0, r3
    e9ac:	4b1f      	ldr	r3, [pc, #124]	; (ea2c <help+0x88>)
    e9ae:	4798      	blx	r3

    printf("client-provision  - Configure and load certificate data onto ATECC device.\r\n");
    e9b0:	4b1f      	ldr	r3, [pc, #124]	; (ea30 <help+0x8c>)
    e9b2:	0018      	movs	r0, r3
    e9b4:	4b1d      	ldr	r3, [pc, #116]	; (ea2c <help+0x88>)
    e9b6:	4798      	blx	r3
    printf("client-build      - Read certificate data off ATECC device and rebuild full signer and device certificates.\r\n");
    e9b8:	4b1e      	ldr	r3, [pc, #120]	; (ea34 <help+0x90>)
    e9ba:	0018      	movs	r0, r3
    e9bc:	4b1b      	ldr	r3, [pc, #108]	; (ea2c <help+0x88>)
    e9be:	4798      	blx	r3
    printf("host-chain-verify - Verify the certificate chain from the client.\r\n");
    e9c0:	4b1d      	ldr	r3, [pc, #116]	; (ea38 <help+0x94>)
    e9c2:	0018      	movs	r0, r3
    e9c4:	4b19      	ldr	r3, [pc, #100]	; (ea2c <help+0x88>)
    e9c6:	4798      	blx	r3
    printf("host-gen-chal     - Generate challenge for the client.\r\n");
    e9c8:	4b1c      	ldr	r3, [pc, #112]	; (ea3c <help+0x98>)
    e9ca:	0018      	movs	r0, r3
    e9cc:	4b17      	ldr	r3, [pc, #92]	; (ea2c <help+0x88>)
    e9ce:	4798      	blx	r3
    printf("client-gen-resp   - Generate response to challenge from host.\r\n");
    e9d0:	4b1b      	ldr	r3, [pc, #108]	; (ea40 <help+0x9c>)
    e9d2:	0018      	movs	r0, r3
    e9d4:	4b15      	ldr	r3, [pc, #84]	; (ea2c <help+0x88>)
    e9d6:	4798      	blx	r3
    printf("host-verify-resp  - Verify the client response to the challenge.\r\n");
    e9d8:	4b1a      	ldr	r3, [pc, #104]	; (ea44 <help+0xa0>)
    e9da:	0018      	movs	r0, r3
    e9dc:	4b13      	ldr	r3, [pc, #76]	; (ea2c <help+0x88>)
    e9de:	4798      	blx	r3
    printf("Utility functions:\r\n");
    e9e0:	4b19      	ldr	r3, [pc, #100]	; (ea48 <help+0xa4>)
    e9e2:	0018      	movs	r0, r3
    e9e4:	4b11      	ldr	r3, [pc, #68]	; (ea2c <help+0x88>)
    e9e6:	4798      	blx	r3
	printf("lockstat - zone lock status\r\n");
    e9e8:	4b18      	ldr	r3, [pc, #96]	; (ea4c <help+0xa8>)
    e9ea:	0018      	movs	r0, r3
    e9ec:	4b0f      	ldr	r3, [pc, #60]	; (ea2c <help+0x88>)
    e9ee:	4798      	blx	r3
	printf("lockcfg  - lock config zone\r\n");
    e9f0:	4b17      	ldr	r3, [pc, #92]	; (ea50 <help+0xac>)
    e9f2:	0018      	movs	r0, r3
    e9f4:	4b0d      	ldr	r3, [pc, #52]	; (ea2c <help+0x88>)
    e9f6:	4798      	blx	r3
	printf("lockdata - lock data and OTP zones\r\n");
    e9f8:	4b16      	ldr	r3, [pc, #88]	; (ea54 <help+0xb0>)
    e9fa:	0018      	movs	r0, r3
    e9fc:	4b0b      	ldr	r3, [pc, #44]	; (ea2c <help+0x88>)
    e9fe:	4798      	blx	r3
	printf("info     - get the chip revision\r\n");
    ea00:	4b15      	ldr	r3, [pc, #84]	; (ea58 <help+0xb4>)
    ea02:	0018      	movs	r0, r3
    ea04:	4b09      	ldr	r3, [pc, #36]	; (ea2c <help+0x88>)
    ea06:	4798      	blx	r3
	printf("sernum   - get the chip serial number\r\n");
    ea08:	4b14      	ldr	r3, [pc, #80]	; (ea5c <help+0xb8>)
    ea0a:	0018      	movs	r0, r3
    ea0c:	4b07      	ldr	r3, [pc, #28]	; (ea2c <help+0x88>)
    ea0e:	4798      	blx	r3
	
	printf("upDown		- wake -idle,wake, sleap \r\n");
    ea10:	4b13      	ldr	r3, [pc, #76]	; (ea60 <help+0xbc>)
    ea12:	0018      	movs	r0, r3
    ea14:	4b05      	ldr	r3, [pc, #20]	; (ea2c <help+0x88>)
    ea16:	4798      	blx	r3
		
	printf("\r\n");
    ea18:	4b12      	ldr	r3, [pc, #72]	; (ea64 <help+0xc0>)
    ea1a:	0018      	movs	r0, r3
    ea1c:	4b03      	ldr	r3, [pc, #12]	; (ea2c <help+0x88>)
    ea1e:	4798      	blx	r3
	return ATCA_SUCCESS;
    ea20:	2300      	movs	r3, #0
}
    ea22:	0018      	movs	r0, r3
    ea24:	46bd      	mov	sp, r7
    ea26:	bd80      	pop	{r7, pc}
    ea28:	00015398 	.word	0x00015398
    ea2c:	00012a8d 	.word	0x00012a8d
    ea30:	000153a4 	.word	0x000153a4
    ea34:	000153f0 	.word	0x000153f0
    ea38:	00015460 	.word	0x00015460
    ea3c:	000154a4 	.word	0x000154a4
    ea40:	000154dc 	.word	0x000154dc
    ea44:	0001551c 	.word	0x0001551c
    ea48:	00015560 	.word	0x00015560
    ea4c:	00015574 	.word	0x00015574
    ea50:	00015594 	.word	0x00015594
    ea54:	000155b4 	.word	0x000155b4
    ea58:	000155d8 	.word	0x000155d8
    ea5c:	000155fc 	.word	0x000155fc
    ea60:	00015624 	.word	0x00015624
    ea64:	00015648 	.word	0x00015648

0000ea68 <lockstatus>:
 *  and prints the status of the zones to the console
 *  \return ATCA_STATUS
 */

static ATCA_STATUS lockstatus(void)
{
    ea68:	b590      	push	{r4, r7, lr}
    ea6a:	b083      	sub	sp, #12
    ea6c:	af00      	add	r7, sp, #0
	ATCA_STATUS status;		
	bool dataIsLocked=0xff, cfgIsLocked=0xff;
    ea6e:	1dbb      	adds	r3, r7, #6
    ea70:	2201      	movs	r2, #1
    ea72:	701a      	strb	r2, [r3, #0]
    ea74:	1d7b      	adds	r3, r7, #5
    ea76:	2201      	movs	r2, #1
    ea78:	701a      	strb	r2, [r3, #0]
	
	if ( (status = atcab_is_locked( LOCK_ZONE_CONFIG, &cfgIsLocked )) != ATCA_SUCCESS )
    ea7a:	1dfc      	adds	r4, r7, #7
    ea7c:	1d7b      	adds	r3, r7, #5
    ea7e:	0019      	movs	r1, r3
    ea80:	2000      	movs	r0, #0
    ea82:	4b1f      	ldr	r3, [pc, #124]	; (eb00 <lockstatus+0x98>)
    ea84:	4798      	blx	r3
    ea86:	0003      	movs	r3, r0
    ea88:	7023      	strb	r3, [r4, #0]
    ea8a:	1dfb      	adds	r3, r7, #7
    ea8c:	781b      	ldrb	r3, [r3, #0]
    ea8e:	2b00      	cmp	r3, #0
    ea90:	d004      	beq.n	ea9c <lockstatus+0x34>
		printf("can't read cfg lock\r\n");
    ea92:	4b1c      	ldr	r3, [pc, #112]	; (eb04 <lockstatus+0x9c>)
    ea94:	0018      	movs	r0, r3
    ea96:	4b1c      	ldr	r3, [pc, #112]	; (eb08 <lockstatus+0xa0>)
    ea98:	4798      	blx	r3
    ea9a:	e00f      	b.n	eabc <lockstatus+0x54>
	else if ( (status = atcab_is_locked( LOCK_ZONE_DATA, &dataIsLocked )) != ATCA_SUCCESS )
    ea9c:	1dfc      	adds	r4, r7, #7
    ea9e:	1dbb      	adds	r3, r7, #6
    eaa0:	0019      	movs	r1, r3
    eaa2:	2001      	movs	r0, #1
    eaa4:	4b16      	ldr	r3, [pc, #88]	; (eb00 <lockstatus+0x98>)
    eaa6:	4798      	blx	r3
    eaa8:	0003      	movs	r3, r0
    eaaa:	7023      	strb	r3, [r4, #0]
    eaac:	1dfb      	adds	r3, r7, #7
    eaae:	781b      	ldrb	r3, [r3, #0]
    eab0:	2b00      	cmp	r3, #0
    eab2:	d003      	beq.n	eabc <lockstatus+0x54>
		printf("can't read data lock\r\n");
    eab4:	4b15      	ldr	r3, [pc, #84]	; (eb0c <lockstatus+0xa4>)
    eab6:	0018      	movs	r0, r3
    eab8:	4b13      	ldr	r3, [pc, #76]	; (eb08 <lockstatus+0xa0>)
    eaba:	4798      	blx	r3

	if ( status == ATCA_SUCCESS ) {
    eabc:	1dfb      	adds	r3, r7, #7
    eabe:	781b      	ldrb	r3, [r3, #0]
    eac0:	2b00      	cmp	r3, #0
    eac2:	d117      	bne.n	eaf4 <lockstatus+0x8c>
        printf("Config Zone Lock: %s\r\n", cfgIsLocked == 0x01 ? "locked" : "unlocked");
    eac4:	1d7b      	adds	r3, r7, #5
    eac6:	781b      	ldrb	r3, [r3, #0]
    eac8:	2b00      	cmp	r3, #0
    eaca:	d001      	beq.n	ead0 <lockstatus+0x68>
    eacc:	4b10      	ldr	r3, [pc, #64]	; (eb10 <lockstatus+0xa8>)
    eace:	e000      	b.n	ead2 <lockstatus+0x6a>
    ead0:	4b10      	ldr	r3, [pc, #64]	; (eb14 <lockstatus+0xac>)
    ead2:	4a11      	ldr	r2, [pc, #68]	; (eb18 <lockstatus+0xb0>)
    ead4:	0019      	movs	r1, r3
    ead6:	0010      	movs	r0, r2
    ead8:	4b10      	ldr	r3, [pc, #64]	; (eb1c <lockstatus+0xb4>)
    eada:	4798      	blx	r3
        printf("Data Zone Lock  : %s\r\n", dataIsLocked == 0x01 ? "locked" :"unlocked" );
    eadc:	1dbb      	adds	r3, r7, #6
    eade:	781b      	ldrb	r3, [r3, #0]
    eae0:	2b00      	cmp	r3, #0
    eae2:	d001      	beq.n	eae8 <lockstatus+0x80>
    eae4:	4b0a      	ldr	r3, [pc, #40]	; (eb10 <lockstatus+0xa8>)
    eae6:	e000      	b.n	eaea <lockstatus+0x82>
    eae8:	4b0a      	ldr	r3, [pc, #40]	; (eb14 <lockstatus+0xac>)
    eaea:	4a0d      	ldr	r2, [pc, #52]	; (eb20 <lockstatus+0xb8>)
    eaec:	0019      	movs	r1, r3
    eaee:	0010      	movs	r0, r2
    eaf0:	4b0a      	ldr	r3, [pc, #40]	; (eb1c <lockstatus+0xb4>)
    eaf2:	4798      	blx	r3
    }
	
	return status;
    eaf4:	1dfb      	adds	r3, r7, #7
    eaf6:	781b      	ldrb	r3, [r3, #0]
}
    eaf8:	0018      	movs	r0, r3
    eafa:	46bd      	mov	sp, r7
    eafc:	b003      	add	sp, #12
    eafe:	bd90      	pop	{r4, r7, pc}
    eb00:	0000ba6d 	.word	0x0000ba6d
    eb04:	0001564c 	.word	0x0001564c
    eb08:	00012a8d 	.word	0x00012a8d
    eb0c:	00015664 	.word	0x00015664
    eb10:	0001567c 	.word	0x0001567c
    eb14:	00015684 	.word	0x00015684
    eb18:	00015690 	.word	0x00015690
    eb1c:	0001296d 	.word	0x0001296d
    eb20:	000156a8 	.word	0x000156a8

0000eb24 <lock_config_zone>:

/** \brief lock_config_zone will lock the configuration zone of the CryptoAuth device
 * \returns the lock response from the chip
 */
static uint8_t lock_config_zone(void)
{
    eb24:	b580      	push	{r7, lr}
    eb26:	b082      	sub	sp, #8
    eb28:	af00      	add	r7, sp, #0
	uint8_t lock_response;
	atcab_lock_config_zone( &lock_response );
    eb2a:	1dfb      	adds	r3, r7, #7
    eb2c:	0018      	movs	r0, r3
    eb2e:	4b04      	ldr	r3, [pc, #16]	; (eb40 <lock_config_zone+0x1c>)
    eb30:	4798      	blx	r3
    
	return lock_response;		
    eb32:	1dfb      	adds	r3, r7, #7
    eb34:	781b      	ldrb	r3, [r3, #0]
}
    eb36:	0018      	movs	r0, r3
    eb38:	46bd      	mov	sp, r7
    eb3a:	b002      	add	sp, #8
    eb3c:	bd80      	pop	{r7, pc}
    eb3e:	46c0      	nop			; (mov r8, r8)
    eb40:	0000c3d9 	.word	0x0000c3d9

0000eb44 <lock_data_zone>:

/** \brief lock_data_zone will lock the data zone of the CryptoAuth device
 * \returns the lock response from the chip
 */
static uint8_t lock_data_zone(void)
{
    eb44:	b580      	push	{r7, lr}
    eb46:	b082      	sub	sp, #8
    eb48:	af00      	add	r7, sp, #0
	uint8_t lock_response;
	atcab_lock_data_zone( &lock_response );
    eb4a:	1dfb      	adds	r3, r7, #7
    eb4c:	0018      	movs	r0, r3
    eb4e:	4b04      	ldr	r3, [pc, #16]	; (eb60 <lock_data_zone+0x1c>)
    eb50:	4798      	blx	r3
    
	return lock_response;		
    eb52:	1dfb      	adds	r3, r7, #7
    eb54:	781b      	ldrb	r3, [r3, #0]
}
    eb56:	0018      	movs	r0, r3
    eb58:	46bd      	mov	sp, r7
    eb5a:	b002      	add	sp, #8
    eb5c:	bd80      	pop	{r7, pc}
    eb5e:	46c0      	nop			; (mov r8, r8)
    eb60:	0000c549 	.word	0x0000c549

0000eb64 <getinfo>:
/** \brief getinfo returns the revision bytes from the chip.  These bytes identify
 * the exact revision of the silicon.
 */

static ATCA_STATUS getinfo( uint8_t *revision )
{
    eb64:	b580      	push	{r7, lr}
    eb66:	b082      	sub	sp, #8
    eb68:	af00      	add	r7, sp, #0
    eb6a:	6078      	str	r0, [r7, #4]
	return atcab_info( revision );
    eb6c:	687b      	ldr	r3, [r7, #4]
    eb6e:	0018      	movs	r0, r3
    eb70:	4b03      	ldr	r3, [pc, #12]	; (eb80 <getinfo+0x1c>)
    eb72:	4798      	blx	r3
    eb74:	0003      	movs	r3, r0
}
    eb76:	0018      	movs	r0, r3
    eb78:	46bd      	mov	sp, r7
    eb7a:	b002      	add	sp, #8
    eb7c:	bd80      	pop	{r7, pc}
    eb7e:	46c0      	nop			; (mov r8, r8)
    eb80:	0000ae41 	.word	0x0000ae41

0000eb84 <getsernum>:

/** \brief getsernum returns the serial number bytes from the chip.  These bytes identify
 * the exact instance of a device - as expected, all serial numbers are unique across devices.
 */
static ATCA_STATUS getsernum( uint8_t *sernum )
{
    eb84:	b580      	push	{r7, lr}
    eb86:	b082      	sub	sp, #8
    eb88:	af00      	add	r7, sp, #0
    eb8a:	6078      	str	r0, [r7, #4]
	return atcab_read_serial_number( sernum );
    eb8c:	687b      	ldr	r3, [r7, #4]
    eb8e:	0018      	movs	r0, r3
    eb90:	4b03      	ldr	r3, [pc, #12]	; (eba0 <getsernum+0x1c>)
    eb92:	4798      	blx	r3
    eb94:	0003      	movs	r3, r0
}
    eb96:	0018      	movs	r0, r3
    eb98:	46bd      	mov	sp, r7
    eb9a:	b002      	add	sp, #8
    eb9c:	bd80      	pop	{r7, pc}
    eb9e:	46c0      	nop			; (mov r8, r8)
    eba0:	0000b625 	.word	0x0000b625

0000eba4 <parseCmd>:
 *  requested.
 *  \param[in] commands - a command string
 */

int parseCmd( char *commands )
{
    eba4:	b590      	push	{r4, r7, lr}
    eba6:	b0e5      	sub	sp, #404	; 0x194
    eba8:	af00      	add	r7, sp, #0
    ebaa:	6078      	str	r0, [r7, #4]
	char *cmds = NULL;
    ebac:	2300      	movs	r3, #0
    ebae:	22c6      	movs	r2, #198	; 0xc6
    ebb0:	0052      	lsls	r2, r2, #1
    ebb2:	18ba      	adds	r2, r7, r2
    ebb4:	6013      	str	r3, [r2, #0]
	
	if ( (cmds = strstr( commands, "help")) ) {
    ebb6:	4ae5      	ldr	r2, [pc, #916]	; (ef4c <parseCmd+0x3a8>)
    ebb8:	687b      	ldr	r3, [r7, #4]
    ebba:	0011      	movs	r1, r2
    ebbc:	0018      	movs	r0, r3
    ebbe:	4be4      	ldr	r3, [pc, #912]	; (ef50 <parseCmd+0x3ac>)
    ebc0:	4798      	blx	r3
    ebc2:	0003      	movs	r3, r0
    ebc4:	22c6      	movs	r2, #198	; 0xc6
    ebc6:	0052      	lsls	r2, r2, #1
    ebc8:	18ba      	adds	r2, r7, r2
    ebca:	6013      	str	r3, [r2, #0]
    ebcc:	23c6      	movs	r3, #198	; 0xc6
    ebce:	005b      	lsls	r3, r3, #1
    ebd0:	18fb      	adds	r3, r7, r3
    ebd2:	681b      	ldr	r3, [r3, #0]
    ebd4:	2b00      	cmp	r3, #0
    ebd6:	d002      	beq.n	ebde <parseCmd+0x3a>
		help();
    ebd8:	4bde      	ldr	r3, [pc, #888]	; (ef54 <parseCmd+0x3b0>)
    ebda:	4798      	blx	r3
    ebdc:	e23c      	b.n	f058 <parseCmd+0x4b4>
	} else if ( (cmds = strstr( commands, "lockstat")) ) {
    ebde:	4ade      	ldr	r2, [pc, #888]	; (ef58 <parseCmd+0x3b4>)
    ebe0:	687b      	ldr	r3, [r7, #4]
    ebe2:	0011      	movs	r1, r2
    ebe4:	0018      	movs	r0, r3
    ebe6:	4bda      	ldr	r3, [pc, #872]	; (ef50 <parseCmd+0x3ac>)
    ebe8:	4798      	blx	r3
    ebea:	0003      	movs	r3, r0
    ebec:	22c6      	movs	r2, #198	; 0xc6
    ebee:	0052      	lsls	r2, r2, #1
    ebf0:	18ba      	adds	r2, r7, r2
    ebf2:	6013      	str	r3, [r2, #0]
    ebf4:	23c6      	movs	r3, #198	; 0xc6
    ebf6:	005b      	lsls	r3, r3, #1
    ebf8:	18fb      	adds	r3, r7, r3
    ebfa:	681b      	ldr	r3, [r3, #0]
    ebfc:	2b00      	cmp	r3, #0
    ebfe:	d002      	beq.n	ec06 <parseCmd+0x62>
		lockstatus();
    ec00:	4bd6      	ldr	r3, [pc, #856]	; (ef5c <parseCmd+0x3b8>)
    ec02:	4798      	blx	r3
    ec04:	e228      	b.n	f058 <parseCmd+0x4b4>
	} else if ( (cmds = strstr( commands, "lockcfg")) ) {
    ec06:	4ad6      	ldr	r2, [pc, #856]	; (ef60 <parseCmd+0x3bc>)
    ec08:	687b      	ldr	r3, [r7, #4]
    ec0a:	0011      	movs	r1, r2
    ec0c:	0018      	movs	r0, r3
    ec0e:	4bd0      	ldr	r3, [pc, #832]	; (ef50 <parseCmd+0x3ac>)
    ec10:	4798      	blx	r3
    ec12:	0003      	movs	r3, r0
    ec14:	22c6      	movs	r2, #198	; 0xc6
    ec16:	0052      	lsls	r2, r2, #1
    ec18:	18ba      	adds	r2, r7, r2
    ec1a:	6013      	str	r3, [r2, #0]
    ec1c:	23c6      	movs	r3, #198	; 0xc6
    ec1e:	005b      	lsls	r3, r3, #1
    ec20:	18fb      	adds	r3, r7, r3
    ec22:	681b      	ldr	r3, [r3, #0]
    ec24:	2b00      	cmp	r3, #0
    ec26:	d00a      	beq.n	ec3e <parseCmd+0x9a>
		if ( lock_config_zone() != ATCA_SUCCESS )
    ec28:	4bce      	ldr	r3, [pc, #824]	; (ef64 <parseCmd+0x3c0>)
    ec2a:	4798      	blx	r3
    ec2c:	1e03      	subs	r3, r0, #0
    ec2e:	d003      	beq.n	ec38 <parseCmd+0x94>
			printf("Could not lock config zone\r\n");
    ec30:	4bcd      	ldr	r3, [pc, #820]	; (ef68 <parseCmd+0x3c4>)
    ec32:	0018      	movs	r0, r3
    ec34:	4bcd      	ldr	r3, [pc, #820]	; (ef6c <parseCmd+0x3c8>)
    ec36:	4798      	blx	r3
		lockstatus();
    ec38:	4bc8      	ldr	r3, [pc, #800]	; (ef5c <parseCmd+0x3b8>)
    ec3a:	4798      	blx	r3
    ec3c:	e20c      	b.n	f058 <parseCmd+0x4b4>
	} else if ( (cmds = strstr( commands, "lockdata")) ) {
    ec3e:	4acc      	ldr	r2, [pc, #816]	; (ef70 <parseCmd+0x3cc>)
    ec40:	687b      	ldr	r3, [r7, #4]
    ec42:	0011      	movs	r1, r2
    ec44:	0018      	movs	r0, r3
    ec46:	4bc2      	ldr	r3, [pc, #776]	; (ef50 <parseCmd+0x3ac>)
    ec48:	4798      	blx	r3
    ec4a:	0003      	movs	r3, r0
    ec4c:	22c6      	movs	r2, #198	; 0xc6
    ec4e:	0052      	lsls	r2, r2, #1
    ec50:	18ba      	adds	r2, r7, r2
    ec52:	6013      	str	r3, [r2, #0]
    ec54:	23c6      	movs	r3, #198	; 0xc6
    ec56:	005b      	lsls	r3, r3, #1
    ec58:	18fb      	adds	r3, r7, r3
    ec5a:	681b      	ldr	r3, [r3, #0]
    ec5c:	2b00      	cmp	r3, #0
    ec5e:	d00a      	beq.n	ec76 <parseCmd+0xd2>
		if ( lock_data_zone() != ATCA_SUCCESS )
    ec60:	4bc4      	ldr	r3, [pc, #784]	; (ef74 <parseCmd+0x3d0>)
    ec62:	4798      	blx	r3
    ec64:	1e03      	subs	r3, r0, #0
    ec66:	d003      	beq.n	ec70 <parseCmd+0xcc>
			printf("Could not lock data zone\r\n");
    ec68:	4bc3      	ldr	r3, [pc, #780]	; (ef78 <parseCmd+0x3d4>)
    ec6a:	0018      	movs	r0, r3
    ec6c:	4bbf      	ldr	r3, [pc, #764]	; (ef6c <parseCmd+0x3c8>)
    ec6e:	4798      	blx	r3
		lockstatus();
    ec70:	4bba      	ldr	r3, [pc, #744]	; (ef5c <parseCmd+0x3b8>)
    ec72:	4798      	blx	r3
    ec74:	e1f0      	b.n	f058 <parseCmd+0x4b4>
	} else if ( (cmds = strstr( commands, "info")) ) {
    ec76:	4ac1      	ldr	r2, [pc, #772]	; (ef7c <parseCmd+0x3d8>)
    ec78:	687b      	ldr	r3, [r7, #4]
    ec7a:	0011      	movs	r1, r2
    ec7c:	0018      	movs	r0, r3
    ec7e:	4bb4      	ldr	r3, [pc, #720]	; (ef50 <parseCmd+0x3ac>)
    ec80:	4798      	blx	r3
    ec82:	0003      	movs	r3, r0
    ec84:	22c6      	movs	r2, #198	; 0xc6
    ec86:	0052      	lsls	r2, r2, #1
    ec88:	18ba      	adds	r2, r7, r2
    ec8a:	6013      	str	r3, [r2, #0]
    ec8c:	23c6      	movs	r3, #198	; 0xc6
    ec8e:	005b      	lsls	r3, r3, #1
    ec90:	18fb      	adds	r3, r7, r3
    ec92:	681b      	ldr	r3, [r3, #0]
    ec94:	2b00      	cmp	r3, #0
    ec96:	d01f      	beq.n	ecd8 <parseCmd+0x134>
		uint8_t revision[4];
		char displaystr[15];
		int displaylen = sizeof(displaystr);
    ec98:	230f      	movs	r3, #15
    ec9a:	22ae      	movs	r2, #174	; 0xae
    ec9c:	0052      	lsls	r2, r2, #1
    ec9e:	18ba      	adds	r2, r7, r2
    eca0:	6013      	str	r3, [r2, #0]
		
		getinfo(revision);
    eca2:	23b8      	movs	r3, #184	; 0xb8
    eca4:	005b      	lsls	r3, r3, #1
    eca6:	18fb      	adds	r3, r7, r3
    eca8:	0018      	movs	r0, r3
    ecaa:	4bb5      	ldr	r3, [pc, #724]	; (ef80 <parseCmd+0x3dc>)
    ecac:	4798      	blx	r3
		// dump revision
		atcab_bin2hex(revision, 4, displaystr, &displaylen );
    ecae:	23ae      	movs	r3, #174	; 0xae
    ecb0:	005b      	lsls	r3, r3, #1
    ecb2:	18fb      	adds	r3, r7, r3
    ecb4:	22b0      	movs	r2, #176	; 0xb0
    ecb6:	0052      	lsls	r2, r2, #1
    ecb8:	18ba      	adds	r2, r7, r2
    ecba:	21b8      	movs	r1, #184	; 0xb8
    ecbc:	0049      	lsls	r1, r1, #1
    ecbe:	1878      	adds	r0, r7, r1
    ecc0:	2104      	movs	r1, #4
    ecc2:	4cb0      	ldr	r4, [pc, #704]	; (ef84 <parseCmd+0x3e0>)
    ecc4:	47a0      	blx	r4
		printf("\r\nrevision:\r\n%s\r\n", displaystr);
    ecc6:	23b0      	movs	r3, #176	; 0xb0
    ecc8:	005b      	lsls	r3, r3, #1
    ecca:	18fa      	adds	r2, r7, r3
    eccc:	4bae      	ldr	r3, [pc, #696]	; (ef88 <parseCmd+0x3e4>)
    ecce:	0011      	movs	r1, r2
    ecd0:	0018      	movs	r0, r3
    ecd2:	4bae      	ldr	r3, [pc, #696]	; (ef8c <parseCmd+0x3e8>)
    ecd4:	4798      	blx	r3
    ecd6:	e1bf      	b.n	f058 <parseCmd+0x4b4>
				
	}else if ( (cmds = strstr( commands, "upDown")) ) {
    ecd8:	4aad      	ldr	r2, [pc, #692]	; (ef90 <parseCmd+0x3ec>)
    ecda:	687b      	ldr	r3, [r7, #4]
    ecdc:	0011      	movs	r1, r2
    ecde:	0018      	movs	r0, r3
    ece0:	4b9b      	ldr	r3, [pc, #620]	; (ef50 <parseCmd+0x3ac>)
    ece2:	4798      	blx	r3
    ece4:	0003      	movs	r3, r0
    ece6:	22c6      	movs	r2, #198	; 0xc6
    ece8:	0052      	lsls	r2, r2, #1
    ecea:	18ba      	adds	r2, r7, r2
    ecec:	6013      	str	r3, [r2, #0]
    ecee:	23c6      	movs	r3, #198	; 0xc6
    ecf0:	005b      	lsls	r3, r3, #1
    ecf2:	18fb      	adds	r3, r7, r3
    ecf4:	681b      	ldr	r3, [r3, #0]
    ecf6:	2b00      	cmp	r3, #0
    ecf8:	d02a      	beq.n	ed50 <parseCmd+0x1ac>
	//printf("endJojo and Random\r\n");
	atcab_wakeup();
    ecfa:	4ba6      	ldr	r3, [pc, #664]	; (ef94 <parseCmd+0x3f0>)
    ecfc:	4798      	blx	r3
	atcab_idle();
    ecfe:	4ba6      	ldr	r3, [pc, #664]	; (ef98 <parseCmd+0x3f4>)
    ed00:	4798      	blx	r3
	//printf("idle\r\n");
	atcab_wakeup();
    ed02:	4ba4      	ldr	r3, [pc, #656]	; (ef94 <parseCmd+0x3f0>)
    ed04:	4798      	blx	r3
	atcab_sleep();
    ed06:	4ba5      	ldr	r3, [pc, #660]	; (ef9c <parseCmd+0x3f8>)
    ed08:	4798      	blx	r3
	uint8_t number[32];
	atcab_random(number);
    ed0a:	2308      	movs	r3, #8
    ed0c:	18fb      	adds	r3, r7, r3
    ed0e:	0018      	movs	r0, r3
    ed10:	4ba3      	ldr	r3, [pc, #652]	; (efa0 <parseCmd+0x3fc>)
    ed12:	4798      	blx	r3
	
	 char disp_str[256];
	 int disp_size = sizeof(disp_str);
    ed14:	2380      	movs	r3, #128	; 0x80
    ed16:	005b      	lsls	r3, r3, #1
    ed18:	22ac      	movs	r2, #172	; 0xac
    ed1a:	0052      	lsls	r2, r2, #1
    ed1c:	18ba      	adds	r2, r7, r2
    ed1e:	6013      	str	r3, [r2, #0]
	 atcab_bin2hex(number, sizeof(number), disp_str, &disp_size);
    ed20:	23ac      	movs	r3, #172	; 0xac
    ed22:	005b      	lsls	r3, r3, #1
    ed24:	18fb      	adds	r3, r7, r3
    ed26:	2228      	movs	r2, #40	; 0x28
    ed28:	18ba      	adds	r2, r7, r2
    ed2a:	2108      	movs	r1, #8
    ed2c:	1878      	adds	r0, r7, r1
    ed2e:	2120      	movs	r1, #32
    ed30:	4c94      	ldr	r4, [pc, #592]	; (ef84 <parseCmd+0x3e0>)
    ed32:	47a0      	blx	r4
	 printf("Random Nr:\r\n%s\r\n", disp_str);
    ed34:	2328      	movs	r3, #40	; 0x28
    ed36:	18fa      	adds	r2, r7, r3
    ed38:	4b9a      	ldr	r3, [pc, #616]	; (efa4 <parseCmd+0x400>)
    ed3a:	0011      	movs	r1, r2
    ed3c:	0018      	movs	r0, r3
    ed3e:	4b93      	ldr	r3, [pc, #588]	; (ef8c <parseCmd+0x3e8>)
    ed40:	4798      	blx	r3
	
	atcab_wakeup();
    ed42:	4b94      	ldr	r3, [pc, #592]	; (ef94 <parseCmd+0x3f0>)
    ed44:	4798      	blx	r3
	printf("end: upDown\r\n");
    ed46:	4b98      	ldr	r3, [pc, #608]	; (efa8 <parseCmd+0x404>)
    ed48:	0018      	movs	r0, r3
    ed4a:	4b88      	ldr	r3, [pc, #544]	; (ef6c <parseCmd+0x3c8>)
    ed4c:	4798      	blx	r3
    ed4e:	e183      	b.n	f058 <parseCmd+0x4b4>

	
	
}
	 else if ( (cmds = strstr( commands, "sernum")) ) {
    ed50:	4a96      	ldr	r2, [pc, #600]	; (efac <parseCmd+0x408>)
    ed52:	687b      	ldr	r3, [r7, #4]
    ed54:	0011      	movs	r1, r2
    ed56:	0018      	movs	r0, r3
    ed58:	4b7d      	ldr	r3, [pc, #500]	; (ef50 <parseCmd+0x3ac>)
    ed5a:	4798      	blx	r3
    ed5c:	0003      	movs	r3, r0
    ed5e:	22c6      	movs	r2, #198	; 0xc6
    ed60:	0052      	lsls	r2, r2, #1
    ed62:	18ba      	adds	r2, r7, r2
    ed64:	6013      	str	r3, [r2, #0]
    ed66:	23c6      	movs	r3, #198	; 0xc6
    ed68:	005b      	lsls	r3, r3, #1
    ed6a:	18fb      	adds	r3, r7, r3
    ed6c:	681b      	ldr	r3, [r3, #0]
    ed6e:	2b00      	cmp	r3, #0
    ed70:	d01f      	beq.n	edb2 <parseCmd+0x20e>
		uint8_t serialnum[ATCA_SERIAL_NUM_SIZE];
		char displaystr[30];
		int displaylen = sizeof(displaystr);
    ed72:	231e      	movs	r3, #30
    ed74:	2294      	movs	r2, #148	; 0x94
    ed76:	0052      	lsls	r2, r2, #1
    ed78:	18ba      	adds	r2, r7, r2
    ed7a:	6013      	str	r3, [r2, #0]
		
		getsernum(serialnum);
    ed7c:	23a6      	movs	r3, #166	; 0xa6
    ed7e:	005b      	lsls	r3, r3, #1
    ed80:	18fb      	adds	r3, r7, r3
    ed82:	0018      	movs	r0, r3
    ed84:	4b8a      	ldr	r3, [pc, #552]	; (efb0 <parseCmd+0x40c>)
    ed86:	4798      	blx	r3
		// dump serial num
		atcab_bin2hex(serialnum, ATCA_SERIAL_NUM_SIZE, displaystr, &displaylen );
    ed88:	2394      	movs	r3, #148	; 0x94
    ed8a:	005b      	lsls	r3, r3, #1
    ed8c:	18fb      	adds	r3, r7, r3
    ed8e:	2296      	movs	r2, #150	; 0x96
    ed90:	0052      	lsls	r2, r2, #1
    ed92:	18ba      	adds	r2, r7, r2
    ed94:	21a6      	movs	r1, #166	; 0xa6
    ed96:	0049      	lsls	r1, r1, #1
    ed98:	1878      	adds	r0, r7, r1
    ed9a:	2109      	movs	r1, #9
    ed9c:	4c79      	ldr	r4, [pc, #484]	; (ef84 <parseCmd+0x3e0>)
    ed9e:	47a0      	blx	r4
		printf("\r\nserial number:\r\n%s\r\n", displaystr);
    eda0:	2396      	movs	r3, #150	; 0x96
    eda2:	005b      	lsls	r3, r3, #1
    eda4:	18fa      	adds	r2, r7, r3
    eda6:	4b83      	ldr	r3, [pc, #524]	; (efb4 <parseCmd+0x410>)
    eda8:	0011      	movs	r1, r2
    edaa:	0018      	movs	r0, r3
    edac:	4b77      	ldr	r3, [pc, #476]	; (ef8c <parseCmd+0x3e8>)
    edae:	4798      	blx	r3
    edb0:	e152      	b.n	f058 <parseCmd+0x4b4>
    } else if ( (cmds = strstr( commands, "client-provision")) ) {
    edb2:	4a81      	ldr	r2, [pc, #516]	; (efb8 <parseCmd+0x414>)
    edb4:	687b      	ldr	r3, [r7, #4]
    edb6:	0011      	movs	r1, r2
    edb8:	0018      	movs	r0, r3
    edba:	4b65      	ldr	r3, [pc, #404]	; (ef50 <parseCmd+0x3ac>)
    edbc:	4798      	blx	r3
    edbe:	0003      	movs	r3, r0
    edc0:	22c6      	movs	r2, #198	; 0xc6
    edc2:	0052      	lsls	r2, r2, #1
    edc4:	18ba      	adds	r2, r7, r2
    edc6:	6013      	str	r3, [r2, #0]
    edc8:	23c6      	movs	r3, #198	; 0xc6
    edca:	005b      	lsls	r3, r3, #1
    edcc:	18fb      	adds	r3, r7, r3
    edce:	681b      	ldr	r3, [r3, #0]
    edd0:	2b00      	cmp	r3, #0
    edd2:	d017      	beq.n	ee04 <parseCmd+0x260>
        int ret = client_provision();
    edd4:	4b79      	ldr	r3, [pc, #484]	; (efbc <parseCmd+0x418>)
    edd6:	4798      	blx	r3
    edd8:	0003      	movs	r3, r0
    edda:	22c4      	movs	r2, #196	; 0xc4
    eddc:	0052      	lsls	r2, r2, #1
    edde:	18ba      	adds	r2, r7, r2
    ede0:	6013      	str	r3, [r2, #0]
        if (ret != ATCA_SUCCESS)
    ede2:	23c4      	movs	r3, #196	; 0xc4
    ede4:	005b      	lsls	r3, r3, #1
    ede6:	18fb      	adds	r3, r7, r3
    ede8:	681b      	ldr	r3, [r3, #0]
    edea:	2b00      	cmp	r3, #0
    edec:	d100      	bne.n	edf0 <parseCmd+0x24c>
    edee:	e133      	b.n	f058 <parseCmd+0x4b4>
        printf("client_provision failed with error code %X\r\n", ret); 
    edf0:	23c4      	movs	r3, #196	; 0xc4
    edf2:	005b      	lsls	r3, r3, #1
    edf4:	18fb      	adds	r3, r7, r3
    edf6:	681a      	ldr	r2, [r3, #0]
    edf8:	4b71      	ldr	r3, [pc, #452]	; (efc0 <parseCmd+0x41c>)
    edfa:	0011      	movs	r1, r2
    edfc:	0018      	movs	r0, r3
    edfe:	4b63      	ldr	r3, [pc, #396]	; (ef8c <parseCmd+0x3e8>)
    ee00:	4798      	blx	r3
    ee02:	e129      	b.n	f058 <parseCmd+0x4b4>
    } else if ( (cmds = strstr( commands, "client-build")) ) {
    ee04:	4a6f      	ldr	r2, [pc, #444]	; (efc4 <parseCmd+0x420>)
    ee06:	687b      	ldr	r3, [r7, #4]
    ee08:	0011      	movs	r1, r2
    ee0a:	0018      	movs	r0, r3
    ee0c:	4b50      	ldr	r3, [pc, #320]	; (ef50 <parseCmd+0x3ac>)
    ee0e:	4798      	blx	r3
    ee10:	0003      	movs	r3, r0
    ee12:	22c6      	movs	r2, #198	; 0xc6
    ee14:	0052      	lsls	r2, r2, #1
    ee16:	18ba      	adds	r2, r7, r2
    ee18:	6013      	str	r3, [r2, #0]
    ee1a:	23c6      	movs	r3, #198	; 0xc6
    ee1c:	005b      	lsls	r3, r3, #1
    ee1e:	18fb      	adds	r3, r7, r3
    ee20:	681b      	ldr	r3, [r3, #0]
    ee22:	2b00      	cmp	r3, #0
    ee24:	d017      	beq.n	ee56 <parseCmd+0x2b2>
        int ret = client_rebuild_certs();
    ee26:	4b68      	ldr	r3, [pc, #416]	; (efc8 <parseCmd+0x424>)
    ee28:	4798      	blx	r3
    ee2a:	0003      	movs	r3, r0
    ee2c:	22c2      	movs	r2, #194	; 0xc2
    ee2e:	0052      	lsls	r2, r2, #1
    ee30:	18ba      	adds	r2, r7, r2
    ee32:	6013      	str	r3, [r2, #0]
        if (ret != ATCA_SUCCESS)
    ee34:	23c2      	movs	r3, #194	; 0xc2
    ee36:	005b      	lsls	r3, r3, #1
    ee38:	18fb      	adds	r3, r7, r3
    ee3a:	681b      	ldr	r3, [r3, #0]
    ee3c:	2b00      	cmp	r3, #0
    ee3e:	d100      	bne.n	ee42 <parseCmd+0x29e>
    ee40:	e10a      	b.n	f058 <parseCmd+0x4b4>
           printf("client_rebuild_certs failed with error code %X\r\n", ret);  
    ee42:	23c2      	movs	r3, #194	; 0xc2
    ee44:	005b      	lsls	r3, r3, #1
    ee46:	18fb      	adds	r3, r7, r3
    ee48:	681a      	ldr	r2, [r3, #0]
    ee4a:	4b60      	ldr	r3, [pc, #384]	; (efcc <parseCmd+0x428>)
    ee4c:	0011      	movs	r1, r2
    ee4e:	0018      	movs	r0, r3
    ee50:	4b4e      	ldr	r3, [pc, #312]	; (ef8c <parseCmd+0x3e8>)
    ee52:	4798      	blx	r3
    ee54:	e100      	b.n	f058 <parseCmd+0x4b4>
    } else if ( (cmds = strstr( commands, "host-chain-verify")) ) {
    ee56:	4a5e      	ldr	r2, [pc, #376]	; (efd0 <parseCmd+0x42c>)
    ee58:	687b      	ldr	r3, [r7, #4]
    ee5a:	0011      	movs	r1, r2
    ee5c:	0018      	movs	r0, r3
    ee5e:	4b3c      	ldr	r3, [pc, #240]	; (ef50 <parseCmd+0x3ac>)
    ee60:	4798      	blx	r3
    ee62:	0003      	movs	r3, r0
    ee64:	22c6      	movs	r2, #198	; 0xc6
    ee66:	0052      	lsls	r2, r2, #1
    ee68:	18ba      	adds	r2, r7, r2
    ee6a:	6013      	str	r3, [r2, #0]
    ee6c:	23c6      	movs	r3, #198	; 0xc6
    ee6e:	005b      	lsls	r3, r3, #1
    ee70:	18fb      	adds	r3, r7, r3
    ee72:	681b      	ldr	r3, [r3, #0]
    ee74:	2b00      	cmp	r3, #0
    ee76:	d017      	beq.n	eea8 <parseCmd+0x304>
        int ret = host_verify_cert_chain();
    ee78:	4b56      	ldr	r3, [pc, #344]	; (efd4 <parseCmd+0x430>)
    ee7a:	4798      	blx	r3
    ee7c:	0003      	movs	r3, r0
    ee7e:	22c0      	movs	r2, #192	; 0xc0
    ee80:	0052      	lsls	r2, r2, #1
    ee82:	18ba      	adds	r2, r7, r2
    ee84:	6013      	str	r3, [r2, #0]
        if (ret != ATCA_SUCCESS)
    ee86:	23c0      	movs	r3, #192	; 0xc0
    ee88:	005b      	lsls	r3, r3, #1
    ee8a:	18fb      	adds	r3, r7, r3
    ee8c:	681b      	ldr	r3, [r3, #0]
    ee8e:	2b00      	cmp	r3, #0
    ee90:	d100      	bne.n	ee94 <parseCmd+0x2f0>
    ee92:	e0e1      	b.n	f058 <parseCmd+0x4b4>
            printf("host_verify_cert_chain failed with error code %X\r\n", ret);
    ee94:	23c0      	movs	r3, #192	; 0xc0
    ee96:	005b      	lsls	r3, r3, #1
    ee98:	18fb      	adds	r3, r7, r3
    ee9a:	681a      	ldr	r2, [r3, #0]
    ee9c:	4b4e      	ldr	r3, [pc, #312]	; (efd8 <parseCmd+0x434>)
    ee9e:	0011      	movs	r1, r2
    eea0:	0018      	movs	r0, r3
    eea2:	4b3a      	ldr	r3, [pc, #232]	; (ef8c <parseCmd+0x3e8>)
    eea4:	4798      	blx	r3
    eea6:	e0d7      	b.n	f058 <parseCmd+0x4b4>
    } else if ( (cmds = strstr( commands, "host-gen-chal")) ) {
    eea8:	4a4c      	ldr	r2, [pc, #304]	; (efdc <parseCmd+0x438>)
    eeaa:	687b      	ldr	r3, [r7, #4]
    eeac:	0011      	movs	r1, r2
    eeae:	0018      	movs	r0, r3
    eeb0:	4b27      	ldr	r3, [pc, #156]	; (ef50 <parseCmd+0x3ac>)
    eeb2:	4798      	blx	r3
    eeb4:	0003      	movs	r3, r0
    eeb6:	22c6      	movs	r2, #198	; 0xc6
    eeb8:	0052      	lsls	r2, r2, #1
    eeba:	18ba      	adds	r2, r7, r2
    eebc:	6013      	str	r3, [r2, #0]
    eebe:	23c6      	movs	r3, #198	; 0xc6
    eec0:	005b      	lsls	r3, r3, #1
    eec2:	18fb      	adds	r3, r7, r3
    eec4:	681b      	ldr	r3, [r3, #0]
    eec6:	2b00      	cmp	r3, #0
    eec8:	d017      	beq.n	eefa <parseCmd+0x356>
        int ret = host_generate_challenge();
    eeca:	4b45      	ldr	r3, [pc, #276]	; (efe0 <parseCmd+0x43c>)
    eecc:	4798      	blx	r3
    eece:	0003      	movs	r3, r0
    eed0:	22be      	movs	r2, #190	; 0xbe
    eed2:	0052      	lsls	r2, r2, #1
    eed4:	18ba      	adds	r2, r7, r2
    eed6:	6013      	str	r3, [r2, #0]
        if (ret != ATCA_SUCCESS)
    eed8:	23be      	movs	r3, #190	; 0xbe
    eeda:	005b      	lsls	r3, r3, #1
    eedc:	18fb      	adds	r3, r7, r3
    eede:	681b      	ldr	r3, [r3, #0]
    eee0:	2b00      	cmp	r3, #0
    eee2:	d100      	bne.n	eee6 <parseCmd+0x342>
    eee4:	e0b8      	b.n	f058 <parseCmd+0x4b4>
            printf("host_generate_challenge failed with error code %X\r\n", ret);
    eee6:	23be      	movs	r3, #190	; 0xbe
    eee8:	005b      	lsls	r3, r3, #1
    eeea:	18fb      	adds	r3, r7, r3
    eeec:	681a      	ldr	r2, [r3, #0]
    eeee:	4b3d      	ldr	r3, [pc, #244]	; (efe4 <parseCmd+0x440>)
    eef0:	0011      	movs	r1, r2
    eef2:	0018      	movs	r0, r3
    eef4:	4b25      	ldr	r3, [pc, #148]	; (ef8c <parseCmd+0x3e8>)
    eef6:	4798      	blx	r3
    eef8:	e0ae      	b.n	f058 <parseCmd+0x4b4>
    } else if ( (cmds = strstr( commands, "client-gen-resp")) ) {
    eefa:	4a3b      	ldr	r2, [pc, #236]	; (efe8 <parseCmd+0x444>)
    eefc:	687b      	ldr	r3, [r7, #4]
    eefe:	0011      	movs	r1, r2
    ef00:	0018      	movs	r0, r3
    ef02:	4b13      	ldr	r3, [pc, #76]	; (ef50 <parseCmd+0x3ac>)
    ef04:	4798      	blx	r3
    ef06:	0003      	movs	r3, r0
    ef08:	22c6      	movs	r2, #198	; 0xc6
    ef0a:	0052      	lsls	r2, r2, #1
    ef0c:	18ba      	adds	r2, r7, r2
    ef0e:	6013      	str	r3, [r2, #0]
    ef10:	23c6      	movs	r3, #198	; 0xc6
    ef12:	005b      	lsls	r3, r3, #1
    ef14:	18fb      	adds	r3, r7, r3
    ef16:	681b      	ldr	r3, [r3, #0]
    ef18:	2b00      	cmp	r3, #0
    ef1a:	d06b      	beq.n	eff4 <parseCmd+0x450>
        int ret = client_generate_response();
    ef1c:	4b33      	ldr	r3, [pc, #204]	; (efec <parseCmd+0x448>)
    ef1e:	4798      	blx	r3
    ef20:	0003      	movs	r3, r0
    ef22:	22bc      	movs	r2, #188	; 0xbc
    ef24:	0052      	lsls	r2, r2, #1
    ef26:	18ba      	adds	r2, r7, r2
    ef28:	6013      	str	r3, [r2, #0]
        if (ret != ATCA_SUCCESS)
    ef2a:	23bc      	movs	r3, #188	; 0xbc
    ef2c:	005b      	lsls	r3, r3, #1
    ef2e:	18fb      	adds	r3, r7, r3
    ef30:	681b      	ldr	r3, [r3, #0]
    ef32:	2b00      	cmp	r3, #0
    ef34:	d100      	bne.n	ef38 <parseCmd+0x394>
    ef36:	e08f      	b.n	f058 <parseCmd+0x4b4>
            printf("client_generate_response failed with error code %X\r\n", ret);
    ef38:	23bc      	movs	r3, #188	; 0xbc
    ef3a:	005b      	lsls	r3, r3, #1
    ef3c:	18fb      	adds	r3, r7, r3
    ef3e:	681a      	ldr	r2, [r3, #0]
    ef40:	4b2b      	ldr	r3, [pc, #172]	; (eff0 <parseCmd+0x44c>)
    ef42:	0011      	movs	r1, r2
    ef44:	0018      	movs	r0, r3
    ef46:	4b11      	ldr	r3, [pc, #68]	; (ef8c <parseCmd+0x3e8>)
    ef48:	4798      	blx	r3
    ef4a:	e085      	b.n	f058 <parseCmd+0x4b4>
    ef4c:	000156c0 	.word	0x000156c0
    ef50:	00012d57 	.word	0x00012d57
    ef54:	0000e9a5 	.word	0x0000e9a5
    ef58:	000156c8 	.word	0x000156c8
    ef5c:	0000ea69 	.word	0x0000ea69
    ef60:	000156d4 	.word	0x000156d4
    ef64:	0000eb25 	.word	0x0000eb25
    ef68:	000156dc 	.word	0x000156dc
    ef6c:	00012a8d 	.word	0x00012a8d
    ef70:	000156f8 	.word	0x000156f8
    ef74:	0000eb45 	.word	0x0000eb45
    ef78:	00015704 	.word	0x00015704
    ef7c:	00015720 	.word	0x00015720
    ef80:	0000eb65 	.word	0x0000eb65
    ef84:	0000d0dd 	.word	0x0000d0dd
    ef88:	00015728 	.word	0x00015728
    ef8c:	0001296d 	.word	0x0001296d
    ef90:	0001573c 	.word	0x0001573c
    ef94:	0000ad9d 	.word	0x0000ad9d
    ef98:	0000adcd 	.word	0x0000adcd
    ef9c:	0000adfd 	.word	0x0000adfd
    efa0:	0000afd5 	.word	0x0000afd5
    efa4:	00015744 	.word	0x00015744
    efa8:	00015758 	.word	0x00015758
    efac:	00015768 	.word	0x00015768
    efb0:	0000eb85 	.word	0x0000eb85
    efb4:	00015770 	.word	0x00015770
    efb8:	00015788 	.word	0x00015788
    efbc:	000012ad 	.word	0x000012ad
    efc0:	0001579c 	.word	0x0001579c
    efc4:	000157cc 	.word	0x000157cc
    efc8:	00000965 	.word	0x00000965
    efcc:	000157dc 	.word	0x000157dc
    efd0:	00015810 	.word	0x00015810
    efd4:	00000a99 	.word	0x00000a99
    efd8:	00015824 	.word	0x00015824
    efdc:	00015858 	.word	0x00015858
    efe0:	00000b41 	.word	0x00000b41
    efe4:	00015868 	.word	0x00015868
    efe8:	0001589c 	.word	0x0001589c
    efec:	00000bb5 	.word	0x00000bb5
    eff0:	000158ac 	.word	0x000158ac
    }  else if ( (cmds = strstr( commands, "host-verify-resp")) ) {
    eff4:	4a1b      	ldr	r2, [pc, #108]	; (f064 <parseCmd+0x4c0>)
    eff6:	687b      	ldr	r3, [r7, #4]
    eff8:	0011      	movs	r1, r2
    effa:	0018      	movs	r0, r3
    effc:	4b1a      	ldr	r3, [pc, #104]	; (f068 <parseCmd+0x4c4>)
    effe:	4798      	blx	r3
    f000:	0003      	movs	r3, r0
    f002:	22c6      	movs	r2, #198	; 0xc6
    f004:	0052      	lsls	r2, r2, #1
    f006:	18ba      	adds	r2, r7, r2
    f008:	6013      	str	r3, [r2, #0]
    f00a:	23c6      	movs	r3, #198	; 0xc6
    f00c:	005b      	lsls	r3, r3, #1
    f00e:	18fb      	adds	r3, r7, r3
    f010:	681b      	ldr	r3, [r3, #0]
    f012:	2b00      	cmp	r3, #0
    f014:	d016      	beq.n	f044 <parseCmd+0x4a0>
        int ret = host_verify_response();
    f016:	4b15      	ldr	r3, [pc, #84]	; (f06c <parseCmd+0x4c8>)
    f018:	4798      	blx	r3
    f01a:	0003      	movs	r3, r0
    f01c:	22ba      	movs	r2, #186	; 0xba
    f01e:	0052      	lsls	r2, r2, #1
    f020:	18ba      	adds	r2, r7, r2
    f022:	6013      	str	r3, [r2, #0]
        if (ret != ATCA_SUCCESS)
    f024:	23ba      	movs	r3, #186	; 0xba
    f026:	005b      	lsls	r3, r3, #1
    f028:	18fb      	adds	r3, r7, r3
    f02a:	681b      	ldr	r3, [r3, #0]
    f02c:	2b00      	cmp	r3, #0
    f02e:	d013      	beq.n	f058 <parseCmd+0x4b4>
            printf("verify_response failed with error code %X\r\n", ret);
    f030:	23ba      	movs	r3, #186	; 0xba
    f032:	005b      	lsls	r3, r3, #1
    f034:	18fb      	adds	r3, r7, r3
    f036:	681a      	ldr	r2, [r3, #0]
    f038:	4b0d      	ldr	r3, [pc, #52]	; (f070 <parseCmd+0x4cc>)
    f03a:	0011      	movs	r1, r2
    f03c:	0018      	movs	r0, r3
    f03e:	4b0d      	ldr	r3, [pc, #52]	; (f074 <parseCmd+0x4d0>)
    f040:	4798      	blx	r3
    f042:	e009      	b.n	f058 <parseCmd+0x4b4>
    } else if ( strlen(commands) ) {
    f044:	687b      	ldr	r3, [r7, #4]
    f046:	781b      	ldrb	r3, [r3, #0]
    f048:	2b00      	cmp	r3, #0
    f04a:	d005      	beq.n	f058 <parseCmd+0x4b4>
		printf("\r\nsyntax error in command: %s\r\n", commands);
    f04c:	687a      	ldr	r2, [r7, #4]
    f04e:	4b0a      	ldr	r3, [pc, #40]	; (f078 <parseCmd+0x4d4>)
    f050:	0011      	movs	r1, r2
    f052:	0018      	movs	r0, r3
    f054:	4b07      	ldr	r3, [pc, #28]	; (f074 <parseCmd+0x4d0>)
    f056:	4798      	blx	r3
	}
	
	return ATCA_SUCCESS;
    f058:	2300      	movs	r3, #0
}
    f05a:	0018      	movs	r0, r3
    f05c:	46bd      	mov	sp, r7
    f05e:	b065      	add	sp, #404	; 0x194
    f060:	bd90      	pop	{r4, r7, pc}
    f062:	46c0      	nop			; (mov r8, r8)
    f064:	000158e4 	.word	0x000158e4
    f068:	00012d57 	.word	0x00012d57
    f06c:	00000c35 	.word	0x00000c35
    f070:	000158f8 	.word	0x000158f8
    f074:	0001296d 	.word	0x0001296d
    f078:	00015924 	.word	0x00015924

0000f07c <processCmd>:

/** \brief processCmd empties a circular buffer of stored command characters
 * int a command string, then makes the call to parse and execute the command
 */
int processCmd(void)
{
    f07c:	b580      	push	{r7, lr}
    f07e:	b082      	sub	sp, #8
    f080:	af00      	add	r7, sp, #0
	static char cmd[256];
	uint16_t i = 0;
    f082:	1dbb      	adds	r3, r7, #6
    f084:	2200      	movs	r2, #0
    f086:	801a      	strh	r2, [r3, #0]
	while( !CBUF_IsEmpty(cmdQ) && i < sizeof(cmd))
    f088:	e013      	b.n	f0b2 <processCmd+0x36>
		cmd[i++] = CBUF_Pop( cmdQ );
    f08a:	1dbb      	adds	r3, r7, #6
    f08c:	881b      	ldrh	r3, [r3, #0]
    f08e:	1dba      	adds	r2, r7, #6
    f090:	1c59      	adds	r1, r3, #1
    f092:	8011      	strh	r1, [r2, #0]
    f094:	0019      	movs	r1, r3
    f096:	4b16      	ldr	r3, [pc, #88]	; (f0f0 <processCmd+0x74>)
    f098:	781b      	ldrb	r3, [r3, #0]
    f09a:	b2db      	uxtb	r3, r3
    f09c:	1c5a      	adds	r2, r3, #1
    f09e:	b2d0      	uxtb	r0, r2
    f0a0:	4a13      	ldr	r2, [pc, #76]	; (f0f0 <processCmd+0x74>)
    f0a2:	7010      	strb	r0, [r2, #0]
    f0a4:	001a      	movs	r2, r3
    f0a6:	4b12      	ldr	r3, [pc, #72]	; (f0f0 <processCmd+0x74>)
    f0a8:	189b      	adds	r3, r3, r2
    f0aa:	789b      	ldrb	r3, [r3, #2]
    f0ac:	b2da      	uxtb	r2, r3
    f0ae:	4b11      	ldr	r3, [pc, #68]	; (f0f4 <processCmd+0x78>)
    f0b0:	545a      	strb	r2, [r3, r1]
 */
int processCmd(void)
{
	static char cmd[256];
	uint16_t i = 0;
	while( !CBUF_IsEmpty(cmdQ) && i < sizeof(cmd))
    f0b2:	4b0f      	ldr	r3, [pc, #60]	; (f0f0 <processCmd+0x74>)
    f0b4:	785b      	ldrb	r3, [r3, #1]
    f0b6:	b2da      	uxtb	r2, r3
    f0b8:	4b0d      	ldr	r3, [pc, #52]	; (f0f0 <processCmd+0x74>)
    f0ba:	781b      	ldrb	r3, [r3, #0]
    f0bc:	b2db      	uxtb	r3, r3
    f0be:	429a      	cmp	r2, r3
    f0c0:	d003      	beq.n	f0ca <processCmd+0x4e>
    f0c2:	1dbb      	adds	r3, r7, #6
    f0c4:	881b      	ldrh	r3, [r3, #0]
    f0c6:	2bff      	cmp	r3, #255	; 0xff
    f0c8:	d9df      	bls.n	f08a <processCmd+0xe>
		cmd[i++] = CBUF_Pop( cmdQ );
	cmd[i] = '\0';
    f0ca:	1dbb      	adds	r3, r7, #6
    f0cc:	881b      	ldrh	r3, [r3, #0]
    f0ce:	4a09      	ldr	r2, [pc, #36]	; (f0f4 <processCmd+0x78>)
    f0d0:	2100      	movs	r1, #0
    f0d2:	54d1      	strb	r1, [r2, r3]
	//printf("\r\n%s\r\n", command );
	parseCmd(cmd);
    f0d4:	4b07      	ldr	r3, [pc, #28]	; (f0f4 <processCmd+0x78>)
    f0d6:	0018      	movs	r0, r3
    f0d8:	4b07      	ldr	r3, [pc, #28]	; (f0f8 <processCmd+0x7c>)
    f0da:	4798      	blx	r3
	printf("$ ");
    f0dc:	4b07      	ldr	r3, [pc, #28]	; (f0fc <processCmd+0x80>)
    f0de:	0018      	movs	r0, r3
    f0e0:	4b07      	ldr	r3, [pc, #28]	; (f100 <processCmd+0x84>)
    f0e2:	4798      	blx	r3
	
	return ATCA_SUCCESS;
    f0e4:	2300      	movs	r3, #0
}
    f0e6:	0018      	movs	r0, r3
    f0e8:	46bd      	mov	sp, r7
    f0ea:	b002      	add	sp, #8
    f0ec:	bd80      	pop	{r7, pc}
    f0ee:	46c0      	nop			; (mov r8, r8)
    f0f0:	20001578 	.word	0x20001578
    f0f4:	20000824 	.word	0x20000824
    f0f8:	0000eba5 	.word	0x0000eba5
    f0fc:	00015944 	.word	0x00015944
    f100:	0001296d 	.word	0x0001296d

0000f104 <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
    f104:	b580      	push	{r7, lr}
    f106:	b082      	sub	sp, #8
    f108:	af00      	add	r7, sp, #0
    f10a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    f10c:	687b      	ldr	r3, [r7, #4]
    f10e:	2200      	movs	r2, #0
    f110:	701a      	strb	r2, [r3, #0]
}
    f112:	46c0      	nop			; (mov r8, r8)
    f114:	46bd      	mov	sp, r7
    f116:	b002      	add	sp, #8
    f118:	bd80      	pop	{r7, pc}
    f11a:	46c0      	nop			; (mov r8, r8)

0000f11c <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
    f11c:	b580      	push	{r7, lr}
    f11e:	b082      	sub	sp, #8
    f120:	af00      	add	r7, sp, #0
    f122:	0002      	movs	r2, r0
    f124:	6039      	str	r1, [r7, #0]
    f126:	1dfb      	adds	r3, r7, #7
    f128:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    f12a:	1dfb      	adds	r3, r7, #7
    f12c:	781b      	ldrb	r3, [r3, #0]
    f12e:	2b01      	cmp	r3, #1
    f130:	d00a      	beq.n	f148 <system_apb_clock_set_mask+0x2c>
    f132:	2b02      	cmp	r3, #2
    f134:	d00f      	beq.n	f156 <system_apb_clock_set_mask+0x3a>
    f136:	2b00      	cmp	r3, #0
    f138:	d114      	bne.n	f164 <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    f13a:	4b0e      	ldr	r3, [pc, #56]	; (f174 <system_apb_clock_set_mask+0x58>)
    f13c:	4a0d      	ldr	r2, [pc, #52]	; (f174 <system_apb_clock_set_mask+0x58>)
    f13e:	6991      	ldr	r1, [r2, #24]
    f140:	683a      	ldr	r2, [r7, #0]
    f142:	430a      	orrs	r2, r1
    f144:	619a      	str	r2, [r3, #24]
			break;
    f146:	e00f      	b.n	f168 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
    f148:	4b0a      	ldr	r3, [pc, #40]	; (f174 <system_apb_clock_set_mask+0x58>)
    f14a:	4a0a      	ldr	r2, [pc, #40]	; (f174 <system_apb_clock_set_mask+0x58>)
    f14c:	69d1      	ldr	r1, [r2, #28]
    f14e:	683a      	ldr	r2, [r7, #0]
    f150:	430a      	orrs	r2, r1
    f152:	61da      	str	r2, [r3, #28]
			break;
    f154:	e008      	b.n	f168 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    f156:	4b07      	ldr	r3, [pc, #28]	; (f174 <system_apb_clock_set_mask+0x58>)
    f158:	4a06      	ldr	r2, [pc, #24]	; (f174 <system_apb_clock_set_mask+0x58>)
    f15a:	6a11      	ldr	r1, [r2, #32]
    f15c:	683a      	ldr	r2, [r7, #0]
    f15e:	430a      	orrs	r2, r1
    f160:	621a      	str	r2, [r3, #32]
			break;
    f162:	e001      	b.n	f168 <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
    f164:	2317      	movs	r3, #23
    f166:	e000      	b.n	f16a <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
    f168:	2300      	movs	r3, #0
}
    f16a:	0018      	movs	r0, r3
    f16c:	46bd      	mov	sp, r7
    f16e:	b002      	add	sp, #8
    f170:	bd80      	pop	{r7, pc}
    f172:	46c0      	nop			; (mov r8, r8)
    f174:	40000400 	.word	0x40000400

0000f178 <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
    f178:	b580      	push	{r7, lr}
    f17a:	b082      	sub	sp, #8
    f17c:	af00      	add	r7, sp, #0
    f17e:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    f180:	687b      	ldr	r3, [r7, #4]
    f182:	2280      	movs	r2, #128	; 0x80
    f184:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    f186:	687b      	ldr	r3, [r7, #4]
    f188:	2200      	movs	r2, #0
    f18a:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    f18c:	687b      	ldr	r3, [r7, #4]
    f18e:	2201      	movs	r2, #1
    f190:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    f192:	687b      	ldr	r3, [r7, #4]
    f194:	2200      	movs	r2, #0
    f196:	70da      	strb	r2, [r3, #3]
}
    f198:	46c0      	nop			; (mov r8, r8)
    f19a:	46bd      	mov	sp, r7
    f19c:	b002      	add	sp, #8
    f19e:	bd80      	pop	{r7, pc}

0000f1a0 <system_interrupt_enable>:
 *
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
    f1a0:	b580      	push	{r7, lr}
    f1a2:	b082      	sub	sp, #8
    f1a4:	af00      	add	r7, sp, #0
    f1a6:	0002      	movs	r2, r0
    f1a8:	1dfb      	adds	r3, r7, #7
    f1aa:	701a      	strb	r2, [r3, #0]
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    f1ac:	4b06      	ldr	r3, [pc, #24]	; (f1c8 <system_interrupt_enable+0x28>)
    f1ae:	1dfa      	adds	r2, r7, #7
    f1b0:	7812      	ldrb	r2, [r2, #0]
    f1b2:	0011      	movs	r1, r2
    f1b4:	221f      	movs	r2, #31
    f1b6:	400a      	ands	r2, r1
    f1b8:	2101      	movs	r1, #1
    f1ba:	4091      	lsls	r1, r2
    f1bc:	000a      	movs	r2, r1
    f1be:	601a      	str	r2, [r3, #0]
}
    f1c0:	46c0      	nop			; (mov r8, r8)
    f1c2:	46bd      	mov	sp, r7
    f1c4:	b002      	add	sp, #8
    f1c6:	bd80      	pop	{r7, pc}
    f1c8:	e000e100 	.word	0xe000e100

0000f1cc <_usb_host_interrupt_handler>:
 *   (Device dis/connection, SOF, reset, resume, wakeup, error)
 * - Pipe events
 *   (End of data transfer, setup, stall, error)
 */
static void _usb_host_interrupt_handler(void)
{
    f1cc:	b580      	push	{r7, lr}
    f1ce:	b082      	sub	sp, #8
    f1d0:	af00      	add	r7, sp, #0
	uint32_t pipe_int;
	uint32_t flags;

	/* Manage pipe interrupts */
	pipe_int = ctz(_usb_instances->hw->HOST.PINTSMRY.reg);
    f1d2:	4bbc      	ldr	r3, [pc, #752]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f1d4:	681b      	ldr	r3, [r3, #0]
    f1d6:	681b      	ldr	r3, [r3, #0]
    f1d8:	8c1b      	ldrh	r3, [r3, #32]
    f1da:	b29b      	uxth	r3, r3
    f1dc:	001a      	movs	r2, r3
    f1de:	4bba      	ldr	r3, [pc, #744]	; (f4c8 <_usb_host_interrupt_handler+0x2fc>)
    f1e0:	0010      	movs	r0, r2
    f1e2:	4798      	blx	r3
    f1e4:	0003      	movs	r3, r0
    f1e6:	607b      	str	r3, [r7, #4]
	if (pipe_int < 32) {
    f1e8:	687b      	ldr	r3, [r7, #4]
    f1ea:	2b1f      	cmp	r3, #31
    f1ec:	d900      	bls.n	f1f0 <_usb_host_interrupt_handler+0x24>
    f1ee:	e175      	b.n	f4dc <_usb_host_interrupt_handler+0x310>
		/* pipe interrupts */

		/* get interrupt flags */
		flags = _usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg;
    f1f0:	4bb4      	ldr	r3, [pc, #720]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f1f2:	681b      	ldr	r3, [r3, #0]
    f1f4:	681a      	ldr	r2, [r3, #0]
    f1f6:	687b      	ldr	r3, [r7, #4]
    f1f8:	3308      	adds	r3, #8
    f1fa:	015b      	lsls	r3, r3, #5
    f1fc:	18d3      	adds	r3, r2, r3
    f1fe:	3307      	adds	r3, #7
    f200:	781b      	ldrb	r3, [r3, #0]
    f202:	b2db      	uxtb	r3, r3
    f204:	603b      	str	r3, [r7, #0]

		/* host pipe transfer complete interrupt */
		if (flags & USB_HOST_PINTFLAG_TRCPT_Msk) {
    f206:	683b      	ldr	r3, [r7, #0]
    f208:	2203      	movs	r2, #3
    f20a:	4013      	ands	r3, r2
    f20c:	d100      	bne.n	f210 <_usb_host_interrupt_handler+0x44>
    f20e:	e088      	b.n	f322 <_usb_host_interrupt_handler+0x156>
			/* Clear busy status */
			host_pipe_job_busy_status &= ~(1 << pipe_int);
    f210:	2201      	movs	r2, #1
    f212:	687b      	ldr	r3, [r7, #4]
    f214:	409a      	lsls	r2, r3
    f216:	0013      	movs	r3, r2
    f218:	43db      	mvns	r3, r3
    f21a:	001a      	movs	r2, r3
    f21c:	4bab      	ldr	r3, [pc, #684]	; (f4cc <_usb_host_interrupt_handler+0x300>)
    f21e:	681b      	ldr	r3, [r3, #0]
    f220:	401a      	ands	r2, r3
    f222:	4baa      	ldr	r3, [pc, #680]	; (f4cc <_usb_host_interrupt_handler+0x300>)
    f224:	601a      	str	r2, [r3, #0]
			/* clear the flag */
			_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
    f226:	4ba7      	ldr	r3, [pc, #668]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f228:	681b      	ldr	r3, [r3, #0]
    f22a:	681a      	ldr	r2, [r3, #0]
    f22c:	687b      	ldr	r3, [r7, #4]
    f22e:	3308      	adds	r3, #8
    f230:	015b      	lsls	r3, r3, #5
    f232:	18d3      	adds	r3, r2, r3
    f234:	3307      	adds	r3, #7
    f236:	2203      	movs	r2, #3
    f238:	701a      	strb	r2, [r3, #0]
					USB_HOST_PINTFLAG_TRCPT_Msk;
			if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
    f23a:	4ba2      	ldr	r3, [pc, #648]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f23c:	681a      	ldr	r2, [r3, #0]
    f23e:	21ae      	movs	r1, #174	; 0xae
    f240:	687b      	ldr	r3, [r7, #4]
    f242:	18d3      	adds	r3, r2, r3
    f244:	185b      	adds	r3, r3, r1
    f246:	781b      	ldrb	r3, [r3, #0]
    f248:	001a      	movs	r2, r3
    f24a:	2301      	movs	r3, #1
    f24c:	4013      	ands	r3, r2
    f24e:	d068      	beq.n	f322 <_usb_host_interrupt_handler+0x156>
					(1 << USB_HOST_PIPE_CALLBACK_TRANSFER_COMPLETE)) {
				pipe_callback_para.pipe_num = pipe_int;
    f250:	687b      	ldr	r3, [r7, #4]
    f252:	b2da      	uxtb	r2, r3
    f254:	4b9e      	ldr	r3, [pc, #632]	; (f4d0 <_usb_host_interrupt_handler+0x304>)
    f256:	701a      	strb	r2, [r3, #0]
				if (_usb_instances->hw->HOST.HostPipe[pipe_int].PCFG.bit.PTOKEN ==
    f258:	4b9a      	ldr	r3, [pc, #616]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f25a:	681b      	ldr	r3, [r3, #0]
    f25c:	681b      	ldr	r3, [r3, #0]
    f25e:	687a      	ldr	r2, [r7, #4]
    f260:	3208      	adds	r2, #8
    f262:	0152      	lsls	r2, r2, #5
    f264:	5cd3      	ldrb	r3, [r2, r3]
    f266:	079b      	lsls	r3, r3, #30
    f268:	0f9b      	lsrs	r3, r3, #30
    f26a:	b2db      	uxtb	r3, r3
    f26c:	2b01      	cmp	r3, #1
    f26e:	d11e      	bne.n	f2ae <_usb_host_interrupt_handler+0xe2>
							USB_HOST_PIPE_TOKEN_IN) {
					/* in  */
					pipe_callback_para.transfered_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.BYTE_COUNT;
    f270:	4a98      	ldr	r2, [pc, #608]	; (f4d4 <_usb_host_interrupt_handler+0x308>)
    f272:	687b      	ldr	r3, [r7, #4]
    f274:	015b      	lsls	r3, r3, #5
    f276:	18d3      	adds	r3, r2, r3
    f278:	685b      	ldr	r3, [r3, #4]
    f27a:	049b      	lsls	r3, r3, #18
    f27c:	0c9b      	lsrs	r3, r3, #18
    f27e:	b29b      	uxth	r3, r3
    f280:	001a      	movs	r2, r3
    f282:	4b93      	ldr	r3, [pc, #588]	; (f4d0 <_usb_host_interrupt_handler+0x304>)
    f284:	805a      	strh	r2, [r3, #2]
					pipe_callback_para.required_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE;
    f286:	4a93      	ldr	r2, [pc, #588]	; (f4d4 <_usb_host_interrupt_handler+0x308>)
    f288:	687b      	ldr	r3, [r7, #4]
    f28a:	015b      	lsls	r3, r3, #5
    f28c:	18d3      	adds	r3, r2, r3
    f28e:	685b      	ldr	r3, [r3, #4]
    f290:	011b      	lsls	r3, r3, #4
    f292:	0c9b      	lsrs	r3, r3, #18
    f294:	b29b      	uxth	r3, r3
    f296:	001a      	movs	r2, r3
    f298:	4b8d      	ldr	r3, [pc, #564]	; (f4d0 <_usb_host_interrupt_handler+0x304>)
    f29a:	809a      	strh	r2, [r3, #4]
					usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.BYTE_COUNT = 0;
    f29c:	4a8d      	ldr	r2, [pc, #564]	; (f4d4 <_usb_host_interrupt_handler+0x308>)
    f29e:	687b      	ldr	r3, [r7, #4]
    f2a0:	015b      	lsls	r3, r3, #5
    f2a2:	18d3      	adds	r3, r2, r3
    f2a4:	685a      	ldr	r2, [r3, #4]
    f2a6:	0b92      	lsrs	r2, r2, #14
    f2a8:	0392      	lsls	r2, r2, #14
    f2aa:	605a      	str	r2, [r3, #4]
    f2ac:	e02c      	b.n	f308 <_usb_host_interrupt_handler+0x13c>
				} else {
					/* out */
					pipe_callback_para.transfered_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE;
    f2ae:	4a89      	ldr	r2, [pc, #548]	; (f4d4 <_usb_host_interrupt_handler+0x308>)
    f2b0:	687b      	ldr	r3, [r7, #4]
    f2b2:	015b      	lsls	r3, r3, #5
    f2b4:	18d3      	adds	r3, r2, r3
    f2b6:	685b      	ldr	r3, [r3, #4]
    f2b8:	011b      	lsls	r3, r3, #4
    f2ba:	0c9b      	lsrs	r3, r3, #18
    f2bc:	b29b      	uxth	r3, r3
    f2be:	001a      	movs	r2, r3
    f2c0:	4b83      	ldr	r3, [pc, #524]	; (f4d0 <_usb_host_interrupt_handler+0x304>)
    f2c2:	805a      	strh	r2, [r3, #2]
					pipe_callback_para.required_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.BYTE_COUNT;
    f2c4:	4a83      	ldr	r2, [pc, #524]	; (f4d4 <_usb_host_interrupt_handler+0x308>)
    f2c6:	687b      	ldr	r3, [r7, #4]
    f2c8:	015b      	lsls	r3, r3, #5
    f2ca:	18d3      	adds	r3, r2, r3
    f2cc:	685b      	ldr	r3, [r3, #4]
    f2ce:	049b      	lsls	r3, r3, #18
    f2d0:	0c9b      	lsrs	r3, r3, #18
    f2d2:	b29b      	uxth	r3, r3
    f2d4:	001a      	movs	r2, r3
    f2d6:	4b7e      	ldr	r3, [pc, #504]	; (f4d0 <_usb_host_interrupt_handler+0x304>)
    f2d8:	809a      	strh	r2, [r3, #4]
					usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = 0;
    f2da:	4a7e      	ldr	r2, [pc, #504]	; (f4d4 <_usb_host_interrupt_handler+0x308>)
    f2dc:	687b      	ldr	r3, [r7, #4]
    f2de:	015b      	lsls	r3, r3, #5
    f2e0:	18d3      	adds	r3, r2, r3
    f2e2:	685a      	ldr	r2, [r3, #4]
    f2e4:	497c      	ldr	r1, [pc, #496]	; (f4d8 <_usb_host_interrupt_handler+0x30c>)
    f2e6:	400a      	ands	r2, r1
    f2e8:	605a      	str	r2, [r3, #4]
					if (0 == pipe_callback_para.transfered_size) {
    f2ea:	4b79      	ldr	r3, [pc, #484]	; (f4d0 <_usb_host_interrupt_handler+0x304>)
    f2ec:	885b      	ldrh	r3, [r3, #2]
    f2ee:	2b00      	cmp	r3, #0
    f2f0:	d10a      	bne.n	f308 <_usb_host_interrupt_handler+0x13c>
						pipe_callback_para.transfered_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.BYTE_COUNT;
    f2f2:	4a78      	ldr	r2, [pc, #480]	; (f4d4 <_usb_host_interrupt_handler+0x308>)
    f2f4:	687b      	ldr	r3, [r7, #4]
    f2f6:	015b      	lsls	r3, r3, #5
    f2f8:	18d3      	adds	r3, r2, r3
    f2fa:	685b      	ldr	r3, [r3, #4]
    f2fc:	049b      	lsls	r3, r3, #18
    f2fe:	0c9b      	lsrs	r3, r3, #18
    f300:	b29b      	uxth	r3, r3
    f302:	001a      	movs	r2, r3
    f304:	4b72      	ldr	r3, [pc, #456]	; (f4d0 <_usb_host_interrupt_handler+0x304>)
    f306:	805a      	strh	r2, [r3, #2]
					}
				}
				(_usb_instances->host_pipe_callback[pipe_int]
    f308:	4b6e      	ldr	r3, [pc, #440]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f30a:	681a      	ldr	r2, [r3, #0]
						[USB_HOST_PIPE_CALLBACK_TRANSFER_COMPLETE])(_usb_instances, &pipe_callback_para);
    f30c:	687b      	ldr	r3, [r7, #4]
    f30e:	3302      	adds	r3, #2
    f310:	011b      	lsls	r3, r3, #4
    f312:	18d3      	adds	r3, r2, r3
    f314:	3304      	adds	r3, #4
    f316:	681a      	ldr	r2, [r3, #0]
					usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = 0;
					if (0 == pipe_callback_para.transfered_size) {
						pipe_callback_para.transfered_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.BYTE_COUNT;
					}
				}
				(_usb_instances->host_pipe_callback[pipe_int]
    f318:	4b6a      	ldr	r3, [pc, #424]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f31a:	681b      	ldr	r3, [r3, #0]
    f31c:	496c      	ldr	r1, [pc, #432]	; (f4d0 <_usb_host_interrupt_handler+0x304>)
    f31e:	0018      	movs	r0, r3
    f320:	4790      	blx	r2
						[USB_HOST_PIPE_CALLBACK_TRANSFER_COMPLETE])(_usb_instances, &pipe_callback_para);
			}
		}

		/* host pipe transfer fail interrupt */
		if (flags & USB_HOST_PINTFLAG_TRFAIL) {
    f322:	683b      	ldr	r3, [r7, #0]
    f324:	2204      	movs	r2, #4
    f326:	4013      	ands	r3, r2
    f328:	d014      	beq.n	f354 <_usb_host_interrupt_handler+0x188>
			/* Clear busy status */
			host_pipe_job_busy_status &= ~(1 << pipe_int);
    f32a:	2201      	movs	r2, #1
    f32c:	687b      	ldr	r3, [r7, #4]
    f32e:	409a      	lsls	r2, r3
    f330:	0013      	movs	r3, r2
    f332:	43db      	mvns	r3, r3
    f334:	001a      	movs	r2, r3
    f336:	4b65      	ldr	r3, [pc, #404]	; (f4cc <_usb_host_interrupt_handler+0x300>)
    f338:	681b      	ldr	r3, [r3, #0]
    f33a:	401a      	ands	r2, r3
    f33c:	4b63      	ldr	r3, [pc, #396]	; (f4cc <_usb_host_interrupt_handler+0x300>)
    f33e:	601a      	str	r2, [r3, #0]
			/* clear the flag */
			_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
    f340:	4b60      	ldr	r3, [pc, #384]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f342:	681b      	ldr	r3, [r3, #0]
    f344:	681a      	ldr	r2, [r3, #0]
    f346:	687b      	ldr	r3, [r7, #4]
    f348:	3308      	adds	r3, #8
    f34a:	015b      	lsls	r3, r3, #5
    f34c:	18d3      	adds	r3, r2, r3
    f34e:	3307      	adds	r3, #7
    f350:	2204      	movs	r2, #4
    f352:	701a      	strb	r2, [r3, #0]
					USB_HOST_PINTFLAG_TRFAIL;
		}

		/* host pipe error interrupt */
		if (flags & USB_HOST_PINTFLAG_PERR) {
    f354:	683b      	ldr	r3, [r7, #0]
    f356:	2208      	movs	r2, #8
    f358:	4013      	ands	r3, r2
    f35a:	d03c      	beq.n	f3d6 <_usb_host_interrupt_handler+0x20a>
			/* Clear busy status */
			host_pipe_job_busy_status &= ~(1 << pipe_int);
    f35c:	2201      	movs	r2, #1
    f35e:	687b      	ldr	r3, [r7, #4]
    f360:	409a      	lsls	r2, r3
    f362:	0013      	movs	r3, r2
    f364:	43db      	mvns	r3, r3
    f366:	001a      	movs	r2, r3
    f368:	4b58      	ldr	r3, [pc, #352]	; (f4cc <_usb_host_interrupt_handler+0x300>)
    f36a:	681b      	ldr	r3, [r3, #0]
    f36c:	401a      	ands	r2, r3
    f36e:	4b57      	ldr	r3, [pc, #348]	; (f4cc <_usb_host_interrupt_handler+0x300>)
    f370:	601a      	str	r2, [r3, #0]
			/* clear the flag */
			_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
    f372:	4b54      	ldr	r3, [pc, #336]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f374:	681b      	ldr	r3, [r3, #0]
    f376:	681a      	ldr	r2, [r3, #0]
    f378:	687b      	ldr	r3, [r7, #4]
    f37a:	3308      	adds	r3, #8
    f37c:	015b      	lsls	r3, r3, #5
    f37e:	18d3      	adds	r3, r2, r3
    f380:	3307      	adds	r3, #7
    f382:	2208      	movs	r2, #8
    f384:	701a      	strb	r2, [r3, #0]
					USB_HOST_PINTFLAG_PERR;
			if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
    f386:	4b4f      	ldr	r3, [pc, #316]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f388:	681a      	ldr	r2, [r3, #0]
    f38a:	21ae      	movs	r1, #174	; 0xae
    f38c:	687b      	ldr	r3, [r7, #4]
    f38e:	18d3      	adds	r3, r2, r3
    f390:	185b      	adds	r3, r3, r1
    f392:	781b      	ldrb	r3, [r3, #0]
    f394:	001a      	movs	r2, r3
    f396:	2302      	movs	r3, #2
    f398:	4013      	ands	r3, r2
    f39a:	d01c      	beq.n	f3d6 <_usb_host_interrupt_handler+0x20a>
					(1 << USB_HOST_PIPE_CALLBACK_ERROR)) {
				pipe_callback_para.pipe_num = pipe_int;
    f39c:	687b      	ldr	r3, [r7, #4]
    f39e:	b2da      	uxtb	r2, r3
    f3a0:	4b4b      	ldr	r3, [pc, #300]	; (f4d0 <_usb_host_interrupt_handler+0x304>)
    f3a2:	701a      	strb	r2, [r3, #0]
				pipe_callback_para.pipe_error_status =
						usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].STATUS_PIPE.reg & 0x1F;
    f3a4:	4a4b      	ldr	r2, [pc, #300]	; (f4d4 <_usb_host_interrupt_handler+0x308>)
    f3a6:	687b      	ldr	r3, [r7, #4]
    f3a8:	015b      	lsls	r3, r3, #5
    f3aa:	18d3      	adds	r3, r2, r3
    f3ac:	330e      	adds	r3, #14
    f3ae:	881b      	ldrh	r3, [r3, #0]
    f3b0:	b29b      	uxth	r3, r3
			_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
					USB_HOST_PINTFLAG_PERR;
			if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
					(1 << USB_HOST_PIPE_CALLBACK_ERROR)) {
				pipe_callback_para.pipe_num = pipe_int;
				pipe_callback_para.pipe_error_status =
    f3b2:	b2db      	uxtb	r3, r3
    f3b4:	221f      	movs	r2, #31
    f3b6:	4013      	ands	r3, r2
    f3b8:	b2da      	uxtb	r2, r3
    f3ba:	4b45      	ldr	r3, [pc, #276]	; (f4d0 <_usb_host_interrupt_handler+0x304>)
    f3bc:	705a      	strb	r2, [r3, #1]
						usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].STATUS_PIPE.reg & 0x1F;
				(_usb_instances->host_pipe_callback[pipe_int]
    f3be:	4b41      	ldr	r3, [pc, #260]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f3c0:	681a      	ldr	r2, [r3, #0]
						[USB_HOST_PIPE_CALLBACK_ERROR])(_usb_instances, &pipe_callback_para);
    f3c2:	687b      	ldr	r3, [r7, #4]
    f3c4:	011b      	lsls	r3, r3, #4
    f3c6:	18d3      	adds	r3, r2, r3
    f3c8:	3328      	adds	r3, #40	; 0x28
    f3ca:	681a      	ldr	r2, [r3, #0]
			if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
					(1 << USB_HOST_PIPE_CALLBACK_ERROR)) {
				pipe_callback_para.pipe_num = pipe_int;
				pipe_callback_para.pipe_error_status =
						usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].STATUS_PIPE.reg & 0x1F;
				(_usb_instances->host_pipe_callback[pipe_int]
    f3cc:	4b3d      	ldr	r3, [pc, #244]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f3ce:	681b      	ldr	r3, [r3, #0]
    f3d0:	493f      	ldr	r1, [pc, #252]	; (f4d0 <_usb_host_interrupt_handler+0x304>)
    f3d2:	0018      	movs	r0, r3
    f3d4:	4790      	blx	r2
						[USB_HOST_PIPE_CALLBACK_ERROR])(_usb_instances, &pipe_callback_para);
			}
		}

		/* host pipe transmitted setup interrupt */
		if (flags & USB_HOST_PINTFLAG_TXSTP) {
    f3d6:	683b      	ldr	r3, [r7, #0]
    f3d8:	2210      	movs	r2, #16
    f3da:	4013      	ands	r3, r2
    f3dc:	d03a      	beq.n	f454 <_usb_host_interrupt_handler+0x288>
			/* Clear busy status */
			host_pipe_job_busy_status &= ~(1 << pipe_int);
    f3de:	2201      	movs	r2, #1
    f3e0:	687b      	ldr	r3, [r7, #4]
    f3e2:	409a      	lsls	r2, r3
    f3e4:	0013      	movs	r3, r2
    f3e6:	43db      	mvns	r3, r3
    f3e8:	001a      	movs	r2, r3
    f3ea:	4b38      	ldr	r3, [pc, #224]	; (f4cc <_usb_host_interrupt_handler+0x300>)
    f3ec:	681b      	ldr	r3, [r3, #0]
    f3ee:	401a      	ands	r2, r3
    f3f0:	4b36      	ldr	r3, [pc, #216]	; (f4cc <_usb_host_interrupt_handler+0x300>)
    f3f2:	601a      	str	r2, [r3, #0]
			/* clear the flag */
			_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
    f3f4:	4b33      	ldr	r3, [pc, #204]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f3f6:	681b      	ldr	r3, [r3, #0]
    f3f8:	681a      	ldr	r2, [r3, #0]
    f3fa:	687b      	ldr	r3, [r7, #4]
    f3fc:	3308      	adds	r3, #8
    f3fe:	015b      	lsls	r3, r3, #5
    f400:	18d3      	adds	r3, r2, r3
    f402:	3307      	adds	r3, #7
    f404:	2210      	movs	r2, #16
    f406:	701a      	strb	r2, [r3, #0]
					USB_HOST_PINTFLAG_TXSTP;
			if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
    f408:	4b2e      	ldr	r3, [pc, #184]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f40a:	681a      	ldr	r2, [r3, #0]
    f40c:	21ae      	movs	r1, #174	; 0xae
    f40e:	687b      	ldr	r3, [r7, #4]
    f410:	18d3      	adds	r3, r2, r3
    f412:	185b      	adds	r3, r3, r1
    f414:	781b      	ldrb	r3, [r3, #0]
    f416:	001a      	movs	r2, r3
    f418:	2304      	movs	r3, #4
    f41a:	4013      	ands	r3, r2
    f41c:	d01a      	beq.n	f454 <_usb_host_interrupt_handler+0x288>
					(1 << USB_HOST_PIPE_CALLBACK_SETUP)) {
				pipe_callback_para.pipe_num = pipe_int;
    f41e:	687b      	ldr	r3, [r7, #4]
    f420:	b2da      	uxtb	r2, r3
    f422:	4b2b      	ldr	r3, [pc, #172]	; (f4d0 <_usb_host_interrupt_handler+0x304>)
    f424:	701a      	strb	r2, [r3, #0]
				pipe_callback_para.transfered_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE;
    f426:	4a2b      	ldr	r2, [pc, #172]	; (f4d4 <_usb_host_interrupt_handler+0x308>)
    f428:	687b      	ldr	r3, [r7, #4]
    f42a:	015b      	lsls	r3, r3, #5
    f42c:	18d3      	adds	r3, r2, r3
    f42e:	685b      	ldr	r3, [r3, #4]
    f430:	011b      	lsls	r3, r3, #4
    f432:	0c9b      	lsrs	r3, r3, #18
    f434:	b29b      	uxth	r3, r3
    f436:	001a      	movs	r2, r3
    f438:	4b25      	ldr	r3, [pc, #148]	; (f4d0 <_usb_host_interrupt_handler+0x304>)
    f43a:	805a      	strh	r2, [r3, #2]
				(_usb_instances->host_pipe_callback[pipe_int]
    f43c:	4b21      	ldr	r3, [pc, #132]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f43e:	681a      	ldr	r2, [r3, #0]
						[USB_HOST_PIPE_CALLBACK_SETUP])(_usb_instances, NULL);
    f440:	687b      	ldr	r3, [r7, #4]
    f442:	011b      	lsls	r3, r3, #4
    f444:	18d3      	adds	r3, r2, r3
    f446:	332c      	adds	r3, #44	; 0x2c
    f448:	681a      	ldr	r2, [r3, #0]
					USB_HOST_PINTFLAG_TXSTP;
			if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
					(1 << USB_HOST_PIPE_CALLBACK_SETUP)) {
				pipe_callback_para.pipe_num = pipe_int;
				pipe_callback_para.transfered_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE;
				(_usb_instances->host_pipe_callback[pipe_int]
    f44a:	4b1e      	ldr	r3, [pc, #120]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f44c:	681b      	ldr	r3, [r3, #0]
    f44e:	2100      	movs	r1, #0
    f450:	0018      	movs	r0, r3
    f452:	4790      	blx	r2
						[USB_HOST_PIPE_CALLBACK_SETUP])(_usb_instances, NULL);
			}
		}

		/* host pipe stall interrupt */
		if (flags & USB_HOST_PINTFLAG_STALL) {
    f454:	683b      	ldr	r3, [r7, #0]
    f456:	2220      	movs	r2, #32
    f458:	4013      	ands	r3, r2
    f45a:	d100      	bne.n	f45e <_usb_host_interrupt_handler+0x292>
    f45c:	e113      	b.n	f686 <_usb_host_interrupt_handler+0x4ba>
			/* Clear busy status */
			host_pipe_job_busy_status &= ~(1 << pipe_int);
    f45e:	2201      	movs	r2, #1
    f460:	687b      	ldr	r3, [r7, #4]
    f462:	409a      	lsls	r2, r3
    f464:	0013      	movs	r3, r2
    f466:	43db      	mvns	r3, r3
    f468:	001a      	movs	r2, r3
    f46a:	4b18      	ldr	r3, [pc, #96]	; (f4cc <_usb_host_interrupt_handler+0x300>)
    f46c:	681b      	ldr	r3, [r3, #0]
    f46e:	401a      	ands	r2, r3
    f470:	4b16      	ldr	r3, [pc, #88]	; (f4cc <_usb_host_interrupt_handler+0x300>)
    f472:	601a      	str	r2, [r3, #0]
			/* clear the flag */
			_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
    f474:	4b13      	ldr	r3, [pc, #76]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f476:	681b      	ldr	r3, [r3, #0]
    f478:	681a      	ldr	r2, [r3, #0]
    f47a:	687b      	ldr	r3, [r7, #4]
    f47c:	3308      	adds	r3, #8
    f47e:	015b      	lsls	r3, r3, #5
    f480:	18d3      	adds	r3, r2, r3
    f482:	3307      	adds	r3, #7
    f484:	2220      	movs	r2, #32
    f486:	701a      	strb	r2, [r3, #0]
					USB_HOST_PINTFLAG_STALL;
			if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
    f488:	4b0e      	ldr	r3, [pc, #56]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f48a:	681a      	ldr	r2, [r3, #0]
    f48c:	21ae      	movs	r1, #174	; 0xae
    f48e:	687b      	ldr	r3, [r7, #4]
    f490:	18d3      	adds	r3, r2, r3
    f492:	185b      	adds	r3, r3, r1
    f494:	781b      	ldrb	r3, [r3, #0]
    f496:	001a      	movs	r2, r3
    f498:	2308      	movs	r3, #8
    f49a:	4013      	ands	r3, r2
    f49c:	d100      	bne.n	f4a0 <_usb_host_interrupt_handler+0x2d4>
    f49e:	e0f2      	b.n	f686 <_usb_host_interrupt_handler+0x4ba>
					(1 << USB_HOST_PIPE_CALLBACK_STALL)) {
				pipe_callback_para.pipe_num = pipe_int;
    f4a0:	687b      	ldr	r3, [r7, #4]
    f4a2:	b2da      	uxtb	r2, r3
    f4a4:	4b0a      	ldr	r3, [pc, #40]	; (f4d0 <_usb_host_interrupt_handler+0x304>)
    f4a6:	701a      	strb	r2, [r3, #0]
				(_usb_instances->host_pipe_callback[pipe_int]
    f4a8:	4b06      	ldr	r3, [pc, #24]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f4aa:	681a      	ldr	r2, [r3, #0]
						[USB_HOST_PIPE_CALLBACK_STALL])(_usb_instances, &pipe_callback_para);
    f4ac:	687b      	ldr	r3, [r7, #4]
    f4ae:	011b      	lsls	r3, r3, #4
    f4b0:	18d3      	adds	r3, r2, r3
    f4b2:	3330      	adds	r3, #48	; 0x30
    f4b4:	681a      	ldr	r2, [r3, #0]
			_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
					USB_HOST_PINTFLAG_STALL;
			if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
					(1 << USB_HOST_PIPE_CALLBACK_STALL)) {
				pipe_callback_para.pipe_num = pipe_int;
				(_usb_instances->host_pipe_callback[pipe_int]
    f4b6:	4b03      	ldr	r3, [pc, #12]	; (f4c4 <_usb_host_interrupt_handler+0x2f8>)
    f4b8:	681b      	ldr	r3, [r3, #0]
    f4ba:	4905      	ldr	r1, [pc, #20]	; (f4d0 <_usb_host_interrupt_handler+0x304>)
    f4bc:	0018      	movs	r0, r3
    f4be:	4790      	blx	r2
				(_usb_instances->host_callback[USB_HOST_CALLBACK_DISCONNECT])(_usb_instances);
			}
		}

	}
}
    f4c0:	e0e1      	b.n	f686 <_usb_host_interrupt_handler+0x4ba>
    f4c2:	46c0      	nop			; (mov r8, r8)
    f4c4:	20000924 	.word	0x20000924
    f4c8:	000124e5 	.word	0x000124e5
    f4cc:	2000093c 	.word	0x2000093c
    f4d0:	20000928 	.word	0x20000928
    f4d4:	2000177c 	.word	0x2000177c
    f4d8:	f0003fff 	.word	0xf0003fff

	} else {
		/* host interrupts */

		/* get interrupt flags */
		flags = _usb_instances->hw->HOST.INTFLAG.reg;
    f4dc:	4b6c      	ldr	r3, [pc, #432]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f4de:	681b      	ldr	r3, [r3, #0]
    f4e0:	681b      	ldr	r3, [r3, #0]
    f4e2:	8b9b      	ldrh	r3, [r3, #28]
    f4e4:	b29b      	uxth	r3, r3
    f4e6:	603b      	str	r3, [r7, #0]

		/* host SOF interrupt */
		if (flags & USB_HOST_INTFLAG_HSOF) {
    f4e8:	683b      	ldr	r3, [r7, #0]
    f4ea:	2204      	movs	r2, #4
    f4ec:	4013      	ands	r3, r2
    f4ee:	d013      	beq.n	f518 <_usb_host_interrupt_handler+0x34c>
			/* clear the flag */
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_HSOF;
    f4f0:	4b67      	ldr	r3, [pc, #412]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f4f2:	681b      	ldr	r3, [r3, #0]
    f4f4:	681b      	ldr	r3, [r3, #0]
    f4f6:	2204      	movs	r2, #4
    f4f8:	839a      	strh	r2, [r3, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_SOF)) {
    f4fa:	4b65      	ldr	r3, [pc, #404]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f4fc:	681b      	ldr	r3, [r3, #0]
    f4fe:	22a5      	movs	r2, #165	; 0xa5
    f500:	5c9b      	ldrb	r3, [r3, r2]
    f502:	001a      	movs	r2, r3
    f504:	2301      	movs	r3, #1
    f506:	4013      	ands	r3, r2
    f508:	d006      	beq.n	f518 <_usb_host_interrupt_handler+0x34c>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_SOF])(_usb_instances);
    f50a:	4b61      	ldr	r3, [pc, #388]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f50c:	681b      	ldr	r3, [r3, #0]
    f50e:	685a      	ldr	r2, [r3, #4]
    f510:	4b5f      	ldr	r3, [pc, #380]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f512:	681b      	ldr	r3, [r3, #0]
    f514:	0018      	movs	r0, r3
    f516:	4790      	blx	r2
			}
		}

		/* host reset interrupt */
		if (flags & USB_HOST_INTFLAG_RST) {
    f518:	683b      	ldr	r3, [r7, #0]
    f51a:	2208      	movs	r2, #8
    f51c:	4013      	ands	r3, r2
    f51e:	d016      	beq.n	f54e <_usb_host_interrupt_handler+0x382>
			/* Clear busy status */
			host_pipe_job_busy_status = 0;
    f520:	4b5c      	ldr	r3, [pc, #368]	; (f694 <_usb_host_interrupt_handler+0x4c8>)
    f522:	2200      	movs	r2, #0
    f524:	601a      	str	r2, [r3, #0]
			/* clear the flag */
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_RST;
    f526:	4b5a      	ldr	r3, [pc, #360]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f528:	681b      	ldr	r3, [r3, #0]
    f52a:	681b      	ldr	r3, [r3, #0]
    f52c:	2208      	movs	r2, #8
    f52e:	839a      	strh	r2, [r3, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_RESET)) {
    f530:	4b57      	ldr	r3, [pc, #348]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f532:	681b      	ldr	r3, [r3, #0]
    f534:	22a5      	movs	r2, #165	; 0xa5
    f536:	5c9b      	ldrb	r3, [r3, r2]
    f538:	001a      	movs	r2, r3
    f53a:	2302      	movs	r3, #2
    f53c:	4013      	ands	r3, r2
    f53e:	d006      	beq.n	f54e <_usb_host_interrupt_handler+0x382>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_RESET])(_usb_instances);
    f540:	4b53      	ldr	r3, [pc, #332]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f542:	681b      	ldr	r3, [r3, #0]
    f544:	689a      	ldr	r2, [r3, #8]
    f546:	4b52      	ldr	r3, [pc, #328]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f548:	681b      	ldr	r3, [r3, #0]
    f54a:	0018      	movs	r0, r3
    f54c:	4790      	blx	r2
			}
		}

		/* host upstream resume interrupts */
		if (flags & USB_HOST_INTFLAG_UPRSM) {
    f54e:	683b      	ldr	r3, [r7, #0]
    f550:	2240      	movs	r2, #64	; 0x40
    f552:	4013      	ands	r3, r2
    f554:	d013      	beq.n	f57e <_usb_host_interrupt_handler+0x3b2>
			/* clear the flags */
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_UPRSM;
    f556:	4b4e      	ldr	r3, [pc, #312]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f558:	681b      	ldr	r3, [r3, #0]
    f55a:	681b      	ldr	r3, [r3, #0]
    f55c:	2240      	movs	r2, #64	; 0x40
    f55e:	839a      	strh	r2, [r3, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_UPRSM)) {
    f560:	4b4b      	ldr	r3, [pc, #300]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f562:	681b      	ldr	r3, [r3, #0]
    f564:	22a5      	movs	r2, #165	; 0xa5
    f566:	5c9b      	ldrb	r3, [r3, r2]
    f568:	001a      	movs	r2, r3
    f56a:	2310      	movs	r3, #16
    f56c:	4013      	ands	r3, r2
    f56e:	d006      	beq.n	f57e <_usb_host_interrupt_handler+0x3b2>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_UPRSM])(_usb_instances);
    f570:	4b47      	ldr	r3, [pc, #284]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f572:	681b      	ldr	r3, [r3, #0]
    f574:	695a      	ldr	r2, [r3, #20]
    f576:	4b46      	ldr	r3, [pc, #280]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f578:	681b      	ldr	r3, [r3, #0]
    f57a:	0018      	movs	r0, r3
    f57c:	4790      	blx	r2
			}
		}

		/* host downstream resume interrupts */
		if (flags & USB_HOST_INTFLAG_DNRSM) {
    f57e:	683b      	ldr	r3, [r7, #0]
    f580:	2220      	movs	r2, #32
    f582:	4013      	ands	r3, r2
    f584:	d013      	beq.n	f5ae <_usb_host_interrupt_handler+0x3e2>
			/* clear the flags */
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_DNRSM;
    f586:	4b42      	ldr	r3, [pc, #264]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f588:	681b      	ldr	r3, [r3, #0]
    f58a:	681b      	ldr	r3, [r3, #0]
    f58c:	2220      	movs	r2, #32
    f58e:	839a      	strh	r2, [r3, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_DNRSM)) {
    f590:	4b3f      	ldr	r3, [pc, #252]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f592:	681b      	ldr	r3, [r3, #0]
    f594:	22a5      	movs	r2, #165	; 0xa5
    f596:	5c9b      	ldrb	r3, [r3, r2]
    f598:	001a      	movs	r2, r3
    f59a:	2308      	movs	r3, #8
    f59c:	4013      	ands	r3, r2
    f59e:	d006      	beq.n	f5ae <_usb_host_interrupt_handler+0x3e2>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_DNRSM])(_usb_instances);
    f5a0:	4b3b      	ldr	r3, [pc, #236]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f5a2:	681b      	ldr	r3, [r3, #0]
    f5a4:	691a      	ldr	r2, [r3, #16]
    f5a6:	4b3a      	ldr	r3, [pc, #232]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f5a8:	681b      	ldr	r3, [r3, #0]
    f5aa:	0018      	movs	r0, r3
    f5ac:	4790      	blx	r2
			}
		}

		/* host wakeup interrupts */
		if (flags & USB_HOST_INTFLAG_WAKEUP) {
    f5ae:	683b      	ldr	r3, [r7, #0]
    f5b0:	2210      	movs	r2, #16
    f5b2:	4013      	ands	r3, r2
    f5b4:	d013      	beq.n	f5de <_usb_host_interrupt_handler+0x412>
			/* clear the flags */
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_WAKEUP;
    f5b6:	4b36      	ldr	r3, [pc, #216]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f5b8:	681b      	ldr	r3, [r3, #0]
    f5ba:	681b      	ldr	r3, [r3, #0]
    f5bc:	2210      	movs	r2, #16
    f5be:	839a      	strh	r2, [r3, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_WAKEUP)) {
    f5c0:	4b33      	ldr	r3, [pc, #204]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f5c2:	681b      	ldr	r3, [r3, #0]
    f5c4:	22a5      	movs	r2, #165	; 0xa5
    f5c6:	5c9b      	ldrb	r3, [r3, r2]
    f5c8:	001a      	movs	r2, r3
    f5ca:	2304      	movs	r3, #4
    f5cc:	4013      	ands	r3, r2
    f5ce:	d006      	beq.n	f5de <_usb_host_interrupt_handler+0x412>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_WAKEUP])(_usb_instances);
    f5d0:	4b2f      	ldr	r3, [pc, #188]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f5d2:	681b      	ldr	r3, [r3, #0]
    f5d4:	68da      	ldr	r2, [r3, #12]
    f5d6:	4b2e      	ldr	r3, [pc, #184]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f5d8:	681b      	ldr	r3, [r3, #0]
    f5da:	0018      	movs	r0, r3
    f5dc:	4790      	blx	r2
			}
		}

		/* host ram access interrupt  */
		if (flags & USB_HOST_INTFLAG_RAMACER) {
    f5de:	683b      	ldr	r3, [r7, #0]
    f5e0:	2280      	movs	r2, #128	; 0x80
    f5e2:	4013      	ands	r3, r2
    f5e4:	d016      	beq.n	f614 <_usb_host_interrupt_handler+0x448>
			/* Clear busy status */
			host_pipe_job_busy_status = 0;
    f5e6:	4b2b      	ldr	r3, [pc, #172]	; (f694 <_usb_host_interrupt_handler+0x4c8>)
    f5e8:	2200      	movs	r2, #0
    f5ea:	601a      	str	r2, [r3, #0]
			/* clear the flag */
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_RAMACER;
    f5ec:	4b28      	ldr	r3, [pc, #160]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f5ee:	681b      	ldr	r3, [r3, #0]
    f5f0:	681b      	ldr	r3, [r3, #0]
    f5f2:	2280      	movs	r2, #128	; 0x80
    f5f4:	839a      	strh	r2, [r3, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_RAMACER)) {
    f5f6:	4b26      	ldr	r3, [pc, #152]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f5f8:	681b      	ldr	r3, [r3, #0]
    f5fa:	22a5      	movs	r2, #165	; 0xa5
    f5fc:	5c9b      	ldrb	r3, [r3, r2]
    f5fe:	001a      	movs	r2, r3
    f600:	2320      	movs	r3, #32
    f602:	4013      	ands	r3, r2
    f604:	d006      	beq.n	f614 <_usb_host_interrupt_handler+0x448>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_RAMACER])(_usb_instances);
    f606:	4b22      	ldr	r3, [pc, #136]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f608:	681b      	ldr	r3, [r3, #0]
    f60a:	699a      	ldr	r2, [r3, #24]
    f60c:	4b20      	ldr	r3, [pc, #128]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f60e:	681b      	ldr	r3, [r3, #0]
    f610:	0018      	movs	r0, r3
    f612:	4790      	blx	r2
			}
		}

		/* host connect interrupt */
		if (flags & USB_HOST_INTFLAG_DCONN) {
    f614:	683a      	ldr	r2, [r7, #0]
    f616:	2380      	movs	r3, #128	; 0x80
    f618:	005b      	lsls	r3, r3, #1
    f61a:	4013      	ands	r3, r2
    f61c:	d017      	beq.n	f64e <_usb_host_interrupt_handler+0x482>
			/* Clear busy status */
			host_pipe_job_busy_status = 0;
    f61e:	4b1d      	ldr	r3, [pc, #116]	; (f694 <_usb_host_interrupt_handler+0x4c8>)
    f620:	2200      	movs	r2, #0
    f622:	601a      	str	r2, [r3, #0]
			/* clear the flag */
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_DCONN;
    f624:	4b1a      	ldr	r3, [pc, #104]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f626:	681b      	ldr	r3, [r3, #0]
    f628:	681b      	ldr	r3, [r3, #0]
    f62a:	2280      	movs	r2, #128	; 0x80
    f62c:	0052      	lsls	r2, r2, #1
    f62e:	839a      	strh	r2, [r3, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_CONNECT)) {
    f630:	4b17      	ldr	r3, [pc, #92]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f632:	681b      	ldr	r3, [r3, #0]
    f634:	22a5      	movs	r2, #165	; 0xa5
    f636:	5c9b      	ldrb	r3, [r3, r2]
    f638:	001a      	movs	r2, r3
    f63a:	2340      	movs	r3, #64	; 0x40
    f63c:	4013      	ands	r3, r2
    f63e:	d006      	beq.n	f64e <_usb_host_interrupt_handler+0x482>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_CONNECT])(_usb_instances);
    f640:	4b13      	ldr	r3, [pc, #76]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f642:	681b      	ldr	r3, [r3, #0]
    f644:	69da      	ldr	r2, [r3, #28]
    f646:	4b12      	ldr	r3, [pc, #72]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f648:	681b      	ldr	r3, [r3, #0]
    f64a:	0018      	movs	r0, r3
    f64c:	4790      	blx	r2
			}
		}

		/* host disconnect interrupt 	*/
		if (flags & USB_HOST_INTFLAG_DDISC) {
    f64e:	683a      	ldr	r2, [r7, #0]
    f650:	2380      	movs	r3, #128	; 0x80
    f652:	009b      	lsls	r3, r3, #2
    f654:	4013      	ands	r3, r2
    f656:	d016      	beq.n	f686 <_usb_host_interrupt_handler+0x4ba>
			/* Clear busy status */
			host_pipe_job_busy_status = 0;
    f658:	4b0e      	ldr	r3, [pc, #56]	; (f694 <_usb_host_interrupt_handler+0x4c8>)
    f65a:	2200      	movs	r2, #0
    f65c:	601a      	str	r2, [r3, #0]
			/* clear the flag */
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_DDISC;
    f65e:	4b0c      	ldr	r3, [pc, #48]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f660:	681b      	ldr	r3, [r3, #0]
    f662:	681b      	ldr	r3, [r3, #0]
    f664:	2280      	movs	r2, #128	; 0x80
    f666:	0092      	lsls	r2, r2, #2
    f668:	839a      	strh	r2, [r3, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_DISCONNECT)) {
    f66a:	4b09      	ldr	r3, [pc, #36]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f66c:	681b      	ldr	r3, [r3, #0]
    f66e:	22a5      	movs	r2, #165	; 0xa5
    f670:	5c9b      	ldrb	r3, [r3, r2]
    f672:	b25b      	sxtb	r3, r3
    f674:	2b00      	cmp	r3, #0
    f676:	da06      	bge.n	f686 <_usb_host_interrupt_handler+0x4ba>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_DISCONNECT])(_usb_instances);
    f678:	4b05      	ldr	r3, [pc, #20]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f67a:	681b      	ldr	r3, [r3, #0]
    f67c:	6a1a      	ldr	r2, [r3, #32]
    f67e:	4b04      	ldr	r3, [pc, #16]	; (f690 <_usb_host_interrupt_handler+0x4c4>)
    f680:	681b      	ldr	r3, [r3, #0]
    f682:	0018      	movs	r0, r3
    f684:	4790      	blx	r2
			}
		}

	}
}
    f686:	46c0      	nop			; (mov r8, r8)
    f688:	46bd      	mov	sp, r7
    f68a:	b002      	add	sp, #8
    f68c:	bd80      	pop	{r7, pc}
    f68e:	46c0      	nop			; (mov r8, r8)
    f690:	20000924 	.word	0x20000924
    f694:	2000093c 	.word	0x2000093c

0000f698 <usb_device_register_callback>:
 * \retval STATUS_OK    The callback was registered successfully.
 */
enum status_code usb_device_register_callback(struct usb_module *module_inst,
		enum usb_device_callback callback_type,
		usb_device_callback_t callback_func)
{
    f698:	b580      	push	{r7, lr}
    f69a:	b084      	sub	sp, #16
    f69c:	af00      	add	r7, sp, #0
    f69e:	60f8      	str	r0, [r7, #12]
    f6a0:	607a      	str	r2, [r7, #4]
    f6a2:	230b      	movs	r3, #11
    f6a4:	18fb      	adds	r3, r7, r3
    f6a6:	1c0a      	adds	r2, r1, #0
    f6a8:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(callback_func);

	/* Register callback function */
	module_inst->device_callback[callback_type] = callback_func;
    f6aa:	230b      	movs	r3, #11
    f6ac:	18fb      	adds	r3, r7, r3
    f6ae:	781a      	ldrb	r2, [r3, #0]
    f6b0:	68fb      	ldr	r3, [r7, #12]
    f6b2:	322e      	adds	r2, #46	; 0x2e
    f6b4:	0092      	lsls	r2, r2, #2
    f6b6:	6879      	ldr	r1, [r7, #4]
    f6b8:	50d1      	str	r1, [r2, r3]

	/* Set the bit corresponding to the callback_type */
	module_inst->device_registered_callback_mask |= _usb_device_irq_bits[callback_type];
    f6ba:	68fa      	ldr	r2, [r7, #12]
    f6bc:	23aa      	movs	r3, #170	; 0xaa
    f6be:	005b      	lsls	r3, r3, #1
    f6c0:	5ad2      	ldrh	r2, [r2, r3]
    f6c2:	230b      	movs	r3, #11
    f6c4:	18fb      	adds	r3, r7, r3
    f6c6:	7819      	ldrb	r1, [r3, #0]
    f6c8:	4b06      	ldr	r3, [pc, #24]	; (f6e4 <usb_device_register_callback+0x4c>)
    f6ca:	0049      	lsls	r1, r1, #1
    f6cc:	5acb      	ldrh	r3, [r1, r3]
    f6ce:	4313      	orrs	r3, r2
    f6d0:	b299      	uxth	r1, r3
    f6d2:	68fa      	ldr	r2, [r7, #12]
    f6d4:	23aa      	movs	r3, #170	; 0xaa
    f6d6:	005b      	lsls	r3, r3, #1
    f6d8:	52d1      	strh	r1, [r2, r3]

	return STATUS_OK;
    f6da:	2300      	movs	r3, #0
}
    f6dc:	0018      	movs	r0, r3
    f6de:	46bd      	mov	sp, r7
    f6e0:	b004      	add	sp, #16
    f6e2:	bd80      	pop	{r7, pc}
    f6e4:	00015948 	.word	0x00015948

0000f6e8 <usb_device_enable_callback>:
 * \return Status of the callback enable operation.
 * \retval STATUS_OK    The callback was enabled successfully.
 */
enum status_code usb_device_enable_callback(struct usb_module *module_inst,
		enum usb_device_callback callback_type)
{
    f6e8:	b580      	push	{r7, lr}
    f6ea:	b082      	sub	sp, #8
    f6ec:	af00      	add	r7, sp, #0
    f6ee:	6078      	str	r0, [r7, #4]
    f6f0:	000a      	movs	r2, r1
    f6f2:	1cfb      	adds	r3, r7, #3
    f6f4:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* clear related flag */
	module_inst->hw->DEVICE.INTFLAG.reg = _usb_device_irq_bits[callback_type];
    f6f6:	687b      	ldr	r3, [r7, #4]
    f6f8:	681b      	ldr	r3, [r3, #0]
    f6fa:	1cfa      	adds	r2, r7, #3
    f6fc:	7811      	ldrb	r1, [r2, #0]
    f6fe:	4a10      	ldr	r2, [pc, #64]	; (f740 <usb_device_enable_callback+0x58>)
    f700:	0049      	lsls	r1, r1, #1
    f702:	5a8a      	ldrh	r2, [r1, r2]
    f704:	839a      	strh	r2, [r3, #28]

	/* Enable callback */
	module_inst->device_enabled_callback_mask |= _usb_device_irq_bits[callback_type];
    f706:	687a      	ldr	r2, [r7, #4]
    f708:	23ab      	movs	r3, #171	; 0xab
    f70a:	005b      	lsls	r3, r3, #1
    f70c:	5ad2      	ldrh	r2, [r2, r3]
    f70e:	1cfb      	adds	r3, r7, #3
    f710:	7819      	ldrb	r1, [r3, #0]
    f712:	4b0b      	ldr	r3, [pc, #44]	; (f740 <usb_device_enable_callback+0x58>)
    f714:	0049      	lsls	r1, r1, #1
    f716:	5acb      	ldrh	r3, [r1, r3]
    f718:	4313      	orrs	r3, r2
    f71a:	b299      	uxth	r1, r3
    f71c:	687a      	ldr	r2, [r7, #4]
    f71e:	23ab      	movs	r3, #171	; 0xab
    f720:	005b      	lsls	r3, r3, #1
    f722:	52d1      	strh	r1, [r2, r3]

	module_inst->hw->DEVICE.INTENSET.reg = _usb_device_irq_bits[callback_type];
    f724:	687b      	ldr	r3, [r7, #4]
    f726:	681b      	ldr	r3, [r3, #0]
    f728:	1cfa      	adds	r2, r7, #3
    f72a:	7811      	ldrb	r1, [r2, #0]
    f72c:	4a04      	ldr	r2, [pc, #16]	; (f740 <usb_device_enable_callback+0x58>)
    f72e:	0049      	lsls	r1, r1, #1
    f730:	5a8a      	ldrh	r2, [r1, r2]
    f732:	831a      	strh	r2, [r3, #24]

	return STATUS_OK;
    f734:	2300      	movs	r3, #0
}
    f736:	0018      	movs	r0, r3
    f738:	46bd      	mov	sp, r7
    f73a:	b002      	add	sp, #8
    f73c:	bd80      	pop	{r7, pc}
    f73e:	46c0      	nop			; (mov r8, r8)
    f740:	00015948 	.word	0x00015948

0000f744 <usb_device_disable_callback>:
 * \return Status of the callback disable operation.
 * \retval STATUS_OK    The callback was disabled successfully.
 */
enum status_code usb_device_disable_callback(struct usb_module *module_inst,
		enum usb_device_callback callback_type)
{
    f744:	b580      	push	{r7, lr}
    f746:	b082      	sub	sp, #8
    f748:	af00      	add	r7, sp, #0
    f74a:	6078      	str	r0, [r7, #4]
    f74c:	000a      	movs	r2, r1
    f74e:	1cfb      	adds	r3, r7, #3
    f750:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Disable callback */
	module_inst->device_enabled_callback_mask &= ~_usb_device_irq_bits[callback_type];
    f752:	687a      	ldr	r2, [r7, #4]
    f754:	23ab      	movs	r3, #171	; 0xab
    f756:	005b      	lsls	r3, r3, #1
    f758:	5ad3      	ldrh	r3, [r2, r3]
    f75a:	b21b      	sxth	r3, r3
    f75c:	1cfa      	adds	r2, r7, #3
    f75e:	7811      	ldrb	r1, [r2, #0]
    f760:	4a0c      	ldr	r2, [pc, #48]	; (f794 <usb_device_disable_callback+0x50>)
    f762:	0049      	lsls	r1, r1, #1
    f764:	5a8a      	ldrh	r2, [r1, r2]
    f766:	b212      	sxth	r2, r2
    f768:	43d2      	mvns	r2, r2
    f76a:	b212      	sxth	r2, r2
    f76c:	4013      	ands	r3, r2
    f76e:	b21b      	sxth	r3, r3
    f770:	b299      	uxth	r1, r3
    f772:	687a      	ldr	r2, [r7, #4]
    f774:	23ab      	movs	r3, #171	; 0xab
    f776:	005b      	lsls	r3, r3, #1
    f778:	52d1      	strh	r1, [r2, r3]

	module_inst->hw->DEVICE.INTENCLR.reg = _usb_device_irq_bits[callback_type];
    f77a:	687b      	ldr	r3, [r7, #4]
    f77c:	681b      	ldr	r3, [r3, #0]
    f77e:	1cfa      	adds	r2, r7, #3
    f780:	7811      	ldrb	r1, [r2, #0]
    f782:	4a04      	ldr	r2, [pc, #16]	; (f794 <usb_device_disable_callback+0x50>)
    f784:	0049      	lsls	r1, r1, #1
    f786:	5a8a      	ldrh	r2, [r1, r2]
    f788:	829a      	strh	r2, [r3, #20]

	return STATUS_OK;
    f78a:	2300      	movs	r3, #0
}
    f78c:	0018      	movs	r0, r3
    f78e:	46bd      	mov	sp, r7
    f790:	b002      	add	sp, #8
    f792:	bd80      	pop	{r7, pc}
    f794:	00015948 	.word	0x00015948

0000f798 <usb_device_endpoint_register_callback>:
 */
enum status_code usb_device_endpoint_register_callback(
		struct usb_module *module_inst, uint8_t ep_num,
		enum usb_device_endpoint_callback callback_type,
		usb_device_endpoint_callback_t callback_func)
{
    f798:	b580      	push	{r7, lr}
    f79a:	b084      	sub	sp, #16
    f79c:	af00      	add	r7, sp, #0
    f79e:	60f8      	str	r0, [r7, #12]
    f7a0:	0008      	movs	r0, r1
    f7a2:	0011      	movs	r1, r2
    f7a4:	607b      	str	r3, [r7, #4]
    f7a6:	230b      	movs	r3, #11
    f7a8:	18fb      	adds	r3, r7, r3
    f7aa:	1c02      	adds	r2, r0, #0
    f7ac:	701a      	strb	r2, [r3, #0]
    f7ae:	230a      	movs	r3, #10
    f7b0:	18fb      	adds	r3, r7, r3
    f7b2:	1c0a      	adds	r2, r1, #0
    f7b4:	701a      	strb	r2, [r3, #0]
	Assert(module_inst);
	Assert(ep_num < USB_EPT_NUM);
	Assert(callback_func);

	/* Register callback function */
	module_inst->device_endpoint_callback[ep_num][callback_type] = callback_func;
    f7b6:	230b      	movs	r3, #11
    f7b8:	18fb      	adds	r3, r7, r3
    f7ba:	7819      	ldrb	r1, [r3, #0]
    f7bc:	230a      	movs	r3, #10
    f7be:	18fb      	adds	r3, r7, r3
    f7c0:	781b      	ldrb	r3, [r3, #0]
    f7c2:	68fa      	ldr	r2, [r7, #12]
    f7c4:	0089      	lsls	r1, r1, #2
    f7c6:	18cb      	adds	r3, r1, r3
    f7c8:	3334      	adds	r3, #52	; 0x34
    f7ca:	009b      	lsls	r3, r3, #2
    f7cc:	18d3      	adds	r3, r2, r3
    f7ce:	3304      	adds	r3, #4
    f7d0:	687a      	ldr	r2, [r7, #4]
    f7d2:	601a      	str	r2, [r3, #0]

	/* Set the bit corresponding to the callback_type */
	module_inst->deivce_endpoint_registered_callback_mask[ep_num] |= _usb_endpoint_irq_bits[callback_type];
    f7d4:	230b      	movs	r3, #11
    f7d6:	18fb      	adds	r3, r7, r3
    f7d8:	781a      	ldrb	r2, [r3, #0]
    f7da:	230b      	movs	r3, #11
    f7dc:	18fb      	adds	r3, r7, r3
    f7de:	7819      	ldrb	r1, [r3, #0]
    f7e0:	68f8      	ldr	r0, [r7, #12]
    f7e2:	23ac      	movs	r3, #172	; 0xac
    f7e4:	005b      	lsls	r3, r3, #1
    f7e6:	1841      	adds	r1, r0, r1
    f7e8:	18cb      	adds	r3, r1, r3
    f7ea:	7819      	ldrb	r1, [r3, #0]
    f7ec:	230a      	movs	r3, #10
    f7ee:	18fb      	adds	r3, r7, r3
    f7f0:	781b      	ldrb	r3, [r3, #0]
    f7f2:	4808      	ldr	r0, [pc, #32]	; (f814 <usb_device_endpoint_register_callback+0x7c>)
    f7f4:	5cc3      	ldrb	r3, [r0, r3]
    f7f6:	430b      	orrs	r3, r1
    f7f8:	b2d8      	uxtb	r0, r3
    f7fa:	68f9      	ldr	r1, [r7, #12]
    f7fc:	23ac      	movs	r3, #172	; 0xac
    f7fe:	005b      	lsls	r3, r3, #1
    f800:	188a      	adds	r2, r1, r2
    f802:	18d3      	adds	r3, r2, r3
    f804:	1c02      	adds	r2, r0, #0
    f806:	701a      	strb	r2, [r3, #0]

	return STATUS_OK;
    f808:	2300      	movs	r3, #0
}
    f80a:	0018      	movs	r0, r3
    f80c:	46bd      	mov	sp, r7
    f80e:	b004      	add	sp, #16
    f810:	bd80      	pop	{r7, pc}
    f812:	46c0      	nop			; (mov r8, r8)
    f814:	00015958 	.word	0x00015958

0000f818 <usb_device_endpoint_unregister_callback>:
 * \retval STATUS_OK    The callback was unregistered successfully.
 */
enum status_code usb_device_endpoint_unregister_callback(
		struct usb_module *module_inst, uint8_t ep_num,
		enum usb_device_endpoint_callback callback_type)
{
    f818:	b580      	push	{r7, lr}
    f81a:	b082      	sub	sp, #8
    f81c:	af00      	add	r7, sp, #0
    f81e:	6078      	str	r0, [r7, #4]
    f820:	0008      	movs	r0, r1
    f822:	0011      	movs	r1, r2
    f824:	1cfb      	adds	r3, r7, #3
    f826:	1c02      	adds	r2, r0, #0
    f828:	701a      	strb	r2, [r3, #0]
    f82a:	1cbb      	adds	r3, r7, #2
    f82c:	1c0a      	adds	r2, r1, #0
    f82e:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(ep_num < USB_EPT_NUM);

	/* Unregister callback function */
	module_inst->device_endpoint_callback[ep_num][callback_type] = NULL;
    f830:	1cfb      	adds	r3, r7, #3
    f832:	7819      	ldrb	r1, [r3, #0]
    f834:	1cbb      	adds	r3, r7, #2
    f836:	781b      	ldrb	r3, [r3, #0]
    f838:	687a      	ldr	r2, [r7, #4]
    f83a:	0089      	lsls	r1, r1, #2
    f83c:	18cb      	adds	r3, r1, r3
    f83e:	3334      	adds	r3, #52	; 0x34
    f840:	009b      	lsls	r3, r3, #2
    f842:	18d3      	adds	r3, r2, r3
    f844:	3304      	adds	r3, #4
    f846:	2200      	movs	r2, #0
    f848:	601a      	str	r2, [r3, #0]

	/* Clear the bit corresponding to the callback_type */
	module_inst->deivce_endpoint_registered_callback_mask[ep_num] &= ~_usb_endpoint_irq_bits[callback_type];
    f84a:	1cfb      	adds	r3, r7, #3
    f84c:	781a      	ldrb	r2, [r3, #0]
    f84e:	1cfb      	adds	r3, r7, #3
    f850:	7819      	ldrb	r1, [r3, #0]
    f852:	6878      	ldr	r0, [r7, #4]
    f854:	23ac      	movs	r3, #172	; 0xac
    f856:	005b      	lsls	r3, r3, #1
    f858:	1841      	adds	r1, r0, r1
    f85a:	18cb      	adds	r3, r1, r3
    f85c:	781b      	ldrb	r3, [r3, #0]
    f85e:	b25b      	sxtb	r3, r3
    f860:	1cb9      	adds	r1, r7, #2
    f862:	7809      	ldrb	r1, [r1, #0]
    f864:	4809      	ldr	r0, [pc, #36]	; (f88c <usb_device_endpoint_unregister_callback+0x74>)
    f866:	5c41      	ldrb	r1, [r0, r1]
    f868:	b249      	sxtb	r1, r1
    f86a:	43c9      	mvns	r1, r1
    f86c:	b249      	sxtb	r1, r1
    f86e:	400b      	ands	r3, r1
    f870:	b25b      	sxtb	r3, r3
    f872:	b2d8      	uxtb	r0, r3
    f874:	6879      	ldr	r1, [r7, #4]
    f876:	23ac      	movs	r3, #172	; 0xac
    f878:	005b      	lsls	r3, r3, #1
    f87a:	188a      	adds	r2, r1, r2
    f87c:	18d3      	adds	r3, r2, r3
    f87e:	1c02      	adds	r2, r0, #0
    f880:	701a      	strb	r2, [r3, #0]

	return STATUS_OK;
    f882:	2300      	movs	r3, #0
}
    f884:	0018      	movs	r0, r3
    f886:	46bd      	mov	sp, r7
    f888:	b002      	add	sp, #8
    f88a:	bd80      	pop	{r7, pc}
    f88c:	00015958 	.word	0x00015958

0000f890 <usb_device_endpoint_enable_callback>:
 * \retval STATUS_OK    The callback was enabled successfully.
 */
enum status_code usb_device_endpoint_enable_callback(
		struct usb_module *module_inst, uint8_t ep,
		enum usb_device_endpoint_callback callback_type)
{
    f890:	b580      	push	{r7, lr}
    f892:	b084      	sub	sp, #16
    f894:	af00      	add	r7, sp, #0
    f896:	6078      	str	r0, [r7, #4]
    f898:	0008      	movs	r0, r1
    f89a:	0011      	movs	r1, r2
    f89c:	1cfb      	adds	r3, r7, #3
    f89e:	1c02      	adds	r2, r0, #0
    f8a0:	701a      	strb	r2, [r3, #0]
    f8a2:	1cbb      	adds	r3, r7, #2
    f8a4:	1c0a      	adds	r2, r1, #0
    f8a6:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	uint8_t ep_num = ep & USB_EP_ADDR_MASK;
    f8a8:	230f      	movs	r3, #15
    f8aa:	18fb      	adds	r3, r7, r3
    f8ac:	1cfa      	adds	r2, r7, #3
    f8ae:	7812      	ldrb	r2, [r2, #0]
    f8b0:	210f      	movs	r1, #15
    f8b2:	400a      	ands	r2, r1
    f8b4:	701a      	strb	r2, [r3, #0]
	Assert(ep_num < USB_EPT_NUM);

	/* Enable callback */
	module_inst->device_endpoint_enabled_callback_mask[ep_num] |= _usb_endpoint_irq_bits[callback_type];
    f8b6:	230f      	movs	r3, #15
    f8b8:	18fb      	adds	r3, r7, r3
    f8ba:	781a      	ldrb	r2, [r3, #0]
    f8bc:	230f      	movs	r3, #15
    f8be:	18fb      	adds	r3, r7, r3
    f8c0:	7819      	ldrb	r1, [r3, #0]
    f8c2:	6878      	ldr	r0, [r7, #4]
    f8c4:	23b0      	movs	r3, #176	; 0xb0
    f8c6:	005b      	lsls	r3, r3, #1
    f8c8:	1841      	adds	r1, r0, r1
    f8ca:	18cb      	adds	r3, r1, r3
    f8cc:	7819      	ldrb	r1, [r3, #0]
    f8ce:	1cbb      	adds	r3, r7, #2
    f8d0:	781b      	ldrb	r3, [r3, #0]
    f8d2:	4855      	ldr	r0, [pc, #340]	; (fa28 <usb_device_endpoint_enable_callback+0x198>)
    f8d4:	5cc3      	ldrb	r3, [r0, r3]
    f8d6:	430b      	orrs	r3, r1
    f8d8:	b2d8      	uxtb	r0, r3
    f8da:	6879      	ldr	r1, [r7, #4]
    f8dc:	23b0      	movs	r3, #176	; 0xb0
    f8de:	005b      	lsls	r3, r3, #1
    f8e0:	188a      	adds	r2, r1, r2
    f8e2:	18d3      	adds	r3, r2, r3
    f8e4:	1c02      	adds	r2, r0, #0
    f8e6:	701a      	strb	r2, [r3, #0]

	if (callback_type == USB_DEVICE_ENDPOINT_CALLBACK_TRCPT) {
    f8e8:	1cbb      	adds	r3, r7, #2
    f8ea:	781b      	ldrb	r3, [r3, #0]
    f8ec:	2b00      	cmp	r3, #0
    f8ee:	d12f      	bne.n	f950 <usb_device_endpoint_enable_callback+0xc0>
		if (ep_num == 0) { // control endpoint
    f8f0:	230f      	movs	r3, #15
    f8f2:	18fb      	adds	r3, r7, r3
    f8f4:	781b      	ldrb	r3, [r3, #0]
    f8f6:	2b00      	cmp	r3, #0
    f8f8:	d10c      	bne.n	f914 <usb_device_endpoint_enable_callback+0x84>
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENSET.reg = USB_DEVICE_EPINTENSET_TRCPT0 | USB_DEVICE_EPINTENSET_TRCPT1;
    f8fa:	687b      	ldr	r3, [r7, #4]
    f8fc:	6819      	ldr	r1, [r3, #0]
    f8fe:	230f      	movs	r3, #15
    f900:	18fb      	adds	r3, r7, r3
    f902:	781a      	ldrb	r2, [r3, #0]
    f904:	230a      	movs	r3, #10
    f906:	33ff      	adds	r3, #255	; 0xff
    f908:	0152      	lsls	r2, r2, #5
    f90a:	188a      	adds	r2, r1, r2
    f90c:	18d3      	adds	r3, r2, r3
    f90e:	2203      	movs	r2, #3
    f910:	701a      	strb	r2, [r3, #0]
    f912:	e01d      	b.n	f950 <usb_device_endpoint_enable_callback+0xc0>
		} else if (ep & USB_EP_DIR_IN) {
    f914:	1cfb      	adds	r3, r7, #3
    f916:	781b      	ldrb	r3, [r3, #0]
    f918:	b25b      	sxtb	r3, r3
    f91a:	2b00      	cmp	r3, #0
    f91c:	da0c      	bge.n	f938 <usb_device_endpoint_enable_callback+0xa8>
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENSET.reg = USB_DEVICE_EPINTENSET_TRCPT1;
    f91e:	687b      	ldr	r3, [r7, #4]
    f920:	6819      	ldr	r1, [r3, #0]
    f922:	230f      	movs	r3, #15
    f924:	18fb      	adds	r3, r7, r3
    f926:	781a      	ldrb	r2, [r3, #0]
    f928:	230a      	movs	r3, #10
    f92a:	33ff      	adds	r3, #255	; 0xff
    f92c:	0152      	lsls	r2, r2, #5
    f92e:	188a      	adds	r2, r1, r2
    f930:	18d3      	adds	r3, r2, r3
    f932:	2202      	movs	r2, #2
    f934:	701a      	strb	r2, [r3, #0]
    f936:	e00b      	b.n	f950 <usb_device_endpoint_enable_callback+0xc0>
		} else {
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENSET.reg = USB_DEVICE_EPINTENSET_TRCPT0;
    f938:	687b      	ldr	r3, [r7, #4]
    f93a:	6819      	ldr	r1, [r3, #0]
    f93c:	230f      	movs	r3, #15
    f93e:	18fb      	adds	r3, r7, r3
    f940:	781a      	ldrb	r2, [r3, #0]
    f942:	230a      	movs	r3, #10
    f944:	33ff      	adds	r3, #255	; 0xff
    f946:	0152      	lsls	r2, r2, #5
    f948:	188a      	adds	r2, r1, r2
    f94a:	18d3      	adds	r3, r2, r3
    f94c:	2201      	movs	r2, #1
    f94e:	701a      	strb	r2, [r3, #0]
		}
	}

	if (callback_type == USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL) {
    f950:	1cbb      	adds	r3, r7, #2
    f952:	781b      	ldrb	r3, [r3, #0]
    f954:	2b01      	cmp	r3, #1
    f956:	d12f      	bne.n	f9b8 <usb_device_endpoint_enable_callback+0x128>
		if (ep_num == 0) { // control endpoint
    f958:	230f      	movs	r3, #15
    f95a:	18fb      	adds	r3, r7, r3
    f95c:	781b      	ldrb	r3, [r3, #0]
    f95e:	2b00      	cmp	r3, #0
    f960:	d10c      	bne.n	f97c <usb_device_endpoint_enable_callback+0xec>
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENSET.reg = USB_DEVICE_EPINTENSET_TRFAIL0 | USB_DEVICE_EPINTENSET_TRFAIL1;
    f962:	687b      	ldr	r3, [r7, #4]
    f964:	6819      	ldr	r1, [r3, #0]
    f966:	230f      	movs	r3, #15
    f968:	18fb      	adds	r3, r7, r3
    f96a:	781a      	ldrb	r2, [r3, #0]
    f96c:	230a      	movs	r3, #10
    f96e:	33ff      	adds	r3, #255	; 0xff
    f970:	0152      	lsls	r2, r2, #5
    f972:	188a      	adds	r2, r1, r2
    f974:	18d3      	adds	r3, r2, r3
    f976:	220c      	movs	r2, #12
    f978:	701a      	strb	r2, [r3, #0]
    f97a:	e01d      	b.n	f9b8 <usb_device_endpoint_enable_callback+0x128>
		} else if (ep & USB_EP_DIR_IN) {
    f97c:	1cfb      	adds	r3, r7, #3
    f97e:	781b      	ldrb	r3, [r3, #0]
    f980:	b25b      	sxtb	r3, r3
    f982:	2b00      	cmp	r3, #0
    f984:	da0c      	bge.n	f9a0 <usb_device_endpoint_enable_callback+0x110>
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENSET.reg = USB_DEVICE_EPINTENSET_TRFAIL1;
    f986:	687b      	ldr	r3, [r7, #4]
    f988:	6819      	ldr	r1, [r3, #0]
    f98a:	230f      	movs	r3, #15
    f98c:	18fb      	adds	r3, r7, r3
    f98e:	781a      	ldrb	r2, [r3, #0]
    f990:	230a      	movs	r3, #10
    f992:	33ff      	adds	r3, #255	; 0xff
    f994:	0152      	lsls	r2, r2, #5
    f996:	188a      	adds	r2, r1, r2
    f998:	18d3      	adds	r3, r2, r3
    f99a:	2208      	movs	r2, #8
    f99c:	701a      	strb	r2, [r3, #0]
    f99e:	e00b      	b.n	f9b8 <usb_device_endpoint_enable_callback+0x128>
		} else {
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENSET.reg = USB_DEVICE_EPINTENSET_TRFAIL0;
    f9a0:	687b      	ldr	r3, [r7, #4]
    f9a2:	6819      	ldr	r1, [r3, #0]
    f9a4:	230f      	movs	r3, #15
    f9a6:	18fb      	adds	r3, r7, r3
    f9a8:	781a      	ldrb	r2, [r3, #0]
    f9aa:	230a      	movs	r3, #10
    f9ac:	33ff      	adds	r3, #255	; 0xff
    f9ae:	0152      	lsls	r2, r2, #5
    f9b0:	188a      	adds	r2, r1, r2
    f9b2:	18d3      	adds	r3, r2, r3
    f9b4:	2204      	movs	r2, #4
    f9b6:	701a      	strb	r2, [r3, #0]
		}
	}

	if (callback_type == USB_DEVICE_ENDPOINT_CALLBACK_RXSTP) {
    f9b8:	1cbb      	adds	r3, r7, #2
    f9ba:	781b      	ldrb	r3, [r3, #0]
    f9bc:	2b02      	cmp	r3, #2
    f9be:	d10b      	bne.n	f9d8 <usb_device_endpoint_enable_callback+0x148>
		module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENSET.reg = USB_DEVICE_EPINTENSET_RXSTP;
    f9c0:	687b      	ldr	r3, [r7, #4]
    f9c2:	6819      	ldr	r1, [r3, #0]
    f9c4:	230f      	movs	r3, #15
    f9c6:	18fb      	adds	r3, r7, r3
    f9c8:	781a      	ldrb	r2, [r3, #0]
    f9ca:	230a      	movs	r3, #10
    f9cc:	33ff      	adds	r3, #255	; 0xff
    f9ce:	0152      	lsls	r2, r2, #5
    f9d0:	188a      	adds	r2, r1, r2
    f9d2:	18d3      	adds	r3, r2, r3
    f9d4:	2210      	movs	r2, #16
    f9d6:	701a      	strb	r2, [r3, #0]
	}

	if (callback_type == USB_DEVICE_ENDPOINT_CALLBACK_STALL) {
    f9d8:	1cbb      	adds	r3, r7, #2
    f9da:	781b      	ldrb	r3, [r3, #0]
    f9dc:	2b03      	cmp	r3, #3
    f9de:	d11d      	bne.n	fa1c <usb_device_endpoint_enable_callback+0x18c>
		if (ep & USB_EP_DIR_IN) {
    f9e0:	1cfb      	adds	r3, r7, #3
    f9e2:	781b      	ldrb	r3, [r3, #0]
    f9e4:	b25b      	sxtb	r3, r3
    f9e6:	2b00      	cmp	r3, #0
    f9e8:	da0c      	bge.n	fa04 <usb_device_endpoint_enable_callback+0x174>
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENSET.reg = USB_DEVICE_EPINTENSET_STALL1;
    f9ea:	687b      	ldr	r3, [r7, #4]
    f9ec:	6819      	ldr	r1, [r3, #0]
    f9ee:	230f      	movs	r3, #15
    f9f0:	18fb      	adds	r3, r7, r3
    f9f2:	781a      	ldrb	r2, [r3, #0]
    f9f4:	230a      	movs	r3, #10
    f9f6:	33ff      	adds	r3, #255	; 0xff
    f9f8:	0152      	lsls	r2, r2, #5
    f9fa:	188a      	adds	r2, r1, r2
    f9fc:	18d3      	adds	r3, r2, r3
    f9fe:	2240      	movs	r2, #64	; 0x40
    fa00:	701a      	strb	r2, [r3, #0]
    fa02:	e00b      	b.n	fa1c <usb_device_endpoint_enable_callback+0x18c>
		} else {
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENSET.reg = USB_DEVICE_EPINTENSET_STALL0;
    fa04:	687b      	ldr	r3, [r7, #4]
    fa06:	6819      	ldr	r1, [r3, #0]
    fa08:	230f      	movs	r3, #15
    fa0a:	18fb      	adds	r3, r7, r3
    fa0c:	781a      	ldrb	r2, [r3, #0]
    fa0e:	230a      	movs	r3, #10
    fa10:	33ff      	adds	r3, #255	; 0xff
    fa12:	0152      	lsls	r2, r2, #5
    fa14:	188a      	adds	r2, r1, r2
    fa16:	18d3      	adds	r3, r2, r3
    fa18:	2220      	movs	r2, #32
    fa1a:	701a      	strb	r2, [r3, #0]
		}
	}

	return STATUS_OK;
    fa1c:	2300      	movs	r3, #0
}
    fa1e:	0018      	movs	r0, r3
    fa20:	46bd      	mov	sp, r7
    fa22:	b004      	add	sp, #16
    fa24:	bd80      	pop	{r7, pc}
    fa26:	46c0      	nop			; (mov r8, r8)
    fa28:	00015958 	.word	0x00015958

0000fa2c <usb_device_endpoint_disable_callback>:
 * \retval STATUS_OK    The callback was disabled successfully.
 */
enum status_code usb_device_endpoint_disable_callback(
		struct usb_module *module_inst, uint8_t ep,
		enum usb_device_endpoint_callback callback_type)
{
    fa2c:	b580      	push	{r7, lr}
    fa2e:	b084      	sub	sp, #16
    fa30:	af00      	add	r7, sp, #0
    fa32:	6078      	str	r0, [r7, #4]
    fa34:	0008      	movs	r0, r1
    fa36:	0011      	movs	r1, r2
    fa38:	1cfb      	adds	r3, r7, #3
    fa3a:	1c02      	adds	r2, r0, #0
    fa3c:	701a      	strb	r2, [r3, #0]
    fa3e:	1cbb      	adds	r3, r7, #2
    fa40:	1c0a      	adds	r2, r1, #0
    fa42:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	uint8_t ep_num = ep & USB_EP_ADDR_MASK;
    fa44:	230f      	movs	r3, #15
    fa46:	18fb      	adds	r3, r7, r3
    fa48:	1cfa      	adds	r2, r7, #3
    fa4a:	7812      	ldrb	r2, [r2, #0]
    fa4c:	210f      	movs	r1, #15
    fa4e:	400a      	ands	r2, r1
    fa50:	701a      	strb	r2, [r3, #0]
	Assert(ep_num < USB_EPT_NUM);

	/* Enable callback */
	module_inst->device_endpoint_enabled_callback_mask[ep_num] &= ~_usb_endpoint_irq_bits[callback_type];
    fa52:	230f      	movs	r3, #15
    fa54:	18fb      	adds	r3, r7, r3
    fa56:	781a      	ldrb	r2, [r3, #0]
    fa58:	230f      	movs	r3, #15
    fa5a:	18fb      	adds	r3, r7, r3
    fa5c:	7819      	ldrb	r1, [r3, #0]
    fa5e:	6878      	ldr	r0, [r7, #4]
    fa60:	23b0      	movs	r3, #176	; 0xb0
    fa62:	005b      	lsls	r3, r3, #1
    fa64:	1841      	adds	r1, r0, r1
    fa66:	18cb      	adds	r3, r1, r3
    fa68:	781b      	ldrb	r3, [r3, #0]
    fa6a:	b25b      	sxtb	r3, r3
    fa6c:	1cb9      	adds	r1, r7, #2
    fa6e:	7809      	ldrb	r1, [r1, #0]
    fa70:	4856      	ldr	r0, [pc, #344]	; (fbcc <usb_device_endpoint_disable_callback+0x1a0>)
    fa72:	5c41      	ldrb	r1, [r0, r1]
    fa74:	b249      	sxtb	r1, r1
    fa76:	43c9      	mvns	r1, r1
    fa78:	b249      	sxtb	r1, r1
    fa7a:	400b      	ands	r3, r1
    fa7c:	b25b      	sxtb	r3, r3
    fa7e:	b2d8      	uxtb	r0, r3
    fa80:	6879      	ldr	r1, [r7, #4]
    fa82:	23b0      	movs	r3, #176	; 0xb0
    fa84:	005b      	lsls	r3, r3, #1
    fa86:	188a      	adds	r2, r1, r2
    fa88:	18d3      	adds	r3, r2, r3
    fa8a:	1c02      	adds	r2, r0, #0
    fa8c:	701a      	strb	r2, [r3, #0]

	if (callback_type == USB_DEVICE_ENDPOINT_CALLBACK_TRCPT) {
    fa8e:	1cbb      	adds	r3, r7, #2
    fa90:	781b      	ldrb	r3, [r3, #0]
    fa92:	2b00      	cmp	r3, #0
    fa94:	d12f      	bne.n	faf6 <usb_device_endpoint_disable_callback+0xca>
		if (ep_num == 0) { // control endpoint
    fa96:	230f      	movs	r3, #15
    fa98:	18fb      	adds	r3, r7, r3
    fa9a:	781b      	ldrb	r3, [r3, #0]
    fa9c:	2b00      	cmp	r3, #0
    fa9e:	d10c      	bne.n	faba <usb_device_endpoint_disable_callback+0x8e>
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENCLR.reg =  USB_DEVICE_EPINTENCLR_TRCPT0 | USB_DEVICE_EPINTENCLR_TRCPT1;
    faa0:	687b      	ldr	r3, [r7, #4]
    faa2:	6819      	ldr	r1, [r3, #0]
    faa4:	230f      	movs	r3, #15
    faa6:	18fb      	adds	r3, r7, r3
    faa8:	781a      	ldrb	r2, [r3, #0]
    faaa:	2384      	movs	r3, #132	; 0x84
    faac:	005b      	lsls	r3, r3, #1
    faae:	0152      	lsls	r2, r2, #5
    fab0:	188a      	adds	r2, r1, r2
    fab2:	18d3      	adds	r3, r2, r3
    fab4:	2203      	movs	r2, #3
    fab6:	701a      	strb	r2, [r3, #0]
    fab8:	e01d      	b.n	faf6 <usb_device_endpoint_disable_callback+0xca>
		} else if (ep & USB_EP_DIR_IN) {
    faba:	1cfb      	adds	r3, r7, #3
    fabc:	781b      	ldrb	r3, [r3, #0]
    fabe:	b25b      	sxtb	r3, r3
    fac0:	2b00      	cmp	r3, #0
    fac2:	da0c      	bge.n	fade <usb_device_endpoint_disable_callback+0xb2>
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENCLR.reg =  USB_DEVICE_EPINTENCLR_TRCPT1;
    fac4:	687b      	ldr	r3, [r7, #4]
    fac6:	6819      	ldr	r1, [r3, #0]
    fac8:	230f      	movs	r3, #15
    faca:	18fb      	adds	r3, r7, r3
    facc:	781a      	ldrb	r2, [r3, #0]
    face:	2384      	movs	r3, #132	; 0x84
    fad0:	005b      	lsls	r3, r3, #1
    fad2:	0152      	lsls	r2, r2, #5
    fad4:	188a      	adds	r2, r1, r2
    fad6:	18d3      	adds	r3, r2, r3
    fad8:	2202      	movs	r2, #2
    fada:	701a      	strb	r2, [r3, #0]
    fadc:	e00b      	b.n	faf6 <usb_device_endpoint_disable_callback+0xca>
		} else {
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENCLR.reg =  USB_DEVICE_EPINTENCLR_TRCPT0;
    fade:	687b      	ldr	r3, [r7, #4]
    fae0:	6819      	ldr	r1, [r3, #0]
    fae2:	230f      	movs	r3, #15
    fae4:	18fb      	adds	r3, r7, r3
    fae6:	781a      	ldrb	r2, [r3, #0]
    fae8:	2384      	movs	r3, #132	; 0x84
    faea:	005b      	lsls	r3, r3, #1
    faec:	0152      	lsls	r2, r2, #5
    faee:	188a      	adds	r2, r1, r2
    faf0:	18d3      	adds	r3, r2, r3
    faf2:	2201      	movs	r2, #1
    faf4:	701a      	strb	r2, [r3, #0]
		}
	}

	if (callback_type == USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL) {
    faf6:	1cbb      	adds	r3, r7, #2
    faf8:	781b      	ldrb	r3, [r3, #0]
    fafa:	2b01      	cmp	r3, #1
    fafc:	d12f      	bne.n	fb5e <usb_device_endpoint_disable_callback+0x132>
		if (ep_num == 0) { // control endpoint
    fafe:	230f      	movs	r3, #15
    fb00:	18fb      	adds	r3, r7, r3
    fb02:	781b      	ldrb	r3, [r3, #0]
    fb04:	2b00      	cmp	r3, #0
    fb06:	d10c      	bne.n	fb22 <usb_device_endpoint_disable_callback+0xf6>
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENCLR.reg = USB_DEVICE_EPINTENCLR_TRFAIL0 | USB_DEVICE_EPINTENCLR_TRFAIL1;
    fb08:	687b      	ldr	r3, [r7, #4]
    fb0a:	6819      	ldr	r1, [r3, #0]
    fb0c:	230f      	movs	r3, #15
    fb0e:	18fb      	adds	r3, r7, r3
    fb10:	781a      	ldrb	r2, [r3, #0]
    fb12:	2384      	movs	r3, #132	; 0x84
    fb14:	005b      	lsls	r3, r3, #1
    fb16:	0152      	lsls	r2, r2, #5
    fb18:	188a      	adds	r2, r1, r2
    fb1a:	18d3      	adds	r3, r2, r3
    fb1c:	220c      	movs	r2, #12
    fb1e:	701a      	strb	r2, [r3, #0]
    fb20:	e01d      	b.n	fb5e <usb_device_endpoint_disable_callback+0x132>
		} else if (ep & USB_EP_DIR_IN) {
    fb22:	1cfb      	adds	r3, r7, #3
    fb24:	781b      	ldrb	r3, [r3, #0]
    fb26:	b25b      	sxtb	r3, r3
    fb28:	2b00      	cmp	r3, #0
    fb2a:	da0c      	bge.n	fb46 <usb_device_endpoint_disable_callback+0x11a>
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENCLR.reg = USB_DEVICE_EPINTENCLR_TRFAIL1;
    fb2c:	687b      	ldr	r3, [r7, #4]
    fb2e:	6819      	ldr	r1, [r3, #0]
    fb30:	230f      	movs	r3, #15
    fb32:	18fb      	adds	r3, r7, r3
    fb34:	781a      	ldrb	r2, [r3, #0]
    fb36:	2384      	movs	r3, #132	; 0x84
    fb38:	005b      	lsls	r3, r3, #1
    fb3a:	0152      	lsls	r2, r2, #5
    fb3c:	188a      	adds	r2, r1, r2
    fb3e:	18d3      	adds	r3, r2, r3
    fb40:	2208      	movs	r2, #8
    fb42:	701a      	strb	r2, [r3, #0]
    fb44:	e00b      	b.n	fb5e <usb_device_endpoint_disable_callback+0x132>
		} else {
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENCLR.reg = USB_DEVICE_EPINTENCLR_TRFAIL0;
    fb46:	687b      	ldr	r3, [r7, #4]
    fb48:	6819      	ldr	r1, [r3, #0]
    fb4a:	230f      	movs	r3, #15
    fb4c:	18fb      	adds	r3, r7, r3
    fb4e:	781a      	ldrb	r2, [r3, #0]
    fb50:	2384      	movs	r3, #132	; 0x84
    fb52:	005b      	lsls	r3, r3, #1
    fb54:	0152      	lsls	r2, r2, #5
    fb56:	188a      	adds	r2, r1, r2
    fb58:	18d3      	adds	r3, r2, r3
    fb5a:	2204      	movs	r2, #4
    fb5c:	701a      	strb	r2, [r3, #0]
		}
	}

	if (callback_type == USB_DEVICE_ENDPOINT_CALLBACK_RXSTP) {
    fb5e:	1cbb      	adds	r3, r7, #2
    fb60:	781b      	ldrb	r3, [r3, #0]
    fb62:	2b02      	cmp	r3, #2
    fb64:	d10b      	bne.n	fb7e <usb_device_endpoint_disable_callback+0x152>
		module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENCLR.reg = USB_DEVICE_EPINTENCLR_RXSTP;
    fb66:	687b      	ldr	r3, [r7, #4]
    fb68:	6819      	ldr	r1, [r3, #0]
    fb6a:	230f      	movs	r3, #15
    fb6c:	18fb      	adds	r3, r7, r3
    fb6e:	781a      	ldrb	r2, [r3, #0]
    fb70:	2384      	movs	r3, #132	; 0x84
    fb72:	005b      	lsls	r3, r3, #1
    fb74:	0152      	lsls	r2, r2, #5
    fb76:	188a      	adds	r2, r1, r2
    fb78:	18d3      	adds	r3, r2, r3
    fb7a:	2210      	movs	r2, #16
    fb7c:	701a      	strb	r2, [r3, #0]
	}

	if (callback_type == USB_DEVICE_ENDPOINT_CALLBACK_STALL) {
    fb7e:	1cbb      	adds	r3, r7, #2
    fb80:	781b      	ldrb	r3, [r3, #0]
    fb82:	2b03      	cmp	r3, #3
    fb84:	d11d      	bne.n	fbc2 <usb_device_endpoint_disable_callback+0x196>
		if (ep & USB_EP_DIR_IN) {
    fb86:	1cfb      	adds	r3, r7, #3
    fb88:	781b      	ldrb	r3, [r3, #0]
    fb8a:	b25b      	sxtb	r3, r3
    fb8c:	2b00      	cmp	r3, #0
    fb8e:	da0c      	bge.n	fbaa <usb_device_endpoint_disable_callback+0x17e>
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENCLR.reg = USB_DEVICE_EPINTENCLR_STALL1;
    fb90:	687b      	ldr	r3, [r7, #4]
    fb92:	6819      	ldr	r1, [r3, #0]
    fb94:	230f      	movs	r3, #15
    fb96:	18fb      	adds	r3, r7, r3
    fb98:	781a      	ldrb	r2, [r3, #0]
    fb9a:	2384      	movs	r3, #132	; 0x84
    fb9c:	005b      	lsls	r3, r3, #1
    fb9e:	0152      	lsls	r2, r2, #5
    fba0:	188a      	adds	r2, r1, r2
    fba2:	18d3      	adds	r3, r2, r3
    fba4:	2240      	movs	r2, #64	; 0x40
    fba6:	701a      	strb	r2, [r3, #0]
    fba8:	e00b      	b.n	fbc2 <usb_device_endpoint_disable_callback+0x196>
		} else {
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTENCLR.reg = USB_DEVICE_EPINTENCLR_STALL0;
    fbaa:	687b      	ldr	r3, [r7, #4]
    fbac:	6819      	ldr	r1, [r3, #0]
    fbae:	230f      	movs	r3, #15
    fbb0:	18fb      	adds	r3, r7, r3
    fbb2:	781a      	ldrb	r2, [r3, #0]
    fbb4:	2384      	movs	r3, #132	; 0x84
    fbb6:	005b      	lsls	r3, r3, #1
    fbb8:	0152      	lsls	r2, r2, #5
    fbba:	188a      	adds	r2, r1, r2
    fbbc:	18d3      	adds	r3, r2, r3
    fbbe:	2220      	movs	r2, #32
    fbc0:	701a      	strb	r2, [r3, #0]
		}
	}

	return STATUS_OK;
    fbc2:	2300      	movs	r3, #0
}
    fbc4:	0018      	movs	r0, r3
    fbc6:	46bd      	mov	sp, r7
    fbc8:	b004      	add	sp, #16
    fbca:	bd80      	pop	{r7, pc}
    fbcc:	00015958 	.word	0x00015958

0000fbd0 <usb_device_endpoint_get_config_defaults>:
 * \li endpoint type is control
 *
 * \param[out] ep_config  Configuration structure to initialize to default values
 */
void usb_device_endpoint_get_config_defaults(struct usb_device_endpoint_config *ep_config)
{
    fbd0:	b580      	push	{r7, lr}
    fbd2:	b082      	sub	sp, #8
    fbd4:	af00      	add	r7, sp, #0
    fbd6:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(ep_config);

	/* Write default config to config struct */
	ep_config->ep_address = 0;
    fbd8:	687b      	ldr	r3, [r7, #4]
    fbda:	2200      	movs	r2, #0
    fbdc:	701a      	strb	r2, [r3, #0]
	ep_config->ep_size = USB_ENDPOINT_8_BYTE;
    fbde:	687b      	ldr	r3, [r7, #4]
    fbe0:	2200      	movs	r2, #0
    fbe2:	705a      	strb	r2, [r3, #1]
	ep_config->auto_zlp = false;
    fbe4:	687b      	ldr	r3, [r7, #4]
    fbe6:	2200      	movs	r2, #0
    fbe8:	709a      	strb	r2, [r3, #2]
	ep_config->ep_type = USB_DEVICE_ENDPOINT_TYPE_CONTROL;
    fbea:	687b      	ldr	r3, [r7, #4]
    fbec:	2201      	movs	r2, #1
    fbee:	70da      	strb	r2, [r3, #3]
}
    fbf0:	46c0      	nop			; (mov r8, r8)
    fbf2:	46bd      	mov	sp, r7
    fbf4:	b002      	add	sp, #8
    fbf6:	bd80      	pop	{r7, pc}

0000fbf8 <usb_device_endpoint_set_config>:
 * \retval STATUS_OK         The device endpoint was configured successfully
 * \retval STATUS_ERR_DENIED The endpoint address is already configured
 */
enum status_code usb_device_endpoint_set_config(struct usb_module *module_inst,
		struct usb_device_endpoint_config *ep_config)
{
    fbf8:	b590      	push	{r4, r7, lr}
    fbfa:	b085      	sub	sp, #20
    fbfc:	af00      	add	r7, sp, #0
    fbfe:	6078      	str	r0, [r7, #4]
    fc00:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(ep_config);

	uint8_t ep_num = ep_config->ep_address & USB_EP_ADDR_MASK;
    fc02:	683b      	ldr	r3, [r7, #0]
    fc04:	781a      	ldrb	r2, [r3, #0]
    fc06:	230f      	movs	r3, #15
    fc08:	18fb      	adds	r3, r7, r3
    fc0a:	210f      	movs	r1, #15
    fc0c:	400a      	ands	r2, r1
    fc0e:	701a      	strb	r2, [r3, #0]
	uint8_t ep_bank = (ep_config->ep_address & USB_EP_DIR_IN) ? 1 : 0;
    fc10:	683b      	ldr	r3, [r7, #0]
    fc12:	781b      	ldrb	r3, [r3, #0]
    fc14:	b25b      	sxtb	r3, r3
    fc16:	b2db      	uxtb	r3, r3
    fc18:	09db      	lsrs	r3, r3, #7
    fc1a:	b2da      	uxtb	r2, r3
    fc1c:	230e      	movs	r3, #14
    fc1e:	18fb      	adds	r3, r7, r3
    fc20:	701a      	strb	r2, [r3, #0]

	switch (ep_config->ep_type) {
    fc22:	683b      	ldr	r3, [r7, #0]
    fc24:	78db      	ldrb	r3, [r3, #3]
    fc26:	2b04      	cmp	r3, #4
    fc28:	d900      	bls.n	fc2c <usb_device_endpoint_set_config+0x34>
    fc2a:	e200      	b.n	1002e <usb_device_endpoint_set_config+0x436>
    fc2c:	009a      	lsls	r2, r3, #2
    fc2e:	4be4      	ldr	r3, [pc, #912]	; (ffc0 <usb_device_endpoint_set_config+0x3c8>)
    fc30:	18d3      	adds	r3, r2, r3
    fc32:	681b      	ldr	r3, [r3, #0]
    fc34:	469f      	mov	pc, r3
		case USB_DEVICE_ENDPOINT_TYPE_DISABLE:
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg = USB_DEVICE_EPCFG_EPTYPE0(0) |  USB_DEVICE_EPCFG_EPTYPE1(0);
    fc36:	687b      	ldr	r3, [r7, #4]
    fc38:	681b      	ldr	r3, [r3, #0]
    fc3a:	220f      	movs	r2, #15
    fc3c:	18ba      	adds	r2, r7, r2
    fc3e:	7812      	ldrb	r2, [r2, #0]
    fc40:	3208      	adds	r2, #8
    fc42:	0152      	lsls	r2, r2, #5
    fc44:	2100      	movs	r1, #0
    fc46:	54d1      	strb	r1, [r2, r3]
			return STATUS_OK;
    fc48:	2300      	movs	r3, #0
    fc4a:	e249      	b.n	100e0 <usb_device_endpoint_set_config+0x4e8>

		case USB_DEVICE_ENDPOINT_TYPE_CONTROL:
			if ((module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE0_Msk) == 0 && \
    fc4c:	687b      	ldr	r3, [r7, #4]
    fc4e:	681b      	ldr	r3, [r3, #0]
    fc50:	220f      	movs	r2, #15
    fc52:	18ba      	adds	r2, r7, r2
    fc54:	7812      	ldrb	r2, [r2, #0]
    fc56:	3208      	adds	r2, #8
    fc58:	0152      	lsls	r2, r2, #5
    fc5a:	5cd3      	ldrb	r3, [r2, r3]
    fc5c:	b2db      	uxtb	r3, r3
    fc5e:	001a      	movs	r2, r3
    fc60:	2307      	movs	r3, #7
    fc62:	4013      	ands	r3, r2
    fc64:	d130      	bne.n	fcc8 <usb_device_endpoint_set_config+0xd0>
				(module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE1_Msk) == 0) {
    fc66:	687b      	ldr	r3, [r7, #4]
    fc68:	681b      	ldr	r3, [r3, #0]
    fc6a:	220f      	movs	r2, #15
    fc6c:	18ba      	adds	r2, r7, r2
    fc6e:	7812      	ldrb	r2, [r2, #0]
    fc70:	3208      	adds	r2, #8
    fc72:	0152      	lsls	r2, r2, #5
    fc74:	5cd3      	ldrb	r3, [r2, r3]
    fc76:	b2db      	uxtb	r3, r3
    fc78:	001a      	movs	r2, r3
    fc7a:	2370      	movs	r3, #112	; 0x70
    fc7c:	4013      	ands	r3, r2
		case USB_DEVICE_ENDPOINT_TYPE_DISABLE:
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg = USB_DEVICE_EPCFG_EPTYPE0(0) |  USB_DEVICE_EPCFG_EPTYPE1(0);
			return STATUS_OK;

		case USB_DEVICE_ENDPOINT_TYPE_CONTROL:
			if ((module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE0_Msk) == 0 && \
    fc7e:	d123      	bne.n	fcc8 <usb_device_endpoint_set_config+0xd0>
				(module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE1_Msk) == 0) {
				module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg = USB_DEVICE_EPCFG_EPTYPE0(1) | USB_DEVICE_EPCFG_EPTYPE1(1);
    fc80:	687b      	ldr	r3, [r7, #4]
    fc82:	681b      	ldr	r3, [r3, #0]
    fc84:	220f      	movs	r2, #15
    fc86:	18ba      	adds	r2, r7, r2
    fc88:	7812      	ldrb	r2, [r2, #0]
    fc8a:	3208      	adds	r2, #8
    fc8c:	0152      	lsls	r2, r2, #5
    fc8e:	2111      	movs	r1, #17
    fc90:	54d1      	strb	r1, [r2, r3]
				module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_BK0RDY;
    fc92:	687b      	ldr	r3, [r7, #4]
    fc94:	681a      	ldr	r2, [r3, #0]
    fc96:	230f      	movs	r3, #15
    fc98:	18fb      	adds	r3, r7, r3
    fc9a:	781b      	ldrb	r3, [r3, #0]
    fc9c:	3308      	adds	r3, #8
    fc9e:	015b      	lsls	r3, r3, #5
    fca0:	18d3      	adds	r3, r2, r3
    fca2:	3305      	adds	r3, #5
    fca4:	2240      	movs	r2, #64	; 0x40
    fca6:	701a      	strb	r2, [r3, #0]
				module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSCLR_BK1RDY;
    fca8:	687b      	ldr	r3, [r7, #4]
    fcaa:	681a      	ldr	r2, [r3, #0]
    fcac:	230f      	movs	r3, #15
    fcae:	18fb      	adds	r3, r7, r3
    fcb0:	781b      	ldrb	r3, [r3, #0]
    fcb2:	3308      	adds	r3, #8
    fcb4:	015b      	lsls	r3, r3, #5
    fcb6:	18d3      	adds	r3, r2, r3
    fcb8:	3304      	adds	r3, #4
    fcba:	2280      	movs	r2, #128	; 0x80
    fcbc:	701a      	strb	r2, [r3, #0]
			} else {
				return STATUS_ERR_DENIED;
			}
			if (true == ep_config->auto_zlp) {
    fcbe:	683b      	ldr	r3, [r7, #0]
    fcc0:	789b      	ldrb	r3, [r3, #2]
    fcc2:	2b00      	cmp	r3, #0
    fcc4:	d102      	bne.n	fccc <usb_device_endpoint_set_config+0xd4>
    fcc6:	e028      	b.n	fd1a <usb_device_endpoint_set_config+0x122>
				(module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE1_Msk) == 0) {
				module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg = USB_DEVICE_EPCFG_EPTYPE0(1) | USB_DEVICE_EPCFG_EPTYPE1(1);
				module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_BK0RDY;
				module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSCLR_BK1RDY;
			} else {
				return STATUS_ERR_DENIED;
    fcc8:	231c      	movs	r3, #28
    fcca:	e209      	b.n	100e0 <usb_device_endpoint_set_config+0x4e8>
			}
			if (true == ep_config->auto_zlp) {
				usb_descriptor_table.usb_endpoint_table[ep_num].DeviceDescBank[0].PCKSIZE.reg |= USB_DEVICE_PCKSIZE_AUTO_ZLP;
    fccc:	230f      	movs	r3, #15
    fcce:	18fb      	adds	r3, r7, r3
    fcd0:	7818      	ldrb	r0, [r3, #0]
    fcd2:	230f      	movs	r3, #15
    fcd4:	18fb      	adds	r3, r7, r3
    fcd6:	781b      	ldrb	r3, [r3, #0]
    fcd8:	4aba      	ldr	r2, [pc, #744]	; (ffc4 <usb_device_endpoint_set_config+0x3cc>)
    fcda:	015b      	lsls	r3, r3, #5
    fcdc:	18d3      	adds	r3, r2, r3
    fcde:	3304      	adds	r3, #4
    fce0:	681b      	ldr	r3, [r3, #0]
    fce2:	2280      	movs	r2, #128	; 0x80
    fce4:	0612      	lsls	r2, r2, #24
    fce6:	431a      	orrs	r2, r3
    fce8:	49b6      	ldr	r1, [pc, #728]	; (ffc4 <usb_device_endpoint_set_config+0x3cc>)
    fcea:	0143      	lsls	r3, r0, #5
    fcec:	18cb      	adds	r3, r1, r3
    fcee:	3304      	adds	r3, #4
    fcf0:	601a      	str	r2, [r3, #0]
				usb_descriptor_table.usb_endpoint_table[ep_num].DeviceDescBank[1].PCKSIZE.reg |= USB_DEVICE_PCKSIZE_AUTO_ZLP;
    fcf2:	230f      	movs	r3, #15
    fcf4:	18fb      	adds	r3, r7, r3
    fcf6:	7818      	ldrb	r0, [r3, #0]
    fcf8:	230f      	movs	r3, #15
    fcfa:	18fb      	adds	r3, r7, r3
    fcfc:	781b      	ldrb	r3, [r3, #0]
    fcfe:	4ab1      	ldr	r2, [pc, #708]	; (ffc4 <usb_device_endpoint_set_config+0x3cc>)
    fd00:	015b      	lsls	r3, r3, #5
    fd02:	18d3      	adds	r3, r2, r3
    fd04:	3314      	adds	r3, #20
    fd06:	681b      	ldr	r3, [r3, #0]
    fd08:	2280      	movs	r2, #128	; 0x80
    fd0a:	0612      	lsls	r2, r2, #24
    fd0c:	431a      	orrs	r2, r3
    fd0e:	49ad      	ldr	r1, [pc, #692]	; (ffc4 <usb_device_endpoint_set_config+0x3cc>)
    fd10:	0143      	lsls	r3, r0, #5
    fd12:	18cb      	adds	r3, r1, r3
    fd14:	3314      	adds	r3, #20
    fd16:	601a      	str	r2, [r3, #0]
    fd18:	e023      	b.n	fd62 <usb_device_endpoint_set_config+0x16a>
			} else {
				usb_descriptor_table.usb_endpoint_table[ep_num].DeviceDescBank[0].PCKSIZE.reg &= ~USB_DEVICE_PCKSIZE_AUTO_ZLP;
    fd1a:	230f      	movs	r3, #15
    fd1c:	18fb      	adds	r3, r7, r3
    fd1e:	7818      	ldrb	r0, [r3, #0]
    fd20:	230f      	movs	r3, #15
    fd22:	18fb      	adds	r3, r7, r3
    fd24:	781b      	ldrb	r3, [r3, #0]
    fd26:	4aa7      	ldr	r2, [pc, #668]	; (ffc4 <usb_device_endpoint_set_config+0x3cc>)
    fd28:	015b      	lsls	r3, r3, #5
    fd2a:	18d3      	adds	r3, r2, r3
    fd2c:	3304      	adds	r3, #4
    fd2e:	681b      	ldr	r3, [r3, #0]
    fd30:	005b      	lsls	r3, r3, #1
    fd32:	085a      	lsrs	r2, r3, #1
    fd34:	49a3      	ldr	r1, [pc, #652]	; (ffc4 <usb_device_endpoint_set_config+0x3cc>)
    fd36:	0143      	lsls	r3, r0, #5
    fd38:	18cb      	adds	r3, r1, r3
    fd3a:	3304      	adds	r3, #4
    fd3c:	601a      	str	r2, [r3, #0]
				usb_descriptor_table.usb_endpoint_table[ep_num].DeviceDescBank[1].PCKSIZE.reg &= ~USB_DEVICE_PCKSIZE_AUTO_ZLP;
    fd3e:	230f      	movs	r3, #15
    fd40:	18fb      	adds	r3, r7, r3
    fd42:	7818      	ldrb	r0, [r3, #0]
    fd44:	230f      	movs	r3, #15
    fd46:	18fb      	adds	r3, r7, r3
    fd48:	781b      	ldrb	r3, [r3, #0]
    fd4a:	4a9e      	ldr	r2, [pc, #632]	; (ffc4 <usb_device_endpoint_set_config+0x3cc>)
    fd4c:	015b      	lsls	r3, r3, #5
    fd4e:	18d3      	adds	r3, r2, r3
    fd50:	3314      	adds	r3, #20
    fd52:	681b      	ldr	r3, [r3, #0]
    fd54:	005b      	lsls	r3, r3, #1
    fd56:	085a      	lsrs	r2, r3, #1
    fd58:	499a      	ldr	r1, [pc, #616]	; (ffc4 <usb_device_endpoint_set_config+0x3cc>)
    fd5a:	0143      	lsls	r3, r0, #5
    fd5c:	18cb      	adds	r3, r1, r3
    fd5e:	3314      	adds	r3, #20
    fd60:	601a      	str	r2, [r3, #0]
			}
			usb_descriptor_table.usb_endpoint_table[ep_num].DeviceDescBank[0].PCKSIZE.bit.SIZE = ep_config->ep_size;
    fd62:	230f      	movs	r3, #15
    fd64:	18fb      	adds	r3, r7, r3
    fd66:	781b      	ldrb	r3, [r3, #0]
    fd68:	683a      	ldr	r2, [r7, #0]
    fd6a:	7852      	ldrb	r2, [r2, #1]
    fd6c:	1c11      	adds	r1, r2, #0
    fd6e:	2207      	movs	r2, #7
    fd70:	400a      	ands	r2, r1
    fd72:	b2d1      	uxtb	r1, r2
    fd74:	4a93      	ldr	r2, [pc, #588]	; (ffc4 <usb_device_endpoint_set_config+0x3cc>)
    fd76:	015b      	lsls	r3, r3, #5
    fd78:	18d3      	adds	r3, r2, r3
    fd7a:	685a      	ldr	r2, [r3, #4]
    fd7c:	2007      	movs	r0, #7
    fd7e:	4001      	ands	r1, r0
    fd80:	0709      	lsls	r1, r1, #28
    fd82:	4891      	ldr	r0, [pc, #580]	; (ffc8 <usb_device_endpoint_set_config+0x3d0>)
    fd84:	4002      	ands	r2, r0
    fd86:	430a      	orrs	r2, r1
    fd88:	605a      	str	r2, [r3, #4]
			usb_descriptor_table.usb_endpoint_table[ep_num].DeviceDescBank[1].PCKSIZE.bit.SIZE = ep_config->ep_size;
    fd8a:	230f      	movs	r3, #15
    fd8c:	18fb      	adds	r3, r7, r3
    fd8e:	781b      	ldrb	r3, [r3, #0]
    fd90:	683a      	ldr	r2, [r7, #0]
    fd92:	7852      	ldrb	r2, [r2, #1]
    fd94:	1c11      	adds	r1, r2, #0
    fd96:	2207      	movs	r2, #7
    fd98:	400a      	ands	r2, r1
    fd9a:	b2d1      	uxtb	r1, r2
    fd9c:	4a89      	ldr	r2, [pc, #548]	; (ffc4 <usb_device_endpoint_set_config+0x3cc>)
    fd9e:	015b      	lsls	r3, r3, #5
    fda0:	18d3      	adds	r3, r2, r3
    fda2:	3310      	adds	r3, #16
    fda4:	685a      	ldr	r2, [r3, #4]
    fda6:	2007      	movs	r0, #7
    fda8:	4001      	ands	r1, r0
    fdaa:	0709      	lsls	r1, r1, #28
    fdac:	4886      	ldr	r0, [pc, #536]	; (ffc8 <usb_device_endpoint_set_config+0x3d0>)
    fdae:	4002      	ands	r2, r0
    fdb0:	430a      	orrs	r2, r1
    fdb2:	605a      	str	r2, [r3, #4]
			return STATUS_OK;
    fdb4:	2300      	movs	r3, #0
    fdb6:	e193      	b.n	100e0 <usb_device_endpoint_set_config+0x4e8>

		case USB_DEVICE_ENDPOINT_TYPE_ISOCHRONOUS:
			if (ep_bank) {
    fdb8:	230e      	movs	r3, #14
    fdba:	18fb      	adds	r3, r7, r3
    fdbc:	781b      	ldrb	r3, [r3, #0]
    fdbe:	2b00      	cmp	r3, #0
    fdc0:	d030      	beq.n	fe24 <usb_device_endpoint_set_config+0x22c>
				if ((module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE1_Msk) == 0){
    fdc2:	687b      	ldr	r3, [r7, #4]
    fdc4:	681b      	ldr	r3, [r3, #0]
    fdc6:	220f      	movs	r2, #15
    fdc8:	18ba      	adds	r2, r7, r2
    fdca:	7812      	ldrb	r2, [r2, #0]
    fdcc:	3208      	adds	r2, #8
    fdce:	0152      	lsls	r2, r2, #5
    fdd0:	5cd3      	ldrb	r3, [r2, r3]
    fdd2:	b2db      	uxtb	r3, r3
    fdd4:	001a      	movs	r2, r3
    fdd6:	2370      	movs	r3, #112	; 0x70
    fdd8:	4013      	ands	r3, r2
    fdda:	d121      	bne.n	fe20 <usb_device_endpoint_set_config+0x228>
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg |= USB_DEVICE_EPCFG_EPTYPE1(2);
    fddc:	687b      	ldr	r3, [r7, #4]
    fdde:	681a      	ldr	r2, [r3, #0]
    fde0:	230f      	movs	r3, #15
    fde2:	18fb      	adds	r3, r7, r3
    fde4:	7819      	ldrb	r1, [r3, #0]
    fde6:	687b      	ldr	r3, [r7, #4]
    fde8:	681b      	ldr	r3, [r3, #0]
    fdea:	200f      	movs	r0, #15
    fdec:	1838      	adds	r0, r7, r0
    fdee:	7800      	ldrb	r0, [r0, #0]
    fdf0:	3008      	adds	r0, #8
    fdf2:	0140      	lsls	r0, r0, #5
    fdf4:	5cc3      	ldrb	r3, [r0, r3]
    fdf6:	b2db      	uxtb	r3, r3
    fdf8:	2020      	movs	r0, #32
    fdfa:	4303      	orrs	r3, r0
    fdfc:	b2d8      	uxtb	r0, r3
    fdfe:	000b      	movs	r3, r1
    fe00:	3308      	adds	r3, #8
    fe02:	015b      	lsls	r3, r3, #5
    fe04:	1c01      	adds	r1, r0, #0
    fe06:	5499      	strb	r1, [r3, r2]
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSCLR_BK1RDY;
    fe08:	687b      	ldr	r3, [r7, #4]
    fe0a:	681a      	ldr	r2, [r3, #0]
    fe0c:	230f      	movs	r3, #15
    fe0e:	18fb      	adds	r3, r7, r3
    fe10:	781b      	ldrb	r3, [r3, #0]
    fe12:	3308      	adds	r3, #8
    fe14:	015b      	lsls	r3, r3, #5
    fe16:	18d3      	adds	r3, r2, r3
    fe18:	3304      	adds	r3, #4
    fe1a:	2280      	movs	r2, #128	; 0x80
    fe1c:	701a      	strb	r2, [r3, #0]
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_BK0RDY;
				} else {
					return STATUS_ERR_DENIED;
				}
			}
			break;
    fe1e:	e107      	b.n	10030 <usb_device_endpoint_set_config+0x438>
			if (ep_bank) {
				if ((module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE1_Msk) == 0){
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg |= USB_DEVICE_EPCFG_EPTYPE1(2);
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSCLR_BK1RDY;
				} else {
					return STATUS_ERR_DENIED;
    fe20:	231c      	movs	r3, #28
    fe22:	e15d      	b.n	100e0 <usb_device_endpoint_set_config+0x4e8>
				}
			} else {
				if ((module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE0_Msk) == 0){
    fe24:	687b      	ldr	r3, [r7, #4]
    fe26:	681b      	ldr	r3, [r3, #0]
    fe28:	220f      	movs	r2, #15
    fe2a:	18ba      	adds	r2, r7, r2
    fe2c:	7812      	ldrb	r2, [r2, #0]
    fe2e:	3208      	adds	r2, #8
    fe30:	0152      	lsls	r2, r2, #5
    fe32:	5cd3      	ldrb	r3, [r2, r3]
    fe34:	b2db      	uxtb	r3, r3
    fe36:	001a      	movs	r2, r3
    fe38:	2307      	movs	r3, #7
    fe3a:	4013      	ands	r3, r2
    fe3c:	d121      	bne.n	fe82 <usb_device_endpoint_set_config+0x28a>
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg |= USB_DEVICE_EPCFG_EPTYPE0(2);
    fe3e:	687b      	ldr	r3, [r7, #4]
    fe40:	681a      	ldr	r2, [r3, #0]
    fe42:	230f      	movs	r3, #15
    fe44:	18fb      	adds	r3, r7, r3
    fe46:	7819      	ldrb	r1, [r3, #0]
    fe48:	687b      	ldr	r3, [r7, #4]
    fe4a:	681b      	ldr	r3, [r3, #0]
    fe4c:	200f      	movs	r0, #15
    fe4e:	1838      	adds	r0, r7, r0
    fe50:	7800      	ldrb	r0, [r0, #0]
    fe52:	3008      	adds	r0, #8
    fe54:	0140      	lsls	r0, r0, #5
    fe56:	5cc3      	ldrb	r3, [r0, r3]
    fe58:	b2db      	uxtb	r3, r3
    fe5a:	2002      	movs	r0, #2
    fe5c:	4303      	orrs	r3, r0
    fe5e:	b2d8      	uxtb	r0, r3
    fe60:	000b      	movs	r3, r1
    fe62:	3308      	adds	r3, #8
    fe64:	015b      	lsls	r3, r3, #5
    fe66:	1c01      	adds	r1, r0, #0
    fe68:	5499      	strb	r1, [r3, r2]
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_BK0RDY;
    fe6a:	687b      	ldr	r3, [r7, #4]
    fe6c:	681a      	ldr	r2, [r3, #0]
    fe6e:	230f      	movs	r3, #15
    fe70:	18fb      	adds	r3, r7, r3
    fe72:	781b      	ldrb	r3, [r3, #0]
    fe74:	3308      	adds	r3, #8
    fe76:	015b      	lsls	r3, r3, #5
    fe78:	18d3      	adds	r3, r2, r3
    fe7a:	3305      	adds	r3, #5
    fe7c:	2240      	movs	r2, #64	; 0x40
    fe7e:	701a      	strb	r2, [r3, #0]
				} else {
					return STATUS_ERR_DENIED;
				}
			}
			break;
    fe80:	e0d6      	b.n	10030 <usb_device_endpoint_set_config+0x438>
			} else {
				if ((module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE0_Msk) == 0){
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg |= USB_DEVICE_EPCFG_EPTYPE0(2);
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_BK0RDY;
				} else {
					return STATUS_ERR_DENIED;
    fe82:	231c      	movs	r3, #28
    fe84:	e12c      	b.n	100e0 <usb_device_endpoint_set_config+0x4e8>
				}
			}
			break;

		case USB_DEVICE_ENDPOINT_TYPE_BULK:
			if (ep_bank) {
    fe86:	230e      	movs	r3, #14
    fe88:	18fb      	adds	r3, r7, r3
    fe8a:	781b      	ldrb	r3, [r3, #0]
    fe8c:	2b00      	cmp	r3, #0
    fe8e:	d030      	beq.n	fef2 <usb_device_endpoint_set_config+0x2fa>
				if ((module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE1_Msk) == 0){
    fe90:	687b      	ldr	r3, [r7, #4]
    fe92:	681b      	ldr	r3, [r3, #0]
    fe94:	220f      	movs	r2, #15
    fe96:	18ba      	adds	r2, r7, r2
    fe98:	7812      	ldrb	r2, [r2, #0]
    fe9a:	3208      	adds	r2, #8
    fe9c:	0152      	lsls	r2, r2, #5
    fe9e:	5cd3      	ldrb	r3, [r2, r3]
    fea0:	b2db      	uxtb	r3, r3
    fea2:	001a      	movs	r2, r3
    fea4:	2370      	movs	r3, #112	; 0x70
    fea6:	4013      	ands	r3, r2
    fea8:	d121      	bne.n	feee <usb_device_endpoint_set_config+0x2f6>
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg |= USB_DEVICE_EPCFG_EPTYPE1(3);
    feaa:	687b      	ldr	r3, [r7, #4]
    feac:	681a      	ldr	r2, [r3, #0]
    feae:	230f      	movs	r3, #15
    feb0:	18fb      	adds	r3, r7, r3
    feb2:	7819      	ldrb	r1, [r3, #0]
    feb4:	687b      	ldr	r3, [r7, #4]
    feb6:	681b      	ldr	r3, [r3, #0]
    feb8:	200f      	movs	r0, #15
    feba:	1838      	adds	r0, r7, r0
    febc:	7800      	ldrb	r0, [r0, #0]
    febe:	3008      	adds	r0, #8
    fec0:	0140      	lsls	r0, r0, #5
    fec2:	5cc3      	ldrb	r3, [r0, r3]
    fec4:	b2db      	uxtb	r3, r3
    fec6:	2030      	movs	r0, #48	; 0x30
    fec8:	4303      	orrs	r3, r0
    feca:	b2d8      	uxtb	r0, r3
    fecc:	000b      	movs	r3, r1
    fece:	3308      	adds	r3, #8
    fed0:	015b      	lsls	r3, r3, #5
    fed2:	1c01      	adds	r1, r0, #0
    fed4:	5499      	strb	r1, [r3, r2]
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSCLR_BK1RDY;
    fed6:	687b      	ldr	r3, [r7, #4]
    fed8:	681a      	ldr	r2, [r3, #0]
    feda:	230f      	movs	r3, #15
    fedc:	18fb      	adds	r3, r7, r3
    fede:	781b      	ldrb	r3, [r3, #0]
    fee0:	3308      	adds	r3, #8
    fee2:	015b      	lsls	r3, r3, #5
    fee4:	18d3      	adds	r3, r2, r3
    fee6:	3304      	adds	r3, #4
    fee8:	2280      	movs	r2, #128	; 0x80
    feea:	701a      	strb	r2, [r3, #0]
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_BK0RDY;
				} else {
					return STATUS_ERR_DENIED;
				}
			}
			break;
    feec:	e0a0      	b.n	10030 <usb_device_endpoint_set_config+0x438>
			if (ep_bank) {
				if ((module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE1_Msk) == 0){
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg |= USB_DEVICE_EPCFG_EPTYPE1(3);
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSCLR_BK1RDY;
				} else {
					return STATUS_ERR_DENIED;
    feee:	231c      	movs	r3, #28
    fef0:	e0f6      	b.n	100e0 <usb_device_endpoint_set_config+0x4e8>
				}
			} else {
				if ((module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE0_Msk) == 0){
    fef2:	687b      	ldr	r3, [r7, #4]
    fef4:	681b      	ldr	r3, [r3, #0]
    fef6:	220f      	movs	r2, #15
    fef8:	18ba      	adds	r2, r7, r2
    fefa:	7812      	ldrb	r2, [r2, #0]
    fefc:	3208      	adds	r2, #8
    fefe:	0152      	lsls	r2, r2, #5
    ff00:	5cd3      	ldrb	r3, [r2, r3]
    ff02:	b2db      	uxtb	r3, r3
    ff04:	001a      	movs	r2, r3
    ff06:	2307      	movs	r3, #7
    ff08:	4013      	ands	r3, r2
    ff0a:	d121      	bne.n	ff50 <usb_device_endpoint_set_config+0x358>
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg |= USB_DEVICE_EPCFG_EPTYPE0(3);
    ff0c:	687b      	ldr	r3, [r7, #4]
    ff0e:	681a      	ldr	r2, [r3, #0]
    ff10:	230f      	movs	r3, #15
    ff12:	18fb      	adds	r3, r7, r3
    ff14:	7819      	ldrb	r1, [r3, #0]
    ff16:	687b      	ldr	r3, [r7, #4]
    ff18:	681b      	ldr	r3, [r3, #0]
    ff1a:	200f      	movs	r0, #15
    ff1c:	1838      	adds	r0, r7, r0
    ff1e:	7800      	ldrb	r0, [r0, #0]
    ff20:	3008      	adds	r0, #8
    ff22:	0140      	lsls	r0, r0, #5
    ff24:	5cc3      	ldrb	r3, [r0, r3]
    ff26:	b2db      	uxtb	r3, r3
    ff28:	2003      	movs	r0, #3
    ff2a:	4303      	orrs	r3, r0
    ff2c:	b2d8      	uxtb	r0, r3
    ff2e:	000b      	movs	r3, r1
    ff30:	3308      	adds	r3, #8
    ff32:	015b      	lsls	r3, r3, #5
    ff34:	1c01      	adds	r1, r0, #0
    ff36:	5499      	strb	r1, [r3, r2]
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_BK0RDY;
    ff38:	687b      	ldr	r3, [r7, #4]
    ff3a:	681a      	ldr	r2, [r3, #0]
    ff3c:	230f      	movs	r3, #15
    ff3e:	18fb      	adds	r3, r7, r3
    ff40:	781b      	ldrb	r3, [r3, #0]
    ff42:	3308      	adds	r3, #8
    ff44:	015b      	lsls	r3, r3, #5
    ff46:	18d3      	adds	r3, r2, r3
    ff48:	3305      	adds	r3, #5
    ff4a:	2240      	movs	r2, #64	; 0x40
    ff4c:	701a      	strb	r2, [r3, #0]
				} else {
					return STATUS_ERR_DENIED;
				}
			}
			break;
    ff4e:	e06f      	b.n	10030 <usb_device_endpoint_set_config+0x438>
			} else {
				if ((module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE0_Msk) == 0){
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg |= USB_DEVICE_EPCFG_EPTYPE0(3);
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_BK0RDY;
				} else {
					return STATUS_ERR_DENIED;
    ff50:	231c      	movs	r3, #28
    ff52:	e0c5      	b.n	100e0 <usb_device_endpoint_set_config+0x4e8>
				}
			}
			break;

		case USB_DEVICE_ENDPOINT_TYPE_INTERRUPT:
			if (ep_bank) {
    ff54:	230e      	movs	r3, #14
    ff56:	18fb      	adds	r3, r7, r3
    ff58:	781b      	ldrb	r3, [r3, #0]
    ff5a:	2b00      	cmp	r3, #0
    ff5c:	d036      	beq.n	ffcc <usb_device_endpoint_set_config+0x3d4>
				if ((module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE1_Msk) == 0){
    ff5e:	687b      	ldr	r3, [r7, #4]
    ff60:	681b      	ldr	r3, [r3, #0]
    ff62:	220f      	movs	r2, #15
    ff64:	18ba      	adds	r2, r7, r2
    ff66:	7812      	ldrb	r2, [r2, #0]
    ff68:	3208      	adds	r2, #8
    ff6a:	0152      	lsls	r2, r2, #5
    ff6c:	5cd3      	ldrb	r3, [r2, r3]
    ff6e:	b2db      	uxtb	r3, r3
    ff70:	001a      	movs	r2, r3
    ff72:	2370      	movs	r3, #112	; 0x70
    ff74:	4013      	ands	r3, r2
    ff76:	d121      	bne.n	ffbc <usb_device_endpoint_set_config+0x3c4>
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg |= USB_DEVICE_EPCFG_EPTYPE1(4);
    ff78:	687b      	ldr	r3, [r7, #4]
    ff7a:	681a      	ldr	r2, [r3, #0]
    ff7c:	230f      	movs	r3, #15
    ff7e:	18fb      	adds	r3, r7, r3
    ff80:	7819      	ldrb	r1, [r3, #0]
    ff82:	687b      	ldr	r3, [r7, #4]
    ff84:	681b      	ldr	r3, [r3, #0]
    ff86:	200f      	movs	r0, #15
    ff88:	1838      	adds	r0, r7, r0
    ff8a:	7800      	ldrb	r0, [r0, #0]
    ff8c:	3008      	adds	r0, #8
    ff8e:	0140      	lsls	r0, r0, #5
    ff90:	5cc3      	ldrb	r3, [r0, r3]
    ff92:	b2db      	uxtb	r3, r3
    ff94:	2040      	movs	r0, #64	; 0x40
    ff96:	4303      	orrs	r3, r0
    ff98:	b2d8      	uxtb	r0, r3
    ff9a:	000b      	movs	r3, r1
    ff9c:	3308      	adds	r3, #8
    ff9e:	015b      	lsls	r3, r3, #5
    ffa0:	1c01      	adds	r1, r0, #0
    ffa2:	5499      	strb	r1, [r3, r2]
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSCLR_BK1RDY;
    ffa4:	687b      	ldr	r3, [r7, #4]
    ffa6:	681a      	ldr	r2, [r3, #0]
    ffa8:	230f      	movs	r3, #15
    ffaa:	18fb      	adds	r3, r7, r3
    ffac:	781b      	ldrb	r3, [r3, #0]
    ffae:	3308      	adds	r3, #8
    ffb0:	015b      	lsls	r3, r3, #5
    ffb2:	18d3      	adds	r3, r2, r3
    ffb4:	3304      	adds	r3, #4
    ffb6:	2280      	movs	r2, #128	; 0x80
    ffb8:	701a      	strb	r2, [r3, #0]
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_BK0RDY;
				} else {
					return STATUS_ERR_DENIED;
				}
			}
			break;
    ffba:	e039      	b.n	10030 <usb_device_endpoint_set_config+0x438>
			if (ep_bank) {
				if ((module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE1_Msk) == 0){
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg |= USB_DEVICE_EPCFG_EPTYPE1(4);
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSCLR_BK1RDY;
				} else {
					return STATUS_ERR_DENIED;
    ffbc:	231c      	movs	r3, #28
    ffbe:	e08f      	b.n	100e0 <usb_device_endpoint_set_config+0x4e8>
    ffc0:	0001595c 	.word	0x0001595c
    ffc4:	2000177c 	.word	0x2000177c
    ffc8:	8fffffff 	.word	0x8fffffff
				}
			} else {
				if ((module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE0_Msk) == 0){
    ffcc:	687b      	ldr	r3, [r7, #4]
    ffce:	681b      	ldr	r3, [r3, #0]
    ffd0:	220f      	movs	r2, #15
    ffd2:	18ba      	adds	r2, r7, r2
    ffd4:	7812      	ldrb	r2, [r2, #0]
    ffd6:	3208      	adds	r2, #8
    ffd8:	0152      	lsls	r2, r2, #5
    ffda:	5cd3      	ldrb	r3, [r2, r3]
    ffdc:	b2db      	uxtb	r3, r3
    ffde:	001a      	movs	r2, r3
    ffe0:	2307      	movs	r3, #7
    ffe2:	4013      	ands	r3, r2
    ffe4:	d121      	bne.n	1002a <usb_device_endpoint_set_config+0x432>
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg |= USB_DEVICE_EPCFG_EPTYPE0(4);
    ffe6:	687b      	ldr	r3, [r7, #4]
    ffe8:	681a      	ldr	r2, [r3, #0]
    ffea:	230f      	movs	r3, #15
    ffec:	18fb      	adds	r3, r7, r3
    ffee:	7819      	ldrb	r1, [r3, #0]
    fff0:	687b      	ldr	r3, [r7, #4]
    fff2:	681b      	ldr	r3, [r3, #0]
    fff4:	200f      	movs	r0, #15
    fff6:	1838      	adds	r0, r7, r0
    fff8:	7800      	ldrb	r0, [r0, #0]
    fffa:	3008      	adds	r0, #8
    fffc:	0140      	lsls	r0, r0, #5
    fffe:	5cc3      	ldrb	r3, [r0, r3]
   10000:	b2db      	uxtb	r3, r3
   10002:	2004      	movs	r0, #4
   10004:	4303      	orrs	r3, r0
   10006:	b2d8      	uxtb	r0, r3
   10008:	000b      	movs	r3, r1
   1000a:	3308      	adds	r3, #8
   1000c:	015b      	lsls	r3, r3, #5
   1000e:	1c01      	adds	r1, r0, #0
   10010:	5499      	strb	r1, [r3, r2]
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_BK0RDY;
   10012:	687b      	ldr	r3, [r7, #4]
   10014:	681a      	ldr	r2, [r3, #0]
   10016:	230f      	movs	r3, #15
   10018:	18fb      	adds	r3, r7, r3
   1001a:	781b      	ldrb	r3, [r3, #0]
   1001c:	3308      	adds	r3, #8
   1001e:	015b      	lsls	r3, r3, #5
   10020:	18d3      	adds	r3, r2, r3
   10022:	3305      	adds	r3, #5
   10024:	2240      	movs	r2, #64	; 0x40
   10026:	701a      	strb	r2, [r3, #0]
				} else {
					return STATUS_ERR_DENIED;
				}
			}
			break;
   10028:	e002      	b.n	10030 <usb_device_endpoint_set_config+0x438>
			} else {
				if ((module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg & USB_DEVICE_EPCFG_EPTYPE0_Msk) == 0){
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.reg |= USB_DEVICE_EPCFG_EPTYPE0(4);
					module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_BK0RDY;
				} else {
					return STATUS_ERR_DENIED;
   1002a:	231c      	movs	r3, #28
   1002c:	e058      	b.n	100e0 <usb_device_endpoint_set_config+0x4e8>
				}
			}
			break;

		default:
			break;
   1002e:	46c0      	nop			; (mov r8, r8)
	}

	usb_descriptor_table.usb_endpoint_table[ep_num].DeviceDescBank[ep_bank].PCKSIZE.bit.SIZE = ep_config->ep_size;
   10030:	230f      	movs	r3, #15
   10032:	18fb      	adds	r3, r7, r3
   10034:	7818      	ldrb	r0, [r3, #0]
   10036:	230e      	movs	r3, #14
   10038:	18fb      	adds	r3, r7, r3
   1003a:	781b      	ldrb	r3, [r3, #0]
   1003c:	683a      	ldr	r2, [r7, #0]
   1003e:	7852      	ldrb	r2, [r2, #1]
   10040:	1c11      	adds	r1, r2, #0
   10042:	2207      	movs	r2, #7
   10044:	400a      	ands	r2, r1
   10046:	b2d1      	uxtb	r1, r2
   10048:	4a27      	ldr	r2, [pc, #156]	; (100e8 <usb_device_endpoint_set_config+0x4f0>)
   1004a:	0040      	lsls	r0, r0, #1
   1004c:	18c3      	adds	r3, r0, r3
   1004e:	011b      	lsls	r3, r3, #4
   10050:	18d3      	adds	r3, r2, r3
   10052:	685a      	ldr	r2, [r3, #4]
   10054:	2007      	movs	r0, #7
   10056:	4001      	ands	r1, r0
   10058:	0709      	lsls	r1, r1, #28
   1005a:	4824      	ldr	r0, [pc, #144]	; (100ec <usb_device_endpoint_set_config+0x4f4>)
   1005c:	4002      	ands	r2, r0
   1005e:	430a      	orrs	r2, r1
   10060:	605a      	str	r2, [r3, #4]

	if (true == ep_config->auto_zlp) {
   10062:	683b      	ldr	r3, [r7, #0]
   10064:	789b      	ldrb	r3, [r3, #2]
   10066:	2b00      	cmp	r3, #0
   10068:	d01d      	beq.n	100a6 <usb_device_endpoint_set_config+0x4ae>
		usb_descriptor_table.usb_endpoint_table[ep_num].DeviceDescBank[ep_bank].PCKSIZE.reg |= USB_DEVICE_PCKSIZE_AUTO_ZLP;
   1006a:	230f      	movs	r3, #15
   1006c:	18fb      	adds	r3, r7, r3
   1006e:	781c      	ldrb	r4, [r3, #0]
   10070:	230e      	movs	r3, #14
   10072:	18fb      	adds	r3, r7, r3
   10074:	7818      	ldrb	r0, [r3, #0]
   10076:	230f      	movs	r3, #15
   10078:	18fb      	adds	r3, r7, r3
   1007a:	7819      	ldrb	r1, [r3, #0]
   1007c:	230e      	movs	r3, #14
   1007e:	18fb      	adds	r3, r7, r3
   10080:	781b      	ldrb	r3, [r3, #0]
   10082:	4a19      	ldr	r2, [pc, #100]	; (100e8 <usb_device_endpoint_set_config+0x4f0>)
   10084:	0049      	lsls	r1, r1, #1
   10086:	18cb      	adds	r3, r1, r3
   10088:	011b      	lsls	r3, r3, #4
   1008a:	18d3      	adds	r3, r2, r3
   1008c:	3304      	adds	r3, #4
   1008e:	681b      	ldr	r3, [r3, #0]
   10090:	2280      	movs	r2, #128	; 0x80
   10092:	0612      	lsls	r2, r2, #24
   10094:	431a      	orrs	r2, r3
   10096:	4914      	ldr	r1, [pc, #80]	; (100e8 <usb_device_endpoint_set_config+0x4f0>)
   10098:	0063      	lsls	r3, r4, #1
   1009a:	181b      	adds	r3, r3, r0
   1009c:	011b      	lsls	r3, r3, #4
   1009e:	18cb      	adds	r3, r1, r3
   100a0:	3304      	adds	r3, #4
   100a2:	601a      	str	r2, [r3, #0]
   100a4:	e01b      	b.n	100de <usb_device_endpoint_set_config+0x4e6>
		} else {
		usb_descriptor_table.usb_endpoint_table[ep_num].DeviceDescBank[ep_bank].PCKSIZE.reg &= ~USB_DEVICE_PCKSIZE_AUTO_ZLP;
   100a6:	230f      	movs	r3, #15
   100a8:	18fb      	adds	r3, r7, r3
   100aa:	781c      	ldrb	r4, [r3, #0]
   100ac:	230e      	movs	r3, #14
   100ae:	18fb      	adds	r3, r7, r3
   100b0:	7818      	ldrb	r0, [r3, #0]
   100b2:	230f      	movs	r3, #15
   100b4:	18fb      	adds	r3, r7, r3
   100b6:	7819      	ldrb	r1, [r3, #0]
   100b8:	230e      	movs	r3, #14
   100ba:	18fb      	adds	r3, r7, r3
   100bc:	781b      	ldrb	r3, [r3, #0]
   100be:	4a0a      	ldr	r2, [pc, #40]	; (100e8 <usb_device_endpoint_set_config+0x4f0>)
   100c0:	0049      	lsls	r1, r1, #1
   100c2:	18cb      	adds	r3, r1, r3
   100c4:	011b      	lsls	r3, r3, #4
   100c6:	18d3      	adds	r3, r2, r3
   100c8:	3304      	adds	r3, #4
   100ca:	681b      	ldr	r3, [r3, #0]
   100cc:	005b      	lsls	r3, r3, #1
   100ce:	085a      	lsrs	r2, r3, #1
   100d0:	4905      	ldr	r1, [pc, #20]	; (100e8 <usb_device_endpoint_set_config+0x4f0>)
   100d2:	0063      	lsls	r3, r4, #1
   100d4:	181b      	adds	r3, r3, r0
   100d6:	011b      	lsls	r3, r3, #4
   100d8:	18cb      	adds	r3, r1, r3
   100da:	3304      	adds	r3, #4
   100dc:	601a      	str	r2, [r3, #0]
	}

	return STATUS_OK;
   100de:	2300      	movs	r3, #0
}
   100e0:	0018      	movs	r0, r3
   100e2:	46bd      	mov	sp, r7
   100e4:	b005      	add	sp, #20
   100e6:	bd90      	pop	{r4, r7, pc}
   100e8:	2000177c 	.word	0x2000177c
   100ec:	8fffffff 	.word	0x8fffffff

000100f0 <usb_device_endpoint_abort_job>:
 *
 * \param module_inst Pointer to USB software instance struct
 * \param ep          Endpoint address
 */
void usb_device_endpoint_abort_job(struct usb_module *module_inst, uint8_t ep)
{
   100f0:	b580      	push	{r7, lr}
   100f2:	b084      	sub	sp, #16
   100f4:	af00      	add	r7, sp, #0
   100f6:	6078      	str	r0, [r7, #4]
   100f8:	000a      	movs	r2, r1
   100fa:	1cfb      	adds	r3, r7, #3
   100fc:	701a      	strb	r2, [r3, #0]
	uint8_t ep_num;
	ep_num = ep & USB_EP_ADDR_MASK;
   100fe:	230f      	movs	r3, #15
   10100:	18fb      	adds	r3, r7, r3
   10102:	1cfa      	adds	r2, r7, #3
   10104:	7812      	ldrb	r2, [r2, #0]
   10106:	210f      	movs	r1, #15
   10108:	400a      	ands	r2, r1
   1010a:	701a      	strb	r2, [r3, #0]

	// Stop transfer
	if (ep & USB_EP_DIR_IN) {
   1010c:	1cfb      	adds	r3, r7, #3
   1010e:	781b      	ldrb	r3, [r3, #0]
   10110:	b25b      	sxtb	r3, r3
   10112:	2b00      	cmp	r3, #0
   10114:	da16      	bge.n	10144 <usb_device_endpoint_abort_job+0x54>
		module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSCLR_BK1RDY;
   10116:	687b      	ldr	r3, [r7, #4]
   10118:	681a      	ldr	r2, [r3, #0]
   1011a:	230f      	movs	r3, #15
   1011c:	18fb      	adds	r3, r7, r3
   1011e:	781b      	ldrb	r3, [r3, #0]
   10120:	3308      	adds	r3, #8
   10122:	015b      	lsls	r3, r3, #5
   10124:	18d3      	adds	r3, r2, r3
   10126:	3304      	adds	r3, #4
   10128:	2280      	movs	r2, #128	; 0x80
   1012a:	701a      	strb	r2, [r3, #0]
		// Eventually ack a transfer occur during abort
		module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT1;
   1012c:	687b      	ldr	r3, [r7, #4]
   1012e:	681a      	ldr	r2, [r3, #0]
   10130:	230f      	movs	r3, #15
   10132:	18fb      	adds	r3, r7, r3
   10134:	781b      	ldrb	r3, [r3, #0]
   10136:	3308      	adds	r3, #8
   10138:	015b      	lsls	r3, r3, #5
   1013a:	18d3      	adds	r3, r2, r3
   1013c:	3307      	adds	r3, #7
   1013e:	2202      	movs	r2, #2
   10140:	701a      	strb	r2, [r3, #0]
	} else {
		module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_BK0RDY;
		// Eventually ack a transfer occur during abort
		module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT0;
	}
}
   10142:	e015      	b.n	10170 <usb_device_endpoint_abort_job+0x80>
	if (ep & USB_EP_DIR_IN) {
		module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSCLR_BK1RDY;
		// Eventually ack a transfer occur during abort
		module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT1;
	} else {
		module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_BK0RDY;
   10144:	687b      	ldr	r3, [r7, #4]
   10146:	681a      	ldr	r2, [r3, #0]
   10148:	230f      	movs	r3, #15
   1014a:	18fb      	adds	r3, r7, r3
   1014c:	781b      	ldrb	r3, [r3, #0]
   1014e:	3308      	adds	r3, #8
   10150:	015b      	lsls	r3, r3, #5
   10152:	18d3      	adds	r3, r2, r3
   10154:	3305      	adds	r3, #5
   10156:	2240      	movs	r2, #64	; 0x40
   10158:	701a      	strb	r2, [r3, #0]
		// Eventually ack a transfer occur during abort
		module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT0;
   1015a:	687b      	ldr	r3, [r7, #4]
   1015c:	681a      	ldr	r2, [r3, #0]
   1015e:	230f      	movs	r3, #15
   10160:	18fb      	adds	r3, r7, r3
   10162:	781b      	ldrb	r3, [r3, #0]
   10164:	3308      	adds	r3, #8
   10166:	015b      	lsls	r3, r3, #5
   10168:	18d3      	adds	r3, r2, r3
   1016a:	3307      	adds	r3, #7
   1016c:	2201      	movs	r2, #1
   1016e:	701a      	strb	r2, [r3, #0]
	}
}
   10170:	46c0      	nop			; (mov r8, r8)
   10172:	46bd      	mov	sp, r7
   10174:	b004      	add	sp, #16
   10176:	bd80      	pop	{r7, pc}

00010178 <usb_device_endpoint_is_halted>:
 * \param ep          Endpoint address
 *
 * \return \c true if the endpoint is halted
 */
bool usb_device_endpoint_is_halted(struct usb_module *module_inst, uint8_t ep)
{
   10178:	b580      	push	{r7, lr}
   1017a:	b084      	sub	sp, #16
   1017c:	af00      	add	r7, sp, #0
   1017e:	6078      	str	r0, [r7, #4]
   10180:	000a      	movs	r2, r1
   10182:	1cfb      	adds	r3, r7, #3
   10184:	701a      	strb	r2, [r3, #0]
	uint8_t ep_num = ep & USB_EP_ADDR_MASK;
   10186:	230f      	movs	r3, #15
   10188:	18fb      	adds	r3, r7, r3
   1018a:	1cfa      	adds	r2, r7, #3
   1018c:	7812      	ldrb	r2, [r2, #0]
   1018e:	210f      	movs	r1, #15
   10190:	400a      	ands	r2, r1
   10192:	701a      	strb	r2, [r3, #0]

	if (ep & USB_EP_DIR_IN) {
   10194:	1cfb      	adds	r3, r7, #3
   10196:	781b      	ldrb	r3, [r3, #0]
   10198:	b25b      	sxtb	r3, r3
   1019a:	2b00      	cmp	r3, #0
   1019c:	da11      	bge.n	101c2 <usb_device_endpoint_is_halted+0x4a>
		return (module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUS.reg & USB_DEVICE_EPSTATUSSET_STALLRQ1);
   1019e:	687b      	ldr	r3, [r7, #4]
   101a0:	681a      	ldr	r2, [r3, #0]
   101a2:	230f      	movs	r3, #15
   101a4:	18fb      	adds	r3, r7, r3
   101a6:	781b      	ldrb	r3, [r3, #0]
   101a8:	3308      	adds	r3, #8
   101aa:	015b      	lsls	r3, r3, #5
   101ac:	18d3      	adds	r3, r2, r3
   101ae:	3306      	adds	r3, #6
   101b0:	781b      	ldrb	r3, [r3, #0]
   101b2:	b2db      	uxtb	r3, r3
   101b4:	001a      	movs	r2, r3
   101b6:	2320      	movs	r3, #32
   101b8:	4013      	ands	r3, r2
   101ba:	1e5a      	subs	r2, r3, #1
   101bc:	4193      	sbcs	r3, r2
   101be:	b2db      	uxtb	r3, r3
   101c0:	e010      	b.n	101e4 <usb_device_endpoint_is_halted+0x6c>
	} else {
		return (module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUS.reg & USB_DEVICE_EPSTATUSSET_STALLRQ0);
   101c2:	687b      	ldr	r3, [r7, #4]
   101c4:	681a      	ldr	r2, [r3, #0]
   101c6:	230f      	movs	r3, #15
   101c8:	18fb      	adds	r3, r7, r3
   101ca:	781b      	ldrb	r3, [r3, #0]
   101cc:	3308      	adds	r3, #8
   101ce:	015b      	lsls	r3, r3, #5
   101d0:	18d3      	adds	r3, r2, r3
   101d2:	3306      	adds	r3, #6
   101d4:	781b      	ldrb	r3, [r3, #0]
   101d6:	b2db      	uxtb	r3, r3
   101d8:	001a      	movs	r2, r3
   101da:	2310      	movs	r3, #16
   101dc:	4013      	ands	r3, r2
   101de:	1e5a      	subs	r2, r3, #1
   101e0:	4193      	sbcs	r3, r2
   101e2:	b2db      	uxtb	r3, r3
	}
}
   101e4:	0018      	movs	r0, r3
   101e6:	46bd      	mov	sp, r7
   101e8:	b004      	add	sp, #16
   101ea:	bd80      	pop	{r7, pc}

000101ec <usb_device_endpoint_set_halt>:
 *
 * \param module_inst Pointer to USB software instance struct
 * \param ep          Endpoint address
 */
void usb_device_endpoint_set_halt(struct usb_module *module_inst, uint8_t ep)
{
   101ec:	b580      	push	{r7, lr}
   101ee:	b084      	sub	sp, #16
   101f0:	af00      	add	r7, sp, #0
   101f2:	6078      	str	r0, [r7, #4]
   101f4:	000a      	movs	r2, r1
   101f6:	1cfb      	adds	r3, r7, #3
   101f8:	701a      	strb	r2, [r3, #0]
	uint8_t ep_num = ep & USB_EP_ADDR_MASK;
   101fa:	230f      	movs	r3, #15
   101fc:	18fb      	adds	r3, r7, r3
   101fe:	1cfa      	adds	r2, r7, #3
   10200:	7812      	ldrb	r2, [r2, #0]
   10202:	210f      	movs	r1, #15
   10204:	400a      	ands	r2, r1
   10206:	701a      	strb	r2, [r3, #0]

	// Stall endpoint
	if (ep & USB_EP_DIR_IN) {
   10208:	1cfb      	adds	r3, r7, #3
   1020a:	781b      	ldrb	r3, [r3, #0]
   1020c:	b25b      	sxtb	r3, r3
   1020e:	2b00      	cmp	r3, #0
   10210:	da0b      	bge.n	1022a <usb_device_endpoint_set_halt+0x3e>
		module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_STALLRQ1;
   10212:	687b      	ldr	r3, [r7, #4]
   10214:	681a      	ldr	r2, [r3, #0]
   10216:	230f      	movs	r3, #15
   10218:	18fb      	adds	r3, r7, r3
   1021a:	781b      	ldrb	r3, [r3, #0]
   1021c:	3308      	adds	r3, #8
   1021e:	015b      	lsls	r3, r3, #5
   10220:	18d3      	adds	r3, r2, r3
   10222:	3305      	adds	r3, #5
   10224:	2220      	movs	r2, #32
   10226:	701a      	strb	r2, [r3, #0]
	} else {
		module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_STALLRQ0;
	}
}
   10228:	e00a      	b.n	10240 <usb_device_endpoint_set_halt+0x54>

	// Stall endpoint
	if (ep & USB_EP_DIR_IN) {
		module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_STALLRQ1;
	} else {
		module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_STALLRQ0;
   1022a:	687b      	ldr	r3, [r7, #4]
   1022c:	681a      	ldr	r2, [r3, #0]
   1022e:	230f      	movs	r3, #15
   10230:	18fb      	adds	r3, r7, r3
   10232:	781b      	ldrb	r3, [r3, #0]
   10234:	3308      	adds	r3, #8
   10236:	015b      	lsls	r3, r3, #5
   10238:	18d3      	adds	r3, r2, r3
   1023a:	3305      	adds	r3, #5
   1023c:	2210      	movs	r2, #16
   1023e:	701a      	strb	r2, [r3, #0]
	}
}
   10240:	46c0      	nop			; (mov r8, r8)
   10242:	46bd      	mov	sp, r7
   10244:	b004      	add	sp, #16
   10246:	bd80      	pop	{r7, pc}

00010248 <usb_device_endpoint_clear_halt>:
 *
 * \param module_inst Pointer to USB software instance struct
 * \param ep          Endpoint address
 */
void usb_device_endpoint_clear_halt(struct usb_module *module_inst, uint8_t ep)
{
   10248:	b580      	push	{r7, lr}
   1024a:	b084      	sub	sp, #16
   1024c:	af00      	add	r7, sp, #0
   1024e:	6078      	str	r0, [r7, #4]
   10250:	000a      	movs	r2, r1
   10252:	1cfb      	adds	r3, r7, #3
   10254:	701a      	strb	r2, [r3, #0]
	uint8_t ep_num = ep & USB_EP_ADDR_MASK;
   10256:	230f      	movs	r3, #15
   10258:	18fb      	adds	r3, r7, r3
   1025a:	1cfa      	adds	r2, r7, #3
   1025c:	7812      	ldrb	r2, [r2, #0]
   1025e:	210f      	movs	r1, #15
   10260:	400a      	ands	r2, r1
   10262:	701a      	strb	r2, [r3, #0]

	if (ep & USB_EP_DIR_IN) {
   10264:	1cfb      	adds	r3, r7, #3
   10266:	781b      	ldrb	r3, [r3, #0]
   10268:	b25b      	sxtb	r3, r3
   1026a:	2b00      	cmp	r3, #0
   1026c:	da3f      	bge.n	102ee <usb_device_endpoint_clear_halt+0xa6>
		if (module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUS.reg & USB_DEVICE_EPSTATUSSET_STALLRQ1) {
   1026e:	687b      	ldr	r3, [r7, #4]
   10270:	681a      	ldr	r2, [r3, #0]
   10272:	230f      	movs	r3, #15
   10274:	18fb      	adds	r3, r7, r3
   10276:	781b      	ldrb	r3, [r3, #0]
   10278:	3308      	adds	r3, #8
   1027a:	015b      	lsls	r3, r3, #5
   1027c:	18d3      	adds	r3, r2, r3
   1027e:	3306      	adds	r3, #6
   10280:	781b      	ldrb	r3, [r3, #0]
   10282:	b2db      	uxtb	r3, r3
   10284:	001a      	movs	r2, r3
   10286:	2320      	movs	r3, #32
   10288:	4013      	ands	r3, r2
   1028a:	d06f      	beq.n	1036c <usb_device_endpoint_clear_halt+0x124>
			// Remove stall request
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSCLR_STALLRQ1;
   1028c:	687b      	ldr	r3, [r7, #4]
   1028e:	681a      	ldr	r2, [r3, #0]
   10290:	230f      	movs	r3, #15
   10292:	18fb      	adds	r3, r7, r3
   10294:	781b      	ldrb	r3, [r3, #0]
   10296:	3308      	adds	r3, #8
   10298:	015b      	lsls	r3, r3, #5
   1029a:	18d3      	adds	r3, r2, r3
   1029c:	3304      	adds	r3, #4
   1029e:	2220      	movs	r2, #32
   102a0:	701a      	strb	r2, [r3, #0]
			if (module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_STALL1) {
   102a2:	687b      	ldr	r3, [r7, #4]
   102a4:	681a      	ldr	r2, [r3, #0]
   102a6:	230f      	movs	r3, #15
   102a8:	18fb      	adds	r3, r7, r3
   102aa:	781b      	ldrb	r3, [r3, #0]
   102ac:	3308      	adds	r3, #8
   102ae:	015b      	lsls	r3, r3, #5
   102b0:	18d3      	adds	r3, r2, r3
   102b2:	3307      	adds	r3, #7
   102b4:	781b      	ldrb	r3, [r3, #0]
   102b6:	b2db      	uxtb	r3, r3
   102b8:	001a      	movs	r2, r3
   102ba:	2340      	movs	r3, #64	; 0x40
   102bc:	4013      	ands	r3, r2
   102be:	d055      	beq.n	1036c <usb_device_endpoint_clear_halt+0x124>
				module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL1;
   102c0:	687b      	ldr	r3, [r7, #4]
   102c2:	681a      	ldr	r2, [r3, #0]
   102c4:	230f      	movs	r3, #15
   102c6:	18fb      	adds	r3, r7, r3
   102c8:	781b      	ldrb	r3, [r3, #0]
   102ca:	3308      	adds	r3, #8
   102cc:	015b      	lsls	r3, r3, #5
   102ce:	18d3      	adds	r3, r2, r3
   102d0:	3307      	adds	r3, #7
   102d2:	2240      	movs	r2, #64	; 0x40
   102d4:	701a      	strb	r2, [r3, #0]
				// The Stall has occurred, then reset data toggle
				module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSSET_DTGLIN;
   102d6:	687b      	ldr	r3, [r7, #4]
   102d8:	681a      	ldr	r2, [r3, #0]
   102da:	230f      	movs	r3, #15
   102dc:	18fb      	adds	r3, r7, r3
   102de:	781b      	ldrb	r3, [r3, #0]
   102e0:	3308      	adds	r3, #8
   102e2:	015b      	lsls	r3, r3, #5
   102e4:	18d3      	adds	r3, r2, r3
   102e6:	3304      	adds	r3, #4
   102e8:	2202      	movs	r2, #2
   102ea:	701a      	strb	r2, [r3, #0]
				// The Stall has occurred, then reset data toggle
				module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSSET_DTGLOUT;
			}
		}
	}
}
   102ec:	e03e      	b.n	1036c <usb_device_endpoint_clear_halt+0x124>
				// The Stall has occurred, then reset data toggle
				module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSSET_DTGLIN;
			}
		}
	} else {
		if (module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUS.reg & USB_DEVICE_EPSTATUSSET_STALLRQ0) {
   102ee:	687b      	ldr	r3, [r7, #4]
   102f0:	681a      	ldr	r2, [r3, #0]
   102f2:	230f      	movs	r3, #15
   102f4:	18fb      	adds	r3, r7, r3
   102f6:	781b      	ldrb	r3, [r3, #0]
   102f8:	3308      	adds	r3, #8
   102fa:	015b      	lsls	r3, r3, #5
   102fc:	18d3      	adds	r3, r2, r3
   102fe:	3306      	adds	r3, #6
   10300:	781b      	ldrb	r3, [r3, #0]
   10302:	b2db      	uxtb	r3, r3
   10304:	001a      	movs	r2, r3
   10306:	2310      	movs	r3, #16
   10308:	4013      	ands	r3, r2
   1030a:	d02f      	beq.n	1036c <usb_device_endpoint_clear_halt+0x124>
			// Remove stall request
			module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSCLR_STALLRQ0;
   1030c:	687b      	ldr	r3, [r7, #4]
   1030e:	681a      	ldr	r2, [r3, #0]
   10310:	230f      	movs	r3, #15
   10312:	18fb      	adds	r3, r7, r3
   10314:	781b      	ldrb	r3, [r3, #0]
   10316:	3308      	adds	r3, #8
   10318:	015b      	lsls	r3, r3, #5
   1031a:	18d3      	adds	r3, r2, r3
   1031c:	3304      	adds	r3, #4
   1031e:	2210      	movs	r2, #16
   10320:	701a      	strb	r2, [r3, #0]
			if (module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_STALL0) {
   10322:	687b      	ldr	r3, [r7, #4]
   10324:	681a      	ldr	r2, [r3, #0]
   10326:	230f      	movs	r3, #15
   10328:	18fb      	adds	r3, r7, r3
   1032a:	781b      	ldrb	r3, [r3, #0]
   1032c:	3308      	adds	r3, #8
   1032e:	015b      	lsls	r3, r3, #5
   10330:	18d3      	adds	r3, r2, r3
   10332:	3307      	adds	r3, #7
   10334:	781b      	ldrb	r3, [r3, #0]
   10336:	b2db      	uxtb	r3, r3
   10338:	001a      	movs	r2, r3
   1033a:	2320      	movs	r3, #32
   1033c:	4013      	ands	r3, r2
   1033e:	d015      	beq.n	1036c <usb_device_endpoint_clear_halt+0x124>
				module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL0;
   10340:	687b      	ldr	r3, [r7, #4]
   10342:	681a      	ldr	r2, [r3, #0]
   10344:	230f      	movs	r3, #15
   10346:	18fb      	adds	r3, r7, r3
   10348:	781b      	ldrb	r3, [r3, #0]
   1034a:	3308      	adds	r3, #8
   1034c:	015b      	lsls	r3, r3, #5
   1034e:	18d3      	adds	r3, r2, r3
   10350:	3307      	adds	r3, #7
   10352:	2220      	movs	r2, #32
   10354:	701a      	strb	r2, [r3, #0]
				// The Stall has occurred, then reset data toggle
				module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSSET_DTGLOUT;
   10356:	687b      	ldr	r3, [r7, #4]
   10358:	681a      	ldr	r2, [r3, #0]
   1035a:	230f      	movs	r3, #15
   1035c:	18fb      	adds	r3, r7, r3
   1035e:	781b      	ldrb	r3, [r3, #0]
   10360:	3308      	adds	r3, #8
   10362:	015b      	lsls	r3, r3, #5
   10364:	18d3      	adds	r3, r2, r3
   10366:	3304      	adds	r3, #4
   10368:	2201      	movs	r2, #1
   1036a:	701a      	strb	r2, [r3, #0]
			}
		}
	}
}
   1036c:	46c0      	nop			; (mov r8, r8)
   1036e:	46bd      	mov	sp, r7
   10370:	b004      	add	sp, #16
   10372:	bd80      	pop	{r7, pc}

00010374 <usb_device_endpoint_write_buffer_job>:
 * \retval STATUS_OK Job started successfully
 * \retval STATUS_ERR_DENIED Endpoint is not ready
 */
enum status_code usb_device_endpoint_write_buffer_job(struct usb_module *module_inst,uint8_t ep_num,
		uint8_t* pbuf, uint32_t buf_size)
{
   10374:	b580      	push	{r7, lr}
   10376:	b086      	sub	sp, #24
   10378:	af00      	add	r7, sp, #0
   1037a:	60f8      	str	r0, [r7, #12]
   1037c:	607a      	str	r2, [r7, #4]
   1037e:	603b      	str	r3, [r7, #0]
   10380:	230b      	movs	r3, #11
   10382:	18fb      	adds	r3, r7, r3
   10384:	1c0a      	adds	r2, r1, #0
   10386:	701a      	strb	r2, [r3, #0]
	Assert(module_inst);
	Assert(module_inst->hw);
	Assert(ep_num < USB_EPT_NUM);

	uint8_t flag;
	flag = (uint8_t)(module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.bit.EPTYPE1);
   10388:	68fb      	ldr	r3, [r7, #12]
   1038a:	681b      	ldr	r3, [r3, #0]
   1038c:	220b      	movs	r2, #11
   1038e:	18ba      	adds	r2, r7, r2
   10390:	7812      	ldrb	r2, [r2, #0]
   10392:	3208      	adds	r2, #8
   10394:	0152      	lsls	r2, r2, #5
   10396:	5cd3      	ldrb	r3, [r2, r3]
   10398:	065b      	lsls	r3, r3, #25
   1039a:	0f5b      	lsrs	r3, r3, #29
   1039c:	b2da      	uxtb	r2, r3
   1039e:	2317      	movs	r3, #23
   103a0:	18fb      	adds	r3, r7, r3
   103a2:	701a      	strb	r2, [r3, #0]
	if ((enum usb_device_endpoint_type)(flag) == USB_DEVICE_ENDPOINT_TYPE_DISABLE) {
   103a4:	2317      	movs	r3, #23
   103a6:	18fb      	adds	r3, r7, r3
   103a8:	781b      	ldrb	r3, [r3, #0]
   103aa:	2b00      	cmp	r3, #0
   103ac:	d101      	bne.n	103b2 <usb_device_endpoint_write_buffer_job+0x3e>
		return STATUS_ERR_DENIED;
   103ae:	231c      	movs	r3, #28
   103b0:	e032      	b.n	10418 <usb_device_endpoint_write_buffer_job+0xa4>
	};

	/* get endpoint configuration from setting register */
	usb_descriptor_table.usb_endpoint_table[ep_num].DeviceDescBank[1].ADDR.reg = (uint32_t)pbuf;
   103b2:	230b      	movs	r3, #11
   103b4:	18fb      	adds	r3, r7, r3
   103b6:	781b      	ldrb	r3, [r3, #0]
   103b8:	687a      	ldr	r2, [r7, #4]
   103ba:	4919      	ldr	r1, [pc, #100]	; (10420 <usb_device_endpoint_write_buffer_job+0xac>)
   103bc:	015b      	lsls	r3, r3, #5
   103be:	18cb      	adds	r3, r1, r3
   103c0:	3310      	adds	r3, #16
   103c2:	601a      	str	r2, [r3, #0]
	usb_descriptor_table.usb_endpoint_table[ep_num].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = 0;
   103c4:	230b      	movs	r3, #11
   103c6:	18fb      	adds	r3, r7, r3
   103c8:	781b      	ldrb	r3, [r3, #0]
   103ca:	4a15      	ldr	r2, [pc, #84]	; (10420 <usb_device_endpoint_write_buffer_job+0xac>)
   103cc:	015b      	lsls	r3, r3, #5
   103ce:	18d3      	adds	r3, r2, r3
   103d0:	3310      	adds	r3, #16
   103d2:	685a      	ldr	r2, [r3, #4]
   103d4:	4913      	ldr	r1, [pc, #76]	; (10424 <usb_device_endpoint_write_buffer_job+0xb0>)
   103d6:	400a      	ands	r2, r1
   103d8:	605a      	str	r2, [r3, #4]
	usb_descriptor_table.usb_endpoint_table[ep_num].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = buf_size;
   103da:	230b      	movs	r3, #11
   103dc:	18fb      	adds	r3, r7, r3
   103de:	781b      	ldrb	r3, [r3, #0]
   103e0:	683a      	ldr	r2, [r7, #0]
   103e2:	b292      	uxth	r2, r2
   103e4:	0492      	lsls	r2, r2, #18
   103e6:	0c92      	lsrs	r2, r2, #18
   103e8:	b291      	uxth	r1, r2
   103ea:	4a0d      	ldr	r2, [pc, #52]	; (10420 <usb_device_endpoint_write_buffer_job+0xac>)
   103ec:	015b      	lsls	r3, r3, #5
   103ee:	18d3      	adds	r3, r2, r3
   103f0:	3310      	adds	r3, #16
   103f2:	685a      	ldr	r2, [r3, #4]
   103f4:	0489      	lsls	r1, r1, #18
   103f6:	0c89      	lsrs	r1, r1, #18
   103f8:	0b92      	lsrs	r2, r2, #14
   103fa:	0392      	lsls	r2, r2, #14
   103fc:	430a      	orrs	r2, r1
   103fe:	605a      	str	r2, [r3, #4]
	module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_BK1RDY;
   10400:	68fb      	ldr	r3, [r7, #12]
   10402:	681a      	ldr	r2, [r3, #0]
   10404:	230b      	movs	r3, #11
   10406:	18fb      	adds	r3, r7, r3
   10408:	781b      	ldrb	r3, [r3, #0]
   1040a:	3308      	adds	r3, #8
   1040c:	015b      	lsls	r3, r3, #5
   1040e:	18d3      	adds	r3, r2, r3
   10410:	3305      	adds	r3, #5
   10412:	2280      	movs	r2, #128	; 0x80
   10414:	701a      	strb	r2, [r3, #0]

	return STATUS_OK;
   10416:	2300      	movs	r3, #0
}
   10418:	0018      	movs	r0, r3
   1041a:	46bd      	mov	sp, r7
   1041c:	b006      	add	sp, #24
   1041e:	bd80      	pop	{r7, pc}
   10420:	2000177c 	.word	0x2000177c
   10424:	f0003fff 	.word	0xf0003fff

00010428 <usb_device_endpoint_read_buffer_job>:
 * \retval STATUS_OK Job started successfully
 * \retval STATUS_ERR_DENIED Endpoint is not ready
 */
enum status_code usb_device_endpoint_read_buffer_job(struct usb_module *module_inst,uint8_t ep_num,
		uint8_t* pbuf, uint32_t buf_size)
{
   10428:	b580      	push	{r7, lr}
   1042a:	b086      	sub	sp, #24
   1042c:	af00      	add	r7, sp, #0
   1042e:	60f8      	str	r0, [r7, #12]
   10430:	607a      	str	r2, [r7, #4]
   10432:	603b      	str	r3, [r7, #0]
   10434:	230b      	movs	r3, #11
   10436:	18fb      	adds	r3, r7, r3
   10438:	1c0a      	adds	r2, r1, #0
   1043a:	701a      	strb	r2, [r3, #0]
	Assert(module_inst);
	Assert(module_inst->hw);
	Assert(ep_num < USB_EPT_NUM);

	uint8_t flag;
	flag = (uint8_t)(module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPCFG.bit.EPTYPE0);
   1043c:	68fb      	ldr	r3, [r7, #12]
   1043e:	681b      	ldr	r3, [r3, #0]
   10440:	220b      	movs	r2, #11
   10442:	18ba      	adds	r2, r7, r2
   10444:	7812      	ldrb	r2, [r2, #0]
   10446:	3208      	adds	r2, #8
   10448:	0152      	lsls	r2, r2, #5
   1044a:	5cd3      	ldrb	r3, [r2, r3]
   1044c:	075b      	lsls	r3, r3, #29
   1044e:	0f5b      	lsrs	r3, r3, #29
   10450:	b2da      	uxtb	r2, r3
   10452:	2317      	movs	r3, #23
   10454:	18fb      	adds	r3, r7, r3
   10456:	701a      	strb	r2, [r3, #0]
	if ((enum usb_device_endpoint_type)(flag) == USB_DEVICE_ENDPOINT_TYPE_DISABLE) {
   10458:	2317      	movs	r3, #23
   1045a:	18fb      	adds	r3, r7, r3
   1045c:	781b      	ldrb	r3, [r3, #0]
   1045e:	2b00      	cmp	r3, #0
   10460:	d101      	bne.n	10466 <usb_device_endpoint_read_buffer_job+0x3e>
		return STATUS_ERR_DENIED;
   10462:	231c      	movs	r3, #28
   10464:	e02f      	b.n	104c6 <usb_device_endpoint_read_buffer_job+0x9e>
	};

	/* get endpoint configuration from setting register */
	usb_descriptor_table.usb_endpoint_table[ep_num].DeviceDescBank[0].ADDR.reg = (uint32_t)pbuf;
   10466:	230b      	movs	r3, #11
   10468:	18fb      	adds	r3, r7, r3
   1046a:	781a      	ldrb	r2, [r3, #0]
   1046c:	6879      	ldr	r1, [r7, #4]
   1046e:	4b18      	ldr	r3, [pc, #96]	; (104d0 <usb_device_endpoint_read_buffer_job+0xa8>)
   10470:	0152      	lsls	r2, r2, #5
   10472:	50d1      	str	r1, [r2, r3]
	usb_descriptor_table.usb_endpoint_table[ep_num].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = buf_size;
   10474:	230b      	movs	r3, #11
   10476:	18fb      	adds	r3, r7, r3
   10478:	781b      	ldrb	r3, [r3, #0]
   1047a:	683a      	ldr	r2, [r7, #0]
   1047c:	b292      	uxth	r2, r2
   1047e:	0492      	lsls	r2, r2, #18
   10480:	0c92      	lsrs	r2, r2, #18
   10482:	b291      	uxth	r1, r2
   10484:	4a12      	ldr	r2, [pc, #72]	; (104d0 <usb_device_endpoint_read_buffer_job+0xa8>)
   10486:	015b      	lsls	r3, r3, #5
   10488:	18d3      	adds	r3, r2, r3
   1048a:	685a      	ldr	r2, [r3, #4]
   1048c:	0489      	lsls	r1, r1, #18
   1048e:	0c89      	lsrs	r1, r1, #18
   10490:	0389      	lsls	r1, r1, #14
   10492:	4810      	ldr	r0, [pc, #64]	; (104d4 <usb_device_endpoint_read_buffer_job+0xac>)
   10494:	4002      	ands	r2, r0
   10496:	430a      	orrs	r2, r1
   10498:	605a      	str	r2, [r3, #4]
	usb_descriptor_table.usb_endpoint_table[ep_num].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = 0;
   1049a:	230b      	movs	r3, #11
   1049c:	18fb      	adds	r3, r7, r3
   1049e:	781b      	ldrb	r3, [r3, #0]
   104a0:	4a0b      	ldr	r2, [pc, #44]	; (104d0 <usb_device_endpoint_read_buffer_job+0xa8>)
   104a2:	015b      	lsls	r3, r3, #5
   104a4:	18d3      	adds	r3, r2, r3
   104a6:	685a      	ldr	r2, [r3, #4]
   104a8:	0b92      	lsrs	r2, r2, #14
   104aa:	0392      	lsls	r2, r2, #14
   104ac:	605a      	str	r2, [r3, #4]
	module_inst->hw->DEVICE.DeviceEndpoint[ep_num].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSCLR_BK0RDY;
   104ae:	68fb      	ldr	r3, [r7, #12]
   104b0:	681a      	ldr	r2, [r3, #0]
   104b2:	230b      	movs	r3, #11
   104b4:	18fb      	adds	r3, r7, r3
   104b6:	781b      	ldrb	r3, [r3, #0]
   104b8:	3308      	adds	r3, #8
   104ba:	015b      	lsls	r3, r3, #5
   104bc:	18d3      	adds	r3, r2, r3
   104be:	3304      	adds	r3, #4
   104c0:	2240      	movs	r2, #64	; 0x40
   104c2:	701a      	strb	r2, [r3, #0]

	return STATUS_OK;
   104c4:	2300      	movs	r3, #0
}
   104c6:	0018      	movs	r0, r3
   104c8:	46bd      	mov	sp, r7
   104ca:	b006      	add	sp, #24
   104cc:	bd80      	pop	{r7, pc}
   104ce:	46c0      	nop			; (mov r8, r8)
   104d0:	2000177c 	.word	0x2000177c
   104d4:	f0003fff 	.word	0xf0003fff

000104d8 <usb_device_endpoint_setup_buffer_job>:
 * \retval STATUS_OK Job started successfully
 * \retval STATUS_ERR_DENIED Endpoint is not ready
 */
enum status_code usb_device_endpoint_setup_buffer_job(struct usb_module *module_inst,
		uint8_t* pbuf)
{
   104d8:	b580      	push	{r7, lr}
   104da:	b082      	sub	sp, #8
   104dc:	af00      	add	r7, sp, #0
   104de:	6078      	str	r0, [r7, #4]
   104e0:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* get endpoint configuration from setting register */
	usb_descriptor_table.usb_endpoint_table[0].DeviceDescBank[0].ADDR.reg = (uint32_t)pbuf;
   104e2:	683a      	ldr	r2, [r7, #0]
   104e4:	4b0c      	ldr	r3, [pc, #48]	; (10518 <usb_device_endpoint_setup_buffer_job+0x40>)
   104e6:	601a      	str	r2, [r3, #0]
	usb_descriptor_table.usb_endpoint_table[0].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = 8;
   104e8:	4b0b      	ldr	r3, [pc, #44]	; (10518 <usb_device_endpoint_setup_buffer_job+0x40>)
   104ea:	685a      	ldr	r2, [r3, #4]
   104ec:	490b      	ldr	r1, [pc, #44]	; (1051c <usb_device_endpoint_setup_buffer_job+0x44>)
   104ee:	400a      	ands	r2, r1
   104f0:	2180      	movs	r1, #128	; 0x80
   104f2:	0289      	lsls	r1, r1, #10
   104f4:	430a      	orrs	r2, r1
   104f6:	605a      	str	r2, [r3, #4]
	usb_descriptor_table.usb_endpoint_table[0].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = 0;
   104f8:	4b07      	ldr	r3, [pc, #28]	; (10518 <usb_device_endpoint_setup_buffer_job+0x40>)
   104fa:	685a      	ldr	r2, [r3, #4]
   104fc:	0b92      	lsrs	r2, r2, #14
   104fe:	0392      	lsls	r2, r2, #14
   10500:	605a      	str	r2, [r3, #4]
	module_inst->hw->DEVICE.DeviceEndpoint[0].EPSTATUSCLR.reg = USB_DEVICE_EPSTATUSCLR_BK0RDY;
   10502:	687b      	ldr	r3, [r7, #4]
   10504:	681a      	ldr	r2, [r3, #0]
   10506:	2382      	movs	r3, #130	; 0x82
   10508:	005b      	lsls	r3, r3, #1
   1050a:	2140      	movs	r1, #64	; 0x40
   1050c:	54d1      	strb	r1, [r2, r3]

	return STATUS_OK;
   1050e:	2300      	movs	r3, #0
}
   10510:	0018      	movs	r0, r3
   10512:	46bd      	mov	sp, r7
   10514:	b002      	add	sp, #8
   10516:	bd80      	pop	{r7, pc}
   10518:	2000177c 	.word	0x2000177c
   1051c:	f0003fff 	.word	0xf0003fff

00010520 <_usb_device_interrupt_handler>:

static void _usb_device_interrupt_handler(void)
{
   10520:	b580      	push	{r7, lr}
   10522:	b084      	sub	sp, #16
   10524:	af00      	add	r7, sp, #0
	uint16_t ep_inst;
	uint16_t flags, flags_run;
	ep_inst = _usb_instances->hw->DEVICE.EPINTSMRY.reg;
   10526:	4bcf      	ldr	r3, [pc, #828]	; (10864 <_usb_device_interrupt_handler+0x344>)
   10528:	681b      	ldr	r3, [r3, #0]
   1052a:	681a      	ldr	r2, [r3, #0]
   1052c:	2308      	movs	r3, #8
   1052e:	18fb      	adds	r3, r7, r3
   10530:	8c12      	ldrh	r2, [r2, #32]
   10532:	801a      	strh	r2, [r3, #0]

	/* device interrupt */
	if (0 == ep_inst) {
   10534:	2308      	movs	r3, #8
   10536:	18fb      	adds	r3, r7, r3
   10538:	881b      	ldrh	r3, [r3, #0]
   1053a:	2b00      	cmp	r3, #0
   1053c:	d155      	bne.n	105ea <_usb_device_interrupt_handler+0xca>
		int i;

		/* get interrupt flags */
		flags = _usb_instances->hw->DEVICE.INTFLAG.reg;
   1053e:	4bc9      	ldr	r3, [pc, #804]	; (10864 <_usb_device_interrupt_handler+0x344>)
   10540:	681b      	ldr	r3, [r3, #0]
   10542:	681a      	ldr	r2, [r3, #0]
   10544:	1dbb      	adds	r3, r7, #6
   10546:	8b92      	ldrh	r2, [r2, #28]
   10548:	801a      	strh	r2, [r3, #0]
		flags_run = flags &
				_usb_instances->device_enabled_callback_mask &
   1054a:	4bc6      	ldr	r3, [pc, #792]	; (10864 <_usb_device_interrupt_handler+0x344>)
   1054c:	681a      	ldr	r2, [r3, #0]
   1054e:	23ab      	movs	r3, #171	; 0xab
   10550:	005b      	lsls	r3, r3, #1
   10552:	5ad3      	ldrh	r3, [r2, r3]
	if (0 == ep_inst) {
		int i;

		/* get interrupt flags */
		flags = _usb_instances->hw->DEVICE.INTFLAG.reg;
		flags_run = flags &
   10554:	1dba      	adds	r2, r7, #6
   10556:	8812      	ldrh	r2, [r2, #0]
   10558:	4013      	ands	r3, r2
   1055a:	b29a      	uxth	r2, r3
				_usb_instances->device_enabled_callback_mask &
				_usb_instances->device_registered_callback_mask;
   1055c:	4bc1      	ldr	r3, [pc, #772]	; (10864 <_usb_device_interrupt_handler+0x344>)
   1055e:	6819      	ldr	r1, [r3, #0]
   10560:	23aa      	movs	r3, #170	; 0xaa
   10562:	005b      	lsls	r3, r3, #1
   10564:	5ac9      	ldrh	r1, [r1, r3]
	if (0 == ep_inst) {
		int i;

		/* get interrupt flags */
		flags = _usb_instances->hw->DEVICE.INTFLAG.reg;
		flags_run = flags &
   10566:	1d3b      	adds	r3, r7, #4
   10568:	400a      	ands	r2, r1
   1056a:	801a      	strh	r2, [r3, #0]
				_usb_instances->device_enabled_callback_mask &
				_usb_instances->device_registered_callback_mask;

		for (i = 0; i < USB_DEVICE_CALLBACK_N; i ++) {
   1056c:	2300      	movs	r3, #0
   1056e:	60fb      	str	r3, [r7, #12]
   10570:	e037      	b.n	105e2 <_usb_device_interrupt_handler+0xc2>
			if (flags & _usb_device_irq_bits[i]) {
   10572:	4bbd      	ldr	r3, [pc, #756]	; (10868 <_usb_device_interrupt_handler+0x348>)
   10574:	68fa      	ldr	r2, [r7, #12]
   10576:	0052      	lsls	r2, r2, #1
   10578:	5ad3      	ldrh	r3, [r2, r3]
   1057a:	1dba      	adds	r2, r7, #6
   1057c:	8812      	ldrh	r2, [r2, #0]
   1057e:	4013      	ands	r3, r2
   10580:	b29b      	uxth	r3, r3
   10582:	2b00      	cmp	r3, #0
   10584:	d007      	beq.n	10596 <_usb_device_interrupt_handler+0x76>
				_usb_instances->hw->DEVICE.INTFLAG.reg =
   10586:	4bb7      	ldr	r3, [pc, #732]	; (10864 <_usb_device_interrupt_handler+0x344>)
   10588:	681b      	ldr	r3, [r3, #0]
   1058a:	681b      	ldr	r3, [r3, #0]
						_usb_device_irq_bits[i];
   1058c:	4ab6      	ldr	r2, [pc, #728]	; (10868 <_usb_device_interrupt_handler+0x348>)
   1058e:	68f9      	ldr	r1, [r7, #12]
   10590:	0049      	lsls	r1, r1, #1
   10592:	5a8a      	ldrh	r2, [r1, r2]
				_usb_instances->device_enabled_callback_mask &
				_usb_instances->device_registered_callback_mask;

		for (i = 0; i < USB_DEVICE_CALLBACK_N; i ++) {
			if (flags & _usb_device_irq_bits[i]) {
				_usb_instances->hw->DEVICE.INTFLAG.reg =
   10594:	839a      	strh	r2, [r3, #28]
						_usb_device_irq_bits[i];
			}
			if (flags_run & _usb_device_irq_bits[i]) {
   10596:	4bb4      	ldr	r3, [pc, #720]	; (10868 <_usb_device_interrupt_handler+0x348>)
   10598:	68fa      	ldr	r2, [r7, #12]
   1059a:	0052      	lsls	r2, r2, #1
   1059c:	5ad3      	ldrh	r3, [r2, r3]
   1059e:	1d3a      	adds	r2, r7, #4
   105a0:	8812      	ldrh	r2, [r2, #0]
   105a2:	4013      	ands	r3, r2
   105a4:	b29b      	uxth	r3, r3
   105a6:	2b00      	cmp	r3, #0
   105a8:	d018      	beq.n	105dc <_usb_device_interrupt_handler+0xbc>
				if (i == USB_DEVICE_CALLBACK_LPMSUSP) {
   105aa:	68fb      	ldr	r3, [r7, #12]
   105ac:	2b06      	cmp	r3, #6
   105ae:	d10a      	bne.n	105c6 <_usb_device_interrupt_handler+0xa6>
					device_callback_lpm_wakeup_enable =
							usb_descriptor_table.usb_endpoint_table[0].DeviceDescBank[0].EXTREG.bit.VARIABLE
   105b0:	4bae      	ldr	r3, [pc, #696]	; (1086c <_usb_device_interrupt_handler+0x34c>)
   105b2:	891b      	ldrh	r3, [r3, #8]
   105b4:	045b      	lsls	r3, r3, #17
   105b6:	0d5b      	lsrs	r3, r3, #21
   105b8:	b29b      	uxth	r3, r3
				_usb_instances->hw->DEVICE.INTFLAG.reg =
						_usb_device_irq_bits[i];
			}
			if (flags_run & _usb_device_irq_bits[i]) {
				if (i == USB_DEVICE_CALLBACK_LPMSUSP) {
					device_callback_lpm_wakeup_enable =
   105ba:	001a      	movs	r2, r3
   105bc:	2380      	movs	r3, #128	; 0x80
   105be:	005b      	lsls	r3, r3, #1
   105c0:	401a      	ands	r2, r3
   105c2:	4bab      	ldr	r3, [pc, #684]	; (10870 <_usb_device_interrupt_handler+0x350>)
   105c4:	601a      	str	r2, [r3, #0]
							usb_descriptor_table.usb_endpoint_table[0].DeviceDescBank[0].EXTREG.bit.VARIABLE
							& USB_LPM_ATTRIBUT_REMOTEWAKE_MASK;
				}
				(_usb_instances->device_callback[i])(_usb_instances, &device_callback_lpm_wakeup_enable);
   105c6:	4ba7      	ldr	r3, [pc, #668]	; (10864 <_usb_device_interrupt_handler+0x344>)
   105c8:	681b      	ldr	r3, [r3, #0]
   105ca:	68fa      	ldr	r2, [r7, #12]
   105cc:	322e      	adds	r2, #46	; 0x2e
   105ce:	0092      	lsls	r2, r2, #2
   105d0:	58d2      	ldr	r2, [r2, r3]
   105d2:	4ba4      	ldr	r3, [pc, #656]	; (10864 <_usb_device_interrupt_handler+0x344>)
   105d4:	681b      	ldr	r3, [r3, #0]
   105d6:	49a6      	ldr	r1, [pc, #664]	; (10870 <_usb_device_interrupt_handler+0x350>)
   105d8:	0018      	movs	r0, r3
   105da:	4790      	blx	r2
		flags = _usb_instances->hw->DEVICE.INTFLAG.reg;
		flags_run = flags &
				_usb_instances->device_enabled_callback_mask &
				_usb_instances->device_registered_callback_mask;

		for (i = 0; i < USB_DEVICE_CALLBACK_N; i ++) {
   105dc:	68fb      	ldr	r3, [r7, #12]
   105de:	3301      	adds	r3, #1
   105e0:	60fb      	str	r3, [r7, #12]
   105e2:	68fb      	ldr	r3, [r7, #12]
   105e4:	2b06      	cmp	r3, #6
   105e6:	ddc4      	ble.n	10572 <_usb_device_interrupt_handler+0x52>
   105e8:	e251      	b.n	10a8e <_usb_device_interrupt_handler+0x56e>
		}

	} else {
		/* endpoint interrupt */

		for (uint8_t i = 0; i < USB_EPT_NUM; i++) {
   105ea:	230b      	movs	r3, #11
   105ec:	18fb      	adds	r3, r7, r3
   105ee:	2200      	movs	r2, #0
   105f0:	701a      	strb	r2, [r3, #0]
   105f2:	e23c      	b.n	10a6e <_usb_device_interrupt_handler+0x54e>

			if (ep_inst & (1 << i)) {
   105f4:	2308      	movs	r3, #8
   105f6:	18fb      	adds	r3, r7, r3
   105f8:	881a      	ldrh	r2, [r3, #0]
   105fa:	230b      	movs	r3, #11
   105fc:	18fb      	adds	r3, r7, r3
   105fe:	781b      	ldrb	r3, [r3, #0]
   10600:	411a      	asrs	r2, r3
   10602:	0013      	movs	r3, r2
   10604:	2201      	movs	r2, #1
   10606:	4013      	ands	r3, r2
   10608:	d100      	bne.n	1060c <_usb_device_interrupt_handler+0xec>
   1060a:	e229      	b.n	10a60 <_usb_device_interrupt_handler+0x540>
				flags = _usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg;
   1060c:	4b95      	ldr	r3, [pc, #596]	; (10864 <_usb_device_interrupt_handler+0x344>)
   1060e:	681b      	ldr	r3, [r3, #0]
   10610:	681a      	ldr	r2, [r3, #0]
   10612:	230b      	movs	r3, #11
   10614:	18fb      	adds	r3, r7, r3
   10616:	781b      	ldrb	r3, [r3, #0]
   10618:	3308      	adds	r3, #8
   1061a:	015b      	lsls	r3, r3, #5
   1061c:	18d3      	adds	r3, r2, r3
   1061e:	3307      	adds	r3, #7
   10620:	781b      	ldrb	r3, [r3, #0]
   10622:	b2da      	uxtb	r2, r3
   10624:	1dbb      	adds	r3, r7, #6
   10626:	801a      	strh	r2, [r3, #0]
				flags_run = flags &
						_usb_instances->device_endpoint_enabled_callback_mask[i] &
   10628:	4b8e      	ldr	r3, [pc, #568]	; (10864 <_usb_device_interrupt_handler+0x344>)
   1062a:	6819      	ldr	r1, [r3, #0]
   1062c:	230b      	movs	r3, #11
   1062e:	18fb      	adds	r3, r7, r3
   10630:	781a      	ldrb	r2, [r3, #0]
   10632:	23b0      	movs	r3, #176	; 0xb0
   10634:	005b      	lsls	r3, r3, #1
   10636:	188a      	adds	r2, r1, r2
   10638:	18d3      	adds	r3, r2, r3
   1063a:	781b      	ldrb	r3, [r3, #0]

		for (uint8_t i = 0; i < USB_EPT_NUM; i++) {

			if (ep_inst & (1 << i)) {
				flags = _usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg;
				flags_run = flags &
   1063c:	b29b      	uxth	r3, r3
   1063e:	1dba      	adds	r2, r7, #6
   10640:	8812      	ldrh	r2, [r2, #0]
   10642:	4013      	ands	r3, r2
   10644:	b29b      	uxth	r3, r3
   10646:	b21a      	sxth	r2, r3
						_usb_instances->device_endpoint_enabled_callback_mask[i] &
						_usb_instances->deivce_endpoint_registered_callback_mask[i];
   10648:	4b86      	ldr	r3, [pc, #536]	; (10864 <_usb_device_interrupt_handler+0x344>)
   1064a:	6818      	ldr	r0, [r3, #0]
   1064c:	230b      	movs	r3, #11
   1064e:	18fb      	adds	r3, r7, r3
   10650:	7819      	ldrb	r1, [r3, #0]
   10652:	23ac      	movs	r3, #172	; 0xac
   10654:	005b      	lsls	r3, r3, #1
   10656:	1841      	adds	r1, r0, r1
   10658:	18cb      	adds	r3, r1, r3
   1065a:	781b      	ldrb	r3, [r3, #0]

		for (uint8_t i = 0; i < USB_EPT_NUM; i++) {

			if (ep_inst & (1 << i)) {
				flags = _usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg;
				flags_run = flags &
   1065c:	b21b      	sxth	r3, r3
   1065e:	4013      	ands	r3, r2
   10660:	b21a      	sxth	r2, r3
   10662:	1d3b      	adds	r3, r7, #4
   10664:	801a      	strh	r2, [r3, #0]
						_usb_instances->device_endpoint_enabled_callback_mask[i] &
						_usb_instances->deivce_endpoint_registered_callback_mask[i];

				// endpoint transfer stall interrupt
				if (flags & USB_DEVICE_EPINTFLAG_STALL_Msk) {
   10666:	1dbb      	adds	r3, r7, #6
   10668:	881b      	ldrh	r3, [r3, #0]
   1066a:	2260      	movs	r2, #96	; 0x60
   1066c:	4013      	ands	r3, r2
   1066e:	d05c      	beq.n	1072a <_usb_device_interrupt_handler+0x20a>
					if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_STALL1) {
   10670:	4b7c      	ldr	r3, [pc, #496]	; (10864 <_usb_device_interrupt_handler+0x344>)
   10672:	681b      	ldr	r3, [r3, #0]
   10674:	681a      	ldr	r2, [r3, #0]
   10676:	230b      	movs	r3, #11
   10678:	18fb      	adds	r3, r7, r3
   1067a:	781b      	ldrb	r3, [r3, #0]
   1067c:	3308      	adds	r3, #8
   1067e:	015b      	lsls	r3, r3, #5
   10680:	18d3      	adds	r3, r2, r3
   10682:	3307      	adds	r3, #7
   10684:	781b      	ldrb	r3, [r3, #0]
   10686:	b2db      	uxtb	r3, r3
   10688:	001a      	movs	r2, r3
   1068a:	2340      	movs	r3, #64	; 0x40
   1068c:	4013      	ands	r3, r2
   1068e:	d015      	beq.n	106bc <_usb_device_interrupt_handler+0x19c>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL1;
   10690:	4b74      	ldr	r3, [pc, #464]	; (10864 <_usb_device_interrupt_handler+0x344>)
   10692:	681b      	ldr	r3, [r3, #0]
   10694:	681a      	ldr	r2, [r3, #0]
   10696:	230b      	movs	r3, #11
   10698:	18fb      	adds	r3, r7, r3
   1069a:	781b      	ldrb	r3, [r3, #0]
   1069c:	3308      	adds	r3, #8
   1069e:	015b      	lsls	r3, r3, #5
   106a0:	18d3      	adds	r3, r2, r3
   106a2:	3307      	adds	r3, #7
   106a4:	2240      	movs	r2, #64	; 0x40
   106a6:	701a      	strb	r2, [r3, #0]
						ep_callback_para.endpoint_address = USB_EP_DIR_IN | i;
   106a8:	230b      	movs	r3, #11
   106aa:	18fb      	adds	r3, r7, r3
   106ac:	781b      	ldrb	r3, [r3, #0]
   106ae:	2280      	movs	r2, #128	; 0x80
   106b0:	4252      	negs	r2, r2
   106b2:	4313      	orrs	r3, r2
   106b4:	b2da      	uxtb	r2, r3
   106b6:	4b6f      	ldr	r3, [pc, #444]	; (10874 <_usb_device_interrupt_handler+0x354>)
   106b8:	719a      	strb	r2, [r3, #6]
   106ba:	e020      	b.n	106fe <_usb_device_interrupt_handler+0x1de>
					} else if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_STALL0) {
   106bc:	4b69      	ldr	r3, [pc, #420]	; (10864 <_usb_device_interrupt_handler+0x344>)
   106be:	681b      	ldr	r3, [r3, #0]
   106c0:	681a      	ldr	r2, [r3, #0]
   106c2:	230b      	movs	r3, #11
   106c4:	18fb      	adds	r3, r7, r3
   106c6:	781b      	ldrb	r3, [r3, #0]
   106c8:	3308      	adds	r3, #8
   106ca:	015b      	lsls	r3, r3, #5
   106cc:	18d3      	adds	r3, r2, r3
   106ce:	3307      	adds	r3, #7
   106d0:	781b      	ldrb	r3, [r3, #0]
   106d2:	b2db      	uxtb	r3, r3
   106d4:	001a      	movs	r2, r3
   106d6:	2320      	movs	r3, #32
   106d8:	4013      	ands	r3, r2
   106da:	d010      	beq.n	106fe <_usb_device_interrupt_handler+0x1de>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL0;
   106dc:	4b61      	ldr	r3, [pc, #388]	; (10864 <_usb_device_interrupt_handler+0x344>)
   106de:	681b      	ldr	r3, [r3, #0]
   106e0:	681a      	ldr	r2, [r3, #0]
   106e2:	230b      	movs	r3, #11
   106e4:	18fb      	adds	r3, r7, r3
   106e6:	781b      	ldrb	r3, [r3, #0]
   106e8:	3308      	adds	r3, #8
   106ea:	015b      	lsls	r3, r3, #5
   106ec:	18d3      	adds	r3, r2, r3
   106ee:	3307      	adds	r3, #7
   106f0:	2220      	movs	r2, #32
   106f2:	701a      	strb	r2, [r3, #0]
						ep_callback_para.endpoint_address = USB_EP_DIR_OUT | i;
   106f4:	4b5f      	ldr	r3, [pc, #380]	; (10874 <_usb_device_interrupt_handler+0x354>)
   106f6:	220b      	movs	r2, #11
   106f8:	18ba      	adds	r2, r7, r2
   106fa:	7812      	ldrb	r2, [r2, #0]
   106fc:	719a      	strb	r2, [r3, #6]
					}

					if (flags_run & USB_DEVICE_EPINTFLAG_STALL_Msk) {
   106fe:	1d3b      	adds	r3, r7, #4
   10700:	881b      	ldrh	r3, [r3, #0]
   10702:	2260      	movs	r2, #96	; 0x60
   10704:	4013      	ands	r3, r2
   10706:	d100      	bne.n	1070a <_usb_device_interrupt_handler+0x1ea>
   10708:	e1b8      	b.n	10a7c <_usb_device_interrupt_handler+0x55c>
						(_usb_instances->device_endpoint_callback[i][USB_DEVICE_ENDPOINT_CALLBACK_STALL])(_usb_instances,&ep_callback_para);
   1070a:	4b56      	ldr	r3, [pc, #344]	; (10864 <_usb_device_interrupt_handler+0x344>)
   1070c:	681a      	ldr	r2, [r3, #0]
   1070e:	230b      	movs	r3, #11
   10710:	18fb      	adds	r3, r7, r3
   10712:	781b      	ldrb	r3, [r3, #0]
   10714:	21e0      	movs	r1, #224	; 0xe0
   10716:	011b      	lsls	r3, r3, #4
   10718:	18d3      	adds	r3, r2, r3
   1071a:	185b      	adds	r3, r3, r1
   1071c:	681a      	ldr	r2, [r3, #0]
   1071e:	4b51      	ldr	r3, [pc, #324]	; (10864 <_usb_device_interrupt_handler+0x344>)
   10720:	681b      	ldr	r3, [r3, #0]
   10722:	4954      	ldr	r1, [pc, #336]	; (10874 <_usb_device_interrupt_handler+0x354>)
   10724:	0018      	movs	r0, r3
   10726:	4790      	blx	r2
					}
					return;
   10728:	e1a8      	b.n	10a7c <_usb_device_interrupt_handler+0x55c>
				}

				// endpoint received setup interrupt
				if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
   1072a:	1dbb      	adds	r3, r7, #6
   1072c:	881b      	ldrh	r3, [r3, #0]
   1072e:	2210      	movs	r2, #16
   10730:	4013      	ands	r3, r2
   10732:	d038      	beq.n	107a6 <_usb_device_interrupt_handler+0x286>
					_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP;
   10734:	4b4b      	ldr	r3, [pc, #300]	; (10864 <_usb_device_interrupt_handler+0x344>)
   10736:	681b      	ldr	r3, [r3, #0]
   10738:	681a      	ldr	r2, [r3, #0]
   1073a:	230b      	movs	r3, #11
   1073c:	18fb      	adds	r3, r7, r3
   1073e:	781b      	ldrb	r3, [r3, #0]
   10740:	3308      	adds	r3, #8
   10742:	015b      	lsls	r3, r3, #5
   10744:	18d3      	adds	r3, r2, r3
   10746:	3307      	adds	r3, #7
   10748:	2210      	movs	r2, #16
   1074a:	701a      	strb	r2, [r3, #0]
					if(_usb_instances->device_endpoint_enabled_callback_mask[i] & _usb_endpoint_irq_bits[USB_DEVICE_ENDPOINT_CALLBACK_RXSTP]) {
   1074c:	4b45      	ldr	r3, [pc, #276]	; (10864 <_usb_device_interrupt_handler+0x344>)
   1074e:	6819      	ldr	r1, [r3, #0]
   10750:	230b      	movs	r3, #11
   10752:	18fb      	adds	r3, r7, r3
   10754:	781a      	ldrb	r2, [r3, #0]
   10756:	23b0      	movs	r3, #176	; 0xb0
   10758:	005b      	lsls	r3, r3, #1
   1075a:	188a      	adds	r2, r1, r2
   1075c:	18d3      	adds	r3, r2, r3
   1075e:	781b      	ldrb	r3, [r3, #0]
   10760:	2210      	movs	r2, #16
   10762:	4013      	ands	r3, r2
   10764:	b2db      	uxtb	r3, r3
   10766:	2b00      	cmp	r3, #0
   10768:	d100      	bne.n	1076c <_usb_device_interrupt_handler+0x24c>
   1076a:	e189      	b.n	10a80 <_usb_device_interrupt_handler+0x560>
						ep_callback_para.received_bytes = (uint16_t)(usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT);
   1076c:	230b      	movs	r3, #11
   1076e:	18fb      	adds	r3, r7, r3
   10770:	781b      	ldrb	r3, [r3, #0]
   10772:	4a3e      	ldr	r2, [pc, #248]	; (1086c <_usb_device_interrupt_handler+0x34c>)
   10774:	015b      	lsls	r3, r3, #5
   10776:	18d3      	adds	r3, r2, r3
   10778:	685b      	ldr	r3, [r3, #4]
   1077a:	049b      	lsls	r3, r3, #18
   1077c:	0c9b      	lsrs	r3, r3, #18
   1077e:	b29b      	uxth	r3, r3
   10780:	001a      	movs	r2, r3
   10782:	4b3c      	ldr	r3, [pc, #240]	; (10874 <_usb_device_interrupt_handler+0x354>)
   10784:	801a      	strh	r2, [r3, #0]
						(_usb_instances->device_endpoint_callback[i][USB_DEVICE_ENDPOINT_CALLBACK_RXSTP])(_usb_instances,&ep_callback_para);
   10786:	4b37      	ldr	r3, [pc, #220]	; (10864 <_usb_device_interrupt_handler+0x344>)
   10788:	681a      	ldr	r2, [r3, #0]
   1078a:	230b      	movs	r3, #11
   1078c:	18fb      	adds	r3, r7, r3
   1078e:	781b      	ldrb	r3, [r3, #0]
   10790:	21dc      	movs	r1, #220	; 0xdc
   10792:	011b      	lsls	r3, r3, #4
   10794:	18d3      	adds	r3, r2, r3
   10796:	185b      	adds	r3, r3, r1
   10798:	681a      	ldr	r2, [r3, #0]
   1079a:	4b32      	ldr	r3, [pc, #200]	; (10864 <_usb_device_interrupt_handler+0x344>)
   1079c:	681b      	ldr	r3, [r3, #0]
   1079e:	4935      	ldr	r1, [pc, #212]	; (10874 <_usb_device_interrupt_handler+0x354>)
   107a0:	0018      	movs	r0, r3
   107a2:	4790      	blx	r2
					}
					return;
   107a4:	e16c      	b.n	10a80 <_usb_device_interrupt_handler+0x560>
				}

				// endpoint transfer fail interrupt
				if (flags & USB_DEVICE_EPINTFLAG_TRFAIL_Msk) {
   107a6:	1dbb      	adds	r3, r7, #6
   107a8:	881b      	ldrh	r3, [r3, #0]
   107aa:	220c      	movs	r2, #12
   107ac:	4013      	ands	r3, r2
   107ae:	d100      	bne.n	107b2 <_usb_device_interrupt_handler+0x292>
   107b0:	e0cc      	b.n	1094c <_usb_device_interrupt_handler+0x42c>
					if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRFAIL1) {
   107b2:	4b2c      	ldr	r3, [pc, #176]	; (10864 <_usb_device_interrupt_handler+0x344>)
   107b4:	681b      	ldr	r3, [r3, #0]
   107b6:	681a      	ldr	r2, [r3, #0]
   107b8:	230b      	movs	r3, #11
   107ba:	18fb      	adds	r3, r7, r3
   107bc:	781b      	ldrb	r3, [r3, #0]
   107be:	3308      	adds	r3, #8
   107c0:	015b      	lsls	r3, r3, #5
   107c2:	18d3      	adds	r3, r2, r3
   107c4:	3307      	adds	r3, #7
   107c6:	781b      	ldrb	r3, [r3, #0]
   107c8:	b2db      	uxtb	r3, r3
   107ca:	001a      	movs	r2, r3
   107cc:	2308      	movs	r3, #8
   107ce:	4013      	ands	r3, r2
   107d0:	d052      	beq.n	10878 <_usb_device_interrupt_handler+0x358>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRFAIL1;
   107d2:	4b24      	ldr	r3, [pc, #144]	; (10864 <_usb_device_interrupt_handler+0x344>)
   107d4:	681b      	ldr	r3, [r3, #0]
   107d6:	681a      	ldr	r2, [r3, #0]
   107d8:	230b      	movs	r3, #11
   107da:	18fb      	adds	r3, r7, r3
   107dc:	781b      	ldrb	r3, [r3, #0]
   107de:	3308      	adds	r3, #8
   107e0:	015b      	lsls	r3, r3, #5
   107e2:	18d3      	adds	r3, r2, r3
   107e4:	3307      	adds	r3, #7
   107e6:	2208      	movs	r2, #8
   107e8:	701a      	strb	r2, [r3, #0]
						if (usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[1].STATUS_BK.reg & USB_DEVICE_STATUS_BK_ERRORFLOW) {
   107ea:	230b      	movs	r3, #11
   107ec:	18fb      	adds	r3, r7, r3
   107ee:	781b      	ldrb	r3, [r3, #0]
   107f0:	4a1e      	ldr	r2, [pc, #120]	; (1086c <_usb_device_interrupt_handler+0x34c>)
   107f2:	015b      	lsls	r3, r3, #5
   107f4:	18d3      	adds	r3, r2, r3
   107f6:	331a      	adds	r3, #26
   107f8:	781b      	ldrb	r3, [r3, #0]
   107fa:	b2db      	uxtb	r3, r3
   107fc:	001a      	movs	r2, r3
   107fe:	2302      	movs	r3, #2
   10800:	4013      	ands	r3, r2
   10802:	d014      	beq.n	1082e <_usb_device_interrupt_handler+0x30e>
							usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[1].STATUS_BK.reg &= ~USB_DEVICE_STATUS_BK_ERRORFLOW;
   10804:	230b      	movs	r3, #11
   10806:	18fb      	adds	r3, r7, r3
   10808:	781b      	ldrb	r3, [r3, #0]
   1080a:	220b      	movs	r2, #11
   1080c:	18ba      	adds	r2, r7, r2
   1080e:	7812      	ldrb	r2, [r2, #0]
   10810:	4916      	ldr	r1, [pc, #88]	; (1086c <_usb_device_interrupt_handler+0x34c>)
   10812:	0152      	lsls	r2, r2, #5
   10814:	188a      	adds	r2, r1, r2
   10816:	321a      	adds	r2, #26
   10818:	7812      	ldrb	r2, [r2, #0]
   1081a:	b2d2      	uxtb	r2, r2
   1081c:	2102      	movs	r1, #2
   1081e:	438a      	bics	r2, r1
   10820:	b2d1      	uxtb	r1, r2
   10822:	4a12      	ldr	r2, [pc, #72]	; (1086c <_usb_device_interrupt_handler+0x34c>)
   10824:	015b      	lsls	r3, r3, #5
   10826:	18d3      	adds	r3, r2, r3
   10828:	331a      	adds	r3, #26
   1082a:	1c0a      	adds	r2, r1, #0
   1082c:	701a      	strb	r2, [r3, #0]
						}
						ep_callback_para.endpoint_address = USB_EP_DIR_IN | i;
   1082e:	230b      	movs	r3, #11
   10830:	18fb      	adds	r3, r7, r3
   10832:	781b      	ldrb	r3, [r3, #0]
   10834:	2280      	movs	r2, #128	; 0x80
   10836:	4252      	negs	r2, r2
   10838:	4313      	orrs	r3, r2
   1083a:	b2da      	uxtb	r2, r3
   1083c:	4b0d      	ldr	r3, [pc, #52]	; (10874 <_usb_device_interrupt_handler+0x354>)
   1083e:	719a      	strb	r2, [r3, #6]
						if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRCPT1) {
   10840:	4b08      	ldr	r3, [pc, #32]	; (10864 <_usb_device_interrupt_handler+0x344>)
   10842:	681b      	ldr	r3, [r3, #0]
   10844:	681a      	ldr	r2, [r3, #0]
   10846:	230b      	movs	r3, #11
   10848:	18fb      	adds	r3, r7, r3
   1084a:	781b      	ldrb	r3, [r3, #0]
   1084c:	3308      	adds	r3, #8
   1084e:	015b      	lsls	r3, r3, #5
   10850:	18d3      	adds	r3, r2, r3
   10852:	3307      	adds	r3, #7
   10854:	781b      	ldrb	r3, [r3, #0]
   10856:	b2db      	uxtb	r3, r3
   10858:	001a      	movs	r2, r3
   1085a:	2302      	movs	r3, #2
   1085c:	4013      	ands	r3, r2
   1085e:	d05f      	beq.n	10920 <_usb_device_interrupt_handler+0x400>
							return;
   10860:	e115      	b.n	10a8e <_usb_device_interrupt_handler+0x56e>
   10862:	46c0      	nop			; (mov r8, r8)
   10864:	20000924 	.word	0x20000924
   10868:	00015948 	.word	0x00015948
   1086c:	2000177c 	.word	0x2000177c
   10870:	20000930 	.word	0x20000930
   10874:	20000934 	.word	0x20000934
						}
					} else if(_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRFAIL0) {
   10878:	4b86      	ldr	r3, [pc, #536]	; (10a94 <_usb_device_interrupt_handler+0x574>)
   1087a:	681b      	ldr	r3, [r3, #0]
   1087c:	681a      	ldr	r2, [r3, #0]
   1087e:	230b      	movs	r3, #11
   10880:	18fb      	adds	r3, r7, r3
   10882:	781b      	ldrb	r3, [r3, #0]
   10884:	3308      	adds	r3, #8
   10886:	015b      	lsls	r3, r3, #5
   10888:	18d3      	adds	r3, r2, r3
   1088a:	3307      	adds	r3, #7
   1088c:	781b      	ldrb	r3, [r3, #0]
   1088e:	b2db      	uxtb	r3, r3
   10890:	001a      	movs	r2, r3
   10892:	2304      	movs	r3, #4
   10894:	4013      	ands	r3, r2
   10896:	d043      	beq.n	10920 <_usb_device_interrupt_handler+0x400>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRFAIL0;
   10898:	4b7e      	ldr	r3, [pc, #504]	; (10a94 <_usb_device_interrupt_handler+0x574>)
   1089a:	681b      	ldr	r3, [r3, #0]
   1089c:	681a      	ldr	r2, [r3, #0]
   1089e:	230b      	movs	r3, #11
   108a0:	18fb      	adds	r3, r7, r3
   108a2:	781b      	ldrb	r3, [r3, #0]
   108a4:	3308      	adds	r3, #8
   108a6:	015b      	lsls	r3, r3, #5
   108a8:	18d3      	adds	r3, r2, r3
   108aa:	3307      	adds	r3, #7
   108ac:	2204      	movs	r2, #4
   108ae:	701a      	strb	r2, [r3, #0]
						if (usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].STATUS_BK.reg & USB_DEVICE_STATUS_BK_ERRORFLOW) {
   108b0:	230b      	movs	r3, #11
   108b2:	18fb      	adds	r3, r7, r3
   108b4:	781b      	ldrb	r3, [r3, #0]
   108b6:	4a78      	ldr	r2, [pc, #480]	; (10a98 <_usb_device_interrupt_handler+0x578>)
   108b8:	015b      	lsls	r3, r3, #5
   108ba:	18d3      	adds	r3, r2, r3
   108bc:	330a      	adds	r3, #10
   108be:	781b      	ldrb	r3, [r3, #0]
   108c0:	b2db      	uxtb	r3, r3
   108c2:	001a      	movs	r2, r3
   108c4:	2302      	movs	r3, #2
   108c6:	4013      	ands	r3, r2
   108c8:	d014      	beq.n	108f4 <_usb_device_interrupt_handler+0x3d4>
							usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].STATUS_BK.reg &= ~USB_DEVICE_STATUS_BK_ERRORFLOW;
   108ca:	230b      	movs	r3, #11
   108cc:	18fb      	adds	r3, r7, r3
   108ce:	781b      	ldrb	r3, [r3, #0]
   108d0:	220b      	movs	r2, #11
   108d2:	18ba      	adds	r2, r7, r2
   108d4:	7812      	ldrb	r2, [r2, #0]
   108d6:	4970      	ldr	r1, [pc, #448]	; (10a98 <_usb_device_interrupt_handler+0x578>)
   108d8:	0152      	lsls	r2, r2, #5
   108da:	188a      	adds	r2, r1, r2
   108dc:	320a      	adds	r2, #10
   108de:	7812      	ldrb	r2, [r2, #0]
   108e0:	b2d2      	uxtb	r2, r2
   108e2:	2102      	movs	r1, #2
   108e4:	438a      	bics	r2, r1
   108e6:	b2d1      	uxtb	r1, r2
   108e8:	4a6b      	ldr	r2, [pc, #428]	; (10a98 <_usb_device_interrupt_handler+0x578>)
   108ea:	015b      	lsls	r3, r3, #5
   108ec:	18d3      	adds	r3, r2, r3
   108ee:	330a      	adds	r3, #10
   108f0:	1c0a      	adds	r2, r1, #0
   108f2:	701a      	strb	r2, [r3, #0]
						}
						ep_callback_para.endpoint_address = USB_EP_DIR_OUT | i;
   108f4:	4b69      	ldr	r3, [pc, #420]	; (10a9c <_usb_device_interrupt_handler+0x57c>)
   108f6:	220b      	movs	r2, #11
   108f8:	18ba      	adds	r2, r7, r2
   108fa:	7812      	ldrb	r2, [r2, #0]
   108fc:	719a      	strb	r2, [r3, #6]
						if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRCPT0) {
   108fe:	4b65      	ldr	r3, [pc, #404]	; (10a94 <_usb_device_interrupt_handler+0x574>)
   10900:	681b      	ldr	r3, [r3, #0]
   10902:	681a      	ldr	r2, [r3, #0]
   10904:	230b      	movs	r3, #11
   10906:	18fb      	adds	r3, r7, r3
   10908:	781b      	ldrb	r3, [r3, #0]
   1090a:	3308      	adds	r3, #8
   1090c:	015b      	lsls	r3, r3, #5
   1090e:	18d3      	adds	r3, r2, r3
   10910:	3307      	adds	r3, #7
   10912:	781b      	ldrb	r3, [r3, #0]
   10914:	b2db      	uxtb	r3, r3
   10916:	001a      	movs	r2, r3
   10918:	2301      	movs	r3, #1
   1091a:	4013      	ands	r3, r2
   1091c:	d000      	beq.n	10920 <_usb_device_interrupt_handler+0x400>
   1091e:	e0b1      	b.n	10a84 <_usb_device_interrupt_handler+0x564>
							return;
						}
					}

					if(flags_run & USB_DEVICE_EPINTFLAG_TRFAIL_Msk) {
   10920:	1d3b      	adds	r3, r7, #4
   10922:	881b      	ldrh	r3, [r3, #0]
   10924:	220c      	movs	r2, #12
   10926:	4013      	ands	r3, r2
   10928:	d100      	bne.n	1092c <_usb_device_interrupt_handler+0x40c>
   1092a:	e0ad      	b.n	10a88 <_usb_device_interrupt_handler+0x568>
						(_usb_instances->device_endpoint_callback[i][USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL])(_usb_instances,&ep_callback_para);
   1092c:	4b59      	ldr	r3, [pc, #356]	; (10a94 <_usb_device_interrupt_handler+0x574>)
   1092e:	681a      	ldr	r2, [r3, #0]
   10930:	230b      	movs	r3, #11
   10932:	18fb      	adds	r3, r7, r3
   10934:	781b      	ldrb	r3, [r3, #0]
   10936:	21d8      	movs	r1, #216	; 0xd8
   10938:	011b      	lsls	r3, r3, #4
   1093a:	18d3      	adds	r3, r2, r3
   1093c:	185b      	adds	r3, r3, r1
   1093e:	681a      	ldr	r2, [r3, #0]
   10940:	4b54      	ldr	r3, [pc, #336]	; (10a94 <_usb_device_interrupt_handler+0x574>)
   10942:	681b      	ldr	r3, [r3, #0]
   10944:	4955      	ldr	r1, [pc, #340]	; (10a9c <_usb_device_interrupt_handler+0x57c>)
   10946:	0018      	movs	r0, r3
   10948:	4790      	blx	r2
					}
					return;
   1094a:	e09d      	b.n	10a88 <_usb_device_interrupt_handler+0x568>
				}

				// endpoint transfer complete interrupt
				if (flags & USB_DEVICE_EPINTFLAG_TRCPT_Msk) {
   1094c:	1dbb      	adds	r3, r7, #6
   1094e:	881b      	ldrh	r3, [r3, #0]
   10950:	2203      	movs	r2, #3
   10952:	4013      	ands	r3, r2
   10954:	d100      	bne.n	10958 <_usb_device_interrupt_handler+0x438>
   10956:	e083      	b.n	10a60 <_usb_device_interrupt_handler+0x540>
					if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRCPT1) {
   10958:	4b4e      	ldr	r3, [pc, #312]	; (10a94 <_usb_device_interrupt_handler+0x574>)
   1095a:	681b      	ldr	r3, [r3, #0]
   1095c:	681a      	ldr	r2, [r3, #0]
   1095e:	230b      	movs	r3, #11
   10960:	18fb      	adds	r3, r7, r3
   10962:	781b      	ldrb	r3, [r3, #0]
   10964:	3308      	adds	r3, #8
   10966:	015b      	lsls	r3, r3, #5
   10968:	18d3      	adds	r3, r2, r3
   1096a:	3307      	adds	r3, #7
   1096c:	781b      	ldrb	r3, [r3, #0]
   1096e:	b2db      	uxtb	r3, r3
   10970:	001a      	movs	r2, r3
   10972:	2302      	movs	r3, #2
   10974:	4013      	ands	r3, r2
   10976:	d023      	beq.n	109c0 <_usb_device_interrupt_handler+0x4a0>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT1;
   10978:	4b46      	ldr	r3, [pc, #280]	; (10a94 <_usb_device_interrupt_handler+0x574>)
   1097a:	681b      	ldr	r3, [r3, #0]
   1097c:	681a      	ldr	r2, [r3, #0]
   1097e:	230b      	movs	r3, #11
   10980:	18fb      	adds	r3, r7, r3
   10982:	781b      	ldrb	r3, [r3, #0]
   10984:	3308      	adds	r3, #8
   10986:	015b      	lsls	r3, r3, #5
   10988:	18d3      	adds	r3, r2, r3
   1098a:	3307      	adds	r3, #7
   1098c:	2202      	movs	r2, #2
   1098e:	701a      	strb	r2, [r3, #0]
						ep_callback_para.endpoint_address = USB_EP_DIR_IN | i;
   10990:	230b      	movs	r3, #11
   10992:	18fb      	adds	r3, r7, r3
   10994:	781b      	ldrb	r3, [r3, #0]
   10996:	2280      	movs	r2, #128	; 0x80
   10998:	4252      	negs	r2, r2
   1099a:	4313      	orrs	r3, r2
   1099c:	b2da      	uxtb	r2, r3
   1099e:	4b3f      	ldr	r3, [pc, #252]	; (10a9c <_usb_device_interrupt_handler+0x57c>)
   109a0:	719a      	strb	r2, [r3, #6]
						ep_callback_para.sent_bytes = (uint16_t)(usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT);
   109a2:	230b      	movs	r3, #11
   109a4:	18fb      	adds	r3, r7, r3
   109a6:	781b      	ldrb	r3, [r3, #0]
   109a8:	4a3b      	ldr	r2, [pc, #236]	; (10a98 <_usb_device_interrupt_handler+0x578>)
   109aa:	015b      	lsls	r3, r3, #5
   109ac:	18d3      	adds	r3, r2, r3
   109ae:	3310      	adds	r3, #16
   109b0:	685b      	ldr	r3, [r3, #4]
   109b2:	049b      	lsls	r3, r3, #18
   109b4:	0c9b      	lsrs	r3, r3, #18
   109b6:	b29b      	uxth	r3, r3
   109b8:	001a      	movs	r2, r3
   109ba:	4b38      	ldr	r3, [pc, #224]	; (10a9c <_usb_device_interrupt_handler+0x57c>)
   109bc:	805a      	strh	r2, [r3, #2]
   109be:	e03a      	b.n	10a36 <_usb_device_interrupt_handler+0x516>

					} else if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRCPT0) {
   109c0:	4b34      	ldr	r3, [pc, #208]	; (10a94 <_usb_device_interrupt_handler+0x574>)
   109c2:	681b      	ldr	r3, [r3, #0]
   109c4:	681a      	ldr	r2, [r3, #0]
   109c6:	230b      	movs	r3, #11
   109c8:	18fb      	adds	r3, r7, r3
   109ca:	781b      	ldrb	r3, [r3, #0]
   109cc:	3308      	adds	r3, #8
   109ce:	015b      	lsls	r3, r3, #5
   109d0:	18d3      	adds	r3, r2, r3
   109d2:	3307      	adds	r3, #7
   109d4:	781b      	ldrb	r3, [r3, #0]
   109d6:	b2db      	uxtb	r3, r3
   109d8:	001a      	movs	r2, r3
   109da:	2301      	movs	r3, #1
   109dc:	4013      	ands	r3, r2
   109de:	d02a      	beq.n	10a36 <_usb_device_interrupt_handler+0x516>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT0;
   109e0:	4b2c      	ldr	r3, [pc, #176]	; (10a94 <_usb_device_interrupt_handler+0x574>)
   109e2:	681b      	ldr	r3, [r3, #0]
   109e4:	681a      	ldr	r2, [r3, #0]
   109e6:	230b      	movs	r3, #11
   109e8:	18fb      	adds	r3, r7, r3
   109ea:	781b      	ldrb	r3, [r3, #0]
   109ec:	3308      	adds	r3, #8
   109ee:	015b      	lsls	r3, r3, #5
   109f0:	18d3      	adds	r3, r2, r3
   109f2:	3307      	adds	r3, #7
   109f4:	2201      	movs	r2, #1
   109f6:	701a      	strb	r2, [r3, #0]
						ep_callback_para.endpoint_address = USB_EP_DIR_OUT | i;
   109f8:	4b28      	ldr	r3, [pc, #160]	; (10a9c <_usb_device_interrupt_handler+0x57c>)
   109fa:	220b      	movs	r2, #11
   109fc:	18ba      	adds	r2, r7, r2
   109fe:	7812      	ldrb	r2, [r2, #0]
   10a00:	719a      	strb	r2, [r3, #6]
						ep_callback_para.received_bytes = (uint16_t)(usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT);
   10a02:	230b      	movs	r3, #11
   10a04:	18fb      	adds	r3, r7, r3
   10a06:	781b      	ldrb	r3, [r3, #0]
   10a08:	4a23      	ldr	r2, [pc, #140]	; (10a98 <_usb_device_interrupt_handler+0x578>)
   10a0a:	015b      	lsls	r3, r3, #5
   10a0c:	18d3      	adds	r3, r2, r3
   10a0e:	685b      	ldr	r3, [r3, #4]
   10a10:	049b      	lsls	r3, r3, #18
   10a12:	0c9b      	lsrs	r3, r3, #18
   10a14:	b29b      	uxth	r3, r3
   10a16:	001a      	movs	r2, r3
   10a18:	4b20      	ldr	r3, [pc, #128]	; (10a9c <_usb_device_interrupt_handler+0x57c>)
   10a1a:	801a      	strh	r2, [r3, #0]
						ep_callback_para.out_buffer_size = (uint16_t)(usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE);
   10a1c:	230b      	movs	r3, #11
   10a1e:	18fb      	adds	r3, r7, r3
   10a20:	781b      	ldrb	r3, [r3, #0]
   10a22:	4a1d      	ldr	r2, [pc, #116]	; (10a98 <_usb_device_interrupt_handler+0x578>)
   10a24:	015b      	lsls	r3, r3, #5
   10a26:	18d3      	adds	r3, r2, r3
   10a28:	685b      	ldr	r3, [r3, #4]
   10a2a:	011b      	lsls	r3, r3, #4
   10a2c:	0c9b      	lsrs	r3, r3, #18
   10a2e:	b29b      	uxth	r3, r3
   10a30:	001a      	movs	r2, r3
   10a32:	4b1a      	ldr	r3, [pc, #104]	; (10a9c <_usb_device_interrupt_handler+0x57c>)
   10a34:	809a      	strh	r2, [r3, #4]
					}
					if(flags_run & USB_DEVICE_EPINTFLAG_TRCPT_Msk) {
   10a36:	1d3b      	adds	r3, r7, #4
   10a38:	881b      	ldrh	r3, [r3, #0]
   10a3a:	2203      	movs	r2, #3
   10a3c:	4013      	ands	r3, r2
   10a3e:	d025      	beq.n	10a8c <_usb_device_interrupt_handler+0x56c>
						(_usb_instances->device_endpoint_callback[i][USB_DEVICE_ENDPOINT_CALLBACK_TRCPT])(_usb_instances,&ep_callback_para);
   10a40:	4b14      	ldr	r3, [pc, #80]	; (10a94 <_usb_device_interrupt_handler+0x574>)
   10a42:	681a      	ldr	r2, [r3, #0]
   10a44:	230b      	movs	r3, #11
   10a46:	18fb      	adds	r3, r7, r3
   10a48:	781b      	ldrb	r3, [r3, #0]
   10a4a:	330d      	adds	r3, #13
   10a4c:	011b      	lsls	r3, r3, #4
   10a4e:	18d3      	adds	r3, r2, r3
   10a50:	3304      	adds	r3, #4
   10a52:	681a      	ldr	r2, [r3, #0]
   10a54:	4b0f      	ldr	r3, [pc, #60]	; (10a94 <_usb_device_interrupt_handler+0x574>)
   10a56:	681b      	ldr	r3, [r3, #0]
   10a58:	4910      	ldr	r1, [pc, #64]	; (10a9c <_usb_device_interrupt_handler+0x57c>)
   10a5a:	0018      	movs	r0, r3
   10a5c:	4790      	blx	r2
					}
					return;
   10a5e:	e015      	b.n	10a8c <_usb_device_interrupt_handler+0x56c>
		}

	} else {
		/* endpoint interrupt */

		for (uint8_t i = 0; i < USB_EPT_NUM; i++) {
   10a60:	230b      	movs	r3, #11
   10a62:	18fb      	adds	r3, r7, r3
   10a64:	781a      	ldrb	r2, [r3, #0]
   10a66:	230b      	movs	r3, #11
   10a68:	18fb      	adds	r3, r7, r3
   10a6a:	3201      	adds	r2, #1
   10a6c:	701a      	strb	r2, [r3, #0]
   10a6e:	230b      	movs	r3, #11
   10a70:	18fb      	adds	r3, r7, r3
   10a72:	781b      	ldrb	r3, [r3, #0]
   10a74:	2b07      	cmp	r3, #7
   10a76:	d800      	bhi.n	10a7a <_usb_device_interrupt_handler+0x55a>
   10a78:	e5bc      	b.n	105f4 <_usb_device_interrupt_handler+0xd4>
   10a7a:	e008      	b.n	10a8e <_usb_device_interrupt_handler+0x56e>
					}

					if (flags_run & USB_DEVICE_EPINTFLAG_STALL_Msk) {
						(_usb_instances->device_endpoint_callback[i][USB_DEVICE_ENDPOINT_CALLBACK_STALL])(_usb_instances,&ep_callback_para);
					}
					return;
   10a7c:	46c0      	nop			; (mov r8, r8)
   10a7e:	e006      	b.n	10a8e <_usb_device_interrupt_handler+0x56e>
					_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP;
					if(_usb_instances->device_endpoint_enabled_callback_mask[i] & _usb_endpoint_irq_bits[USB_DEVICE_ENDPOINT_CALLBACK_RXSTP]) {
						ep_callback_para.received_bytes = (uint16_t)(usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT);
						(_usb_instances->device_endpoint_callback[i][USB_DEVICE_ENDPOINT_CALLBACK_RXSTP])(_usb_instances,&ep_callback_para);
					}
					return;
   10a80:	46c0      	nop			; (mov r8, r8)
   10a82:	e004      	b.n	10a8e <_usb_device_interrupt_handler+0x56e>
						if (usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].STATUS_BK.reg & USB_DEVICE_STATUS_BK_ERRORFLOW) {
							usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].STATUS_BK.reg &= ~USB_DEVICE_STATUS_BK_ERRORFLOW;
						}
						ep_callback_para.endpoint_address = USB_EP_DIR_OUT | i;
						if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRCPT0) {
							return;
   10a84:	46c0      	nop			; (mov r8, r8)
   10a86:	e002      	b.n	10a8e <_usb_device_interrupt_handler+0x56e>
					}

					if(flags_run & USB_DEVICE_EPINTFLAG_TRFAIL_Msk) {
						(_usb_instances->device_endpoint_callback[i][USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL])(_usb_instances,&ep_callback_para);
					}
					return;
   10a88:	46c0      	nop			; (mov r8, r8)
   10a8a:	e000      	b.n	10a8e <_usb_device_interrupt_handler+0x56e>
						ep_callback_para.out_buffer_size = (uint16_t)(usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE);
					}
					if(flags_run & USB_DEVICE_EPINTFLAG_TRCPT_Msk) {
						(_usb_instances->device_endpoint_callback[i][USB_DEVICE_ENDPOINT_CALLBACK_TRCPT])(_usb_instances,&ep_callback_para);
					}
					return;
   10a8c:	46c0      	nop			; (mov r8, r8)
				}
			}
		}
	}
}
   10a8e:	46bd      	mov	sp, r7
   10a90:	b004      	add	sp, #16
   10a92:	bd80      	pop	{r7, pc}
   10a94:	20000924 	.word	0x20000924
   10a98:	2000177c 	.word	0x2000177c
   10a9c:	20000934 	.word	0x20000934

00010aa0 <usb_enable>:
 * \brief Enable the USB module peripheral
 *
 * \param module_inst pointer to USB module instance
 */
void usb_enable(struct usb_module *module_inst)
{
   10aa0:	b580      	push	{r7, lr}
   10aa2:	b082      	sub	sp, #8
   10aa4:	af00      	add	r7, sp, #0
   10aa6:	6078      	str	r0, [r7, #4]
	Assert(module_inst);
	Assert(module_inst->hw);

	module_inst->hw->DEVICE.CTRLA.reg |= USB_CTRLA_ENABLE;
   10aa8:	687b      	ldr	r3, [r7, #4]
   10aaa:	681a      	ldr	r2, [r3, #0]
   10aac:	687b      	ldr	r3, [r7, #4]
   10aae:	681b      	ldr	r3, [r3, #0]
   10ab0:	781b      	ldrb	r3, [r3, #0]
   10ab2:	b2db      	uxtb	r3, r3
   10ab4:	2102      	movs	r1, #2
   10ab6:	430b      	orrs	r3, r1
   10ab8:	b2db      	uxtb	r3, r3
   10aba:	7013      	strb	r3, [r2, #0]
	while (module_inst->hw->DEVICE.SYNCBUSY.reg == USB_SYNCBUSY_ENABLE);
   10abc:	46c0      	nop			; (mov r8, r8)
   10abe:	687b      	ldr	r3, [r7, #4]
   10ac0:	681b      	ldr	r3, [r3, #0]
   10ac2:	789b      	ldrb	r3, [r3, #2]
   10ac4:	b2db      	uxtb	r3, r3
   10ac6:	2b02      	cmp	r3, #2
   10ac8:	d0f9      	beq.n	10abe <usb_enable+0x1e>
}
   10aca:	46c0      	nop			; (mov r8, r8)
   10acc:	46bd      	mov	sp, r7
   10ace:	b002      	add	sp, #8
   10ad0:	bd80      	pop	{r7, pc}
   10ad2:	46c0      	nop			; (mov r8, r8)

00010ad4 <USB_Handler>:

/**
 * \brief Interrupt handler for the USB module.
 */
void USB_Handler(void)
{
   10ad4:	b580      	push	{r7, lr}
   10ad6:	af00      	add	r7, sp, #0
	if (_usb_instances->hw->DEVICE.CTRLA.bit.MODE) {
   10ad8:	4b08      	ldr	r3, [pc, #32]	; (10afc <USB_Handler+0x28>)
   10ada:	681b      	ldr	r3, [r3, #0]
   10adc:	681b      	ldr	r3, [r3, #0]
   10ade:	781b      	ldrb	r3, [r3, #0]
   10ae0:	061b      	lsls	r3, r3, #24
   10ae2:	0fdb      	lsrs	r3, r3, #31
   10ae4:	b2db      	uxtb	r3, r3
   10ae6:	2b00      	cmp	r3, #0
   10ae8:	d002      	beq.n	10af0 <USB_Handler+0x1c>
#if !SAMD11
		/*host mode ISR */
		_usb_host_interrupt_handler();
   10aea:	4b05      	ldr	r3, [pc, #20]	; (10b00 <USB_Handler+0x2c>)
   10aec:	4798      	blx	r3
#endif
	} else {
		/*device mode ISR */
		_usb_device_interrupt_handler();
	}
}
   10aee:	e001      	b.n	10af4 <USB_Handler+0x20>
		/*host mode ISR */
		_usb_host_interrupt_handler();
#endif
	} else {
		/*device mode ISR */
		_usb_device_interrupt_handler();
   10af0:	4b04      	ldr	r3, [pc, #16]	; (10b04 <USB_Handler+0x30>)
   10af2:	4798      	blx	r3
	}
}
   10af4:	46c0      	nop			; (mov r8, r8)
   10af6:	46bd      	mov	sp, r7
   10af8:	bd80      	pop	{r7, pc}
   10afa:	46c0      	nop			; (mov r8, r8)
   10afc:	20000924 	.word	0x20000924
   10b00:	0000f1cd 	.word	0x0000f1cd
   10b04:	00010521 	.word	0x00010521

00010b08 <usb_get_config_defaults>:
 * \brief Get the default USB module settings
 *
 * \param[out] module_config  Configuration structure to initialize to default values
 */
void usb_get_config_defaults(struct usb_config *module_config)
{
   10b08:	b580      	push	{r7, lr}
   10b0a:	b082      	sub	sp, #8
   10b0c:	af00      	add	r7, sp, #0
   10b0e:	6078      	str	r0, [r7, #4]
	Assert(module_config);

	/* Sanity check arguments */
	Assert(module_config);
	/* Write default configuration to config struct */
	module_config->select_host_mode = 0;
   10b10:	687b      	ldr	r3, [r7, #4]
   10b12:	2200      	movs	r2, #0
   10b14:	701a      	strb	r2, [r3, #0]
	module_config->run_in_standby = 1;
   10b16:	687b      	ldr	r3, [r7, #4]
   10b18:	2201      	movs	r2, #1
   10b1a:	705a      	strb	r2, [r3, #1]
	module_config->source_generator = GCLK_GENERATOR_0;
   10b1c:	687b      	ldr	r3, [r7, #4]
   10b1e:	2200      	movs	r2, #0
   10b20:	709a      	strb	r2, [r3, #2]
	module_config->speed_mode = USB_SPEED_FULL;
   10b22:	687b      	ldr	r3, [r7, #4]
   10b24:	2201      	movs	r2, #1
   10b26:	70da      	strb	r2, [r3, #3]
}
   10b28:	46c0      	nop			; (mov r8, r8)
   10b2a:	46bd      	mov	sp, r7
   10b2c:	b002      	add	sp, #8
   10b2e:	bd80      	pop	{r7, pc}

00010b30 <usb_init>:
 *
 * \retval STATUS_OK           The module was initialized successfully
 */
enum status_code usb_init(struct usb_module *module_inst, Usb *const hw,
		struct usb_config *module_config)
{
   10b30:	b580      	push	{r7, lr}
   10b32:	b08c      	sub	sp, #48	; 0x30
   10b34:	af00      	add	r7, sp, #0
   10b36:	60f8      	str	r0, [r7, #12]
   10b38:	60b9      	str	r1, [r7, #8]
   10b3a:	607a      	str	r2, [r7, #4]
	uint32_t pad_transn, pad_transp, pad_trim;
	struct system_pinmux_config pin_config;
	struct system_gclk_chan_config gclk_chan_config;

#if !SAMD11
	host_pipe_job_busy_status = 0;
   10b3c:	4bc4      	ldr	r3, [pc, #784]	; (10e50 <usb_init+0x320>)
   10b3e:	2200      	movs	r2, #0
   10b40:	601a      	str	r2, [r3, #0]
#endif

	_usb_instances = module_inst;
   10b42:	4bc4      	ldr	r3, [pc, #784]	; (10e54 <usb_init+0x324>)
   10b44:	68fa      	ldr	r2, [r7, #12]
   10b46:	601a      	str	r2, [r3, #0]

	/* Associate the software module instance with the hardware module */
	module_inst->hw = hw;
   10b48:	68fb      	ldr	r3, [r7, #12]
   10b4a:	68ba      	ldr	r2, [r7, #8]
   10b4c:	601a      	str	r2, [r3, #0]

	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBB, PM_APBBMASK_USB);
   10b4e:	2120      	movs	r1, #32
   10b50:	2001      	movs	r0, #1
   10b52:	4bc1      	ldr	r3, [pc, #772]	; (10e58 <usb_init+0x328>)
   10b54:	4798      	blx	r3

	/* Set up the USB DP/DN pins */
	system_pinmux_get_config_defaults(&pin_config);
   10b56:	2318      	movs	r3, #24
   10b58:	18fb      	adds	r3, r7, r3
   10b5a:	0018      	movs	r0, r3
   10b5c:	4bbf      	ldr	r3, [pc, #764]	; (10e5c <usb_init+0x32c>)
   10b5e:	4798      	blx	r3
	pin_config.mux_position = MUX_PA24G_USB_DM;
   10b60:	2318      	movs	r3, #24
   10b62:	18fb      	adds	r3, r7, r3
   10b64:	2206      	movs	r2, #6
   10b66:	701a      	strb	r2, [r3, #0]
	system_pinmux_pin_set_config(PIN_PA24G_USB_DM, &pin_config);
   10b68:	2318      	movs	r3, #24
   10b6a:	18fb      	adds	r3, r7, r3
   10b6c:	0019      	movs	r1, r3
   10b6e:	2018      	movs	r0, #24
   10b70:	4bbb      	ldr	r3, [pc, #748]	; (10e60 <usb_init+0x330>)
   10b72:	4798      	blx	r3
	pin_config.mux_position = MUX_PA25G_USB_DP;
   10b74:	2318      	movs	r3, #24
   10b76:	18fb      	adds	r3, r7, r3
   10b78:	2206      	movs	r2, #6
   10b7a:	701a      	strb	r2, [r3, #0]
	system_pinmux_pin_set_config(PIN_PA25G_USB_DP, &pin_config);
   10b7c:	2318      	movs	r3, #24
   10b7e:	18fb      	adds	r3, r7, r3
   10b80:	0019      	movs	r1, r3
   10b82:	2019      	movs	r0, #25
   10b84:	4bb6      	ldr	r3, [pc, #728]	; (10e60 <usb_init+0x330>)
   10b86:	4798      	blx	r3

	/* Setup clock for module */
	system_gclk_chan_get_config_defaults(&gclk_chan_config);
   10b88:	2314      	movs	r3, #20
   10b8a:	18fb      	adds	r3, r7, r3
   10b8c:	0018      	movs	r0, r3
   10b8e:	4bb5      	ldr	r3, [pc, #724]	; (10e64 <usb_init+0x334>)
   10b90:	4798      	blx	r3
	gclk_chan_config.source_generator = module_config->source_generator;
   10b92:	687b      	ldr	r3, [r7, #4]
   10b94:	789a      	ldrb	r2, [r3, #2]
   10b96:	2314      	movs	r3, #20
   10b98:	18fb      	adds	r3, r7, r3
   10b9a:	701a      	strb	r2, [r3, #0]
	system_gclk_chan_set_config(USB_GCLK_ID, &gclk_chan_config);
   10b9c:	2314      	movs	r3, #20
   10b9e:	18fb      	adds	r3, r7, r3
   10ba0:	0019      	movs	r1, r3
   10ba2:	2006      	movs	r0, #6
   10ba4:	4bb0      	ldr	r3, [pc, #704]	; (10e68 <usb_init+0x338>)
   10ba6:	4798      	blx	r3
	system_gclk_chan_enable(USB_GCLK_ID);
   10ba8:	2006      	movs	r0, #6
   10baa:	4bb0      	ldr	r3, [pc, #704]	; (10e6c <usb_init+0x33c>)
   10bac:	4798      	blx	r3

	/* Reset */
	hw->DEVICE.CTRLA.bit.SWRST = 1;
   10bae:	68ba      	ldr	r2, [r7, #8]
   10bb0:	7813      	ldrb	r3, [r2, #0]
   10bb2:	2101      	movs	r1, #1
   10bb4:	430b      	orrs	r3, r1
   10bb6:	7013      	strb	r3, [r2, #0]
	while (hw->DEVICE.SYNCBUSY.bit.SWRST) {
   10bb8:	46c0      	nop			; (mov r8, r8)
   10bba:	68bb      	ldr	r3, [r7, #8]
   10bbc:	789b      	ldrb	r3, [r3, #2]
   10bbe:	07db      	lsls	r3, r3, #31
   10bc0:	0fdb      	lsrs	r3, r3, #31
   10bc2:	b2db      	uxtb	r3, r3
   10bc4:	2b00      	cmp	r3, #0
   10bc6:	d1f8      	bne.n	10bba <usb_init+0x8a>
		/* Sync wait */
	}

	/* Change QOS values to have the best performance and correct USB behaviour */
	USB->DEVICE.QOSCTRL.bit.CQOS = 2;
   10bc8:	4aa9      	ldr	r2, [pc, #676]	; (10e70 <usb_init+0x340>)
   10bca:	78d3      	ldrb	r3, [r2, #3]
   10bcc:	2103      	movs	r1, #3
   10bce:	438b      	bics	r3, r1
   10bd0:	1c19      	adds	r1, r3, #0
   10bd2:	2302      	movs	r3, #2
   10bd4:	430b      	orrs	r3, r1
   10bd6:	70d3      	strb	r3, [r2, #3]
	USB->DEVICE.QOSCTRL.bit.DQOS = 2;
   10bd8:	4aa5      	ldr	r2, [pc, #660]	; (10e70 <usb_init+0x340>)
   10bda:	78d3      	ldrb	r3, [r2, #3]
   10bdc:	210c      	movs	r1, #12
   10bde:	438b      	bics	r3, r1
   10be0:	1c19      	adds	r1, r3, #0
   10be2:	2308      	movs	r3, #8
   10be4:	430b      	orrs	r3, r1
   10be6:	70d3      	strb	r3, [r2, #3]

	/* Load Pad Calibration */
	pad_transn =( *((uint32_t *)(NVMCTRL_OTP4)
   10be8:	4ba2      	ldr	r3, [pc, #648]	; (10e74 <usb_init+0x344>)
   10bea:	681b      	ldr	r3, [r3, #0]
			+ (NVM_USB_PAD_TRANSN_POS / 32))
		>> (NVM_USB_PAD_TRANSN_POS % 32))
   10bec:	0b5b      	lsrs	r3, r3, #13
	/* Change QOS values to have the best performance and correct USB behaviour */
	USB->DEVICE.QOSCTRL.bit.CQOS = 2;
	USB->DEVICE.QOSCTRL.bit.DQOS = 2;

	/* Load Pad Calibration */
	pad_transn =( *((uint32_t *)(NVMCTRL_OTP4)
   10bee:	221f      	movs	r2, #31
   10bf0:	4013      	ands	r3, r2
   10bf2:	627b      	str	r3, [r7, #36]	; 0x24
			+ (NVM_USB_PAD_TRANSN_POS / 32))
		>> (NVM_USB_PAD_TRANSN_POS % 32))
		& ((1 << NVM_USB_PAD_TRANSN_SIZE) - 1);

	if (pad_transn == 0x1F) {
   10bf4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10bf6:	2b1f      	cmp	r3, #31
   10bf8:	d101      	bne.n	10bfe <usb_init+0xce>
		pad_transn = 5;
   10bfa:	2305      	movs	r3, #5
   10bfc:	627b      	str	r3, [r7, #36]	; 0x24
	}

	hw->DEVICE.PADCAL.bit.TRANSN = pad_transn;
   10bfe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10c00:	b2db      	uxtb	r3, r3
   10c02:	1c1a      	adds	r2, r3, #0
   10c04:	231f      	movs	r3, #31
   10c06:	4013      	ands	r3, r2
   10c08:	b2d9      	uxtb	r1, r3
   10c0a:	68ba      	ldr	r2, [r7, #8]
   10c0c:	8d13      	ldrh	r3, [r2, #40]	; 0x28
   10c0e:	1c08      	adds	r0, r1, #0
   10c10:	211f      	movs	r1, #31
   10c12:	4001      	ands	r1, r0
   10c14:	0188      	lsls	r0, r1, #6
   10c16:	4998      	ldr	r1, [pc, #608]	; (10e78 <usb_init+0x348>)
   10c18:	400b      	ands	r3, r1
   10c1a:	1c19      	adds	r1, r3, #0
   10c1c:	1c03      	adds	r3, r0, #0
   10c1e:	430b      	orrs	r3, r1
   10c20:	8513      	strh	r3, [r2, #40]	; 0x28

	pad_transp =( *((uint32_t *)(NVMCTRL_OTP4)
   10c22:	4b94      	ldr	r3, [pc, #592]	; (10e74 <usb_init+0x344>)
   10c24:	681b      	ldr	r3, [r3, #0]
			+ (NVM_USB_PAD_TRANSP_POS / 32))
			>> (NVM_USB_PAD_TRANSP_POS % 32))
   10c26:	0c9b      	lsrs	r3, r3, #18
		pad_transn = 5;
	}

	hw->DEVICE.PADCAL.bit.TRANSN = pad_transn;

	pad_transp =( *((uint32_t *)(NVMCTRL_OTP4)
   10c28:	221f      	movs	r2, #31
   10c2a:	4013      	ands	r3, r2
   10c2c:	623b      	str	r3, [r7, #32]
			+ (NVM_USB_PAD_TRANSP_POS / 32))
			>> (NVM_USB_PAD_TRANSP_POS % 32))
			& ((1 << NVM_USB_PAD_TRANSP_SIZE) - 1);

	if (pad_transp == 0x1F) {
   10c2e:	6a3b      	ldr	r3, [r7, #32]
   10c30:	2b1f      	cmp	r3, #31
   10c32:	d101      	bne.n	10c38 <usb_init+0x108>
		pad_transp = 29;
   10c34:	231d      	movs	r3, #29
   10c36:	623b      	str	r3, [r7, #32]
	}

	hw->DEVICE.PADCAL.bit.TRANSP = pad_transp;
   10c38:	6a3b      	ldr	r3, [r7, #32]
   10c3a:	b2db      	uxtb	r3, r3
   10c3c:	1c1a      	adds	r2, r3, #0
   10c3e:	231f      	movs	r3, #31
   10c40:	4013      	ands	r3, r2
   10c42:	b2d9      	uxtb	r1, r3
   10c44:	68ba      	ldr	r2, [r7, #8]
   10c46:	8d13      	ldrh	r3, [r2, #40]	; 0x28
   10c48:	1c08      	adds	r0, r1, #0
   10c4a:	211f      	movs	r1, #31
   10c4c:	4008      	ands	r0, r1
   10c4e:	211f      	movs	r1, #31
   10c50:	438b      	bics	r3, r1
   10c52:	1c19      	adds	r1, r3, #0
   10c54:	1c03      	adds	r3, r0, #0
   10c56:	430b      	orrs	r3, r1
   10c58:	8513      	strh	r3, [r2, #40]	; 0x28

	pad_trim =( *((uint32_t *)(NVMCTRL_OTP4)
   10c5a:	4b86      	ldr	r3, [pc, #536]	; (10e74 <usb_init+0x344>)
   10c5c:	681b      	ldr	r3, [r3, #0]
			+ (NVM_USB_PAD_TRIM_POS / 32))
			>> (NVM_USB_PAD_TRIM_POS % 32))
   10c5e:	0ddb      	lsrs	r3, r3, #23
		pad_transp = 29;
	}

	hw->DEVICE.PADCAL.bit.TRANSP = pad_transp;

	pad_trim =( *((uint32_t *)(NVMCTRL_OTP4)
   10c60:	2207      	movs	r2, #7
   10c62:	4013      	ands	r3, r2
   10c64:	61fb      	str	r3, [r7, #28]
			+ (NVM_USB_PAD_TRIM_POS / 32))
			>> (NVM_USB_PAD_TRIM_POS % 32))
			& ((1 << NVM_USB_PAD_TRIM_SIZE) - 1);

	if (pad_trim == 0x7) {
   10c66:	69fb      	ldr	r3, [r7, #28]
   10c68:	2b07      	cmp	r3, #7
   10c6a:	d101      	bne.n	10c70 <usb_init+0x140>
		pad_trim = 3;
   10c6c:	2303      	movs	r3, #3
   10c6e:	61fb      	str	r3, [r7, #28]
	}

	hw->DEVICE.PADCAL.bit.TRIM = pad_trim;
   10c70:	69fb      	ldr	r3, [r7, #28]
   10c72:	b2db      	uxtb	r3, r3
   10c74:	1c1a      	adds	r2, r3, #0
   10c76:	2307      	movs	r3, #7
   10c78:	4013      	ands	r3, r2
   10c7a:	b2d9      	uxtb	r1, r3
   10c7c:	68ba      	ldr	r2, [r7, #8]
   10c7e:	8d13      	ldrh	r3, [r2, #40]	; 0x28
   10c80:	1c08      	adds	r0, r1, #0
   10c82:	2107      	movs	r1, #7
   10c84:	4001      	ands	r1, r0
   10c86:	0308      	lsls	r0, r1, #12
   10c88:	497c      	ldr	r1, [pc, #496]	; (10e7c <usb_init+0x34c>)
   10c8a:	400b      	ands	r3, r1
   10c8c:	1c19      	adds	r1, r3, #0
   10c8e:	1c03      	adds	r3, r0, #0
   10c90:	430b      	orrs	r3, r1
   10c92:	8513      	strh	r3, [r2, #40]	; 0x28

	/* Set the configuration */
	hw->DEVICE.CTRLA.bit.MODE = module_config->select_host_mode;
   10c94:	687b      	ldr	r3, [r7, #4]
   10c96:	7819      	ldrb	r1, [r3, #0]
   10c98:	68ba      	ldr	r2, [r7, #8]
   10c9a:	7813      	ldrb	r3, [r2, #0]
   10c9c:	01c8      	lsls	r0, r1, #7
   10c9e:	217f      	movs	r1, #127	; 0x7f
   10ca0:	400b      	ands	r3, r1
   10ca2:	1c19      	adds	r1, r3, #0
   10ca4:	1c03      	adds	r3, r0, #0
   10ca6:	430b      	orrs	r3, r1
   10ca8:	7013      	strb	r3, [r2, #0]
	hw->DEVICE.CTRLA.bit.RUNSTDBY = module_config->run_in_standby;
   10caa:	687b      	ldr	r3, [r7, #4]
   10cac:	7859      	ldrb	r1, [r3, #1]
   10cae:	68ba      	ldr	r2, [r7, #8]
   10cb0:	7813      	ldrb	r3, [r2, #0]
   10cb2:	2001      	movs	r0, #1
   10cb4:	4001      	ands	r1, r0
   10cb6:	0088      	lsls	r0, r1, #2
   10cb8:	2104      	movs	r1, #4
   10cba:	438b      	bics	r3, r1
   10cbc:	1c19      	adds	r1, r3, #0
   10cbe:	1c03      	adds	r3, r0, #0
   10cc0:	430b      	orrs	r3, r1
   10cc2:	7013      	strb	r3, [r2, #0]
	hw->DEVICE.DESCADD.reg = (uint32_t)(&usb_descriptor_table.usb_endpoint_table[0]);
   10cc4:	4a6e      	ldr	r2, [pc, #440]	; (10e80 <usb_init+0x350>)
   10cc6:	68bb      	ldr	r3, [r7, #8]
   10cc8:	625a      	str	r2, [r3, #36]	; 0x24
	if (USB_SPEED_FULL == module_config->speed_mode) {
   10cca:	687b      	ldr	r3, [r7, #4]
   10ccc:	78db      	ldrb	r3, [r3, #3]
   10cce:	2b01      	cmp	r3, #1
   10cd0:	d106      	bne.n	10ce0 <usb_init+0x1b0>
		module_inst->hw->DEVICE.CTRLB.bit.SPDCONF = USB_DEVICE_CTRLB_SPDCONF_FS_Val;
   10cd2:	68fb      	ldr	r3, [r7, #12]
   10cd4:	681a      	ldr	r2, [r3, #0]
   10cd6:	8913      	ldrh	r3, [r2, #8]
   10cd8:	210c      	movs	r1, #12
   10cda:	438b      	bics	r3, r1
   10cdc:	8113      	strh	r3, [r2, #8]
   10cde:	e00c      	b.n	10cfa <usb_init+0x1ca>
	} else if(USB_SPEED_LOW == module_config->speed_mode) {
   10ce0:	687b      	ldr	r3, [r7, #4]
   10ce2:	78db      	ldrb	r3, [r3, #3]
   10ce4:	2b00      	cmp	r3, #0
   10ce6:	d108      	bne.n	10cfa <usb_init+0x1ca>
		module_inst->hw->DEVICE.CTRLB.bit.SPDCONF = USB_DEVICE_CTRLB_SPDCONF_LS_Val;
   10ce8:	68fb      	ldr	r3, [r7, #12]
   10cea:	681a      	ldr	r2, [r3, #0]
   10cec:	8913      	ldrh	r3, [r2, #8]
   10cee:	210c      	movs	r1, #12
   10cf0:	438b      	bics	r3, r1
   10cf2:	1c19      	adds	r1, r3, #0
   10cf4:	2304      	movs	r3, #4
   10cf6:	430b      	orrs	r3, r1
   10cf8:	8113      	strh	r3, [r2, #8]
	}

	memset((uint8_t *)(&usb_descriptor_table.usb_endpoint_table[0]), 0,
   10cfa:	2380      	movs	r3, #128	; 0x80
   10cfc:	005a      	lsls	r2, r3, #1
   10cfe:	4b60      	ldr	r3, [pc, #384]	; (10e80 <usb_init+0x350>)
   10d00:	2100      	movs	r1, #0
   10d02:	0018      	movs	r0, r3
   10d04:	4b5f      	ldr	r3, [pc, #380]	; (10e84 <usb_init+0x354>)
   10d06:	4798      	blx	r3
			sizeof(usb_descriptor_table.usb_endpoint_table));

#if !SAMD11
	/* callback related init */
	for (i = 0; i < USB_HOST_CALLBACK_N; i++) {
   10d08:	2300      	movs	r3, #0
   10d0a:	62fb      	str	r3, [r7, #44]	; 0x2c
   10d0c:	e009      	b.n	10d22 <usb_init+0x1f2>
		module_inst->host_callback[i] = NULL;
   10d0e:	68fa      	ldr	r2, [r7, #12]
   10d10:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10d12:	009b      	lsls	r3, r3, #2
   10d14:	18d3      	adds	r3, r2, r3
   10d16:	3304      	adds	r3, #4
   10d18:	2200      	movs	r2, #0
   10d1a:	601a      	str	r2, [r3, #0]
	memset((uint8_t *)(&usb_descriptor_table.usb_endpoint_table[0]), 0,
			sizeof(usb_descriptor_table.usb_endpoint_table));

#if !SAMD11
	/* callback related init */
	for (i = 0; i < USB_HOST_CALLBACK_N; i++) {
   10d1c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10d1e:	3301      	adds	r3, #1
   10d20:	62fb      	str	r3, [r7, #44]	; 0x2c
   10d22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10d24:	2b07      	cmp	r3, #7
   10d26:	d9f2      	bls.n	10d0e <usb_init+0x1de>
		module_inst->host_callback[i] = NULL;
	};
	for (i = 0; i < USB_PIPE_NUM; i++) {
   10d28:	2300      	movs	r3, #0
   10d2a:	62fb      	str	r3, [r7, #44]	; 0x2c
   10d2c:	e016      	b.n	10d5c <usb_init+0x22c>
		for (j = 0; j < USB_HOST_PIPE_CALLBACK_N; j++) {
   10d2e:	2300      	movs	r3, #0
   10d30:	62bb      	str	r3, [r7, #40]	; 0x28
   10d32:	e00d      	b.n	10d50 <usb_init+0x220>
			module_inst->host_pipe_callback[i][j] = NULL;
   10d34:	68fa      	ldr	r2, [r7, #12]
   10d36:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10d38:	0099      	lsls	r1, r3, #2
   10d3a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   10d3c:	18cb      	adds	r3, r1, r3
   10d3e:	3308      	adds	r3, #8
   10d40:	009b      	lsls	r3, r3, #2
   10d42:	18d3      	adds	r3, r2, r3
   10d44:	3304      	adds	r3, #4
   10d46:	2200      	movs	r2, #0
   10d48:	601a      	str	r2, [r3, #0]
	/* callback related init */
	for (i = 0; i < USB_HOST_CALLBACK_N; i++) {
		module_inst->host_callback[i] = NULL;
	};
	for (i = 0; i < USB_PIPE_NUM; i++) {
		for (j = 0; j < USB_HOST_PIPE_CALLBACK_N; j++) {
   10d4a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   10d4c:	3301      	adds	r3, #1
   10d4e:	62bb      	str	r3, [r7, #40]	; 0x28
   10d50:	6abb      	ldr	r3, [r7, #40]	; 0x28
   10d52:	2b03      	cmp	r3, #3
   10d54:	d9ee      	bls.n	10d34 <usb_init+0x204>
#if !SAMD11
	/* callback related init */
	for (i = 0; i < USB_HOST_CALLBACK_N; i++) {
		module_inst->host_callback[i] = NULL;
	};
	for (i = 0; i < USB_PIPE_NUM; i++) {
   10d56:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10d58:	3301      	adds	r3, #1
   10d5a:	62fb      	str	r3, [r7, #44]	; 0x2c
   10d5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10d5e:	2b07      	cmp	r3, #7
   10d60:	d9e5      	bls.n	10d2e <usb_init+0x1fe>
		for (j = 0; j < USB_HOST_PIPE_CALLBACK_N; j++) {
			module_inst->host_pipe_callback[i][j] = NULL;
		}
	};
	module_inst->host_registered_callback_mask = 0;
   10d62:	68fb      	ldr	r3, [r7, #12]
   10d64:	22a4      	movs	r2, #164	; 0xa4
   10d66:	2100      	movs	r1, #0
   10d68:	5499      	strb	r1, [r3, r2]
	module_inst->host_enabled_callback_mask = 0;
   10d6a:	68fb      	ldr	r3, [r7, #12]
   10d6c:	22a5      	movs	r2, #165	; 0xa5
   10d6e:	2100      	movs	r1, #0
   10d70:	5499      	strb	r1, [r3, r2]
	for (i = 0; i < USB_PIPE_NUM; i++) {
   10d72:	2300      	movs	r3, #0
   10d74:	62fb      	str	r3, [r7, #44]	; 0x2c
   10d76:	e010      	b.n	10d9a <usb_init+0x26a>
		module_inst->host_pipe_registered_callback_mask[i] = 0;
   10d78:	68fa      	ldr	r2, [r7, #12]
   10d7a:	21a6      	movs	r1, #166	; 0xa6
   10d7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10d7e:	18d3      	adds	r3, r2, r3
   10d80:	185b      	adds	r3, r3, r1
   10d82:	2200      	movs	r2, #0
   10d84:	701a      	strb	r2, [r3, #0]
		module_inst->host_pipe_enabled_callback_mask[i] = 0;
   10d86:	68fa      	ldr	r2, [r7, #12]
   10d88:	21ae      	movs	r1, #174	; 0xae
   10d8a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10d8c:	18d3      	adds	r3, r2, r3
   10d8e:	185b      	adds	r3, r3, r1
   10d90:	2200      	movs	r2, #0
   10d92:	701a      	strb	r2, [r3, #0]
			module_inst->host_pipe_callback[i][j] = NULL;
		}
	};
	module_inst->host_registered_callback_mask = 0;
	module_inst->host_enabled_callback_mask = 0;
	for (i = 0; i < USB_PIPE_NUM; i++) {
   10d94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10d96:	3301      	adds	r3, #1
   10d98:	62fb      	str	r3, [r7, #44]	; 0x2c
   10d9a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10d9c:	2b07      	cmp	r3, #7
   10d9e:	d9eb      	bls.n	10d78 <usb_init+0x248>
		module_inst->host_pipe_enabled_callback_mask[i] = 0;
	}
#endif

	/*  device callback related */
	for (i = 0; i < USB_DEVICE_CALLBACK_N; i++) {
   10da0:	2300      	movs	r3, #0
   10da2:	62fb      	str	r3, [r7, #44]	; 0x2c
   10da4:	e008      	b.n	10db8 <usb_init+0x288>
		module_inst->device_callback[i] = NULL;
   10da6:	68fb      	ldr	r3, [r7, #12]
   10da8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   10daa:	322e      	adds	r2, #46	; 0x2e
   10dac:	0092      	lsls	r2, r2, #2
   10dae:	2100      	movs	r1, #0
   10db0:	50d1      	str	r1, [r2, r3]
		module_inst->host_pipe_enabled_callback_mask[i] = 0;
	}
#endif

	/*  device callback related */
	for (i = 0; i < USB_DEVICE_CALLBACK_N; i++) {
   10db2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10db4:	3301      	adds	r3, #1
   10db6:	62fb      	str	r3, [r7, #44]	; 0x2c
   10db8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10dba:	2b06      	cmp	r3, #6
   10dbc:	d9f3      	bls.n	10da6 <usb_init+0x276>
		module_inst->device_callback[i] = NULL;
	}
	for (i = 0; i < USB_EPT_NUM; i++) {
   10dbe:	2300      	movs	r3, #0
   10dc0:	62fb      	str	r3, [r7, #44]	; 0x2c
   10dc2:	e016      	b.n	10df2 <usb_init+0x2c2>
		for(j = 0; j < USB_DEVICE_EP_CALLBACK_N; j++) {
   10dc4:	2300      	movs	r3, #0
   10dc6:	62bb      	str	r3, [r7, #40]	; 0x28
   10dc8:	e00d      	b.n	10de6 <usb_init+0x2b6>
			module_inst->device_endpoint_callback[i][j] = NULL;
   10dca:	68fa      	ldr	r2, [r7, #12]
   10dcc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10dce:	0099      	lsls	r1, r3, #2
   10dd0:	6abb      	ldr	r3, [r7, #40]	; 0x28
   10dd2:	18cb      	adds	r3, r1, r3
   10dd4:	3334      	adds	r3, #52	; 0x34
   10dd6:	009b      	lsls	r3, r3, #2
   10dd8:	18d3      	adds	r3, r2, r3
   10dda:	3304      	adds	r3, #4
   10ddc:	2200      	movs	r2, #0
   10dde:	601a      	str	r2, [r3, #0]
	/*  device callback related */
	for (i = 0; i < USB_DEVICE_CALLBACK_N; i++) {
		module_inst->device_callback[i] = NULL;
	}
	for (i = 0; i < USB_EPT_NUM; i++) {
		for(j = 0; j < USB_DEVICE_EP_CALLBACK_N; j++) {
   10de0:	6abb      	ldr	r3, [r7, #40]	; 0x28
   10de2:	3301      	adds	r3, #1
   10de4:	62bb      	str	r3, [r7, #40]	; 0x28
   10de6:	6abb      	ldr	r3, [r7, #40]	; 0x28
   10de8:	2b03      	cmp	r3, #3
   10dea:	d9ee      	bls.n	10dca <usb_init+0x29a>

	/*  device callback related */
	for (i = 0; i < USB_DEVICE_CALLBACK_N; i++) {
		module_inst->device_callback[i] = NULL;
	}
	for (i = 0; i < USB_EPT_NUM; i++) {
   10dec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10dee:	3301      	adds	r3, #1
   10df0:	62fb      	str	r3, [r7, #44]	; 0x2c
   10df2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   10df4:	2b07      	cmp	r3, #7
   10df6:	d9e5      	bls.n	10dc4 <usb_init+0x294>
		for(j = 0; j < USB_DEVICE_EP_CALLBACK_N; j++) {
			module_inst->device_endpoint_callback[i][j] = NULL;
		}
	}
	module_inst->device_registered_callback_mask = 0;
   10df8:	68fa      	ldr	r2, [r7, #12]
   10dfa:	23aa      	movs	r3, #170	; 0xaa
   10dfc:	005b      	lsls	r3, r3, #1
   10dfe:	2100      	movs	r1, #0
   10e00:	52d1      	strh	r1, [r2, r3]
	module_inst->device_enabled_callback_mask = 0;
   10e02:	68fa      	ldr	r2, [r7, #12]
   10e04:	23ab      	movs	r3, #171	; 0xab
   10e06:	005b      	lsls	r3, r3, #1
   10e08:	2100      	movs	r1, #0
   10e0a:	52d1      	strh	r1, [r2, r3]
	for (j = 0; j < USB_EPT_NUM; j++) {
   10e0c:	2300      	movs	r3, #0
   10e0e:	62bb      	str	r3, [r7, #40]	; 0x28
   10e10:	e012      	b.n	10e38 <usb_init+0x308>
		module_inst->deivce_endpoint_registered_callback_mask[j] = 0;
   10e12:	68f9      	ldr	r1, [r7, #12]
   10e14:	23ac      	movs	r3, #172	; 0xac
   10e16:	005b      	lsls	r3, r3, #1
   10e18:	6aba      	ldr	r2, [r7, #40]	; 0x28
   10e1a:	188a      	adds	r2, r1, r2
   10e1c:	18d3      	adds	r3, r2, r3
   10e1e:	2200      	movs	r2, #0
   10e20:	701a      	strb	r2, [r3, #0]
		module_inst->device_endpoint_enabled_callback_mask[j] = 0;
   10e22:	68f9      	ldr	r1, [r7, #12]
   10e24:	23b0      	movs	r3, #176	; 0xb0
   10e26:	005b      	lsls	r3, r3, #1
   10e28:	6aba      	ldr	r2, [r7, #40]	; 0x28
   10e2a:	188a      	adds	r2, r1, r2
   10e2c:	18d3      	adds	r3, r2, r3
   10e2e:	2200      	movs	r2, #0
   10e30:	701a      	strb	r2, [r3, #0]
			module_inst->device_endpoint_callback[i][j] = NULL;
		}
	}
	module_inst->device_registered_callback_mask = 0;
	module_inst->device_enabled_callback_mask = 0;
	for (j = 0; j < USB_EPT_NUM; j++) {
   10e32:	6abb      	ldr	r3, [r7, #40]	; 0x28
   10e34:	3301      	adds	r3, #1
   10e36:	62bb      	str	r3, [r7, #40]	; 0x28
   10e38:	6abb      	ldr	r3, [r7, #40]	; 0x28
   10e3a:	2b07      	cmp	r3, #7
   10e3c:	d9e9      	bls.n	10e12 <usb_init+0x2e2>
		module_inst->deivce_endpoint_registered_callback_mask[j] = 0;
		module_inst->device_endpoint_enabled_callback_mask[j] = 0;
	}

	/* Enable interrupts for this USB module */
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_USB);
   10e3e:	2007      	movs	r0, #7
   10e40:	4b11      	ldr	r3, [pc, #68]	; (10e88 <usb_init+0x358>)
   10e42:	4798      	blx	r3

	return STATUS_OK;
   10e44:	2300      	movs	r3, #0
}
   10e46:	0018      	movs	r0, r3
   10e48:	46bd      	mov	sp, r7
   10e4a:	b00c      	add	sp, #48	; 0x30
   10e4c:	bd80      	pop	{r7, pc}
   10e4e:	46c0      	nop			; (mov r8, r8)
   10e50:	2000093c 	.word	0x2000093c
   10e54:	20000924 	.word	0x20000924
   10e58:	0000f11d 	.word	0x0000f11d
   10e5c:	0000f179 	.word	0x0000f179
   10e60:	00011ef1 	.word	0x00011ef1
   10e64:	0000f105 	.word	0x0000f105
   10e68:	00011c05 	.word	0x00011c05
   10e6c:	00011c49 	.word	0x00011c49
   10e70:	41005000 	.word	0x41005000
   10e74:	00806024 	.word	0x00806024
   10e78:	fffff83f 	.word	0xfffff83f
   10e7c:	ffff8fff 	.word	0xffff8fff
   10e80:	2000177c 	.word	0x2000177c
   10e84:	00012823 	.word	0x00012823
   10e88:	0000f1a1 	.word	0x0000f1a1

00010e8c <_extint_get_eic_from_channel>:
 *
 * \return Base address of the associated EIC module.
 */
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
   10e8c:	b580      	push	{r7, lr}
   10e8e:	b084      	sub	sp, #16
   10e90:	af00      	add	r7, sp, #0
   10e92:	0002      	movs	r2, r0
   10e94:	1dfb      	adds	r3, r7, #7
   10e96:	701a      	strb	r2, [r3, #0]
	uint8_t eic_index = (channel / 32);
   10e98:	230f      	movs	r3, #15
   10e9a:	18fb      	adds	r3, r7, r3
   10e9c:	1dfa      	adds	r2, r7, #7
   10e9e:	7812      	ldrb	r2, [r2, #0]
   10ea0:	0952      	lsrs	r2, r2, #5
   10ea2:	701a      	strb	r2, [r3, #0]

	if (eic_index < EIC_INST_NUM) {
   10ea4:	230f      	movs	r3, #15
   10ea6:	18fb      	adds	r3, r7, r3
   10ea8:	781b      	ldrb	r3, [r3, #0]
   10eaa:	2b00      	cmp	r3, #0
   10eac:	d10c      	bne.n	10ec8 <_extint_get_eic_from_channel+0x3c>
		/* Array of available EICs. */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
   10eae:	4b09      	ldr	r3, [pc, #36]	; (10ed4 <_extint_get_eic_from_channel+0x48>)
   10eb0:	60bb      	str	r3, [r7, #8]

		return eics[eic_index];
   10eb2:	230f      	movs	r3, #15
   10eb4:	18fb      	adds	r3, r7, r3
   10eb6:	781b      	ldrb	r3, [r3, #0]
   10eb8:	009b      	lsls	r3, r3, #2
   10eba:	2210      	movs	r2, #16
   10ebc:	4694      	mov	ip, r2
   10ebe:	44bc      	add	ip, r7
   10ec0:	4463      	add	r3, ip
   10ec2:	3b08      	subs	r3, #8
   10ec4:	681b      	ldr	r3, [r3, #0]
   10ec6:	e000      	b.n	10eca <_extint_get_eic_from_channel+0x3e>
	} else {
		Assert(false);
		return NULL;
   10ec8:	2300      	movs	r3, #0
	}
}
   10eca:	0018      	movs	r0, r3
   10ecc:	46bd      	mov	sp, r7
   10ece:	b004      	add	sp, #16
   10ed0:	bd80      	pop	{r7, pc}
   10ed2:	46c0      	nop			; (mov r8, r8)
   10ed4:	40001800 	.word	0x40001800

00010ed8 <extint_chan_is_detected>:
 *  \retval true   If the channel's edge/level detection criteria was met
 *  \retval false  If the channel has not detected its configured criteria
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
   10ed8:	b580      	push	{r7, lr}
   10eda:	b084      	sub	sp, #16
   10edc:	af00      	add	r7, sp, #0
   10ede:	0002      	movs	r2, r0
   10ee0:	1dfb      	adds	r3, r7, #7
   10ee2:	701a      	strb	r2, [r3, #0]
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
   10ee4:	1dfb      	adds	r3, r7, #7
   10ee6:	781b      	ldrb	r3, [r3, #0]
   10ee8:	0018      	movs	r0, r3
   10eea:	4b0b      	ldr	r3, [pc, #44]	; (10f18 <extint_chan_is_detected+0x40>)
   10eec:	4798      	blx	r3
   10eee:	0003      	movs	r3, r0
   10ef0:	60fb      	str	r3, [r7, #12]
	uint32_t eic_mask   = (1UL << (channel % 32));
   10ef2:	1dfb      	adds	r3, r7, #7
   10ef4:	781b      	ldrb	r3, [r3, #0]
   10ef6:	221f      	movs	r2, #31
   10ef8:	4013      	ands	r3, r2
   10efa:	2201      	movs	r2, #1
   10efc:	409a      	lsls	r2, r3
   10efe:	0013      	movs	r3, r2
   10f00:	60bb      	str	r3, [r7, #8]

	return (eic_module->INTFLAG.reg & eic_mask);
   10f02:	68fb      	ldr	r3, [r7, #12]
   10f04:	691b      	ldr	r3, [r3, #16]
   10f06:	68ba      	ldr	r2, [r7, #8]
   10f08:	4013      	ands	r3, r2
   10f0a:	1e5a      	subs	r2, r3, #1
   10f0c:	4193      	sbcs	r3, r2
   10f0e:	b2db      	uxtb	r3, r3
}
   10f10:	0018      	movs	r0, r3
   10f12:	46bd      	mov	sp, r7
   10f14:	b004      	add	sp, #16
   10f16:	bd80      	pop	{r7, pc}
   10f18:	00010e8d 	.word	0x00010e8d

00010f1c <extint_chan_clear_detected>:
 *
 *  \param[in] channel  External Interrupt channel index to check
 */
static inline void extint_chan_clear_detected(
		const uint8_t channel)
{
   10f1c:	b580      	push	{r7, lr}
   10f1e:	b084      	sub	sp, #16
   10f20:	af00      	add	r7, sp, #0
   10f22:	0002      	movs	r2, r0
   10f24:	1dfb      	adds	r3, r7, #7
   10f26:	701a      	strb	r2, [r3, #0]
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
   10f28:	1dfb      	adds	r3, r7, #7
   10f2a:	781b      	ldrb	r3, [r3, #0]
   10f2c:	0018      	movs	r0, r3
   10f2e:	4b09      	ldr	r3, [pc, #36]	; (10f54 <extint_chan_clear_detected+0x38>)
   10f30:	4798      	blx	r3
   10f32:	0003      	movs	r3, r0
   10f34:	60fb      	str	r3, [r7, #12]
	uint32_t eic_mask   = (1UL << (channel % 32));
   10f36:	1dfb      	adds	r3, r7, #7
   10f38:	781b      	ldrb	r3, [r3, #0]
   10f3a:	221f      	movs	r2, #31
   10f3c:	4013      	ands	r3, r2
   10f3e:	2201      	movs	r2, #1
   10f40:	409a      	lsls	r2, r3
   10f42:	0013      	movs	r3, r2
   10f44:	60bb      	str	r3, [r7, #8]

	eic_module->INTFLAG.reg = eic_mask;
   10f46:	68fb      	ldr	r3, [r7, #12]
   10f48:	68ba      	ldr	r2, [r7, #8]
   10f4a:	611a      	str	r2, [r3, #16]
}
   10f4c:	46c0      	nop			; (mov r8, r8)
   10f4e:	46bd      	mov	sp, r7
   10f50:	b004      	add	sp, #16
   10f52:	bd80      	pop	{r7, pc}
   10f54:	00010e8d 	.word	0x00010e8d

00010f58 <EIC_Handler>:
	return _current_channel;
}

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
   10f58:	b580      	push	{r7, lr}
   10f5a:	af00      	add	r7, sp, #0
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
   10f5c:	4b15      	ldr	r3, [pc, #84]	; (10fb4 <EIC_Handler+0x5c>)
   10f5e:	2200      	movs	r2, #0
   10f60:	701a      	strb	r2, [r3, #0]
   10f62:	e020      	b.n	10fa6 <EIC_Handler+0x4e>
		if (extint_chan_is_detected(_current_channel)) {
   10f64:	4b13      	ldr	r3, [pc, #76]	; (10fb4 <EIC_Handler+0x5c>)
   10f66:	781b      	ldrb	r3, [r3, #0]
   10f68:	0018      	movs	r0, r3
   10f6a:	4b13      	ldr	r3, [pc, #76]	; (10fb8 <EIC_Handler+0x60>)
   10f6c:	4798      	blx	r3
   10f6e:	1e03      	subs	r3, r0, #0
   10f70:	d013      	beq.n	10f9a <EIC_Handler+0x42>
			/* Clear flag */
			extint_chan_clear_detected(_current_channel);
   10f72:	4b10      	ldr	r3, [pc, #64]	; (10fb4 <EIC_Handler+0x5c>)
   10f74:	781b      	ldrb	r3, [r3, #0]
   10f76:	0018      	movs	r0, r3
   10f78:	4b10      	ldr	r3, [pc, #64]	; (10fbc <EIC_Handler+0x64>)
   10f7a:	4798      	blx	r3
			/* Find any associated callback entries in the callback table */
			if (_extint_dev.callbacks[_current_channel] != NULL) {
   10f7c:	4b0d      	ldr	r3, [pc, #52]	; (10fb4 <EIC_Handler+0x5c>)
   10f7e:	781b      	ldrb	r3, [r3, #0]
   10f80:	001a      	movs	r2, r3
   10f82:	4b0f      	ldr	r3, [pc, #60]	; (10fc0 <EIC_Handler+0x68>)
   10f84:	0092      	lsls	r2, r2, #2
   10f86:	58d3      	ldr	r3, [r2, r3]
   10f88:	2b00      	cmp	r3, #0
   10f8a:	d006      	beq.n	10f9a <EIC_Handler+0x42>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
   10f8c:	4b09      	ldr	r3, [pc, #36]	; (10fb4 <EIC_Handler+0x5c>)
   10f8e:	781b      	ldrb	r3, [r3, #0]
   10f90:	001a      	movs	r2, r3
   10f92:	4b0b      	ldr	r3, [pc, #44]	; (10fc0 <EIC_Handler+0x68>)
   10f94:	0092      	lsls	r2, r2, #2
   10f96:	58d3      	ldr	r3, [r2, r3]
   10f98:	4798      	blx	r3

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
   10f9a:	4b06      	ldr	r3, [pc, #24]	; (10fb4 <EIC_Handler+0x5c>)
   10f9c:	781b      	ldrb	r3, [r3, #0]
   10f9e:	3301      	adds	r3, #1
   10fa0:	b2da      	uxtb	r2, r3
   10fa2:	4b04      	ldr	r3, [pc, #16]	; (10fb4 <EIC_Handler+0x5c>)
   10fa4:	701a      	strb	r2, [r3, #0]
   10fa6:	4b03      	ldr	r3, [pc, #12]	; (10fb4 <EIC_Handler+0x5c>)
   10fa8:	781b      	ldrb	r3, [r3, #0]
   10faa:	2b0f      	cmp	r3, #15
   10fac:	d9da      	bls.n	10f64 <EIC_Handler+0xc>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
			}
		}
	}
}
   10fae:	46c0      	nop			; (mov r8, r8)
   10fb0:	46bd      	mov	sp, r7
   10fb2:	bd80      	pop	{r7, pc}
   10fb4:	2000187c 	.word	0x2000187c
   10fb8:	00010ed9 	.word	0x00010ed9
   10fbc:	00010f1d 	.word	0x00010f1d
   10fc0:	20001214 	.word	0x20001214

00010fc4 <cpu_irq_enter_critical>:
 */
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
   10fc4:	b580      	push	{r7, lr}
   10fc6:	b082      	sub	sp, #8
   10fc8:	af00      	add	r7, sp, #0
	if (cpu_irq_critical_section_counter == 0) {
   10fca:	4b10      	ldr	r3, [pc, #64]	; (1100c <cpu_irq_enter_critical+0x48>)
   10fcc:	681b      	ldr	r3, [r3, #0]
   10fce:	2b00      	cmp	r3, #0
   10fd0:	d112      	bne.n	10ff8 <cpu_irq_enter_critical+0x34>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   10fd2:	f3ef 8310 	mrs	r3, PRIMASK
   10fd6:	607b      	str	r3, [r7, #4]
  return(result);
   10fd8:	687b      	ldr	r3, [r7, #4]
		if (cpu_irq_is_enabled()) {
   10fda:	2b00      	cmp	r3, #0
   10fdc:	d109      	bne.n	10ff2 <cpu_irq_enter_critical+0x2e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   10fde:	b672      	cpsid	i
   10fe0:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
   10fe4:	4b0a      	ldr	r3, [pc, #40]	; (11010 <cpu_irq_enter_critical+0x4c>)
   10fe6:	2200      	movs	r2, #0
   10fe8:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
   10fea:	4b0a      	ldr	r3, [pc, #40]	; (11014 <cpu_irq_enter_critical+0x50>)
   10fec:	2201      	movs	r2, #1
   10fee:	701a      	strb	r2, [r3, #0]
   10ff0:	e002      	b.n	10ff8 <cpu_irq_enter_critical+0x34>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
   10ff2:	4b08      	ldr	r3, [pc, #32]	; (11014 <cpu_irq_enter_critical+0x50>)
   10ff4:	2200      	movs	r2, #0
   10ff6:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
   10ff8:	4b04      	ldr	r3, [pc, #16]	; (1100c <cpu_irq_enter_critical+0x48>)
   10ffa:	681b      	ldr	r3, [r3, #0]
   10ffc:	1c5a      	adds	r2, r3, #1
   10ffe:	4b03      	ldr	r3, [pc, #12]	; (1100c <cpu_irq_enter_critical+0x48>)
   11000:	601a      	str	r2, [r3, #0]
}
   11002:	46c0      	nop			; (mov r8, r8)
   11004:	46bd      	mov	sp, r7
   11006:	b002      	add	sp, #8
   11008:	bd80      	pop	{r7, pc}
   1100a:	46c0      	nop			; (mov r8, r8)
   1100c:	20000940 	.word	0x20000940
   11010:	2000017c 	.word	0x2000017c
   11014:	20000944 	.word	0x20000944

00011018 <cpu_irq_leave_critical>:

void cpu_irq_leave_critical(void)
{
   11018:	b580      	push	{r7, lr}
   1101a:	af00      	add	r7, sp, #0
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
   1101c:	4b0b      	ldr	r3, [pc, #44]	; (1104c <cpu_irq_leave_critical+0x34>)
   1101e:	681b      	ldr	r3, [r3, #0]
   11020:	1e5a      	subs	r2, r3, #1
   11022:	4b0a      	ldr	r3, [pc, #40]	; (1104c <cpu_irq_leave_critical+0x34>)
   11024:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
   11026:	4b09      	ldr	r3, [pc, #36]	; (1104c <cpu_irq_leave_critical+0x34>)
   11028:	681b      	ldr	r3, [r3, #0]
   1102a:	2b00      	cmp	r3, #0
   1102c:	d10a      	bne.n	11044 <cpu_irq_leave_critical+0x2c>
   1102e:	4b08      	ldr	r3, [pc, #32]	; (11050 <cpu_irq_leave_critical+0x38>)
   11030:	781b      	ldrb	r3, [r3, #0]
   11032:	b2db      	uxtb	r3, r3
   11034:	2b00      	cmp	r3, #0
   11036:	d005      	beq.n	11044 <cpu_irq_leave_critical+0x2c>
		cpu_irq_enable();
   11038:	4b06      	ldr	r3, [pc, #24]	; (11054 <cpu_irq_leave_critical+0x3c>)
   1103a:	2201      	movs	r2, #1
   1103c:	701a      	strb	r2, [r3, #0]
   1103e:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   11042:	b662      	cpsie	i
	}
}
   11044:	46c0      	nop			; (mov r8, r8)
   11046:	46bd      	mov	sp, r7
   11048:	bd80      	pop	{r7, pc}
   1104a:	46c0      	nop			; (mov r8, r8)
   1104c:	20000940 	.word	0x20000940
   11050:	20000944 	.word	0x20000944
   11054:	2000017c 	.word	0x2000017c

00011058 <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
   11058:	b580      	push	{r7, lr}
   1105a:	b084      	sub	sp, #16
   1105c:	af00      	add	r7, sp, #0
   1105e:	0002      	movs	r2, r0
   11060:	1dfb      	adds	r3, r7, #7
   11062:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
   11064:	230f      	movs	r3, #15
   11066:	18fb      	adds	r3, r7, r3
   11068:	1dfa      	adds	r2, r7, #7
   1106a:	7812      	ldrb	r2, [r2, #0]
   1106c:	09d2      	lsrs	r2, r2, #7
   1106e:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
   11070:	230e      	movs	r3, #14
   11072:	18fb      	adds	r3, r7, r3
   11074:	1dfa      	adds	r2, r7, #7
   11076:	7812      	ldrb	r2, [r2, #0]
   11078:	0952      	lsrs	r2, r2, #5
   1107a:	701a      	strb	r2, [r3, #0]

	/* Array of available ports. */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
   1107c:	4b0d      	ldr	r3, [pc, #52]	; (110b4 <system_pinmux_get_group_from_gpio_pin+0x5c>)
   1107e:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
   11080:	230f      	movs	r3, #15
   11082:	18fb      	adds	r3, r7, r3
   11084:	781b      	ldrb	r3, [r3, #0]
   11086:	2b00      	cmp	r3, #0
   11088:	d10f      	bne.n	110aa <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
   1108a:	230f      	movs	r3, #15
   1108c:	18fb      	adds	r3, r7, r3
   1108e:	781b      	ldrb	r3, [r3, #0]
   11090:	009b      	lsls	r3, r3, #2
   11092:	2210      	movs	r2, #16
   11094:	4694      	mov	ip, r2
   11096:	44bc      	add	ip, r7
   11098:	4463      	add	r3, ip
   1109a:	3b08      	subs	r3, #8
   1109c:	681a      	ldr	r2, [r3, #0]
   1109e:	230e      	movs	r3, #14
   110a0:	18fb      	adds	r3, r7, r3
   110a2:	781b      	ldrb	r3, [r3, #0]
   110a4:	01db      	lsls	r3, r3, #7
   110a6:	18d3      	adds	r3, r2, r3
   110a8:	e000      	b.n	110ac <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
   110aa:	2300      	movs	r3, #0
	}
}
   110ac:	0018      	movs	r0, r3
   110ae:	46bd      	mov	sp, r7
   110b0:	b004      	add	sp, #16
   110b2:	bd80      	pop	{r7, pc}
   110b4:	41004400 	.word	0x41004400

000110b8 <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
   110b8:	b580      	push	{r7, lr}
   110ba:	b082      	sub	sp, #8
   110bc:	af00      	add	r7, sp, #0
   110be:	0002      	movs	r2, r0
   110c0:	1dfb      	adds	r3, r7, #7
   110c2:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
   110c4:	1dfb      	adds	r3, r7, #7
   110c6:	781b      	ldrb	r3, [r3, #0]
   110c8:	0018      	movs	r0, r3
   110ca:	4b03      	ldr	r3, [pc, #12]	; (110d8 <port_get_group_from_gpio_pin+0x20>)
   110cc:	4798      	blx	r3
   110ce:	0003      	movs	r3, r0
}
   110d0:	0018      	movs	r0, r3
   110d2:	46bd      	mov	sp, r7
   110d4:	b002      	add	sp, #8
   110d6:	bd80      	pop	{r7, pc}
   110d8:	00011059 	.word	0x00011059

000110dc <port_get_config_defaults>:
 *
 *  \param[out] config  Configuration structure to initialize to default values
 */
static inline void port_get_config_defaults(
		struct port_config *const config)
{
   110dc:	b580      	push	{r7, lr}
   110de:	b082      	sub	sp, #8
   110e0:	af00      	add	r7, sp, #0
   110e2:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
   110e4:	687b      	ldr	r3, [r7, #4]
   110e6:	2200      	movs	r2, #0
   110e8:	701a      	strb	r2, [r3, #0]
	config->input_pull = PORT_PIN_PULL_UP;
   110ea:	687b      	ldr	r3, [r7, #4]
   110ec:	2201      	movs	r2, #1
   110ee:	705a      	strb	r2, [r3, #1]
	config->powersave  = false;
   110f0:	687b      	ldr	r3, [r7, #4]
   110f2:	2200      	movs	r2, #0
   110f4:	709a      	strb	r2, [r3, #2]
}
   110f6:	46c0      	nop			; (mov r8, r8)
   110f8:	46bd      	mov	sp, r7
   110fa:	b002      	add	sp, #8
   110fc:	bd80      	pop	{r7, pc}
   110fe:	46c0      	nop			; (mov r8, r8)

00011100 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
   11100:	b580      	push	{r7, lr}
   11102:	b084      	sub	sp, #16
   11104:	af00      	add	r7, sp, #0
   11106:	0002      	movs	r2, r0
   11108:	1dfb      	adds	r3, r7, #7
   1110a:	701a      	strb	r2, [r3, #0]
   1110c:	1dbb      	adds	r3, r7, #6
   1110e:	1c0a      	adds	r2, r1, #0
   11110:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
   11112:	1dfb      	adds	r3, r7, #7
   11114:	781b      	ldrb	r3, [r3, #0]
   11116:	0018      	movs	r0, r3
   11118:	4b0d      	ldr	r3, [pc, #52]	; (11150 <port_pin_set_output_level+0x50>)
   1111a:	4798      	blx	r3
   1111c:	0003      	movs	r3, r0
   1111e:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
   11120:	1dfb      	adds	r3, r7, #7
   11122:	781b      	ldrb	r3, [r3, #0]
   11124:	221f      	movs	r2, #31
   11126:	4013      	ands	r3, r2
   11128:	2201      	movs	r2, #1
   1112a:	409a      	lsls	r2, r3
   1112c:	0013      	movs	r3, r2
   1112e:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
   11130:	1dbb      	adds	r3, r7, #6
   11132:	781b      	ldrb	r3, [r3, #0]
   11134:	2b00      	cmp	r3, #0
   11136:	d003      	beq.n	11140 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
   11138:	68fb      	ldr	r3, [r7, #12]
   1113a:	68ba      	ldr	r2, [r7, #8]
   1113c:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
   1113e:	e002      	b.n	11146 <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
   11140:	68fb      	ldr	r3, [r7, #12]
   11142:	68ba      	ldr	r2, [r7, #8]
   11144:	615a      	str	r2, [r3, #20]
	}
}
   11146:	46c0      	nop			; (mov r8, r8)
   11148:	46bd      	mov	sp, r7
   1114a:	b004      	add	sp, #16
   1114c:	bd80      	pop	{r7, pc}
   1114e:	46c0      	nop			; (mov r8, r8)
   11150:	000110b9 	.word	0x000110b9

00011154 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
   11154:	b580      	push	{r7, lr}
   11156:	b082      	sub	sp, #8
   11158:	af00      	add	r7, sp, #0
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);
   1115a:	1d3b      	adds	r3, r7, #4
   1115c:	0018      	movs	r0, r3
   1115e:	4b0e      	ldr	r3, [pc, #56]	; (11198 <system_board_init+0x44>)
   11160:	4798      	blx	r3

	/* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
   11162:	1d3b      	adds	r3, r7, #4
   11164:	2201      	movs	r2, #1
   11166:	701a      	strb	r2, [r3, #0]
	port_pin_set_config(LED_0_PIN, &pin_conf);
   11168:	1d3b      	adds	r3, r7, #4
   1116a:	0019      	movs	r1, r3
   1116c:	203e      	movs	r0, #62	; 0x3e
   1116e:	4b0b      	ldr	r3, [pc, #44]	; (1119c <system_board_init+0x48>)
   11170:	4798      	blx	r3
	port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);
   11172:	2101      	movs	r1, #1
   11174:	203e      	movs	r0, #62	; 0x3e
   11176:	4b0a      	ldr	r3, [pc, #40]	; (111a0 <system_board_init+0x4c>)
   11178:	4798      	blx	r3

	/* Set buttons as inputs */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
   1117a:	1d3b      	adds	r3, r7, #4
   1117c:	2200      	movs	r2, #0
   1117e:	701a      	strb	r2, [r3, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
   11180:	1d3b      	adds	r3, r7, #4
   11182:	2201      	movs	r2, #1
   11184:	705a      	strb	r2, [r3, #1]
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
   11186:	1d3b      	adds	r3, r7, #4
   11188:	0019      	movs	r1, r3
   1118a:	200f      	movs	r0, #15
   1118c:	4b03      	ldr	r3, [pc, #12]	; (1119c <system_board_init+0x48>)
   1118e:	4798      	blx	r3
	port_pin_set_output_level(AT86RFX_RST_PIN, true);
	port_pin_set_output_level(AT86RFX_SLP_PIN, true);
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
	port_pin_set_config(AT86RFX_SPI_MISO, &pin_conf);
#endif	
}
   11190:	46c0      	nop			; (mov r8, r8)
   11192:	46bd      	mov	sp, r7
   11194:	b002      	add	sp, #8
   11196:	bd80      	pop	{r7, pc}
   11198:	000110dd 	.word	0x000110dd
   1119c:	000111cd 	.word	0x000111cd
   111a0:	00011101 	.word	0x00011101

000111a4 <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
   111a4:	b580      	push	{r7, lr}
   111a6:	b082      	sub	sp, #8
   111a8:	af00      	add	r7, sp, #0
   111aa:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
   111ac:	687b      	ldr	r3, [r7, #4]
   111ae:	2280      	movs	r2, #128	; 0x80
   111b0:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
   111b2:	687b      	ldr	r3, [r7, #4]
   111b4:	2200      	movs	r2, #0
   111b6:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
   111b8:	687b      	ldr	r3, [r7, #4]
   111ba:	2201      	movs	r2, #1
   111bc:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
   111be:	687b      	ldr	r3, [r7, #4]
   111c0:	2200      	movs	r2, #0
   111c2:	70da      	strb	r2, [r3, #3]
}
   111c4:	46c0      	nop			; (mov r8, r8)
   111c6:	46bd      	mov	sp, r7
   111c8:	b002      	add	sp, #8
   111ca:	bd80      	pop	{r7, pc}

000111cc <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
   111cc:	b580      	push	{r7, lr}
   111ce:	b084      	sub	sp, #16
   111d0:	af00      	add	r7, sp, #0
   111d2:	0002      	movs	r2, r0
   111d4:	6039      	str	r1, [r7, #0]
   111d6:	1dfb      	adds	r3, r7, #7
   111d8:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);
   111da:	230c      	movs	r3, #12
   111dc:	18fb      	adds	r3, r7, r3
   111de:	0018      	movs	r0, r3
   111e0:	4b10      	ldr	r3, [pc, #64]	; (11224 <port_pin_set_config+0x58>)
   111e2:	4798      	blx	r3

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
   111e4:	230c      	movs	r3, #12
   111e6:	18fb      	adds	r3, r7, r3
   111e8:	2280      	movs	r2, #128	; 0x80
   111ea:	701a      	strb	r2, [r3, #0]
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
   111ec:	683b      	ldr	r3, [r7, #0]
   111ee:	781a      	ldrb	r2, [r3, #0]
   111f0:	230c      	movs	r3, #12
   111f2:	18fb      	adds	r3, r7, r3
   111f4:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
   111f6:	683b      	ldr	r3, [r7, #0]
   111f8:	785a      	ldrb	r2, [r3, #1]
   111fa:	230c      	movs	r3, #12
   111fc:	18fb      	adds	r3, r7, r3
   111fe:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
   11200:	683b      	ldr	r3, [r7, #0]
   11202:	789a      	ldrb	r2, [r3, #2]
   11204:	230c      	movs	r3, #12
   11206:	18fb      	adds	r3, r7, r3
   11208:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
   1120a:	230c      	movs	r3, #12
   1120c:	18fa      	adds	r2, r7, r3
   1120e:	1dfb      	adds	r3, r7, #7
   11210:	781b      	ldrb	r3, [r3, #0]
   11212:	0011      	movs	r1, r2
   11214:	0018      	movs	r0, r3
   11216:	4b04      	ldr	r3, [pc, #16]	; (11228 <port_pin_set_config+0x5c>)
   11218:	4798      	blx	r3
}
   1121a:	46c0      	nop			; (mov r8, r8)
   1121c:	46bd      	mov	sp, r7
   1121e:	b004      	add	sp, #16
   11220:	bd80      	pop	{r7, pc}
   11222:	46c0      	nop			; (mov r8, r8)
   11224:	000111a5 	.word	0x000111a5
   11228:	00011ef1 	.word	0x00011ef1

0001122c <system_gclk_gen_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_gen_get_config_defaults(
		struct system_gclk_gen_config *const config)
{
   1122c:	b580      	push	{r7, lr}
   1122e:	b082      	sub	sp, #8
   11230:	af00      	add	r7, sp, #0
   11232:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
   11234:	687b      	ldr	r3, [r7, #4]
   11236:	2201      	movs	r2, #1
   11238:	605a      	str	r2, [r3, #4]
	config->high_when_disabled = false;
   1123a:	687b      	ldr	r3, [r7, #4]
   1123c:	2200      	movs	r2, #0
   1123e:	705a      	strb	r2, [r3, #1]
#if SAML21
	config->source_clock       = GCLK_SOURCE_OSC16M;
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
   11240:	687b      	ldr	r3, [r7, #4]
   11242:	2206      	movs	r2, #6
   11244:	701a      	strb	r2, [r3, #0]
#endif
	config->run_in_standby     = false;
   11246:	687b      	ldr	r3, [r7, #4]
   11248:	2200      	movs	r2, #0
   1124a:	721a      	strb	r2, [r3, #8]
	config->output_enable      = false;
   1124c:	687b      	ldr	r3, [r7, #4]
   1124e:	2200      	movs	r2, #0
   11250:	725a      	strb	r2, [r3, #9]
}
   11252:	46c0      	nop			; (mov r8, r8)
   11254:	46bd      	mov	sp, r7
   11256:	b002      	add	sp, #8
   11258:	bd80      	pop	{r7, pc}
   1125a:	46c0      	nop			; (mov r8, r8)

0001125c <system_clock_source_osc8m_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to fill with default values
 */
static inline void system_clock_source_osc8m_get_config_defaults(
		struct system_clock_source_osc8m_config *const config)
{
   1125c:	b580      	push	{r7, lr}
   1125e:	b082      	sub	sp, #8
   11260:	af00      	add	r7, sp, #0
   11262:	6078      	str	r0, [r7, #4]
	Assert(config);

	config->prescaler       = SYSTEM_OSC8M_DIV_8;
   11264:	687b      	ldr	r3, [r7, #4]
   11266:	2203      	movs	r2, #3
   11268:	701a      	strb	r2, [r3, #0]
	config->run_in_standby  = false;
   1126a:	687b      	ldr	r3, [r7, #4]
   1126c:	2200      	movs	r2, #0
   1126e:	705a      	strb	r2, [r3, #1]
	config->on_demand       = true;
   11270:	687b      	ldr	r3, [r7, #4]
   11272:	2201      	movs	r2, #1
   11274:	709a      	strb	r2, [r3, #2]
}
   11276:	46c0      	nop			; (mov r8, r8)
   11278:	46bd      	mov	sp, r7
   1127a:	b002      	add	sp, #8
   1127c:	bd80      	pop	{r7, pc}
   1127e:	46c0      	nop			; (mov r8, r8)

00011280 <system_clock_source_dfll_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to fill with default values
 */
static inline void system_clock_source_dfll_get_config_defaults(
		struct system_clock_source_dfll_config *const config)
{
   11280:	b580      	push	{r7, lr}
   11282:	b082      	sub	sp, #8
   11284:	af00      	add	r7, sp, #0
   11286:	6078      	str	r0, [r7, #4]
	Assert(config);

	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
   11288:	687b      	ldr	r3, [r7, #4]
   1128a:	2200      	movs	r2, #0
   1128c:	701a      	strb	r2, [r3, #0]
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
   1128e:	687b      	ldr	r3, [r7, #4]
   11290:	2200      	movs	r2, #0
   11292:	805a      	strh	r2, [r3, #2]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
   11294:	687b      	ldr	r3, [r7, #4]
   11296:	2200      	movs	r2, #0
   11298:	809a      	strh	r2, [r3, #4]
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
   1129a:	687b      	ldr	r3, [r7, #4]
   1129c:	2200      	movs	r2, #0
   1129e:	719a      	strb	r2, [r3, #6]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
   112a0:	687b      	ldr	r3, [r7, #4]
   112a2:	2200      	movs	r2, #0
   112a4:	71da      	strb	r2, [r3, #7]
	config->on_demand       = true;
   112a6:	687b      	ldr	r3, [r7, #4]
   112a8:	2201      	movs	r2, #1
   112aa:	705a      	strb	r2, [r3, #1]

	/* Open loop mode calibration value */
	config->coarse_value    = 0x1f / 4; /* Midpoint */
   112ac:	687b      	ldr	r3, [r7, #4]
   112ae:	2207      	movs	r2, #7
   112b0:	721a      	strb	r2, [r3, #8]
	config->fine_value      = 0xff / 4; /* Midpoint */
   112b2:	687b      	ldr	r3, [r7, #4]
   112b4:	223f      	movs	r2, #63	; 0x3f
   112b6:	815a      	strh	r2, [r3, #10]

	/* Closed loop mode */
	config->coarse_max_step = 1;
   112b8:	687b      	ldr	r3, [r7, #4]
   112ba:	2201      	movs	r2, #1
   112bc:	731a      	strb	r2, [r3, #12]
	config->fine_max_step   = 1;
   112be:	687b      	ldr	r3, [r7, #4]
   112c0:	2201      	movs	r2, #1
   112c2:	81da      	strh	r2, [r3, #14]
	config->multiply_factor = 6; /* Multiply 8MHz by 6 to get 48MHz */
   112c4:	687b      	ldr	r3, [r7, #4]
   112c6:	2206      	movs	r2, #6
   112c8:	821a      	strh	r2, [r3, #16]
}
   112ca:	46c0      	nop			; (mov r8, r8)
   112cc:	46bd      	mov	sp, r7
   112ce:	b002      	add	sp, #8
   112d0:	bd80      	pop	{r7, pc}
   112d2:	46c0      	nop			; (mov r8, r8)

000112d4 <system_cpu_clock_set_divider>:
 *
 * \param[in] divider  CPU clock divider to set
 */
static inline void system_cpu_clock_set_divider(
		const enum system_main_clock_div divider)
{
   112d4:	b580      	push	{r7, lr}
   112d6:	b082      	sub	sp, #8
   112d8:	af00      	add	r7, sp, #0
   112da:	0002      	movs	r2, r0
   112dc:	1dfb      	adds	r3, r7, #7
   112de:	701a      	strb	r2, [r3, #0]
	Assert(((uint32_t)divider & PM_CPUSEL_CPUDIV_Msk) == divider);
	PM->CPUSEL.reg = (uint32_t)divider;
   112e0:	4a03      	ldr	r2, [pc, #12]	; (112f0 <system_cpu_clock_set_divider+0x1c>)
   112e2:	1dfb      	adds	r3, r7, #7
   112e4:	781b      	ldrb	r3, [r3, #0]
   112e6:	7213      	strb	r3, [r2, #8]
}
   112e8:	46c0      	nop			; (mov r8, r8)
   112ea:	46bd      	mov	sp, r7
   112ec:	b002      	add	sp, #8
   112ee:	bd80      	pop	{r7, pc}
   112f0:	40000400 	.word	0x40000400

000112f4 <system_apb_clock_set_divider>:
 * \retval STATUS_OK               The APBx clock was set successfully
 */
static inline enum status_code system_apb_clock_set_divider(
		const enum system_clock_apb_bus bus,
		const enum system_main_clock_div divider)
{
   112f4:	b580      	push	{r7, lr}
   112f6:	b082      	sub	sp, #8
   112f8:	af00      	add	r7, sp, #0
   112fa:	0002      	movs	r2, r0
   112fc:	1dfb      	adds	r3, r7, #7
   112fe:	701a      	strb	r2, [r3, #0]
   11300:	1dbb      	adds	r3, r7, #6
   11302:	1c0a      	adds	r2, r1, #0
   11304:	701a      	strb	r2, [r3, #0]
	switch (bus) {
   11306:	1dfb      	adds	r3, r7, #7
   11308:	781b      	ldrb	r3, [r3, #0]
   1130a:	2b01      	cmp	r3, #1
   1130c:	d008      	beq.n	11320 <system_apb_clock_set_divider+0x2c>
   1130e:	2b02      	cmp	r3, #2
   11310:	d00b      	beq.n	1132a <system_apb_clock_set_divider+0x36>
   11312:	2b00      	cmp	r3, #0
   11314:	d10e      	bne.n	11334 <system_apb_clock_set_divider+0x40>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBASEL.reg = (uint32_t)divider;
   11316:	4a0b      	ldr	r2, [pc, #44]	; (11344 <system_apb_clock_set_divider+0x50>)
   11318:	1dbb      	adds	r3, r7, #6
   1131a:	781b      	ldrb	r3, [r3, #0]
   1131c:	7253      	strb	r3, [r2, #9]
			break;
   1131e:	e00b      	b.n	11338 <system_apb_clock_set_divider+0x44>
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBSEL.reg = (uint32_t)divider;
   11320:	4a08      	ldr	r2, [pc, #32]	; (11344 <system_apb_clock_set_divider+0x50>)
   11322:	1dbb      	adds	r3, r7, #6
   11324:	781b      	ldrb	r3, [r3, #0]
   11326:	7293      	strb	r3, [r2, #10]
			break;
   11328:	e006      	b.n	11338 <system_apb_clock_set_divider+0x44>
		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCSEL.reg = (uint32_t)divider;
   1132a:	4a06      	ldr	r2, [pc, #24]	; (11344 <system_apb_clock_set_divider+0x50>)
   1132c:	1dbb      	adds	r3, r7, #6
   1132e:	781b      	ldrb	r3, [r3, #0]
   11330:	72d3      	strb	r3, [r2, #11]
			break;
   11332:	e001      	b.n	11338 <system_apb_clock_set_divider+0x44>
		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
   11334:	2317      	movs	r3, #23
   11336:	e000      	b.n	1133a <system_apb_clock_set_divider+0x46>
	}

	return STATUS_OK;
   11338:	2300      	movs	r3, #0
}
   1133a:	0018      	movs	r0, r3
   1133c:	46bd      	mov	sp, r7
   1133e:	b002      	add	sp, #8
   11340:	bd80      	pop	{r7, pc}
   11342:	46c0      	nop			; (mov r8, r8)
   11344:	40000400 	.word	0x40000400

00011348 <system_flash_set_waitstates>:
 * can be found in the electrical characteristics of the device.
 *
 * \param[in] wait_states Number of wait states to use for internal flash
 */
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
   11348:	b580      	push	{r7, lr}
   1134a:	b082      	sub	sp, #8
   1134c:	af00      	add	r7, sp, #0
   1134e:	0002      	movs	r2, r0
   11350:	1dfb      	adds	r3, r7, #7
   11352:	701a      	strb	r2, [r3, #0]
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
   11354:	4a08      	ldr	r2, [pc, #32]	; (11378 <system_flash_set_waitstates+0x30>)
   11356:	1dfb      	adds	r3, r7, #7
   11358:	781b      	ldrb	r3, [r3, #0]
   1135a:	210f      	movs	r1, #15
   1135c:	400b      	ands	r3, r1
   1135e:	b2d9      	uxtb	r1, r3
   11360:	6853      	ldr	r3, [r2, #4]
   11362:	200f      	movs	r0, #15
   11364:	4001      	ands	r1, r0
   11366:	0049      	lsls	r1, r1, #1
   11368:	201e      	movs	r0, #30
   1136a:	4383      	bics	r3, r0
   1136c:	430b      	orrs	r3, r1
   1136e:	6053      	str	r3, [r2, #4]
}
   11370:	46c0      	nop			; (mov r8, r8)
   11372:	46bd      	mov	sp, r7
   11374:	b002      	add	sp, #8
   11376:	bd80      	pop	{r7, pc}
   11378:	41004000 	.word	0x41004000

0001137c <_system_dfll_wait_for_sync>:
/**
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
   1137c:	b580      	push	{r7, lr}
   1137e:	af00      	add	r7, sp, #0
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
   11380:	46c0      	nop			; (mov r8, r8)
   11382:	4b04      	ldr	r3, [pc, #16]	; (11394 <_system_dfll_wait_for_sync+0x18>)
   11384:	68db      	ldr	r3, [r3, #12]
   11386:	2210      	movs	r2, #16
   11388:	4013      	ands	r3, r2
   1138a:	d0fa      	beq.n	11382 <_system_dfll_wait_for_sync+0x6>
		/* Wait for DFLL sync */
	}
}
   1138c:	46c0      	nop			; (mov r8, r8)
   1138e:	46bd      	mov	sp, r7
   11390:	bd80      	pop	{r7, pc}
   11392:	46c0      	nop			; (mov r8, r8)
   11394:	40000800 	.word	0x40000800

00011398 <_system_clock_source_dfll_set_config_errata_9905>:
		/* Wait for OSC32K sync */
	}
}

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{
   11398:	b580      	push	{r7, lr}
   1139a:	af00      	add	r7, sp, #0

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control & ~SYSCTRL_DFLLCTRL_ONDEMAND;
   1139c:	4a0c      	ldr	r2, [pc, #48]	; (113d0 <_system_clock_source_dfll_set_config_errata_9905+0x38>)
   1139e:	4b0d      	ldr	r3, [pc, #52]	; (113d4 <_system_clock_source_dfll_set_config_errata_9905+0x3c>)
   113a0:	681b      	ldr	r3, [r3, #0]
   113a2:	b29b      	uxth	r3, r3
   113a4:	2180      	movs	r1, #128	; 0x80
   113a6:	438b      	bics	r3, r1
   113a8:	b29b      	uxth	r3, r3
   113aa:	8493      	strh	r3, [r2, #36]	; 0x24
	_system_dfll_wait_for_sync();
   113ac:	4b0a      	ldr	r3, [pc, #40]	; (113d8 <_system_clock_source_dfll_set_config_errata_9905+0x40>)
   113ae:	4798      	blx	r3

	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
   113b0:	4a07      	ldr	r2, [pc, #28]	; (113d0 <_system_clock_source_dfll_set_config_errata_9905+0x38>)
   113b2:	4b08      	ldr	r3, [pc, #32]	; (113d4 <_system_clock_source_dfll_set_config_errata_9905+0x3c>)
   113b4:	689b      	ldr	r3, [r3, #8]
   113b6:	62d3      	str	r3, [r2, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
   113b8:	4a05      	ldr	r2, [pc, #20]	; (113d0 <_system_clock_source_dfll_set_config_errata_9905+0x38>)
   113ba:	4b06      	ldr	r3, [pc, #24]	; (113d4 <_system_clock_source_dfll_set_config_errata_9905+0x3c>)
   113bc:	685b      	ldr	r3, [r3, #4]
   113be:	6293      	str	r3, [r2, #40]	; 0x28

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
   113c0:	4a03      	ldr	r2, [pc, #12]	; (113d0 <_system_clock_source_dfll_set_config_errata_9905+0x38>)
   113c2:	4b04      	ldr	r3, [pc, #16]	; (113d4 <_system_clock_source_dfll_set_config_errata_9905+0x3c>)
   113c4:	681b      	ldr	r3, [r3, #0]
   113c6:	b29b      	uxth	r3, r3
   113c8:	8493      	strh	r3, [r2, #36]	; 0x24
}
   113ca:	46c0      	nop			; (mov r8, r8)
   113cc:	46bd      	mov	sp, r7
   113ce:	bd80      	pop	{r7, pc}
   113d0:	40000800 	.word	0x40000800
   113d4:	20000948 	.word	0x20000948
   113d8:	0001137d 	.word	0x0001137d

000113dc <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
   113dc:	b580      	push	{r7, lr}
   113de:	b082      	sub	sp, #8
   113e0:	af00      	add	r7, sp, #0
   113e2:	0002      	movs	r2, r0
   113e4:	1dfb      	adds	r3, r7, #7
   113e6:	701a      	strb	r2, [r3, #0]
	switch (clock_source) {
   113e8:	1dfb      	adds	r3, r7, #7
   113ea:	781b      	ldrb	r3, [r3, #0]
   113ec:	2b08      	cmp	r3, #8
   113ee:	d840      	bhi.n	11472 <system_clock_source_get_hz+0x96>
   113f0:	009a      	lsls	r2, r3, #2
   113f2:	4b22      	ldr	r3, [pc, #136]	; (1147c <system_clock_source_get_hz+0xa0>)
   113f4:	18d3      	adds	r3, r2, r3
   113f6:	681b      	ldr	r3, [r3, #0]
   113f8:	469f      	mov	pc, r3
	case SYSTEM_CLOCK_SOURCE_XOSC:
		return _system_clock_inst.xosc.frequency;
   113fa:	4b21      	ldr	r3, [pc, #132]	; (11480 <system_clock_source_get_hz+0xa4>)
   113fc:	691b      	ldr	r3, [r3, #16]
   113fe:	e039      	b.n	11474 <system_clock_source_get_hz+0x98>

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
   11400:	4b20      	ldr	r3, [pc, #128]	; (11484 <system_clock_source_get_hz+0xa8>)
   11402:	6a1b      	ldr	r3, [r3, #32]
   11404:	059b      	lsls	r3, r3, #22
   11406:	0f9b      	lsrs	r3, r3, #30
   11408:	b2db      	uxtb	r3, r3
   1140a:	001a      	movs	r2, r3
   1140c:	4b1e      	ldr	r3, [pc, #120]	; (11488 <system_clock_source_get_hz+0xac>)
   1140e:	40d3      	lsrs	r3, r2
   11410:	e030      	b.n	11474 <system_clock_source_get_hz+0x98>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		return 32768UL;
   11412:	2380      	movs	r3, #128	; 0x80
   11414:	021b      	lsls	r3, r3, #8
   11416:	e02d      	b.n	11474 <system_clock_source_get_hz+0x98>

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		return 32768UL;
   11418:	2380      	movs	r3, #128	; 0x80
   1141a:	021b      	lsls	r3, r3, #8
   1141c:	e02a      	b.n	11474 <system_clock_source_get_hz+0x98>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		return _system_clock_inst.xosc32k.frequency;
   1141e:	4b18      	ldr	r3, [pc, #96]	; (11480 <system_clock_source_get_hz+0xa4>)
   11420:	695b      	ldr	r3, [r3, #20]
   11422:	e027      	b.n	11474 <system_clock_source_get_hz+0x98>

	case SYSTEM_CLOCK_SOURCE_DFLL:

		/* Check if the DFLL has been configured */
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
   11424:	4b16      	ldr	r3, [pc, #88]	; (11480 <system_clock_source_get_hz+0xa4>)
   11426:	681b      	ldr	r3, [r3, #0]
   11428:	2202      	movs	r2, #2
   1142a:	4013      	ands	r3, r2
   1142c:	d101      	bne.n	11432 <system_clock_source_get_hz+0x56>
			return 0;
   1142e:	2300      	movs	r3, #0
   11430:	e020      	b.n	11474 <system_clock_source_get_hz+0x98>

		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();
   11432:	4b16      	ldr	r3, [pc, #88]	; (1148c <system_clock_source_get_hz+0xb0>)
   11434:	4798      	blx	r3

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
   11436:	4b12      	ldr	r3, [pc, #72]	; (11480 <system_clock_source_get_hz+0xa4>)
   11438:	681b      	ldr	r3, [r3, #0]
   1143a:	2204      	movs	r2, #4
   1143c:	4013      	ands	r3, r2
   1143e:	d009      	beq.n	11454 <system_clock_source_get_hz+0x78>
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
   11440:	2000      	movs	r0, #0
   11442:	4b13      	ldr	r3, [pc, #76]	; (11490 <system_clock_source_get_hz+0xb4>)
   11444:	4798      	blx	r3
   11446:	0002      	movs	r2, r0
					(_system_clock_inst.dfll.mul & 0xffff);
   11448:	4b0d      	ldr	r3, [pc, #52]	; (11480 <system_clock_source_get_hz+0xa4>)
   1144a:	689b      	ldr	r3, [r3, #8]
   1144c:	041b      	lsls	r3, r3, #16
   1144e:	0c1b      	lsrs	r3, r3, #16
		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
   11450:	4353      	muls	r3, r2
   11452:	e00f      	b.n	11474 <system_clock_source_get_hz+0x98>
					(_system_clock_inst.dfll.mul & 0xffff);
		}

		return 48000000UL;
   11454:	4b0f      	ldr	r3, [pc, #60]	; (11494 <system_clock_source_get_hz+0xb8>)
   11456:	e00d      	b.n	11474 <system_clock_source_get_hz+0x98>

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
   11458:	4a0a      	ldr	r2, [pc, #40]	; (11484 <system_clock_source_get_hz+0xa8>)
   1145a:	2350      	movs	r3, #80	; 0x50
   1145c:	5cd3      	ldrb	r3, [r2, r3]
   1145e:	b2db      	uxtb	r3, r3
   11460:	001a      	movs	r2, r3
   11462:	2304      	movs	r3, #4
   11464:	4013      	ands	r3, r2
   11466:	d101      	bne.n	1146c <system_clock_source_get_hz+0x90>
			return 0;
   11468:	2300      	movs	r3, #0
   1146a:	e003      	b.n	11474 <system_clock_source_get_hz+0x98>
		}

		return _system_clock_inst.dpll.frequency;
   1146c:	4b04      	ldr	r3, [pc, #16]	; (11480 <system_clock_source_get_hz+0xa4>)
   1146e:	68db      	ldr	r3, [r3, #12]
   11470:	e000      	b.n	11474 <system_clock_source_get_hz+0x98>
#endif

	default:
		return 0;
   11472:	2300      	movs	r3, #0
	}
}
   11474:	0018      	movs	r0, r3
   11476:	46bd      	mov	sp, r7
   11478:	b002      	add	sp, #8
   1147a:	bd80      	pop	{r7, pc}
   1147c:	00015970 	.word	0x00015970
   11480:	20000948 	.word	0x20000948
   11484:	40000800 	.word	0x40000800
   11488:	007a1200 	.word	0x007a1200
   1148c:	0001137d 	.word	0x0001137d
   11490:	00011d29 	.word	0x00011d29
   11494:	02dc6c00 	.word	0x02dc6c00

00011498 <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
   11498:	b580      	push	{r7, lr}
   1149a:	b084      	sub	sp, #16
   1149c:	af00      	add	r7, sp, #0
   1149e:	6078      	str	r0, [r7, #4]
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
   114a0:	4b1a      	ldr	r3, [pc, #104]	; (1150c <system_clock_source_osc8m_set_config+0x74>)
   114a2:	6a1b      	ldr	r3, [r3, #32]
   114a4:	60fb      	str	r3, [r7, #12]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
   114a6:	687b      	ldr	r3, [r7, #4]
   114a8:	781b      	ldrb	r3, [r3, #0]
   114aa:	1c1a      	adds	r2, r3, #0
   114ac:	2303      	movs	r3, #3
   114ae:	4013      	ands	r3, r2
   114b0:	b2da      	uxtb	r2, r3
   114b2:	230d      	movs	r3, #13
   114b4:	18fb      	adds	r3, r7, r3
   114b6:	2103      	movs	r1, #3
   114b8:	400a      	ands	r2, r1
   114ba:	0010      	movs	r0, r2
   114bc:	781a      	ldrb	r2, [r3, #0]
   114be:	2103      	movs	r1, #3
   114c0:	438a      	bics	r2, r1
   114c2:	1c11      	adds	r1, r2, #0
   114c4:	1c02      	adds	r2, r0, #0
   114c6:	430a      	orrs	r2, r1
   114c8:	701a      	strb	r2, [r3, #0]
	temp.bit.ONDEMAND = config->on_demand;
   114ca:	687b      	ldr	r3, [r7, #4]
   114cc:	789a      	ldrb	r2, [r3, #2]
   114ce:	230c      	movs	r3, #12
   114d0:	18fb      	adds	r3, r7, r3
   114d2:	01d0      	lsls	r0, r2, #7
   114d4:	781a      	ldrb	r2, [r3, #0]
   114d6:	217f      	movs	r1, #127	; 0x7f
   114d8:	400a      	ands	r2, r1
   114da:	1c11      	adds	r1, r2, #0
   114dc:	1c02      	adds	r2, r0, #0
   114de:	430a      	orrs	r2, r1
   114e0:	701a      	strb	r2, [r3, #0]
	temp.bit.RUNSTDBY = config->run_in_standby;
   114e2:	687b      	ldr	r3, [r7, #4]
   114e4:	785a      	ldrb	r2, [r3, #1]
   114e6:	230c      	movs	r3, #12
   114e8:	18fb      	adds	r3, r7, r3
   114ea:	2101      	movs	r1, #1
   114ec:	400a      	ands	r2, r1
   114ee:	0190      	lsls	r0, r2, #6
   114f0:	781a      	ldrb	r2, [r3, #0]
   114f2:	2140      	movs	r1, #64	; 0x40
   114f4:	438a      	bics	r2, r1
   114f6:	1c11      	adds	r1, r2, #0
   114f8:	1c02      	adds	r2, r0, #0
   114fa:	430a      	orrs	r2, r1
   114fc:	701a      	strb	r2, [r3, #0]

	SYSCTRL->OSC8M = temp;
   114fe:	4b03      	ldr	r3, [pc, #12]	; (1150c <system_clock_source_osc8m_set_config+0x74>)
   11500:	68fa      	ldr	r2, [r7, #12]
   11502:	621a      	str	r2, [r3, #32]
}
   11504:	46c0      	nop			; (mov r8, r8)
   11506:	46bd      	mov	sp, r7
   11508:	b004      	add	sp, #16
   1150a:	bd80      	pop	{r7, pc}
   1150c:	40000800 	.word	0x40000800

00011510 <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
   11510:	b580      	push	{r7, lr}
   11512:	b082      	sub	sp, #8
   11514:	af00      	add	r7, sp, #0
   11516:	6078      	str	r0, [r7, #4]
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
   11518:	687b      	ldr	r3, [r7, #4]
   1151a:	7a1b      	ldrb	r3, [r3, #8]
   1151c:	029b      	lsls	r3, r3, #10
   1151e:	041b      	lsls	r3, r3, #16
   11520:	0c1a      	lsrs	r2, r3, #16
			SYSCTRL_DFLLVAL_FINE(config->fine_value);
   11522:	687b      	ldr	r3, [r7, #4]
   11524:	895b      	ldrh	r3, [r3, #10]
   11526:	059b      	lsls	r3, r3, #22
   11528:	0d9b      	lsrs	r3, r3, #22
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
   1152a:	431a      	orrs	r2, r3
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
   1152c:	4b23      	ldr	r3, [pc, #140]	; (115bc <system_clock_source_dfll_set_config+0xac>)
   1152e:	605a      	str	r2, [r3, #4]
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
   11530:	687b      	ldr	r3, [r7, #4]
   11532:	799a      	ldrb	r2, [r3, #6]
			(uint32_t)config->stable_tracking |
   11534:	687b      	ldr	r3, [r7, #4]
   11536:	79db      	ldrb	r3, [r3, #7]
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
   11538:	4313      	orrs	r3, r2
   1153a:	b2db      	uxtb	r3, r3
   1153c:	001a      	movs	r2, r3
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
   1153e:	687b      	ldr	r3, [r7, #4]
   11540:	885b      	ldrh	r3, [r3, #2]
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
   11542:	4313      	orrs	r3, r2
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
   11544:	687a      	ldr	r2, [r7, #4]
   11546:	8892      	ldrh	r2, [r2, #4]
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
   11548:	431a      	orrs	r2, r3
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);
   1154a:	687b      	ldr	r3, [r7, #4]
   1154c:	785b      	ldrb	r3, [r3, #1]
   1154e:	01db      	lsls	r3, r3, #7

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
   11550:	431a      	orrs	r2, r3
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
   11552:	4b1a      	ldr	r3, [pc, #104]	; (115bc <system_clock_source_dfll_set_config+0xac>)
   11554:	601a      	str	r2, [r3, #0]
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
   11556:	687b      	ldr	r3, [r7, #4]
   11558:	781b      	ldrb	r3, [r3, #0]
   1155a:	2b04      	cmp	r3, #4
   1155c:	d116      	bne.n	1158c <system_clock_source_dfll_set_config+0x7c>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
   1155e:	687b      	ldr	r3, [r7, #4]
   11560:	7b1b      	ldrb	r3, [r3, #12]
   11562:	069b      	lsls	r3, r3, #26
   11564:	001a      	movs	r2, r3
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
   11566:	687b      	ldr	r3, [r7, #4]
   11568:	89db      	ldrh	r3, [r3, #14]
   1156a:	041b      	lsls	r3, r3, #16
   1156c:	0019      	movs	r1, r3
   1156e:	4b14      	ldr	r3, [pc, #80]	; (115c0 <system_clock_source_dfll_set_config+0xb0>)
   11570:	400b      	ands	r3, r1
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
   11572:	4313      	orrs	r3, r2
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
   11574:	687a      	ldr	r2, [r7, #4]
   11576:	8a12      	ldrh	r2, [r2, #16]

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
   11578:	431a      	orrs	r2, r3
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
   1157a:	4b10      	ldr	r3, [pc, #64]	; (115bc <system_clock_source_dfll_set_config+0xac>)
   1157c:	609a      	str	r2, [r3, #8]
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
   1157e:	4b0f      	ldr	r3, [pc, #60]	; (115bc <system_clock_source_dfll_set_config+0xac>)
   11580:	681b      	ldr	r3, [r3, #0]
   11582:	687a      	ldr	r2, [r7, #4]
   11584:	7812      	ldrb	r2, [r2, #0]
   11586:	431a      	orrs	r2, r3
   11588:	4b0c      	ldr	r3, [pc, #48]	; (115bc <system_clock_source_dfll_set_config+0xac>)
   1158a:	601a      	str	r2, [r3, #0]
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {
   1158c:	687b      	ldr	r3, [r7, #4]
   1158e:	781b      	ldrb	r3, [r3, #0]
   11590:	2b20      	cmp	r3, #32
   11592:	d10e      	bne.n	115b2 <system_clock_source_dfll_set_config+0xa2>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
   11594:	687b      	ldr	r3, [r7, #4]
   11596:	8a1b      	ldrh	r3, [r3, #16]
   11598:	001a      	movs	r2, r3
		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
   1159a:	4b08      	ldr	r3, [pc, #32]	; (115bc <system_clock_source_dfll_set_config+0xac>)
   1159c:	609a      	str	r2, [r3, #8]
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the USB recovery mode */
		_system_clock_inst.dfll.control |= config->loop_mode |
   1159e:	4b07      	ldr	r3, [pc, #28]	; (115bc <system_clock_source_dfll_set_config+0xac>)
   115a0:	681b      	ldr	r3, [r3, #0]
   115a2:	687a      	ldr	r2, [r7, #4]
   115a4:	7812      	ldrb	r2, [r2, #0]
   115a6:	4313      	orrs	r3, r2
   115a8:	2280      	movs	r2, #128	; 0x80
   115aa:	00d2      	lsls	r2, r2, #3
   115ac:	431a      	orrs	r2, r3
   115ae:	4b03      	ldr	r3, [pc, #12]	; (115bc <system_clock_source_dfll_set_config+0xac>)
   115b0:	601a      	str	r2, [r3, #0]
				SYSCTRL_DFLLCTRL_BPLCKC;
	}
}
   115b2:	46c0      	nop			; (mov r8, r8)
   115b4:	46bd      	mov	sp, r7
   115b6:	b002      	add	sp, #8
   115b8:	bd80      	pop	{r7, pc}
   115ba:	46c0      	nop			; (mov r8, r8)
   115bc:	20000948 	.word	0x20000948
   115c0:	03ff0000 	.word	0x03ff0000

000115c4 <system_clock_source_enable>:
 * \retval STATUS_ERR_INVALID_ARG  The clock source is not available on this
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
   115c4:	b580      	push	{r7, lr}
   115c6:	b082      	sub	sp, #8
   115c8:	af00      	add	r7, sp, #0
   115ca:	0002      	movs	r2, r0
   115cc:	1dfb      	adds	r3, r7, #7
   115ce:	701a      	strb	r2, [r3, #0]
	switch (clock_source) {
   115d0:	1dfb      	adds	r3, r7, #7
   115d2:	781b      	ldrb	r3, [r3, #0]
   115d4:	2b08      	cmp	r3, #8
   115d6:	d83b      	bhi.n	11650 <system_clock_source_enable+0x8c>
   115d8:	009a      	lsls	r2, r3, #2
   115da:	4b21      	ldr	r3, [pc, #132]	; (11660 <system_clock_source_enable+0x9c>)
   115dc:	18d3      	adds	r3, r2, r3
   115de:	681b      	ldr	r3, [r3, #0]
   115e0:	469f      	mov	pc, r3
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
   115e2:	4b20      	ldr	r3, [pc, #128]	; (11664 <system_clock_source_enable+0xa0>)
   115e4:	4a1f      	ldr	r2, [pc, #124]	; (11664 <system_clock_source_enable+0xa0>)
   115e6:	6a12      	ldr	r2, [r2, #32]
   115e8:	2102      	movs	r1, #2
   115ea:	430a      	orrs	r2, r1
   115ec:	621a      	str	r2, [r3, #32]
		return STATUS_OK;
   115ee:	2300      	movs	r3, #0
   115f0:	e031      	b.n	11656 <system_clock_source_enable+0x92>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
   115f2:	4b1c      	ldr	r3, [pc, #112]	; (11664 <system_clock_source_enable+0xa0>)
   115f4:	4a1b      	ldr	r2, [pc, #108]	; (11664 <system_clock_source_enable+0xa0>)
   115f6:	6992      	ldr	r2, [r2, #24]
   115f8:	2102      	movs	r1, #2
   115fa:	430a      	orrs	r2, r1
   115fc:	619a      	str	r2, [r3, #24]
		break;
   115fe:	e029      	b.n	11654 <system_clock_source_enable+0x90>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
   11600:	4a18      	ldr	r2, [pc, #96]	; (11664 <system_clock_source_enable+0xa0>)
   11602:	4b18      	ldr	r3, [pc, #96]	; (11664 <system_clock_source_enable+0xa0>)
   11604:	8a1b      	ldrh	r3, [r3, #16]
   11606:	b29b      	uxth	r3, r3
   11608:	2102      	movs	r1, #2
   1160a:	430b      	orrs	r3, r1
   1160c:	b29b      	uxth	r3, r3
   1160e:	8213      	strh	r3, [r2, #16]
		break;
   11610:	e020      	b.n	11654 <system_clock_source_enable+0x90>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
   11612:	4a14      	ldr	r2, [pc, #80]	; (11664 <system_clock_source_enable+0xa0>)
   11614:	4b13      	ldr	r3, [pc, #76]	; (11664 <system_clock_source_enable+0xa0>)
   11616:	8a9b      	ldrh	r3, [r3, #20]
   11618:	b29b      	uxth	r3, r3
   1161a:	2102      	movs	r1, #2
   1161c:	430b      	orrs	r3, r1
   1161e:	b29b      	uxth	r3, r3
   11620:	8293      	strh	r3, [r2, #20]
		break;
   11622:	e017      	b.n	11654 <system_clock_source_enable+0x90>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
   11624:	4b10      	ldr	r3, [pc, #64]	; (11668 <system_clock_source_enable+0xa4>)
   11626:	681b      	ldr	r3, [r3, #0]
   11628:	2202      	movs	r2, #2
   1162a:	431a      	orrs	r2, r3
   1162c:	4b0e      	ldr	r3, [pc, #56]	; (11668 <system_clock_source_enable+0xa4>)
   1162e:	601a      	str	r2, [r3, #0]
		_system_clock_source_dfll_set_config_errata_9905();
   11630:	4b0e      	ldr	r3, [pc, #56]	; (1166c <system_clock_source_enable+0xa8>)
   11632:	4798      	blx	r3
		break;
   11634:	e00e      	b.n	11654 <system_clock_source_enable+0x90>

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
   11636:	4a0b      	ldr	r2, [pc, #44]	; (11664 <system_clock_source_enable+0xa0>)
   11638:	490a      	ldr	r1, [pc, #40]	; (11664 <system_clock_source_enable+0xa0>)
   1163a:	2344      	movs	r3, #68	; 0x44
   1163c:	5ccb      	ldrb	r3, [r1, r3]
   1163e:	b2db      	uxtb	r3, r3
   11640:	2102      	movs	r1, #2
   11642:	430b      	orrs	r3, r1
   11644:	b2d9      	uxtb	r1, r3
   11646:	2344      	movs	r3, #68	; 0x44
   11648:	54d1      	strb	r1, [r2, r3]
		break;
   1164a:	e003      	b.n	11654 <system_clock_source_enable+0x90>
#endif

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
   1164c:	2300      	movs	r3, #0
   1164e:	e002      	b.n	11656 <system_clock_source_enable+0x92>

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
   11650:	2317      	movs	r3, #23
   11652:	e000      	b.n	11656 <system_clock_source_enable+0x92>
	}

	return STATUS_OK;
   11654:	2300      	movs	r3, #0
}
   11656:	0018      	movs	r0, r3
   11658:	46bd      	mov	sp, r7
   1165a:	b002      	add	sp, #8
   1165c:	bd80      	pop	{r7, pc}
   1165e:	46c0      	nop			; (mov r8, r8)
   11660:	00015994 	.word	0x00015994
   11664:	40000800 	.word	0x40000800
   11668:	20000948 	.word	0x20000948
   1166c:	00011399 	.word	0x00011399

00011670 <system_clock_source_is_ready>:
 * \retval true   Clock source is enabled and ready
 * \retval false  Clock source is disabled or not yet ready
 */
bool system_clock_source_is_ready(
		const enum system_clock_source clock_source)
{
   11670:	b580      	push	{r7, lr}
   11672:	b084      	sub	sp, #16
   11674:	af00      	add	r7, sp, #0
   11676:	0002      	movs	r2, r0
   11678:	1dfb      	adds	r3, r7, #7
   1167a:	701a      	strb	r2, [r3, #0]
	uint32_t mask = 0;
   1167c:	2300      	movs	r3, #0
   1167e:	60fb      	str	r3, [r7, #12]

	switch (clock_source) {
   11680:	1dfb      	adds	r3, r7, #7
   11682:	781b      	ldrb	r3, [r3, #0]
   11684:	2b08      	cmp	r3, #8
   11686:	d821      	bhi.n	116cc <system_clock_source_is_ready+0x5c>
   11688:	009a      	lsls	r2, r3, #2
   1168a:	4b18      	ldr	r3, [pc, #96]	; (116ec <system_clock_source_is_ready+0x7c>)
   1168c:	18d3      	adds	r3, r2, r3
   1168e:	681b      	ldr	r3, [r3, #0]
   11690:	469f      	mov	pc, r3
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		mask = SYSCTRL_PCLKSR_OSC8MRDY;
   11692:	2308      	movs	r3, #8
   11694:	60fb      	str	r3, [r7, #12]
		break;
   11696:	e01b      	b.n	116d0 <system_clock_source_is_ready+0x60>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		mask = SYSCTRL_PCLKSR_OSC32KRDY;
   11698:	2304      	movs	r3, #4
   1169a:	60fb      	str	r3, [r7, #12]
		break;
   1169c:	e018      	b.n	116d0 <system_clock_source_is_ready+0x60>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		mask = SYSCTRL_PCLKSR_XOSCRDY;
   1169e:	2301      	movs	r3, #1
   116a0:	60fb      	str	r3, [r7, #12]
		break;
   116a2:	e015      	b.n	116d0 <system_clock_source_is_ready+0x60>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		mask = SYSCTRL_PCLKSR_XOSC32KRDY;
   116a4:	2302      	movs	r3, #2
   116a6:	60fb      	str	r3, [r7, #12]
		break;
   116a8:	e012      	b.n	116d0 <system_clock_source_is_ready+0x60>
	case SYSTEM_CLOCK_SOURCE_DFLL:
		if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
			mask = (SYSCTRL_PCLKSR_DFLLRDY |
			        SYSCTRL_PCLKSR_DFLLLCKF | SYSCTRL_PCLKSR_DFLLLCKC);
		} else {
			mask = SYSCTRL_PCLKSR_DFLLRDY;
   116aa:	2310      	movs	r3, #16
   116ac:	60fb      	str	r3, [r7, #12]
		}
		break;
   116ae:	e00f      	b.n	116d0 <system_clock_source_is_ready+0x60>

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		return ((SYSCTRL->DPLLSTATUS.reg &
   116b0:	4a0f      	ldr	r2, [pc, #60]	; (116f0 <system_clock_source_is_ready+0x80>)
   116b2:	2350      	movs	r3, #80	; 0x50
   116b4:	5cd3      	ldrb	r3, [r2, r3]
   116b6:	b2db      	uxtb	r3, r3
   116b8:	001a      	movs	r2, r3
   116ba:	2303      	movs	r3, #3
   116bc:	4013      	ands	r3, r2
   116be:	3b03      	subs	r3, #3
   116c0:	425a      	negs	r2, r3
   116c2:	4153      	adcs	r3, r2
   116c4:	b2db      	uxtb	r3, r3
   116c6:	e00c      	b.n	116e2 <system_clock_source_is_ready+0x72>
				(SYSCTRL_DPLLSTATUS_CLKRDY | SYSCTRL_DPLLSTATUS_LOCK));
#endif

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Not possible to disable */
		return true;
   116c8:	2301      	movs	r3, #1
   116ca:	e00a      	b.n	116e2 <system_clock_source_is_ready+0x72>

	default:
		return false;
   116cc:	2300      	movs	r3, #0
   116ce:	e008      	b.n	116e2 <system_clock_source_is_ready+0x72>
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
   116d0:	4b07      	ldr	r3, [pc, #28]	; (116f0 <system_clock_source_is_ready+0x80>)
   116d2:	68db      	ldr	r3, [r3, #12]
   116d4:	68fa      	ldr	r2, [r7, #12]
   116d6:	401a      	ands	r2, r3
   116d8:	68fb      	ldr	r3, [r7, #12]
   116da:	1ad3      	subs	r3, r2, r3
   116dc:	425a      	negs	r2, r3
   116de:	4153      	adcs	r3, r2
   116e0:	b2db      	uxtb	r3, r3
}
   116e2:	0018      	movs	r0, r3
   116e4:	46bd      	mov	sp, r7
   116e6:	b004      	add	sp, #16
   116e8:	bd80      	pop	{r7, pc}
   116ea:	46c0      	nop			; (mov r8, r8)
   116ec:	000159b8 	.word	0x000159b8
   116f0:	40000800 	.word	0x40000800

000116f4 <_switch_peripheral_gclk>:
 *
 * Switch all peripheral clock to a not enabled general clock
 * to save power.
 */
static void _switch_peripheral_gclk(void)
{
   116f4:	b580      	push	{r7, lr}
   116f6:	b082      	sub	sp, #8
   116f8:	af00      	add	r7, sp, #0
	uint32_t gclk_id;
	struct system_gclk_chan_config gclk_conf;

#if CONF_CLOCK_GCLK_1_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_1;
   116fa:	003b      	movs	r3, r7
   116fc:	2201      	movs	r2, #1
   116fe:	701a      	strb	r2, [r3, #0]
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
   11700:	2300      	movs	r3, #0
   11702:	607b      	str	r3, [r7, #4]
   11704:	e009      	b.n	1171a <_switch_peripheral_gclk+0x26>
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
   11706:	687b      	ldr	r3, [r7, #4]
   11708:	b2db      	uxtb	r3, r3
   1170a:	003a      	movs	r2, r7
   1170c:	0011      	movs	r1, r2
   1170e:	0018      	movs	r0, r3
   11710:	4b05      	ldr	r3, [pc, #20]	; (11728 <_switch_peripheral_gclk+0x34>)
   11712:	4798      	blx	r3
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
   11714:	687b      	ldr	r3, [r7, #4]
   11716:	3301      	adds	r3, #1
   11718:	607b      	str	r3, [r7, #4]
   1171a:	687b      	ldr	r3, [r7, #4]
   1171c:	2b24      	cmp	r3, #36	; 0x24
   1171e:	d9f2      	bls.n	11706 <_switch_peripheral_gclk+0x12>
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
	}
}
   11720:	46c0      	nop			; (mov r8, r8)
   11722:	46bd      	mov	sp, r7
   11724:	b002      	add	sp, #8
   11726:	bd80      	pop	{r7, pc}
   11728:	00011c05 	.word	0x00011c05

0001172c <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
   1172c:	b580      	push	{r7, lr}
   1172e:	b0a6      	sub	sp, #152	; 0x98
   11730:	af00      	add	r7, sp, #0
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
   11732:	4b5d      	ldr	r3, [pc, #372]	; (118a8 <system_clock_init+0x17c>)
   11734:	22c2      	movs	r2, #194	; 0xc2
   11736:	00d2      	lsls	r2, r2, #3
   11738:	609a      	str	r2, [r3, #8]
			SYSCTRL_INTFLAG_DFLLRDY;

	system_flash_set_waitstates(CONF_CLOCK_FLASH_WAIT_STATES);
   1173a:	2002      	movs	r0, #2
   1173c:	4b5b      	ldr	r3, [pc, #364]	; (118ac <system_clock_init+0x180>)
   1173e:	4798      	blx	r3

	/* Switch all peripheral clock to a not enabled general clock to save power. */
	_switch_peripheral_gclk();
   11740:	4b5b      	ldr	r3, [pc, #364]	; (118b0 <system_clock_init+0x184>)
   11742:	4798      	blx	r3


	/* DFLL Config (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	struct system_clock_source_dfll_config dfll_conf;
	system_clock_source_dfll_get_config_defaults(&dfll_conf);
   11744:	2380      	movs	r3, #128	; 0x80
   11746:	18fb      	adds	r3, r7, r3
   11748:	0018      	movs	r0, r3
   1174a:	4b5a      	ldr	r3, [pc, #360]	; (118b4 <system_clock_init+0x188>)
   1174c:	4798      	blx	r3

	dfll_conf.loop_mode      = CONF_CLOCK_DFLL_LOOP_MODE;
   1174e:	2380      	movs	r3, #128	; 0x80
   11750:	18fb      	adds	r3, r7, r3
   11752:	2220      	movs	r2, #32
   11754:	701a      	strb	r2, [r3, #0]
	dfll_conf.on_demand      = false;
   11756:	2380      	movs	r3, #128	; 0x80
   11758:	18fb      	adds	r3, r7, r3
   1175a:	2200      	movs	r2, #0
   1175c:	705a      	strb	r2, [r3, #1]
	/* Using DFLL48M COARSE CAL value from NVM Software Calibration Area Mapping 
	   in DFLL.COARSE helps to output a frequency close to 48 MHz.*/
#define NVM_DFLL_COARSE_POS    58 /* DFLL48M Coarse calibration value bit position.*/
#define NVM_DFLL_COARSE_SIZE   6  /* DFLL48M Coarse calibration value bit size.*/

	uint32_t coarse =( *((uint32_t *)(NVMCTRL_OTP4)
   1175e:	4b56      	ldr	r3, [pc, #344]	; (118b8 <system_clock_init+0x18c>)
   11760:	681b      	ldr	r3, [r3, #0]
   11762:	0e9b      	lsrs	r3, r3, #26
   11764:	2294      	movs	r2, #148	; 0x94
   11766:	18ba      	adds	r2, r7, r2
   11768:	6013      	str	r3, [r2, #0]
			+ (NVM_DFLL_COARSE_POS / 32))
		>> (NVM_DFLL_COARSE_POS % 32))
		& ((1 << NVM_DFLL_COARSE_SIZE) - 1);
	/* In some revision chip, the coarse calibration value is not correct. */
	if (coarse == 0x3f) {
   1176a:	2394      	movs	r3, #148	; 0x94
   1176c:	18fb      	adds	r3, r7, r3
   1176e:	681b      	ldr	r3, [r3, #0]
   11770:	2b3f      	cmp	r3, #63	; 0x3f
   11772:	d103      	bne.n	1177c <system_clock_init+0x50>
		coarse = 0x1f;
   11774:	231f      	movs	r3, #31
   11776:	2294      	movs	r2, #148	; 0x94
   11778:	18ba      	adds	r2, r7, r2
   1177a:	6013      	str	r3, [r2, #0]
	}
	dfll_conf.coarse_value = coarse;
   1177c:	2394      	movs	r3, #148	; 0x94
   1177e:	18fb      	adds	r3, r7, r3
   11780:	681b      	ldr	r3, [r3, #0]
   11782:	b2da      	uxtb	r2, r3
   11784:	2380      	movs	r3, #128	; 0x80
   11786:	18fb      	adds	r3, r7, r3
   11788:	721a      	strb	r2, [r3, #8]
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN) {
		dfll_conf.fine_value   = CONF_CLOCK_DFLL_FINE_VALUE;
	}

#  if CONF_CLOCK_DFLL_QUICK_LOCK == true
	dfll_conf.quick_lock = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
   1178a:	2380      	movs	r3, #128	; 0x80
   1178c:	18fb      	adds	r3, r7, r3
   1178e:	2200      	movs	r2, #0
   11790:	805a      	strh	r2, [r3, #2]
#  else
	dfll_conf.quick_lock = SYSTEM_CLOCK_DFLL_QUICK_LOCK_DISABLE;
#  endif

#  if CONF_CLOCK_DFLL_TRACK_AFTER_FINE_LOCK == true
	dfll_conf.stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
   11792:	2380      	movs	r3, #128	; 0x80
   11794:	18fb      	adds	r3, r7, r3
   11796:	2200      	movs	r2, #0
   11798:	71da      	strb	r2, [r3, #7]
#  else
	dfll_conf.stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_FIX_AFTER_LOCK;
#  endif

#  if CONF_CLOCK_DFLL_KEEP_LOCK_ON_WAKEUP == true
	dfll_conf.wakeup_lock = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
   1179a:	2380      	movs	r3, #128	; 0x80
   1179c:	18fb      	adds	r3, r7, r3
   1179e:	2200      	movs	r2, #0
   117a0:	719a      	strb	r2, [r3, #6]
#  else
	dfll_conf.wakeup_lock = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_LOSE;
#  endif

#  if CONF_CLOCK_DFLL_ENABLE_CHILL_CYCLE == true
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
   117a2:	2380      	movs	r3, #128	; 0x80
   117a4:	18fb      	adds	r3, r7, r3
   117a6:	2200      	movs	r2, #0
   117a8:	809a      	strh	r2, [r3, #4]

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		dfll_conf.multiply_factor = CONF_CLOCK_DFLL_MULTIPLY_FACTOR;
	}

	dfll_conf.coarse_max_step = CONF_CLOCK_DFLL_MAX_COARSE_STEP_SIZE;
   117aa:	2380      	movs	r3, #128	; 0x80
   117ac:	18fb      	adds	r3, r7, r3
   117ae:	2207      	movs	r2, #7
   117b0:	731a      	strb	r2, [r3, #12]
	dfll_conf.fine_max_step   = CONF_CLOCK_DFLL_MAX_FINE_STEP_SIZE;
   117b2:	2380      	movs	r3, #128	; 0x80
   117b4:	18fb      	adds	r3, r7, r3
   117b6:	223f      	movs	r2, #63	; 0x3f
   117b8:	81da      	strh	r2, [r3, #14]

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {
		dfll_conf.fine_value   = 0x1ff;
   117ba:	2380      	movs	r3, #128	; 0x80
   117bc:	18fb      	adds	r3, r7, r3
   117be:	4a3f      	ldr	r2, [pc, #252]	; (118bc <system_clock_init+0x190>)
   117c0:	815a      	strh	r2, [r3, #10]
		dfll_conf.quick_lock = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
   117c2:	2380      	movs	r3, #128	; 0x80
   117c4:	18fb      	adds	r3, r7, r3
   117c6:	2200      	movs	r2, #0
   117c8:	805a      	strh	r2, [r3, #2]
		dfll_conf.stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_FIX_AFTER_LOCK;
   117ca:	2380      	movs	r3, #128	; 0x80
   117cc:	18fb      	adds	r3, r7, r3
   117ce:	2208      	movs	r2, #8
   117d0:	71da      	strb	r2, [r3, #7]
		dfll_conf.wakeup_lock = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
   117d2:	2380      	movs	r3, #128	; 0x80
   117d4:	18fb      	adds	r3, r7, r3
   117d6:	2200      	movs	r2, #0
   117d8:	719a      	strb	r2, [r3, #6]
		dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;
   117da:	2380      	movs	r3, #128	; 0x80
   117dc:	18fb      	adds	r3, r7, r3
   117de:	2280      	movs	r2, #128	; 0x80
   117e0:	0052      	lsls	r2, r2, #1
   117e2:	809a      	strh	r2, [r3, #4]

		dfll_conf.multiply_factor = 48000;
   117e4:	2380      	movs	r3, #128	; 0x80
   117e6:	18fb      	adds	r3, r7, r3
   117e8:	4a35      	ldr	r2, [pc, #212]	; (118c0 <system_clock_init+0x194>)
   117ea:	821a      	strh	r2, [r3, #16]
	}

	system_clock_source_dfll_set_config(&dfll_conf);
   117ec:	2380      	movs	r3, #128	; 0x80
   117ee:	18fb      	adds	r3, r7, r3
   117f0:	0018      	movs	r0, r3
   117f2:	4b34      	ldr	r3, [pc, #208]	; (118c4 <system_clock_init+0x198>)
   117f4:	4798      	blx	r3
#endif


	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);
   117f6:	237c      	movs	r3, #124	; 0x7c
   117f8:	18fb      	adds	r3, r7, r3
   117fa:	0018      	movs	r0, r3
   117fc:	4b32      	ldr	r3, [pc, #200]	; (118c8 <system_clock_init+0x19c>)
   117fe:	4798      	blx	r3

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
   11800:	237c      	movs	r3, #124	; 0x7c
   11802:	18fb      	adds	r3, r7, r3
   11804:	2200      	movs	r2, #0
   11806:	701a      	strb	r2, [r3, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
   11808:	237c      	movs	r3, #124	; 0x7c
   1180a:	18fb      	adds	r3, r7, r3
   1180c:	2201      	movs	r2, #1
   1180e:	709a      	strb	r2, [r3, #2]
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;
   11810:	237c      	movs	r3, #124	; 0x7c
   11812:	18fb      	adds	r3, r7, r3
   11814:	2200      	movs	r2, #0
   11816:	705a      	strb	r2, [r3, #1]

	system_clock_source_osc8m_set_config(&osc8m_conf);
   11818:	237c      	movs	r3, #124	; 0x7c
   1181a:	18fb      	adds	r3, r7, r3
   1181c:	0018      	movs	r0, r3
   1181e:	4b2b      	ldr	r3, [pc, #172]	; (118cc <system_clock_init+0x1a0>)
   11820:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
   11822:	2006      	movs	r0, #6
   11824:	4b2a      	ldr	r3, [pc, #168]	; (118d0 <system_clock_init+0x1a4>)
   11826:	4798      	blx	r3


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
   11828:	4b2a      	ldr	r3, [pc, #168]	; (118d4 <system_clock_init+0x1a8>)
   1182a:	4798      	blx	r3
#endif


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
   1182c:	2007      	movs	r0, #7
   1182e:	4b28      	ldr	r3, [pc, #160]	; (118d0 <system_clock_init+0x1a4>)
   11830:	4798      	blx	r3
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
   11832:	46c0      	nop			; (mov r8, r8)
   11834:	2007      	movs	r0, #7
   11836:	4b28      	ldr	r3, [pc, #160]	; (118d8 <system_clock_init+0x1ac>)
   11838:	4798      	blx	r3
   1183a:	0003      	movs	r3, r0
   1183c:	001a      	movs	r2, r3
   1183e:	2301      	movs	r3, #1
   11840:	4053      	eors	r3, r2
   11842:	b2db      	uxtb	r3, r3
   11844:	2b00      	cmp	r3, #0
   11846:	d1f5      	bne.n	11834 <system_clock_init+0x108>
	if (CONF_CLOCK_DFLL_ON_DEMAND) {
		SYSCTRL->DFLLCTRL.bit.ONDEMAND = 1;
   11848:	4a17      	ldr	r2, [pc, #92]	; (118a8 <system_clock_init+0x17c>)
   1184a:	8c93      	ldrh	r3, [r2, #36]	; 0x24
   1184c:	2180      	movs	r1, #128	; 0x80
   1184e:	430b      	orrs	r3, r1
   11850:	8493      	strh	r3, [r2, #36]	; 0x24

#  endif
#endif

	/* CPU and BUS clocks */
	system_cpu_clock_set_divider(CONF_CLOCK_CPU_DIVIDER);
   11852:	2000      	movs	r0, #0
   11854:	4b21      	ldr	r3, [pc, #132]	; (118dc <system_clock_init+0x1b0>)
   11856:	4798      	blx	r3

	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBA, CONF_CLOCK_APBA_DIVIDER);
   11858:	2100      	movs	r1, #0
   1185a:	2000      	movs	r0, #0
   1185c:	4b20      	ldr	r3, [pc, #128]	; (118e0 <system_clock_init+0x1b4>)
   1185e:	4798      	blx	r3
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBB, CONF_CLOCK_APBB_DIVIDER);
   11860:	2100      	movs	r1, #0
   11862:	2001      	movs	r0, #1
   11864:	4b1e      	ldr	r3, [pc, #120]	; (118e0 <system_clock_init+0x1b4>)
   11866:	4798      	blx	r3
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBC, CONF_CLOCK_APBC_DIVIDER);
   11868:	2100      	movs	r1, #0
   1186a:	2002      	movs	r0, #2
   1186c:	4b1c      	ldr	r3, [pc, #112]	; (118e0 <system_clock_init+0x1b4>)
   1186e:	4798      	blx	r3

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
   11870:	003b      	movs	r3, r7
   11872:	0018      	movs	r0, r3
   11874:	4b1b      	ldr	r3, [pc, #108]	; (118e4 <system_clock_init+0x1b8>)
   11876:	4798      	blx	r3
   11878:	003b      	movs	r3, r7
   1187a:	2207      	movs	r2, #7
   1187c:	701a      	strb	r2, [r3, #0]
   1187e:	003b      	movs	r3, r7
   11880:	2201      	movs	r2, #1
   11882:	605a      	str	r2, [r3, #4]
   11884:	003b      	movs	r3, r7
   11886:	2201      	movs	r2, #1
   11888:	721a      	strb	r2, [r3, #8]
   1188a:	003b      	movs	r3, r7
   1188c:	2200      	movs	r2, #0
   1188e:	725a      	strb	r2, [r3, #9]
   11890:	003b      	movs	r3, r7
   11892:	0019      	movs	r1, r3
   11894:	2000      	movs	r0, #0
   11896:	4b14      	ldr	r3, [pc, #80]	; (118e8 <system_clock_init+0x1bc>)
   11898:	4798      	blx	r3
   1189a:	2000      	movs	r0, #0
   1189c:	4b13      	ldr	r3, [pc, #76]	; (118ec <system_clock_init+0x1c0>)
   1189e:	4798      	blx	r3
#endif
}
   118a0:	46c0      	nop			; (mov r8, r8)
   118a2:	46bd      	mov	sp, r7
   118a4:	b026      	add	sp, #152	; 0x98
   118a6:	bd80      	pop	{r7, pc}
   118a8:	40000800 	.word	0x40000800
   118ac:	00011349 	.word	0x00011349
   118b0:	000116f5 	.word	0x000116f5
   118b4:	00011281 	.word	0x00011281
   118b8:	00806024 	.word	0x00806024
   118bc:	000001ff 	.word	0x000001ff
   118c0:	ffffbb80 	.word	0xffffbb80
   118c4:	00011511 	.word	0x00011511
   118c8:	0001125d 	.word	0x0001125d
   118cc:	00011499 	.word	0x00011499
   118d0:	000115c5 	.word	0x000115c5
   118d4:	00011995 	.word	0x00011995
   118d8:	00011671 	.word	0x00011671
   118dc:	000112d5 	.word	0x000112d5
   118e0:	000112f5 	.word	0x000112f5
   118e4:	0001122d 	.word	0x0001122d
   118e8:	000119c5 	.word	0x000119c5
   118ec:	00011ad1 	.word	0x00011ad1

000118f0 <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
   118f0:	b580      	push	{r7, lr}
   118f2:	b082      	sub	sp, #8
   118f4:	af00      	add	r7, sp, #0
   118f6:	0002      	movs	r2, r0
   118f8:	6039      	str	r1, [r7, #0]
   118fa:	1dfb      	adds	r3, r7, #7
   118fc:	701a      	strb	r2, [r3, #0]
	switch (bus) {
   118fe:	1dfb      	adds	r3, r7, #7
   11900:	781b      	ldrb	r3, [r3, #0]
   11902:	2b01      	cmp	r3, #1
   11904:	d00a      	beq.n	1191c <system_apb_clock_set_mask+0x2c>
   11906:	2b02      	cmp	r3, #2
   11908:	d00f      	beq.n	1192a <system_apb_clock_set_mask+0x3a>
   1190a:	2b00      	cmp	r3, #0
   1190c:	d114      	bne.n	11938 <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
   1190e:	4b0e      	ldr	r3, [pc, #56]	; (11948 <system_apb_clock_set_mask+0x58>)
   11910:	4a0d      	ldr	r2, [pc, #52]	; (11948 <system_apb_clock_set_mask+0x58>)
   11912:	6991      	ldr	r1, [r2, #24]
   11914:	683a      	ldr	r2, [r7, #0]
   11916:	430a      	orrs	r2, r1
   11918:	619a      	str	r2, [r3, #24]
			break;
   1191a:	e00f      	b.n	1193c <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
   1191c:	4b0a      	ldr	r3, [pc, #40]	; (11948 <system_apb_clock_set_mask+0x58>)
   1191e:	4a0a      	ldr	r2, [pc, #40]	; (11948 <system_apb_clock_set_mask+0x58>)
   11920:	69d1      	ldr	r1, [r2, #28]
   11922:	683a      	ldr	r2, [r7, #0]
   11924:	430a      	orrs	r2, r1
   11926:	61da      	str	r2, [r3, #28]
			break;
   11928:	e008      	b.n	1193c <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
   1192a:	4b07      	ldr	r3, [pc, #28]	; (11948 <system_apb_clock_set_mask+0x58>)
   1192c:	4a06      	ldr	r2, [pc, #24]	; (11948 <system_apb_clock_set_mask+0x58>)
   1192e:	6a11      	ldr	r1, [r2, #32]
   11930:	683a      	ldr	r2, [r7, #0]
   11932:	430a      	orrs	r2, r1
   11934:	621a      	str	r2, [r3, #32]
			break;
   11936:	e001      	b.n	1193c <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
   11938:	2317      	movs	r3, #23
   1193a:	e000      	b.n	1193e <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
   1193c:	2300      	movs	r3, #0
}
   1193e:	0018      	movs	r0, r3
   11940:	46bd      	mov	sp, r7
   11942:	b002      	add	sp, #8
   11944:	bd80      	pop	{r7, pc}
   11946:	46c0      	nop			; (mov r8, r8)
   11948:	40000400 	.word	0x40000400

0001194c <system_interrupt_enter_critical_section>:
 * count of the critical section nesting will be kept, so that global interrupts
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
   1194c:	b580      	push	{r7, lr}
   1194e:	af00      	add	r7, sp, #0
	cpu_irq_enter_critical();
   11950:	4b02      	ldr	r3, [pc, #8]	; (1195c <system_interrupt_enter_critical_section+0x10>)
   11952:	4798      	blx	r3
}
   11954:	46c0      	nop			; (mov r8, r8)
   11956:	46bd      	mov	sp, r7
   11958:	bd80      	pop	{r7, pc}
   1195a:	46c0      	nop			; (mov r8, r8)
   1195c:	00010fc5 	.word	0x00010fc5

00011960 <system_interrupt_leave_critical_section>:
 * count of the critical section nesting will be kept, so that global interrupts
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
   11960:	b580      	push	{r7, lr}
   11962:	af00      	add	r7, sp, #0
	cpu_irq_leave_critical();
   11964:	4b02      	ldr	r3, [pc, #8]	; (11970 <system_interrupt_leave_critical_section+0x10>)
   11966:	4798      	blx	r3
}
   11968:	46c0      	nop			; (mov r8, r8)
   1196a:	46bd      	mov	sp, r7
   1196c:	bd80      	pop	{r7, pc}
   1196e:	46c0      	nop			; (mov r8, r8)
   11970:	00011019 	.word	0x00011019

00011974 <system_gclk_is_syncing>:
 *
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
   11974:	b580      	push	{r7, lr}
   11976:	af00      	add	r7, sp, #0
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
   11978:	4b05      	ldr	r3, [pc, #20]	; (11990 <system_gclk_is_syncing+0x1c>)
   1197a:	785b      	ldrb	r3, [r3, #1]
   1197c:	b2db      	uxtb	r3, r3
   1197e:	b25b      	sxtb	r3, r3
   11980:	2b00      	cmp	r3, #0
   11982:	da01      	bge.n	11988 <system_gclk_is_syncing+0x14>
		return true;
   11984:	2301      	movs	r3, #1
   11986:	e000      	b.n	1198a <system_gclk_is_syncing+0x16>
	}

	return false;
   11988:	2300      	movs	r3, #0
}
   1198a:	0018      	movs	r0, r3
   1198c:	46bd      	mov	sp, r7
   1198e:	bd80      	pop	{r7, pc}
   11990:	40000c00 	.word	0x40000c00

00011994 <system_gclk_init>:
 *
 * Initializes the Generic Clock module, disabling and resetting all active
 * Generic Clock Generators and Channels to their power-on default values.
 */
void system_gclk_init(void)
{
   11994:	b580      	push	{r7, lr}
   11996:	af00      	add	r7, sp, #0
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);
   11998:	2108      	movs	r1, #8
   1199a:	2000      	movs	r0, #0
   1199c:	4b07      	ldr	r3, [pc, #28]	; (119bc <system_gclk_init+0x28>)
   1199e:	4798      	blx	r3

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
   119a0:	4b07      	ldr	r3, [pc, #28]	; (119c0 <system_gclk_init+0x2c>)
   119a2:	2201      	movs	r2, #1
   119a4:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
   119a6:	46c0      	nop			; (mov r8, r8)
   119a8:	4b05      	ldr	r3, [pc, #20]	; (119c0 <system_gclk_init+0x2c>)
   119aa:	781b      	ldrb	r3, [r3, #0]
   119ac:	b2db      	uxtb	r3, r3
   119ae:	001a      	movs	r2, r3
   119b0:	2301      	movs	r3, #1
   119b2:	4013      	ands	r3, r2
   119b4:	d1f8      	bne.n	119a8 <system_gclk_init+0x14>
		/* Wait for reset to complete */
	}
}
   119b6:	46c0      	nop			; (mov r8, r8)
   119b8:	46bd      	mov	sp, r7
   119ba:	bd80      	pop	{r7, pc}
   119bc:	000118f1 	.word	0x000118f1
   119c0:	40000c00 	.word	0x40000c00

000119c4 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
   119c4:	b580      	push	{r7, lr}
   119c6:	b086      	sub	sp, #24
   119c8:	af00      	add	r7, sp, #0
   119ca:	0002      	movs	r2, r0
   119cc:	6039      	str	r1, [r7, #0]
   119ce:	1dfb      	adds	r3, r7, #7
   119d0:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
   119d2:	1dfb      	adds	r3, r7, #7
   119d4:	781b      	ldrb	r3, [r3, #0]
   119d6:	617b      	str	r3, [r7, #20]
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);
   119d8:	1dfb      	adds	r3, r7, #7
   119da:	781b      	ldrb	r3, [r3, #0]
   119dc:	613b      	str	r3, [r7, #16]

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
   119de:	683b      	ldr	r3, [r7, #0]
   119e0:	781b      	ldrb	r3, [r3, #0]
   119e2:	021b      	lsls	r3, r3, #8
   119e4:	001a      	movs	r2, r3
   119e6:	697b      	ldr	r3, [r7, #20]
   119e8:	4313      	orrs	r3, r2
   119ea:	617b      	str	r3, [r7, #20]

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
   119ec:	683b      	ldr	r3, [r7, #0]
   119ee:	785b      	ldrb	r3, [r3, #1]
   119f0:	2b00      	cmp	r3, #0
   119f2:	d004      	beq.n	119fe <system_gclk_gen_set_config+0x3a>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
   119f4:	697b      	ldr	r3, [r7, #20]
   119f6:	2280      	movs	r2, #128	; 0x80
   119f8:	02d2      	lsls	r2, r2, #11
   119fa:	4313      	orrs	r3, r2
   119fc:	617b      	str	r3, [r7, #20]
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
   119fe:	683b      	ldr	r3, [r7, #0]
   11a00:	7a5b      	ldrb	r3, [r3, #9]
   11a02:	2b00      	cmp	r3, #0
   11a04:	d004      	beq.n	11a10 <system_gclk_gen_set_config+0x4c>
		new_genctrl_config |= GCLK_GENCTRL_OE;
   11a06:	697b      	ldr	r3, [r7, #20]
   11a08:	2280      	movs	r2, #128	; 0x80
   11a0a:	0312      	lsls	r2, r2, #12
   11a0c:	4313      	orrs	r3, r2
   11a0e:	617b      	str	r3, [r7, #20]
	}

	/* Set division factor */
	if (config->division_factor > 1) {
   11a10:	683b      	ldr	r3, [r7, #0]
   11a12:	685b      	ldr	r3, [r3, #4]
   11a14:	2b01      	cmp	r3, #1
   11a16:	d92c      	bls.n	11a72 <system_gclk_gen_set_config+0xae>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
   11a18:	683b      	ldr	r3, [r7, #0]
   11a1a:	685a      	ldr	r2, [r3, #4]
   11a1c:	683b      	ldr	r3, [r7, #0]
   11a1e:	685b      	ldr	r3, [r3, #4]
   11a20:	3b01      	subs	r3, #1
   11a22:	4013      	ands	r3, r2
   11a24:	d11a      	bne.n	11a5c <system_gclk_gen_set_config+0x98>
			/* Determine the index of the highest bit set to get the
			 * division factor that must be loaded into the division
			 * register */

			uint32_t div2_count = 0;
   11a26:	2300      	movs	r3, #0
   11a28:	60fb      	str	r3, [r7, #12]

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
   11a2a:	2302      	movs	r3, #2
   11a2c:	60bb      	str	r3, [r7, #8]
   11a2e:	e005      	b.n	11a3c <system_gclk_gen_set_config+0x78>
						mask <<= 1) {
				div2_count++;
   11a30:	68fb      	ldr	r3, [r7, #12]
   11a32:	3301      	adds	r3, #1
   11a34:	60fb      	str	r3, [r7, #12]

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
						mask <<= 1) {
   11a36:	68bb      	ldr	r3, [r7, #8]
   11a38:	005b      	lsls	r3, r3, #1
   11a3a:	60bb      	str	r3, [r7, #8]
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
   11a3c:	683b      	ldr	r3, [r7, #0]
   11a3e:	685a      	ldr	r2, [r3, #4]
   11a40:	68bb      	ldr	r3, [r7, #8]
   11a42:	429a      	cmp	r2, r3
   11a44:	d8f4      	bhi.n	11a30 <system_gclk_gen_set_config+0x6c>
						mask <<= 1) {
				div2_count++;
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
   11a46:	68fb      	ldr	r3, [r7, #12]
   11a48:	021b      	lsls	r3, r3, #8
   11a4a:	693a      	ldr	r2, [r7, #16]
   11a4c:	4313      	orrs	r3, r2
   11a4e:	613b      	str	r3, [r7, #16]
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
   11a50:	697b      	ldr	r3, [r7, #20]
   11a52:	2280      	movs	r2, #128	; 0x80
   11a54:	0352      	lsls	r2, r2, #13
   11a56:	4313      	orrs	r3, r2
   11a58:	617b      	str	r3, [r7, #20]
   11a5a:	e00a      	b.n	11a72 <system_gclk_gen_set_config+0xae>
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
   11a5c:	683b      	ldr	r3, [r7, #0]
   11a5e:	685b      	ldr	r3, [r3, #4]
   11a60:	021b      	lsls	r3, r3, #8
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
   11a62:	693a      	ldr	r2, [r7, #16]
   11a64:	4313      	orrs	r3, r2
   11a66:	613b      	str	r3, [r7, #16]
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
   11a68:	697b      	ldr	r3, [r7, #20]
   11a6a:	2280      	movs	r2, #128	; 0x80
   11a6c:	0292      	lsls	r2, r2, #10
   11a6e:	4313      	orrs	r3, r2
   11a70:	617b      	str	r3, [r7, #20]
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
   11a72:	683b      	ldr	r3, [r7, #0]
   11a74:	7a1b      	ldrb	r3, [r3, #8]
   11a76:	2b00      	cmp	r3, #0
   11a78:	d004      	beq.n	11a84 <system_gclk_gen_set_config+0xc0>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
   11a7a:	697b      	ldr	r3, [r7, #20]
   11a7c:	2280      	movs	r2, #128	; 0x80
   11a7e:	0392      	lsls	r2, r2, #14
   11a80:	4313      	orrs	r3, r2
   11a82:	617b      	str	r3, [r7, #20]
	}

	while (system_gclk_is_syncing()) {
   11a84:	46c0      	nop			; (mov r8, r8)
   11a86:	4b0e      	ldr	r3, [pc, #56]	; (11ac0 <system_gclk_gen_set_config+0xfc>)
   11a88:	4798      	blx	r3
   11a8a:	1e03      	subs	r3, r0, #0
   11a8c:	d1fb      	bne.n	11a86 <system_gclk_gen_set_config+0xc2>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
   11a8e:	4b0d      	ldr	r3, [pc, #52]	; (11ac4 <system_gclk_gen_set_config+0x100>)
   11a90:	4798      	blx	r3

	GCLK->GENDIV.reg  = new_gendiv_config;
   11a92:	4b0d      	ldr	r3, [pc, #52]	; (11ac8 <system_gclk_gen_set_config+0x104>)
   11a94:	693a      	ldr	r2, [r7, #16]
   11a96:	609a      	str	r2, [r3, #8]

	while (system_gclk_is_syncing()) {
   11a98:	46c0      	nop			; (mov r8, r8)
   11a9a:	4b09      	ldr	r3, [pc, #36]	; (11ac0 <system_gclk_gen_set_config+0xfc>)
   11a9c:	4798      	blx	r3
   11a9e:	1e03      	subs	r3, r0, #0
   11aa0:	d1fb      	bne.n	11a9a <system_gclk_gen_set_config+0xd6>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
   11aa2:	4b09      	ldr	r3, [pc, #36]	; (11ac8 <system_gclk_gen_set_config+0x104>)
   11aa4:	4a08      	ldr	r2, [pc, #32]	; (11ac8 <system_gclk_gen_set_config+0x104>)
   11aa6:	6851      	ldr	r1, [r2, #4]
   11aa8:	2280      	movs	r2, #128	; 0x80
   11aaa:	0252      	lsls	r2, r2, #9
   11aac:	4011      	ands	r1, r2
   11aae:	697a      	ldr	r2, [r7, #20]
   11ab0:	430a      	orrs	r2, r1
   11ab2:	605a      	str	r2, [r3, #4]

	system_interrupt_leave_critical_section();
   11ab4:	4b05      	ldr	r3, [pc, #20]	; (11acc <system_gclk_gen_set_config+0x108>)
   11ab6:	4798      	blx	r3
}
   11ab8:	46c0      	nop			; (mov r8, r8)
   11aba:	46bd      	mov	sp, r7
   11abc:	b006      	add	sp, #24
   11abe:	bd80      	pop	{r7, pc}
   11ac0:	00011975 	.word	0x00011975
   11ac4:	0001194d 	.word	0x0001194d
   11ac8:	40000c00 	.word	0x40000c00
   11acc:	00011961 	.word	0x00011961

00011ad0 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
   11ad0:	b580      	push	{r7, lr}
   11ad2:	b082      	sub	sp, #8
   11ad4:	af00      	add	r7, sp, #0
   11ad6:	0002      	movs	r2, r0
   11ad8:	1dfb      	adds	r3, r7, #7
   11ada:	701a      	strb	r2, [r3, #0]
	while (system_gclk_is_syncing()) {
   11adc:	46c0      	nop			; (mov r8, r8)
   11ade:	4b0e      	ldr	r3, [pc, #56]	; (11b18 <system_gclk_gen_enable+0x48>)
   11ae0:	4798      	blx	r3
   11ae2:	1e03      	subs	r3, r0, #0
   11ae4:	d1fb      	bne.n	11ade <system_gclk_gen_enable+0xe>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
   11ae6:	4b0d      	ldr	r3, [pc, #52]	; (11b1c <system_gclk_gen_enable+0x4c>)
   11ae8:	4798      	blx	r3

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
   11aea:	4a0d      	ldr	r2, [pc, #52]	; (11b20 <system_gclk_gen_enable+0x50>)
   11aec:	1dfb      	adds	r3, r7, #7
   11aee:	781b      	ldrb	r3, [r3, #0]
   11af0:	7013      	strb	r3, [r2, #0]
	while (system_gclk_is_syncing()) {
   11af2:	46c0      	nop			; (mov r8, r8)
   11af4:	4b08      	ldr	r3, [pc, #32]	; (11b18 <system_gclk_gen_enable+0x48>)
   11af6:	4798      	blx	r3
   11af8:	1e03      	subs	r3, r0, #0
   11afa:	d1fb      	bne.n	11af4 <system_gclk_gen_enable+0x24>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
   11afc:	4b09      	ldr	r3, [pc, #36]	; (11b24 <system_gclk_gen_enable+0x54>)
   11afe:	4a09      	ldr	r2, [pc, #36]	; (11b24 <system_gclk_gen_enable+0x54>)
   11b00:	6852      	ldr	r2, [r2, #4]
   11b02:	2180      	movs	r1, #128	; 0x80
   11b04:	0249      	lsls	r1, r1, #9
   11b06:	430a      	orrs	r2, r1
   11b08:	605a      	str	r2, [r3, #4]

	system_interrupt_leave_critical_section();
   11b0a:	4b07      	ldr	r3, [pc, #28]	; (11b28 <system_gclk_gen_enable+0x58>)
   11b0c:	4798      	blx	r3
}
   11b0e:	46c0      	nop			; (mov r8, r8)
   11b10:	46bd      	mov	sp, r7
   11b12:	b002      	add	sp, #8
   11b14:	bd80      	pop	{r7, pc}
   11b16:	46c0      	nop			; (mov r8, r8)
   11b18:	00011975 	.word	0x00011975
   11b1c:	0001194d 	.word	0x0001194d
   11b20:	40000c04 	.word	0x40000c04
   11b24:	40000c00 	.word	0x40000c00
   11b28:	00011961 	.word	0x00011961

00011b2c <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
   11b2c:	b580      	push	{r7, lr}
   11b2e:	b086      	sub	sp, #24
   11b30:	af00      	add	r7, sp, #0
   11b32:	0002      	movs	r2, r0
   11b34:	1dfb      	adds	r3, r7, #7
   11b36:	701a      	strb	r2, [r3, #0]
	while (system_gclk_is_syncing()) {
   11b38:	46c0      	nop			; (mov r8, r8)
   11b3a:	4b2a      	ldr	r3, [pc, #168]	; (11be4 <system_gclk_gen_get_hz+0xb8>)
   11b3c:	4798      	blx	r3
   11b3e:	1e03      	subs	r3, r0, #0
   11b40:	d1fb      	bne.n	11b3a <system_gclk_gen_get_hz+0xe>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
   11b42:	4b29      	ldr	r3, [pc, #164]	; (11be8 <system_gclk_gen_get_hz+0xbc>)
   11b44:	4798      	blx	r3

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
   11b46:	4a29      	ldr	r2, [pc, #164]	; (11bec <system_gclk_gen_get_hz+0xc0>)
   11b48:	1dfb      	adds	r3, r7, #7
   11b4a:	781b      	ldrb	r3, [r3, #0]
   11b4c:	7013      	strb	r3, [r2, #0]
	while (system_gclk_is_syncing()) {
   11b4e:	46c0      	nop			; (mov r8, r8)
   11b50:	4b24      	ldr	r3, [pc, #144]	; (11be4 <system_gclk_gen_get_hz+0xb8>)
   11b52:	4798      	blx	r3
   11b54:	1e03      	subs	r3, r0, #0
   11b56:	d1fb      	bne.n	11b50 <system_gclk_gen_get_hz+0x24>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
   11b58:	4b25      	ldr	r3, [pc, #148]	; (11bf0 <system_gclk_gen_get_hz+0xc4>)
   11b5a:	685b      	ldr	r3, [r3, #4]
   11b5c:	04db      	lsls	r3, r3, #19
   11b5e:	0edb      	lsrs	r3, r3, #27
   11b60:	b2db      	uxtb	r3, r3
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
   11b62:	0018      	movs	r0, r3
   11b64:	4b23      	ldr	r3, [pc, #140]	; (11bf4 <system_gclk_gen_get_hz+0xc8>)
   11b66:	4798      	blx	r3
   11b68:	0003      	movs	r3, r0
   11b6a:	617b      	str	r3, [r7, #20]
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
   11b6c:	4a1f      	ldr	r2, [pc, #124]	; (11bec <system_gclk_gen_get_hz+0xc0>)
   11b6e:	1dfb      	adds	r3, r7, #7
   11b70:	781b      	ldrb	r3, [r3, #0]
   11b72:	7013      	strb	r3, [r2, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
   11b74:	4b1e      	ldr	r3, [pc, #120]	; (11bf0 <system_gclk_gen_get_hz+0xc4>)
   11b76:	685b      	ldr	r3, [r3, #4]
   11b78:	02db      	lsls	r3, r3, #11
   11b7a:	0fdb      	lsrs	r3, r3, #31
   11b7c:	b2da      	uxtb	r2, r3
   11b7e:	2313      	movs	r3, #19
   11b80:	18fb      	adds	r3, r7, r3
   11b82:	701a      	strb	r2, [r3, #0]

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
   11b84:	4a1c      	ldr	r2, [pc, #112]	; (11bf8 <system_gclk_gen_get_hz+0xcc>)
   11b86:	1dfb      	adds	r3, r7, #7
   11b88:	781b      	ldrb	r3, [r3, #0]
   11b8a:	7013      	strb	r3, [r2, #0]
	while (system_gclk_is_syncing()) {
   11b8c:	46c0      	nop			; (mov r8, r8)
   11b8e:	4b15      	ldr	r3, [pc, #84]	; (11be4 <system_gclk_gen_get_hz+0xb8>)
   11b90:	4798      	blx	r3
   11b92:	1e03      	subs	r3, r0, #0
   11b94:	d1fb      	bne.n	11b8e <system_gclk_gen_get_hz+0x62>
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
   11b96:	4b16      	ldr	r3, [pc, #88]	; (11bf0 <system_gclk_gen_get_hz+0xc4>)
   11b98:	689b      	ldr	r3, [r3, #8]
   11b9a:	021b      	lsls	r3, r3, #8
   11b9c:	0c1b      	lsrs	r3, r3, #16
   11b9e:	b29b      	uxth	r3, r3
   11ba0:	60fb      	str	r3, [r7, #12]

	system_interrupt_leave_critical_section();
   11ba2:	4b16      	ldr	r3, [pc, #88]	; (11bfc <system_gclk_gen_get_hz+0xd0>)
   11ba4:	4798      	blx	r3

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
   11ba6:	2313      	movs	r3, #19
   11ba8:	18fb      	adds	r3, r7, r3
   11baa:	781b      	ldrb	r3, [r3, #0]
   11bac:	2b00      	cmp	r3, #0
   11bae:	d109      	bne.n	11bc4 <system_gclk_gen_get_hz+0x98>
   11bb0:	68fb      	ldr	r3, [r7, #12]
   11bb2:	2b01      	cmp	r3, #1
   11bb4:	d906      	bls.n	11bc4 <system_gclk_gen_get_hz+0x98>
		gen_input_hz /= divider;
   11bb6:	4b12      	ldr	r3, [pc, #72]	; (11c00 <system_gclk_gen_get_hz+0xd4>)
   11bb8:	68f9      	ldr	r1, [r7, #12]
   11bba:	6978      	ldr	r0, [r7, #20]
   11bbc:	4798      	blx	r3
   11bbe:	0003      	movs	r3, r0
   11bc0:	617b      	str	r3, [r7, #20]
   11bc2:	e00a      	b.n	11bda <system_gclk_gen_get_hz+0xae>
	} else if (divsel) {
   11bc4:	2313      	movs	r3, #19
   11bc6:	18fb      	adds	r3, r7, r3
   11bc8:	781b      	ldrb	r3, [r3, #0]
   11bca:	2b00      	cmp	r3, #0
   11bcc:	d005      	beq.n	11bda <system_gclk_gen_get_hz+0xae>
		gen_input_hz >>= (divider+1);
   11bce:	68fb      	ldr	r3, [r7, #12]
   11bd0:	3301      	adds	r3, #1
   11bd2:	697a      	ldr	r2, [r7, #20]
   11bd4:	40da      	lsrs	r2, r3
   11bd6:	0013      	movs	r3, r2
   11bd8:	617b      	str	r3, [r7, #20]
	}

	return gen_input_hz;
   11bda:	697b      	ldr	r3, [r7, #20]
}
   11bdc:	0018      	movs	r0, r3
   11bde:	46bd      	mov	sp, r7
   11be0:	b006      	add	sp, #24
   11be2:	bd80      	pop	{r7, pc}
   11be4:	00011975 	.word	0x00011975
   11be8:	0001194d 	.word	0x0001194d
   11bec:	40000c04 	.word	0x40000c04
   11bf0:	40000c00 	.word	0x40000c00
   11bf4:	000113dd 	.word	0x000113dd
   11bf8:	40000c08 	.word	0x40000c08
   11bfc:	00011961 	.word	0x00011961
   11c00:	000121bd 	.word	0x000121bd

00011c04 <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
   11c04:	b580      	push	{r7, lr}
   11c06:	b084      	sub	sp, #16
   11c08:	af00      	add	r7, sp, #0
   11c0a:	0002      	movs	r2, r0
   11c0c:	6039      	str	r1, [r7, #0]
   11c0e:	1dfb      	adds	r3, r7, #7
   11c10:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Cache the new config to reduce sync requirements */
	uint32_t new_clkctrl_config = (channel << GCLK_CLKCTRL_ID_Pos);
   11c12:	1dfb      	adds	r3, r7, #7
   11c14:	781b      	ldrb	r3, [r3, #0]
   11c16:	60fb      	str	r3, [r7, #12]

	/* Select the desired generic clock generator */
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
   11c18:	683b      	ldr	r3, [r7, #0]
   11c1a:	781b      	ldrb	r3, [r3, #0]
   11c1c:	021b      	lsls	r3, r3, #8
   11c1e:	001a      	movs	r2, r3
   11c20:	68fb      	ldr	r3, [r7, #12]
   11c22:	4313      	orrs	r3, r2
   11c24:	60fb      	str	r3, [r7, #12]

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
   11c26:	1dfb      	adds	r3, r7, #7
   11c28:	781b      	ldrb	r3, [r3, #0]
   11c2a:	0018      	movs	r0, r3
   11c2c:	4b04      	ldr	r3, [pc, #16]	; (11c40 <system_gclk_chan_set_config+0x3c>)
   11c2e:	4798      	blx	r3

	/* Write the new configuration */
	GCLK->CLKCTRL.reg = new_clkctrl_config;
   11c30:	4b04      	ldr	r3, [pc, #16]	; (11c44 <system_gclk_chan_set_config+0x40>)
   11c32:	68fa      	ldr	r2, [r7, #12]
   11c34:	b292      	uxth	r2, r2
   11c36:	805a      	strh	r2, [r3, #2]
}
   11c38:	46c0      	nop			; (mov r8, r8)
   11c3a:	46bd      	mov	sp, r7
   11c3c:	b004      	add	sp, #16
   11c3e:	bd80      	pop	{r7, pc}
   11c40:	00011c91 	.word	0x00011c91
   11c44:	40000c00 	.word	0x40000c00

00011c48 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
   11c48:	b580      	push	{r7, lr}
   11c4a:	b082      	sub	sp, #8
   11c4c:	af00      	add	r7, sp, #0
   11c4e:	0002      	movs	r2, r0
   11c50:	1dfb      	adds	r3, r7, #7
   11c52:	701a      	strb	r2, [r3, #0]
	system_interrupt_enter_critical_section();
   11c54:	4b0a      	ldr	r3, [pc, #40]	; (11c80 <system_gclk_chan_enable+0x38>)
   11c56:	4798      	blx	r3

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
   11c58:	4a0a      	ldr	r2, [pc, #40]	; (11c84 <system_gclk_chan_enable+0x3c>)
   11c5a:	1dfb      	adds	r3, r7, #7
   11c5c:	781b      	ldrb	r3, [r3, #0]
   11c5e:	7013      	strb	r3, [r2, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
   11c60:	4909      	ldr	r1, [pc, #36]	; (11c88 <system_gclk_chan_enable+0x40>)
   11c62:	4b09      	ldr	r3, [pc, #36]	; (11c88 <system_gclk_chan_enable+0x40>)
   11c64:	885b      	ldrh	r3, [r3, #2]
   11c66:	b29b      	uxth	r3, r3
   11c68:	2280      	movs	r2, #128	; 0x80
   11c6a:	01d2      	lsls	r2, r2, #7
   11c6c:	4313      	orrs	r3, r2
   11c6e:	b29b      	uxth	r3, r3
   11c70:	804b      	strh	r3, [r1, #2]

	system_interrupt_leave_critical_section();
   11c72:	4b06      	ldr	r3, [pc, #24]	; (11c8c <system_gclk_chan_enable+0x44>)
   11c74:	4798      	blx	r3
}
   11c76:	46c0      	nop			; (mov r8, r8)
   11c78:	46bd      	mov	sp, r7
   11c7a:	b002      	add	sp, #8
   11c7c:	bd80      	pop	{r7, pc}
   11c7e:	46c0      	nop			; (mov r8, r8)
   11c80:	0001194d 	.word	0x0001194d
   11c84:	40000c02 	.word	0x40000c02
   11c88:	40000c00 	.word	0x40000c00
   11c8c:	00011961 	.word	0x00011961

00011c90 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
   11c90:	b580      	push	{r7, lr}
   11c92:	b084      	sub	sp, #16
   11c94:	af00      	add	r7, sp, #0
   11c96:	0002      	movs	r2, r0
   11c98:	1dfb      	adds	r3, r7, #7
   11c9a:	701a      	strb	r2, [r3, #0]
	system_interrupt_enter_critical_section();
   11c9c:	4b1c      	ldr	r3, [pc, #112]	; (11d10 <system_gclk_chan_disable+0x80>)
   11c9e:	4798      	blx	r3

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
   11ca0:	4a1c      	ldr	r2, [pc, #112]	; (11d14 <system_gclk_chan_disable+0x84>)
   11ca2:	1dfb      	adds	r3, r7, #7
   11ca4:	781b      	ldrb	r3, [r3, #0]
   11ca6:	7013      	strb	r3, [r2, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
   11ca8:	4b1b      	ldr	r3, [pc, #108]	; (11d18 <system_gclk_chan_disable+0x88>)
   11caa:	885b      	ldrh	r3, [r3, #2]
   11cac:	051b      	lsls	r3, r3, #20
   11cae:	0f1b      	lsrs	r3, r3, #28
   11cb0:	b2db      	uxtb	r3, r3
   11cb2:	60fb      	str	r3, [r7, #12]
	GCLK->CLKCTRL.bit.GEN = 0;
   11cb4:	4a18      	ldr	r2, [pc, #96]	; (11d18 <system_gclk_chan_disable+0x88>)
   11cb6:	8853      	ldrh	r3, [r2, #2]
   11cb8:	4918      	ldr	r1, [pc, #96]	; (11d1c <system_gclk_chan_disable+0x8c>)
   11cba:	400b      	ands	r3, r1
   11cbc:	8053      	strh	r3, [r2, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
   11cbe:	4a16      	ldr	r2, [pc, #88]	; (11d18 <system_gclk_chan_disable+0x88>)
   11cc0:	4b15      	ldr	r3, [pc, #84]	; (11d18 <system_gclk_chan_disable+0x88>)
   11cc2:	885b      	ldrh	r3, [r3, #2]
   11cc4:	b29b      	uxth	r3, r3
   11cc6:	4916      	ldr	r1, [pc, #88]	; (11d20 <system_gclk_chan_disable+0x90>)
   11cc8:	400b      	ands	r3, r1
   11cca:	b29b      	uxth	r3, r3
   11ccc:	8053      	strh	r3, [r2, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
   11cce:	46c0      	nop			; (mov r8, r8)
   11cd0:	4b11      	ldr	r3, [pc, #68]	; (11d18 <system_gclk_chan_disable+0x88>)
   11cd2:	885b      	ldrh	r3, [r3, #2]
   11cd4:	b29b      	uxth	r3, r3
   11cd6:	001a      	movs	r2, r3
   11cd8:	2380      	movs	r3, #128	; 0x80
   11cda:	01db      	lsls	r3, r3, #7
   11cdc:	4013      	ands	r3, r2
   11cde:	d1f7      	bne.n	11cd0 <system_gclk_chan_disable+0x40>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
   11ce0:	4a0d      	ldr	r2, [pc, #52]	; (11d18 <system_gclk_chan_disable+0x88>)
   11ce2:	68fb      	ldr	r3, [r7, #12]
   11ce4:	b2db      	uxtb	r3, r3
   11ce6:	1c19      	adds	r1, r3, #0
   11ce8:	230f      	movs	r3, #15
   11cea:	400b      	ands	r3, r1
   11cec:	b2d9      	uxtb	r1, r3
   11cee:	8853      	ldrh	r3, [r2, #2]
   11cf0:	1c08      	adds	r0, r1, #0
   11cf2:	210f      	movs	r1, #15
   11cf4:	4001      	ands	r1, r0
   11cf6:	0208      	lsls	r0, r1, #8
   11cf8:	4908      	ldr	r1, [pc, #32]	; (11d1c <system_gclk_chan_disable+0x8c>)
   11cfa:	400b      	ands	r3, r1
   11cfc:	1c19      	adds	r1, r3, #0
   11cfe:	1c03      	adds	r3, r0, #0
   11d00:	430b      	orrs	r3, r1
   11d02:	8053      	strh	r3, [r2, #2]

	system_interrupt_leave_critical_section();
   11d04:	4b07      	ldr	r3, [pc, #28]	; (11d24 <system_gclk_chan_disable+0x94>)
   11d06:	4798      	blx	r3
}
   11d08:	46c0      	nop			; (mov r8, r8)
   11d0a:	46bd      	mov	sp, r7
   11d0c:	b004      	add	sp, #16
   11d0e:	bd80      	pop	{r7, pc}
   11d10:	0001194d 	.word	0x0001194d
   11d14:	40000c02 	.word	0x40000c02
   11d18:	40000c00 	.word	0x40000c00
   11d1c:	fffff0ff 	.word	0xfffff0ff
   11d20:	ffffbfff 	.word	0xffffbfff
   11d24:	00011961 	.word	0x00011961

00011d28 <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
   11d28:	b580      	push	{r7, lr}
   11d2a:	b084      	sub	sp, #16
   11d2c:	af00      	add	r7, sp, #0
   11d2e:	0002      	movs	r2, r0
   11d30:	1dfb      	adds	r3, r7, #7
   11d32:	701a      	strb	r2, [r3, #0]
	uint8_t gen_id;

	system_interrupt_enter_critical_section();
   11d34:	4b0d      	ldr	r3, [pc, #52]	; (11d6c <system_gclk_chan_get_hz+0x44>)
   11d36:	4798      	blx	r3

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
   11d38:	4a0d      	ldr	r2, [pc, #52]	; (11d70 <system_gclk_chan_get_hz+0x48>)
   11d3a:	1dfb      	adds	r3, r7, #7
   11d3c:	781b      	ldrb	r3, [r3, #0]
   11d3e:	7013      	strb	r3, [r2, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
   11d40:	4b0c      	ldr	r3, [pc, #48]	; (11d74 <system_gclk_chan_get_hz+0x4c>)
   11d42:	885b      	ldrh	r3, [r3, #2]
   11d44:	051b      	lsls	r3, r3, #20
   11d46:	0f1b      	lsrs	r3, r3, #28
   11d48:	b2da      	uxtb	r2, r3
   11d4a:	230f      	movs	r3, #15
   11d4c:	18fb      	adds	r3, r7, r3
   11d4e:	701a      	strb	r2, [r3, #0]

	system_interrupt_leave_critical_section();
   11d50:	4b09      	ldr	r3, [pc, #36]	; (11d78 <system_gclk_chan_get_hz+0x50>)
   11d52:	4798      	blx	r3

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
   11d54:	230f      	movs	r3, #15
   11d56:	18fb      	adds	r3, r7, r3
   11d58:	781b      	ldrb	r3, [r3, #0]
   11d5a:	0018      	movs	r0, r3
   11d5c:	4b07      	ldr	r3, [pc, #28]	; (11d7c <system_gclk_chan_get_hz+0x54>)
   11d5e:	4798      	blx	r3
   11d60:	0003      	movs	r3, r0
}
   11d62:	0018      	movs	r0, r3
   11d64:	46bd      	mov	sp, r7
   11d66:	b004      	add	sp, #16
   11d68:	bd80      	pop	{r7, pc}
   11d6a:	46c0      	nop			; (mov r8, r8)
   11d6c:	0001194d 	.word	0x0001194d
   11d70:	40000c02 	.word	0x40000c02
   11d74:	40000c00 	.word	0x40000c00
   11d78:	00011961 	.word	0x00011961
   11d7c:	00011b2d 	.word	0x00011b2d

00011d80 <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
   11d80:	b580      	push	{r7, lr}
   11d82:	b084      	sub	sp, #16
   11d84:	af00      	add	r7, sp, #0
   11d86:	0002      	movs	r2, r0
   11d88:	1dfb      	adds	r3, r7, #7
   11d8a:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
   11d8c:	230f      	movs	r3, #15
   11d8e:	18fb      	adds	r3, r7, r3
   11d90:	1dfa      	adds	r2, r7, #7
   11d92:	7812      	ldrb	r2, [r2, #0]
   11d94:	09d2      	lsrs	r2, r2, #7
   11d96:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
   11d98:	230e      	movs	r3, #14
   11d9a:	18fb      	adds	r3, r7, r3
   11d9c:	1dfa      	adds	r2, r7, #7
   11d9e:	7812      	ldrb	r2, [r2, #0]
   11da0:	0952      	lsrs	r2, r2, #5
   11da2:	701a      	strb	r2, [r3, #0]

	/* Array of available ports. */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
   11da4:	4b0d      	ldr	r3, [pc, #52]	; (11ddc <system_pinmux_get_group_from_gpio_pin+0x5c>)
   11da6:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
   11da8:	230f      	movs	r3, #15
   11daa:	18fb      	adds	r3, r7, r3
   11dac:	781b      	ldrb	r3, [r3, #0]
   11dae:	2b00      	cmp	r3, #0
   11db0:	d10f      	bne.n	11dd2 <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
   11db2:	230f      	movs	r3, #15
   11db4:	18fb      	adds	r3, r7, r3
   11db6:	781b      	ldrb	r3, [r3, #0]
   11db8:	009b      	lsls	r3, r3, #2
   11dba:	2210      	movs	r2, #16
   11dbc:	4694      	mov	ip, r2
   11dbe:	44bc      	add	ip, r7
   11dc0:	4463      	add	r3, ip
   11dc2:	3b08      	subs	r3, #8
   11dc4:	681a      	ldr	r2, [r3, #0]
   11dc6:	230e      	movs	r3, #14
   11dc8:	18fb      	adds	r3, r7, r3
   11dca:	781b      	ldrb	r3, [r3, #0]
   11dcc:	01db      	lsls	r3, r3, #7
   11dce:	18d3      	adds	r3, r2, r3
   11dd0:	e000      	b.n	11dd4 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
   11dd2:	2300      	movs	r3, #0
	}
}
   11dd4:	0018      	movs	r0, r3
   11dd6:	46bd      	mov	sp, r7
   11dd8:	b004      	add	sp, #16
   11dda:	bd80      	pop	{r7, pc}
   11ddc:	41004400 	.word	0x41004400

00011de0 <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
   11de0:	b580      	push	{r7, lr}
   11de2:	b088      	sub	sp, #32
   11de4:	af00      	add	r7, sp, #0
   11de6:	60f8      	str	r0, [r7, #12]
   11de8:	60b9      	str	r1, [r7, #8]
   11dea:	607a      	str	r2, [r7, #4]
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
   11dec:	2300      	movs	r3, #0
   11dee:	61fb      	str	r3, [r7, #28]

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
   11df0:	687b      	ldr	r3, [r7, #4]
   11df2:	78db      	ldrb	r3, [r3, #3]
   11df4:	2201      	movs	r2, #1
   11df6:	4053      	eors	r3, r2
   11df8:	b2db      	uxtb	r3, r3
   11dfa:	2b00      	cmp	r3, #0
   11dfc:	d035      	beq.n	11e6a <_system_pinmux_config+0x8a>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
   11dfe:	687b      	ldr	r3, [r7, #4]
   11e00:	781b      	ldrb	r3, [r3, #0]
   11e02:	2b80      	cmp	r3, #128	; 0x80
   11e04:	d00b      	beq.n	11e1e <_system_pinmux_config+0x3e>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
   11e06:	69fb      	ldr	r3, [r7, #28]
   11e08:	2280      	movs	r2, #128	; 0x80
   11e0a:	0252      	lsls	r2, r2, #9
   11e0c:	4313      	orrs	r3, r2
   11e0e:	61fb      	str	r3, [r7, #28]
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
   11e10:	687b      	ldr	r3, [r7, #4]
   11e12:	781b      	ldrb	r3, [r3, #0]
   11e14:	061b      	lsls	r3, r3, #24
   11e16:	001a      	movs	r2, r3
   11e18:	69fb      	ldr	r3, [r7, #28]
   11e1a:	4313      	orrs	r3, r2
   11e1c:	61fb      	str	r3, [r7, #28]
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
   11e1e:	687b      	ldr	r3, [r7, #4]
   11e20:	785b      	ldrb	r3, [r3, #1]
   11e22:	2b00      	cmp	r3, #0
   11e24:	d003      	beq.n	11e2e <_system_pinmux_config+0x4e>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
   11e26:	687b      	ldr	r3, [r7, #4]
   11e28:	785b      	ldrb	r3, [r3, #1]
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
   11e2a:	2b02      	cmp	r3, #2
   11e2c:	d110      	bne.n	11e50 <_system_pinmux_config+0x70>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
   11e2e:	69fb      	ldr	r3, [r7, #28]
   11e30:	2280      	movs	r2, #128	; 0x80
   11e32:	0292      	lsls	r2, r2, #10
   11e34:	4313      	orrs	r3, r2
   11e36:	61fb      	str	r3, [r7, #28]

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
   11e38:	687b      	ldr	r3, [r7, #4]
   11e3a:	789b      	ldrb	r3, [r3, #2]
   11e3c:	2b00      	cmp	r3, #0
   11e3e:	d004      	beq.n	11e4a <_system_pinmux_config+0x6a>
				pin_cfg |= PORT_WRCONFIG_PULLEN;
   11e40:	69fb      	ldr	r3, [r7, #28]
   11e42:	2280      	movs	r2, #128	; 0x80
   11e44:	02d2      	lsls	r2, r2, #11
   11e46:	4313      	orrs	r3, r2
   11e48:	61fb      	str	r3, [r7, #28]
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
   11e4a:	68fb      	ldr	r3, [r7, #12]
   11e4c:	68ba      	ldr	r2, [r7, #8]
   11e4e:	605a      	str	r2, [r3, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
   11e50:	687b      	ldr	r3, [r7, #4]
   11e52:	785b      	ldrb	r3, [r3, #1]
   11e54:	2b01      	cmp	r3, #1
   11e56:	d003      	beq.n	11e60 <_system_pinmux_config+0x80>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
   11e58:	687b      	ldr	r3, [r7, #4]
   11e5a:	785b      	ldrb	r3, [r3, #1]
			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
   11e5c:	2b02      	cmp	r3, #2
   11e5e:	d107      	bne.n	11e70 <_system_pinmux_config+0x90>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pull-up if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
   11e60:	69fb      	ldr	r3, [r7, #28]
   11e62:	4a22      	ldr	r2, [pc, #136]	; (11eec <_system_pinmux_config+0x10c>)
   11e64:	4013      	ands	r3, r2
   11e66:	61fb      	str	r3, [r7, #28]
   11e68:	e002      	b.n	11e70 <_system_pinmux_config+0x90>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
   11e6a:	68fb      	ldr	r3, [r7, #12]
   11e6c:	68ba      	ldr	r2, [r7, #8]
   11e6e:	605a      	str	r2, [r3, #4]
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
   11e70:	68bb      	ldr	r3, [r7, #8]
   11e72:	041b      	lsls	r3, r3, #16
   11e74:	0c1b      	lsrs	r3, r3, #16
   11e76:	61bb      	str	r3, [r7, #24]
	uint32_t upper_pin_mask = (pin_mask >> 16);
   11e78:	68bb      	ldr	r3, [r7, #8]
   11e7a:	0c1b      	lsrs	r3, r3, #16
   11e7c:	617b      	str	r3, [r7, #20]

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
   11e7e:	69ba      	ldr	r2, [r7, #24]
   11e80:	69fb      	ldr	r3, [r7, #28]
   11e82:	4313      	orrs	r3, r2
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
   11e84:	22a0      	movs	r2, #160	; 0xa0
   11e86:	05d2      	lsls	r2, r2, #23
   11e88:	431a      	orrs	r2, r3
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
   11e8a:	68fb      	ldr	r3, [r7, #12]
   11e8c:	629a      	str	r2, [r3, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
   11e8e:	697a      	ldr	r2, [r7, #20]
   11e90:	69fb      	ldr	r3, [r7, #28]
   11e92:	4313      	orrs	r3, r2
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
   11e94:	22d0      	movs	r2, #208	; 0xd0
   11e96:	0612      	lsls	r2, r2, #24
   11e98:	431a      	orrs	r2, r3
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
   11e9a:	68fb      	ldr	r3, [r7, #12]
   11e9c:	629a      	str	r2, [r3, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
   11e9e:	687b      	ldr	r3, [r7, #4]
   11ea0:	78db      	ldrb	r3, [r3, #3]
   11ea2:	2201      	movs	r2, #1
   11ea4:	4053      	eors	r3, r2
   11ea6:	b2db      	uxtb	r3, r3
   11ea8:	2b00      	cmp	r3, #0
   11eaa:	d01a      	beq.n	11ee2 <_system_pinmux_config+0x102>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
   11eac:	69fa      	ldr	r2, [r7, #28]
   11eae:	2380      	movs	r3, #128	; 0x80
   11eb0:	02db      	lsls	r3, r3, #11
   11eb2:	4013      	ands	r3, r2
   11eb4:	d00a      	beq.n	11ecc <_system_pinmux_config+0xec>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
   11eb6:	687b      	ldr	r3, [r7, #4]
   11eb8:	789b      	ldrb	r3, [r3, #2]
   11eba:	2b01      	cmp	r3, #1
   11ebc:	d103      	bne.n	11ec6 <_system_pinmux_config+0xe6>
				port->OUTSET.reg = pin_mask;
   11ebe:	68fb      	ldr	r3, [r7, #12]
   11ec0:	68ba      	ldr	r2, [r7, #8]
   11ec2:	619a      	str	r2, [r3, #24]
   11ec4:	e002      	b.n	11ecc <_system_pinmux_config+0xec>
			} else {
				port->OUTCLR.reg = pin_mask;
   11ec6:	68fb      	ldr	r3, [r7, #12]
   11ec8:	68ba      	ldr	r2, [r7, #8]
   11eca:	615a      	str	r2, [r3, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
   11ecc:	687b      	ldr	r3, [r7, #4]
   11ece:	785b      	ldrb	r3, [r3, #1]
   11ed0:	2b01      	cmp	r3, #1
   11ed2:	d003      	beq.n	11edc <_system_pinmux_config+0xfc>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
   11ed4:	687b      	ldr	r3, [r7, #4]
   11ed6:	785b      	ldrb	r3, [r3, #1]
				port->OUTCLR.reg = pin_mask;
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
   11ed8:	2b02      	cmp	r3, #2
   11eda:	d102      	bne.n	11ee2 <_system_pinmux_config+0x102>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
   11edc:	68fb      	ldr	r3, [r7, #12]
   11ede:	68ba      	ldr	r2, [r7, #8]
   11ee0:	609a      	str	r2, [r3, #8]
		}
	}
}
   11ee2:	46c0      	nop			; (mov r8, r8)
   11ee4:	46bd      	mov	sp, r7
   11ee6:	b008      	add	sp, #32
   11ee8:	bd80      	pop	{r7, pc}
   11eea:	46c0      	nop			; (mov r8, r8)
   11eec:	fffbffff 	.word	0xfffbffff

00011ef0 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
   11ef0:	b580      	push	{r7, lr}
   11ef2:	b084      	sub	sp, #16
   11ef4:	af00      	add	r7, sp, #0
   11ef6:	0002      	movs	r2, r0
   11ef8:	6039      	str	r1, [r7, #0]
   11efa:	1dfb      	adds	r3, r7, #7
   11efc:	701a      	strb	r2, [r3, #0]
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
   11efe:	1dfb      	adds	r3, r7, #7
   11f00:	781b      	ldrb	r3, [r3, #0]
   11f02:	0018      	movs	r0, r3
   11f04:	4b0a      	ldr	r3, [pc, #40]	; (11f30 <system_pinmux_pin_set_config+0x40>)
   11f06:	4798      	blx	r3
   11f08:	0003      	movs	r3, r0
   11f0a:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
   11f0c:	1dfb      	adds	r3, r7, #7
   11f0e:	781b      	ldrb	r3, [r3, #0]
   11f10:	221f      	movs	r2, #31
   11f12:	4013      	ands	r3, r2
   11f14:	2201      	movs	r2, #1
   11f16:	409a      	lsls	r2, r3
   11f18:	0013      	movs	r3, r2
   11f1a:	60bb      	str	r3, [r7, #8]

	_system_pinmux_config(port, pin_mask, config);
   11f1c:	683a      	ldr	r2, [r7, #0]
   11f1e:	68b9      	ldr	r1, [r7, #8]
   11f20:	68fb      	ldr	r3, [r7, #12]
   11f22:	0018      	movs	r0, r3
   11f24:	4b03      	ldr	r3, [pc, #12]	; (11f34 <system_pinmux_pin_set_config+0x44>)
   11f26:	4798      	blx	r3
}
   11f28:	46c0      	nop			; (mov r8, r8)
   11f2a:	46bd      	mov	sp, r7
   11f2c:	b004      	add	sp, #16
   11f2e:	bd80      	pop	{r7, pc}
   11f30:	00011d81 	.word	0x00011d81
   11f34:	00011de1 	.word	0x00011de1

00011f38 <_system_dummy_init>:
 * Dummy initialization function, used as a weak alias target for the various
 * init functions called by \ref system_init().
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
   11f38:	b580      	push	{r7, lr}
   11f3a:	af00      	add	r7, sp, #0
	return;
   11f3c:	46c0      	nop			; (mov r8, r8)
}
   11f3e:	46bd      	mov	sp, r7
   11f40:	bd80      	pop	{r7, pc}
   11f42:	46c0      	nop			; (mov r8, r8)

00011f44 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
   11f44:	b580      	push	{r7, lr}
   11f46:	af00      	add	r7, sp, #0
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
   11f48:	4b06      	ldr	r3, [pc, #24]	; (11f64 <system_init+0x20>)
   11f4a:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
   11f4c:	4b06      	ldr	r3, [pc, #24]	; (11f68 <system_init+0x24>)
   11f4e:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
   11f50:	4b06      	ldr	r3, [pc, #24]	; (11f6c <system_init+0x28>)
   11f52:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
   11f54:	4b06      	ldr	r3, [pc, #24]	; (11f70 <system_init+0x2c>)
   11f56:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
   11f58:	4b06      	ldr	r3, [pc, #24]	; (11f74 <system_init+0x30>)
   11f5a:	4798      	blx	r3
}
   11f5c:	46c0      	nop			; (mov r8, r8)
   11f5e:	46bd      	mov	sp, r7
   11f60:	bd80      	pop	{r7, pc}
   11f62:	46c0      	nop			; (mov r8, r8)
   11f64:	0001172d 	.word	0x0001172d
   11f68:	00011155 	.word	0x00011155
   11f6c:	00011f39 	.word	0x00011f39
   11f70:	00003575 	.word	0x00003575
   11f74:	00011f39 	.word	0x00011f39

00011f78 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
   11f78:	b580      	push	{r7, lr}
   11f7a:	b082      	sub	sp, #8
   11f7c:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
   11f7e:	4b2f      	ldr	r3, [pc, #188]	; (1203c <Reset_Handler+0xc4>)
   11f80:	607b      	str	r3, [r7, #4]
        pDest = &_srelocate;
   11f82:	4b2f      	ldr	r3, [pc, #188]	; (12040 <Reset_Handler+0xc8>)
   11f84:	603b      	str	r3, [r7, #0]

        if (pSrc != pDest) {
   11f86:	687a      	ldr	r2, [r7, #4]
   11f88:	683b      	ldr	r3, [r7, #0]
   11f8a:	429a      	cmp	r2, r3
   11f8c:	d00c      	beq.n	11fa8 <Reset_Handler+0x30>
                for (; pDest < &_erelocate;) {
   11f8e:	e007      	b.n	11fa0 <Reset_Handler+0x28>
                        *pDest++ = *pSrc++;
   11f90:	683b      	ldr	r3, [r7, #0]
   11f92:	1d1a      	adds	r2, r3, #4
   11f94:	603a      	str	r2, [r7, #0]
   11f96:	687a      	ldr	r2, [r7, #4]
   11f98:	1d11      	adds	r1, r2, #4
   11f9a:	6079      	str	r1, [r7, #4]
   11f9c:	6812      	ldr	r2, [r2, #0]
   11f9e:	601a      	str	r2, [r3, #0]
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
   11fa0:	683a      	ldr	r2, [r7, #0]
   11fa2:	4b28      	ldr	r3, [pc, #160]	; (12044 <Reset_Handler+0xcc>)
   11fa4:	429a      	cmp	r2, r3
   11fa6:	d3f3      	bcc.n	11f90 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
   11fa8:	4b27      	ldr	r3, [pc, #156]	; (12048 <Reset_Handler+0xd0>)
   11faa:	603b      	str	r3, [r7, #0]
   11fac:	e004      	b.n	11fb8 <Reset_Handler+0x40>
                *pDest++ = 0;
   11fae:	683b      	ldr	r3, [r7, #0]
   11fb0:	1d1a      	adds	r2, r3, #4
   11fb2:	603a      	str	r2, [r7, #0]
   11fb4:	2200      	movs	r2, #0
   11fb6:	601a      	str	r2, [r3, #0]
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
   11fb8:	683a      	ldr	r2, [r7, #0]
   11fba:	4b24      	ldr	r3, [pc, #144]	; (1204c <Reset_Handler+0xd4>)
   11fbc:	429a      	cmp	r2, r3
   11fbe:	d3f6      	bcc.n	11fae <Reset_Handler+0x36>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
   11fc0:	4b23      	ldr	r3, [pc, #140]	; (12050 <Reset_Handler+0xd8>)
   11fc2:	607b      	str	r3, [r7, #4]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
   11fc4:	4b23      	ldr	r3, [pc, #140]	; (12054 <Reset_Handler+0xdc>)
   11fc6:	687a      	ldr	r2, [r7, #4]
   11fc8:	21ff      	movs	r1, #255	; 0xff
   11fca:	438a      	bics	r2, r1
   11fcc:	609a      	str	r2, [r3, #8]

        /* Change default QOS values to have the best performance and correct USB behaviour */
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
   11fce:	4a22      	ldr	r2, [pc, #136]	; (12058 <Reset_Handler+0xe0>)
   11fd0:	2390      	movs	r3, #144	; 0x90
   11fd2:	005b      	lsls	r3, r3, #1
   11fd4:	2102      	movs	r1, #2
   11fd6:	50d1      	str	r1, [r2, r3]
#if defined(ID_USB)
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
   11fd8:	4a20      	ldr	r2, [pc, #128]	; (1205c <Reset_Handler+0xe4>)
   11fda:	78d3      	ldrb	r3, [r2, #3]
   11fdc:	2103      	movs	r1, #3
   11fde:	438b      	bics	r3, r1
   11fe0:	1c19      	adds	r1, r3, #0
   11fe2:	2302      	movs	r3, #2
   11fe4:	430b      	orrs	r3, r1
   11fe6:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
   11fe8:	4a1c      	ldr	r2, [pc, #112]	; (1205c <Reset_Handler+0xe4>)
   11fea:	78d3      	ldrb	r3, [r2, #3]
   11fec:	210c      	movs	r1, #12
   11fee:	438b      	bics	r3, r1
   11ff0:	1c19      	adds	r1, r3, #0
   11ff2:	2308      	movs	r3, #8
   11ff4:	430b      	orrs	r3, r1
   11ff6:	70d3      	strb	r3, [r2, #3]
#endif
        DMAC->QOSCTRL.bit.DQOS = 2;
   11ff8:	4a19      	ldr	r2, [pc, #100]	; (12060 <Reset_Handler+0xe8>)
   11ffa:	7b93      	ldrb	r3, [r2, #14]
   11ffc:	2130      	movs	r1, #48	; 0x30
   11ffe:	438b      	bics	r3, r1
   12000:	1c19      	adds	r1, r3, #0
   12002:	2320      	movs	r3, #32
   12004:	430b      	orrs	r3, r1
   12006:	7393      	strb	r3, [r2, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
   12008:	4a15      	ldr	r2, [pc, #84]	; (12060 <Reset_Handler+0xe8>)
   1200a:	7b93      	ldrb	r3, [r2, #14]
   1200c:	210c      	movs	r1, #12
   1200e:	438b      	bics	r3, r1
   12010:	1c19      	adds	r1, r3, #0
   12012:	2308      	movs	r3, #8
   12014:	430b      	orrs	r3, r1
   12016:	7393      	strb	r3, [r2, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
   12018:	4a11      	ldr	r2, [pc, #68]	; (12060 <Reset_Handler+0xe8>)
   1201a:	7b93      	ldrb	r3, [r2, #14]
   1201c:	2103      	movs	r1, #3
   1201e:	438b      	bics	r3, r1
   12020:	1c19      	adds	r1, r3, #0
   12022:	2302      	movs	r3, #2
   12024:	430b      	orrs	r3, r1
   12026:	7393      	strb	r3, [r2, #14]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
   12028:	4a0e      	ldr	r2, [pc, #56]	; (12064 <Reset_Handler+0xec>)
   1202a:	6853      	ldr	r3, [r2, #4]
   1202c:	2180      	movs	r1, #128	; 0x80
   1202e:	430b      	orrs	r3, r1
   12030:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
   12032:	4b0d      	ldr	r3, [pc, #52]	; (12068 <Reset_Handler+0xf0>)
   12034:	4798      	blx	r3

        /* Branch to main function */
        main();
   12036:	4b0d      	ldr	r3, [pc, #52]	; (1206c <Reset_Handler+0xf4>)
   12038:	4798      	blx	r3

        /* Infinite loop */
        while (1);
   1203a:	e7fe      	b.n	1203a <Reset_Handler+0xc2>
   1203c:	00015c40 	.word	0x00015c40
   12040:	20000000 	.word	0x20000000
   12044:	200001e8 	.word	0x200001e8
   12048:	200001e8 	.word	0x200001e8
   1204c:	20001884 	.word	0x20001884
   12050:	00000000 	.word	0x00000000
   12054:	e000ed00 	.word	0xe000ed00
   12058:	41007000 	.word	0x41007000
   1205c:	41005000 	.word	0x41005000
   12060:	41004800 	.word	0x41004800
   12064:	41004000 	.word	0x41004000
   12068:	00012755 	.word	0x00012755
   1206c:	00012111 	.word	0x00012111

00012070 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
   12070:	b580      	push	{r7, lr}
   12072:	af00      	add	r7, sp, #0
        while (1) {
        }
   12074:	e7fe      	b.n	12074 <Dummy_Handler+0x4>
   12076:	46c0      	nop			; (mov r8, r8)

00012078 <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
   12078:	b580      	push	{r7, lr}
   1207a:	b084      	sub	sp, #16
   1207c:	af00      	add	r7, sp, #0
   1207e:	6078      	str	r0, [r7, #4]
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;

	if (heap == NULL) {
   12080:	4b0a      	ldr	r3, [pc, #40]	; (120ac <_sbrk+0x34>)
   12082:	681b      	ldr	r3, [r3, #0]
   12084:	2b00      	cmp	r3, #0
   12086:	d102      	bne.n	1208e <_sbrk+0x16>
		heap = (unsigned char *)&_end;
   12088:	4b08      	ldr	r3, [pc, #32]	; (120ac <_sbrk+0x34>)
   1208a:	4a09      	ldr	r2, [pc, #36]	; (120b0 <_sbrk+0x38>)
   1208c:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
   1208e:	4b07      	ldr	r3, [pc, #28]	; (120ac <_sbrk+0x34>)
   12090:	681b      	ldr	r3, [r3, #0]
   12092:	60fb      	str	r3, [r7, #12]

	heap += incr;
   12094:	4b05      	ldr	r3, [pc, #20]	; (120ac <_sbrk+0x34>)
   12096:	681a      	ldr	r2, [r3, #0]
   12098:	687b      	ldr	r3, [r7, #4]
   1209a:	18d2      	adds	r2, r2, r3
   1209c:	4b03      	ldr	r3, [pc, #12]	; (120ac <_sbrk+0x34>)
   1209e:	601a      	str	r2, [r3, #0]

	return (caddr_t) prev_heap;
   120a0:	68fb      	ldr	r3, [r7, #12]
}
   120a2:	0018      	movs	r0, r3
   120a4:	46bd      	mov	sp, r7
   120a6:	b004      	add	sp, #16
   120a8:	bd80      	pop	{r7, pc}
   120aa:	46c0      	nop			; (mov r8, r8)
   120ac:	20000960 	.word	0x20000960
   120b0:	20003888 	.word	0x20003888

000120b4 <_close>:
{
	return -1;
}

extern int _close(int file)
{
   120b4:	b580      	push	{r7, lr}
   120b6:	b082      	sub	sp, #8
   120b8:	af00      	add	r7, sp, #0
   120ba:	6078      	str	r0, [r7, #4]
	return -1;
   120bc:	2301      	movs	r3, #1
   120be:	425b      	negs	r3, r3
}
   120c0:	0018      	movs	r0, r3
   120c2:	46bd      	mov	sp, r7
   120c4:	b002      	add	sp, #8
   120c6:	bd80      	pop	{r7, pc}

000120c8 <_fstat>:

extern int _fstat(int file, struct stat *st)
{
   120c8:	b580      	push	{r7, lr}
   120ca:	b082      	sub	sp, #8
   120cc:	af00      	add	r7, sp, #0
   120ce:	6078      	str	r0, [r7, #4]
   120d0:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
   120d2:	683b      	ldr	r3, [r7, #0]
   120d4:	2280      	movs	r2, #128	; 0x80
   120d6:	0192      	lsls	r2, r2, #6
   120d8:	605a      	str	r2, [r3, #4]

	return 0;
   120da:	2300      	movs	r3, #0
}
   120dc:	0018      	movs	r0, r3
   120de:	46bd      	mov	sp, r7
   120e0:	b002      	add	sp, #8
   120e2:	bd80      	pop	{r7, pc}

000120e4 <_isatty>:

extern int _isatty(int file)
{
   120e4:	b580      	push	{r7, lr}
   120e6:	b082      	sub	sp, #8
   120e8:	af00      	add	r7, sp, #0
   120ea:	6078      	str	r0, [r7, #4]
	return 1;
   120ec:	2301      	movs	r3, #1
}
   120ee:	0018      	movs	r0, r3
   120f0:	46bd      	mov	sp, r7
   120f2:	b002      	add	sp, #8
   120f4:	bd80      	pop	{r7, pc}
   120f6:	46c0      	nop			; (mov r8, r8)

000120f8 <_lseek>:

extern int _lseek(int file, int ptr, int dir)
{
   120f8:	b580      	push	{r7, lr}
   120fa:	b084      	sub	sp, #16
   120fc:	af00      	add	r7, sp, #0
   120fe:	60f8      	str	r0, [r7, #12]
   12100:	60b9      	str	r1, [r7, #8]
   12102:	607a      	str	r2, [r7, #4]
	return 0;
   12104:	2300      	movs	r3, #0
}
   12106:	0018      	movs	r0, r3
   12108:	46bd      	mov	sp, r7
   1210a:	b004      	add	sp, #16
   1210c:	bd80      	pop	{r7, pc}
   1210e:	46c0      	nop			; (mov r8, r8)

00012110 <main>:
}



int main(void)
{
   12110:	b580      	push	{r7, lr}
   12112:	b082      	sub	sp, #8
   12114:	af00      	add	r7, sp, #0
	system_init();
   12116:	4b1e      	ldr	r3, [pc, #120]	; (12190 <main+0x80>)
   12118:	4798      	blx	r3

	// Initialize interrupt vector table support.
	irq_initialize_vectors();

	// Enable interrupts
	cpu_irq_enable();
   1211a:	4b1e      	ldr	r3, [pc, #120]	; (12194 <main+0x84>)
   1211c:	2201      	movs	r2, #1
   1211e:	701a      	strb	r2, [r3, #0]
   12120:	f3bf 8f5f 	dmb	sy
   12124:	b662      	cpsie	i

	stdio_usb_init();
   12126:	4b1c      	ldr	r3, [pc, #112]	; (12198 <main+0x88>)
   12128:	4798      	blx	r3
			
	uint8_t ch;
    
    atcab_init( &cfg_ateccx08a_i2c_default );
   1212a:	4b1c      	ldr	r3, [pc, #112]	; (1219c <main+0x8c>)
   1212c:	0018      	movs	r0, r3
   1212e:	4b1c      	ldr	r3, [pc, #112]	; (121a0 <main+0x90>)
   12130:	4798      	blx	r3
	
	//uint8_t number[32];
	//atcab_random(number);
	
	while (true) { // original True
		ch = 0;
   12132:	1dfb      	adds	r3, r7, #7
   12134:	2200      	movs	r2, #0
   12136:	701a      	strb	r2, [r3, #0]
		if (udi_cdc_is_rx_ready())
   12138:	4b1a      	ldr	r3, [pc, #104]	; (121a4 <main+0x94>)
   1213a:	4798      	blx	r3
   1213c:	1e03      	subs	r3, r0, #0
   1213e:	d005      	beq.n	1214c <main+0x3c>
			scanf("%c",&ch);
   12140:	1dfa      	adds	r2, r7, #7
   12142:	4b19      	ldr	r3, [pc, #100]	; (121a8 <main+0x98>)
   12144:	0011      	movs	r1, r2
   12146:	0018      	movs	r0, r3
   12148:	4b18      	ldr	r3, [pc, #96]	; (121ac <main+0x9c>)
   1214a:	4798      	blx	r3
	
		if (ch) {
   1214c:	1dfb      	adds	r3, r7, #7
   1214e:	781b      	ldrb	r3, [r3, #0]
   12150:	2b00      	cmp	r3, #0
   12152:	d0ee      	beq.n	12132 <main+0x22>
			printf("%c",ch); // echo to output
   12154:	1dfb      	adds	r3, r7, #7
   12156:	781b      	ldrb	r3, [r3, #0]
   12158:	0018      	movs	r0, r3
   1215a:	4b15      	ldr	r3, [pc, #84]	; (121b0 <main+0xa0>)
   1215c:	4798      	blx	r3
			if ( ch == 0x0d || ch == 0x0a ) {
   1215e:	1dfb      	adds	r3, r7, #7
   12160:	781b      	ldrb	r3, [r3, #0]
   12162:	2b0d      	cmp	r3, #13
   12164:	d003      	beq.n	1216e <main+0x5e>
   12166:	1dfb      	adds	r3, r7, #7
   12168:	781b      	ldrb	r3, [r3, #0]
   1216a:	2b0a      	cmp	r3, #10
   1216c:	d102      	bne.n	12174 <main+0x64>
				processCmd();
   1216e:	4b11      	ldr	r3, [pc, #68]	; (121b4 <main+0xa4>)
   12170:	4798      	blx	r3
   12172:	e00c      	b.n	1218e <main+0x7e>
			} else {
				CBUF_Push( cmdQ, ch );  // queue character into circular buffer
   12174:	4b10      	ldr	r3, [pc, #64]	; (121b8 <main+0xa8>)
   12176:	785b      	ldrb	r3, [r3, #1]
   12178:	b2db      	uxtb	r3, r3
   1217a:	1c5a      	adds	r2, r3, #1
   1217c:	b2d1      	uxtb	r1, r2
   1217e:	4a0e      	ldr	r2, [pc, #56]	; (121b8 <main+0xa8>)
   12180:	7051      	strb	r1, [r2, #1]
   12182:	0019      	movs	r1, r3
   12184:	1dfb      	adds	r3, r7, #7
   12186:	781a      	ldrb	r2, [r3, #0]
   12188:	4b0b      	ldr	r3, [pc, #44]	; (121b8 <main+0xa8>)
   1218a:	185b      	adds	r3, r3, r1
   1218c:	709a      	strb	r2, [r3, #2]
			}
		}
	}
   1218e:	e7d0      	b.n	12132 <main+0x22>
   12190:	00011f45 	.word	0x00011f45
   12194:	2000017c 	.word	0x2000017c
   12198:	00003431 	.word	0x00003431
   1219c:	20000074 	.word	0x20000074
   121a0:	0000acf9 	.word	0x0000acf9
   121a4:	0000238d 	.word	0x0000238d
   121a8:	00015a50 	.word	0x00015a50
   121ac:	00012ac5 	.word	0x00012ac5
   121b0:	000129a1 	.word	0x000129a1
   121b4:	0000f07d 	.word	0x0000f07d
   121b8:	20001578 	.word	0x20001578

000121bc <__aeabi_uidiv>:
   121bc:	2200      	movs	r2, #0
   121be:	0843      	lsrs	r3, r0, #1
   121c0:	428b      	cmp	r3, r1
   121c2:	d374      	bcc.n	122ae <__aeabi_uidiv+0xf2>
   121c4:	0903      	lsrs	r3, r0, #4
   121c6:	428b      	cmp	r3, r1
   121c8:	d35f      	bcc.n	1228a <__aeabi_uidiv+0xce>
   121ca:	0a03      	lsrs	r3, r0, #8
   121cc:	428b      	cmp	r3, r1
   121ce:	d344      	bcc.n	1225a <__aeabi_uidiv+0x9e>
   121d0:	0b03      	lsrs	r3, r0, #12
   121d2:	428b      	cmp	r3, r1
   121d4:	d328      	bcc.n	12228 <__aeabi_uidiv+0x6c>
   121d6:	0c03      	lsrs	r3, r0, #16
   121d8:	428b      	cmp	r3, r1
   121da:	d30d      	bcc.n	121f8 <__aeabi_uidiv+0x3c>
   121dc:	22ff      	movs	r2, #255	; 0xff
   121de:	0209      	lsls	r1, r1, #8
   121e0:	ba12      	rev	r2, r2
   121e2:	0c03      	lsrs	r3, r0, #16
   121e4:	428b      	cmp	r3, r1
   121e6:	d302      	bcc.n	121ee <__aeabi_uidiv+0x32>
   121e8:	1212      	asrs	r2, r2, #8
   121ea:	0209      	lsls	r1, r1, #8
   121ec:	d065      	beq.n	122ba <__aeabi_uidiv+0xfe>
   121ee:	0b03      	lsrs	r3, r0, #12
   121f0:	428b      	cmp	r3, r1
   121f2:	d319      	bcc.n	12228 <__aeabi_uidiv+0x6c>
   121f4:	e000      	b.n	121f8 <__aeabi_uidiv+0x3c>
   121f6:	0a09      	lsrs	r1, r1, #8
   121f8:	0bc3      	lsrs	r3, r0, #15
   121fa:	428b      	cmp	r3, r1
   121fc:	d301      	bcc.n	12202 <__aeabi_uidiv+0x46>
   121fe:	03cb      	lsls	r3, r1, #15
   12200:	1ac0      	subs	r0, r0, r3
   12202:	4152      	adcs	r2, r2
   12204:	0b83      	lsrs	r3, r0, #14
   12206:	428b      	cmp	r3, r1
   12208:	d301      	bcc.n	1220e <__aeabi_uidiv+0x52>
   1220a:	038b      	lsls	r3, r1, #14
   1220c:	1ac0      	subs	r0, r0, r3
   1220e:	4152      	adcs	r2, r2
   12210:	0b43      	lsrs	r3, r0, #13
   12212:	428b      	cmp	r3, r1
   12214:	d301      	bcc.n	1221a <__aeabi_uidiv+0x5e>
   12216:	034b      	lsls	r3, r1, #13
   12218:	1ac0      	subs	r0, r0, r3
   1221a:	4152      	adcs	r2, r2
   1221c:	0b03      	lsrs	r3, r0, #12
   1221e:	428b      	cmp	r3, r1
   12220:	d301      	bcc.n	12226 <__aeabi_uidiv+0x6a>
   12222:	030b      	lsls	r3, r1, #12
   12224:	1ac0      	subs	r0, r0, r3
   12226:	4152      	adcs	r2, r2
   12228:	0ac3      	lsrs	r3, r0, #11
   1222a:	428b      	cmp	r3, r1
   1222c:	d301      	bcc.n	12232 <__aeabi_uidiv+0x76>
   1222e:	02cb      	lsls	r3, r1, #11
   12230:	1ac0      	subs	r0, r0, r3
   12232:	4152      	adcs	r2, r2
   12234:	0a83      	lsrs	r3, r0, #10
   12236:	428b      	cmp	r3, r1
   12238:	d301      	bcc.n	1223e <__aeabi_uidiv+0x82>
   1223a:	028b      	lsls	r3, r1, #10
   1223c:	1ac0      	subs	r0, r0, r3
   1223e:	4152      	adcs	r2, r2
   12240:	0a43      	lsrs	r3, r0, #9
   12242:	428b      	cmp	r3, r1
   12244:	d301      	bcc.n	1224a <__aeabi_uidiv+0x8e>
   12246:	024b      	lsls	r3, r1, #9
   12248:	1ac0      	subs	r0, r0, r3
   1224a:	4152      	adcs	r2, r2
   1224c:	0a03      	lsrs	r3, r0, #8
   1224e:	428b      	cmp	r3, r1
   12250:	d301      	bcc.n	12256 <__aeabi_uidiv+0x9a>
   12252:	020b      	lsls	r3, r1, #8
   12254:	1ac0      	subs	r0, r0, r3
   12256:	4152      	adcs	r2, r2
   12258:	d2cd      	bcs.n	121f6 <__aeabi_uidiv+0x3a>
   1225a:	09c3      	lsrs	r3, r0, #7
   1225c:	428b      	cmp	r3, r1
   1225e:	d301      	bcc.n	12264 <__aeabi_uidiv+0xa8>
   12260:	01cb      	lsls	r3, r1, #7
   12262:	1ac0      	subs	r0, r0, r3
   12264:	4152      	adcs	r2, r2
   12266:	0983      	lsrs	r3, r0, #6
   12268:	428b      	cmp	r3, r1
   1226a:	d301      	bcc.n	12270 <__aeabi_uidiv+0xb4>
   1226c:	018b      	lsls	r3, r1, #6
   1226e:	1ac0      	subs	r0, r0, r3
   12270:	4152      	adcs	r2, r2
   12272:	0943      	lsrs	r3, r0, #5
   12274:	428b      	cmp	r3, r1
   12276:	d301      	bcc.n	1227c <__aeabi_uidiv+0xc0>
   12278:	014b      	lsls	r3, r1, #5
   1227a:	1ac0      	subs	r0, r0, r3
   1227c:	4152      	adcs	r2, r2
   1227e:	0903      	lsrs	r3, r0, #4
   12280:	428b      	cmp	r3, r1
   12282:	d301      	bcc.n	12288 <__aeabi_uidiv+0xcc>
   12284:	010b      	lsls	r3, r1, #4
   12286:	1ac0      	subs	r0, r0, r3
   12288:	4152      	adcs	r2, r2
   1228a:	08c3      	lsrs	r3, r0, #3
   1228c:	428b      	cmp	r3, r1
   1228e:	d301      	bcc.n	12294 <__aeabi_uidiv+0xd8>
   12290:	00cb      	lsls	r3, r1, #3
   12292:	1ac0      	subs	r0, r0, r3
   12294:	4152      	adcs	r2, r2
   12296:	0883      	lsrs	r3, r0, #2
   12298:	428b      	cmp	r3, r1
   1229a:	d301      	bcc.n	122a0 <__aeabi_uidiv+0xe4>
   1229c:	008b      	lsls	r3, r1, #2
   1229e:	1ac0      	subs	r0, r0, r3
   122a0:	4152      	adcs	r2, r2
   122a2:	0843      	lsrs	r3, r0, #1
   122a4:	428b      	cmp	r3, r1
   122a6:	d301      	bcc.n	122ac <__aeabi_uidiv+0xf0>
   122a8:	004b      	lsls	r3, r1, #1
   122aa:	1ac0      	subs	r0, r0, r3
   122ac:	4152      	adcs	r2, r2
   122ae:	1a41      	subs	r1, r0, r1
   122b0:	d200      	bcs.n	122b4 <__aeabi_uidiv+0xf8>
   122b2:	4601      	mov	r1, r0
   122b4:	4152      	adcs	r2, r2
   122b6:	4610      	mov	r0, r2
   122b8:	4770      	bx	lr
   122ba:	e7ff      	b.n	122bc <__aeabi_uidiv+0x100>
   122bc:	b501      	push	{r0, lr}
   122be:	2000      	movs	r0, #0
   122c0:	f000 f8f0 	bl	124a4 <__aeabi_idiv0>
   122c4:	bd02      	pop	{r1, pc}
   122c6:	46c0      	nop			; (mov r8, r8)

000122c8 <__aeabi_uidivmod>:
   122c8:	2900      	cmp	r1, #0
   122ca:	d0f7      	beq.n	122bc <__aeabi_uidiv+0x100>
   122cc:	e776      	b.n	121bc <__aeabi_uidiv>
   122ce:	4770      	bx	lr

000122d0 <__aeabi_idiv>:
   122d0:	4603      	mov	r3, r0
   122d2:	430b      	orrs	r3, r1
   122d4:	d47f      	bmi.n	123d6 <__aeabi_idiv+0x106>
   122d6:	2200      	movs	r2, #0
   122d8:	0843      	lsrs	r3, r0, #1
   122da:	428b      	cmp	r3, r1
   122dc:	d374      	bcc.n	123c8 <__aeabi_idiv+0xf8>
   122de:	0903      	lsrs	r3, r0, #4
   122e0:	428b      	cmp	r3, r1
   122e2:	d35f      	bcc.n	123a4 <__aeabi_idiv+0xd4>
   122e4:	0a03      	lsrs	r3, r0, #8
   122e6:	428b      	cmp	r3, r1
   122e8:	d344      	bcc.n	12374 <__aeabi_idiv+0xa4>
   122ea:	0b03      	lsrs	r3, r0, #12
   122ec:	428b      	cmp	r3, r1
   122ee:	d328      	bcc.n	12342 <__aeabi_idiv+0x72>
   122f0:	0c03      	lsrs	r3, r0, #16
   122f2:	428b      	cmp	r3, r1
   122f4:	d30d      	bcc.n	12312 <__aeabi_idiv+0x42>
   122f6:	22ff      	movs	r2, #255	; 0xff
   122f8:	0209      	lsls	r1, r1, #8
   122fa:	ba12      	rev	r2, r2
   122fc:	0c03      	lsrs	r3, r0, #16
   122fe:	428b      	cmp	r3, r1
   12300:	d302      	bcc.n	12308 <__aeabi_idiv+0x38>
   12302:	1212      	asrs	r2, r2, #8
   12304:	0209      	lsls	r1, r1, #8
   12306:	d065      	beq.n	123d4 <__aeabi_idiv+0x104>
   12308:	0b03      	lsrs	r3, r0, #12
   1230a:	428b      	cmp	r3, r1
   1230c:	d319      	bcc.n	12342 <__aeabi_idiv+0x72>
   1230e:	e000      	b.n	12312 <__aeabi_idiv+0x42>
   12310:	0a09      	lsrs	r1, r1, #8
   12312:	0bc3      	lsrs	r3, r0, #15
   12314:	428b      	cmp	r3, r1
   12316:	d301      	bcc.n	1231c <__aeabi_idiv+0x4c>
   12318:	03cb      	lsls	r3, r1, #15
   1231a:	1ac0      	subs	r0, r0, r3
   1231c:	4152      	adcs	r2, r2
   1231e:	0b83      	lsrs	r3, r0, #14
   12320:	428b      	cmp	r3, r1
   12322:	d301      	bcc.n	12328 <__aeabi_idiv+0x58>
   12324:	038b      	lsls	r3, r1, #14
   12326:	1ac0      	subs	r0, r0, r3
   12328:	4152      	adcs	r2, r2
   1232a:	0b43      	lsrs	r3, r0, #13
   1232c:	428b      	cmp	r3, r1
   1232e:	d301      	bcc.n	12334 <__aeabi_idiv+0x64>
   12330:	034b      	lsls	r3, r1, #13
   12332:	1ac0      	subs	r0, r0, r3
   12334:	4152      	adcs	r2, r2
   12336:	0b03      	lsrs	r3, r0, #12
   12338:	428b      	cmp	r3, r1
   1233a:	d301      	bcc.n	12340 <__aeabi_idiv+0x70>
   1233c:	030b      	lsls	r3, r1, #12
   1233e:	1ac0      	subs	r0, r0, r3
   12340:	4152      	adcs	r2, r2
   12342:	0ac3      	lsrs	r3, r0, #11
   12344:	428b      	cmp	r3, r1
   12346:	d301      	bcc.n	1234c <__aeabi_idiv+0x7c>
   12348:	02cb      	lsls	r3, r1, #11
   1234a:	1ac0      	subs	r0, r0, r3
   1234c:	4152      	adcs	r2, r2
   1234e:	0a83      	lsrs	r3, r0, #10
   12350:	428b      	cmp	r3, r1
   12352:	d301      	bcc.n	12358 <__aeabi_idiv+0x88>
   12354:	028b      	lsls	r3, r1, #10
   12356:	1ac0      	subs	r0, r0, r3
   12358:	4152      	adcs	r2, r2
   1235a:	0a43      	lsrs	r3, r0, #9
   1235c:	428b      	cmp	r3, r1
   1235e:	d301      	bcc.n	12364 <__aeabi_idiv+0x94>
   12360:	024b      	lsls	r3, r1, #9
   12362:	1ac0      	subs	r0, r0, r3
   12364:	4152      	adcs	r2, r2
   12366:	0a03      	lsrs	r3, r0, #8
   12368:	428b      	cmp	r3, r1
   1236a:	d301      	bcc.n	12370 <__aeabi_idiv+0xa0>
   1236c:	020b      	lsls	r3, r1, #8
   1236e:	1ac0      	subs	r0, r0, r3
   12370:	4152      	adcs	r2, r2
   12372:	d2cd      	bcs.n	12310 <__aeabi_idiv+0x40>
   12374:	09c3      	lsrs	r3, r0, #7
   12376:	428b      	cmp	r3, r1
   12378:	d301      	bcc.n	1237e <__aeabi_idiv+0xae>
   1237a:	01cb      	lsls	r3, r1, #7
   1237c:	1ac0      	subs	r0, r0, r3
   1237e:	4152      	adcs	r2, r2
   12380:	0983      	lsrs	r3, r0, #6
   12382:	428b      	cmp	r3, r1
   12384:	d301      	bcc.n	1238a <__aeabi_idiv+0xba>
   12386:	018b      	lsls	r3, r1, #6
   12388:	1ac0      	subs	r0, r0, r3
   1238a:	4152      	adcs	r2, r2
   1238c:	0943      	lsrs	r3, r0, #5
   1238e:	428b      	cmp	r3, r1
   12390:	d301      	bcc.n	12396 <__aeabi_idiv+0xc6>
   12392:	014b      	lsls	r3, r1, #5
   12394:	1ac0      	subs	r0, r0, r3
   12396:	4152      	adcs	r2, r2
   12398:	0903      	lsrs	r3, r0, #4
   1239a:	428b      	cmp	r3, r1
   1239c:	d301      	bcc.n	123a2 <__aeabi_idiv+0xd2>
   1239e:	010b      	lsls	r3, r1, #4
   123a0:	1ac0      	subs	r0, r0, r3
   123a2:	4152      	adcs	r2, r2
   123a4:	08c3      	lsrs	r3, r0, #3
   123a6:	428b      	cmp	r3, r1
   123a8:	d301      	bcc.n	123ae <__aeabi_idiv+0xde>
   123aa:	00cb      	lsls	r3, r1, #3
   123ac:	1ac0      	subs	r0, r0, r3
   123ae:	4152      	adcs	r2, r2
   123b0:	0883      	lsrs	r3, r0, #2
   123b2:	428b      	cmp	r3, r1
   123b4:	d301      	bcc.n	123ba <__aeabi_idiv+0xea>
   123b6:	008b      	lsls	r3, r1, #2
   123b8:	1ac0      	subs	r0, r0, r3
   123ba:	4152      	adcs	r2, r2
   123bc:	0843      	lsrs	r3, r0, #1
   123be:	428b      	cmp	r3, r1
   123c0:	d301      	bcc.n	123c6 <__aeabi_idiv+0xf6>
   123c2:	004b      	lsls	r3, r1, #1
   123c4:	1ac0      	subs	r0, r0, r3
   123c6:	4152      	adcs	r2, r2
   123c8:	1a41      	subs	r1, r0, r1
   123ca:	d200      	bcs.n	123ce <__aeabi_idiv+0xfe>
   123cc:	4601      	mov	r1, r0
   123ce:	4152      	adcs	r2, r2
   123d0:	4610      	mov	r0, r2
   123d2:	4770      	bx	lr
   123d4:	e05d      	b.n	12492 <__aeabi_idiv+0x1c2>
   123d6:	0fca      	lsrs	r2, r1, #31
   123d8:	d000      	beq.n	123dc <__aeabi_idiv+0x10c>
   123da:	4249      	negs	r1, r1
   123dc:	1003      	asrs	r3, r0, #32
   123de:	d300      	bcc.n	123e2 <__aeabi_idiv+0x112>
   123e0:	4240      	negs	r0, r0
   123e2:	4053      	eors	r3, r2
   123e4:	2200      	movs	r2, #0
   123e6:	469c      	mov	ip, r3
   123e8:	0903      	lsrs	r3, r0, #4
   123ea:	428b      	cmp	r3, r1
   123ec:	d32d      	bcc.n	1244a <__aeabi_idiv+0x17a>
   123ee:	0a03      	lsrs	r3, r0, #8
   123f0:	428b      	cmp	r3, r1
   123f2:	d312      	bcc.n	1241a <__aeabi_idiv+0x14a>
   123f4:	22fc      	movs	r2, #252	; 0xfc
   123f6:	0189      	lsls	r1, r1, #6
   123f8:	ba12      	rev	r2, r2
   123fa:	0a03      	lsrs	r3, r0, #8
   123fc:	428b      	cmp	r3, r1
   123fe:	d30c      	bcc.n	1241a <__aeabi_idiv+0x14a>
   12400:	0189      	lsls	r1, r1, #6
   12402:	1192      	asrs	r2, r2, #6
   12404:	428b      	cmp	r3, r1
   12406:	d308      	bcc.n	1241a <__aeabi_idiv+0x14a>
   12408:	0189      	lsls	r1, r1, #6
   1240a:	1192      	asrs	r2, r2, #6
   1240c:	428b      	cmp	r3, r1
   1240e:	d304      	bcc.n	1241a <__aeabi_idiv+0x14a>
   12410:	0189      	lsls	r1, r1, #6
   12412:	d03a      	beq.n	1248a <__aeabi_idiv+0x1ba>
   12414:	1192      	asrs	r2, r2, #6
   12416:	e000      	b.n	1241a <__aeabi_idiv+0x14a>
   12418:	0989      	lsrs	r1, r1, #6
   1241a:	09c3      	lsrs	r3, r0, #7
   1241c:	428b      	cmp	r3, r1
   1241e:	d301      	bcc.n	12424 <__aeabi_idiv+0x154>
   12420:	01cb      	lsls	r3, r1, #7
   12422:	1ac0      	subs	r0, r0, r3
   12424:	4152      	adcs	r2, r2
   12426:	0983      	lsrs	r3, r0, #6
   12428:	428b      	cmp	r3, r1
   1242a:	d301      	bcc.n	12430 <__aeabi_idiv+0x160>
   1242c:	018b      	lsls	r3, r1, #6
   1242e:	1ac0      	subs	r0, r0, r3
   12430:	4152      	adcs	r2, r2
   12432:	0943      	lsrs	r3, r0, #5
   12434:	428b      	cmp	r3, r1
   12436:	d301      	bcc.n	1243c <__aeabi_idiv+0x16c>
   12438:	014b      	lsls	r3, r1, #5
   1243a:	1ac0      	subs	r0, r0, r3
   1243c:	4152      	adcs	r2, r2
   1243e:	0903      	lsrs	r3, r0, #4
   12440:	428b      	cmp	r3, r1
   12442:	d301      	bcc.n	12448 <__aeabi_idiv+0x178>
   12444:	010b      	lsls	r3, r1, #4
   12446:	1ac0      	subs	r0, r0, r3
   12448:	4152      	adcs	r2, r2
   1244a:	08c3      	lsrs	r3, r0, #3
   1244c:	428b      	cmp	r3, r1
   1244e:	d301      	bcc.n	12454 <__aeabi_idiv+0x184>
   12450:	00cb      	lsls	r3, r1, #3
   12452:	1ac0      	subs	r0, r0, r3
   12454:	4152      	adcs	r2, r2
   12456:	0883      	lsrs	r3, r0, #2
   12458:	428b      	cmp	r3, r1
   1245a:	d301      	bcc.n	12460 <__aeabi_idiv+0x190>
   1245c:	008b      	lsls	r3, r1, #2
   1245e:	1ac0      	subs	r0, r0, r3
   12460:	4152      	adcs	r2, r2
   12462:	d2d9      	bcs.n	12418 <__aeabi_idiv+0x148>
   12464:	0843      	lsrs	r3, r0, #1
   12466:	428b      	cmp	r3, r1
   12468:	d301      	bcc.n	1246e <__aeabi_idiv+0x19e>
   1246a:	004b      	lsls	r3, r1, #1
   1246c:	1ac0      	subs	r0, r0, r3
   1246e:	4152      	adcs	r2, r2
   12470:	1a41      	subs	r1, r0, r1
   12472:	d200      	bcs.n	12476 <__aeabi_idiv+0x1a6>
   12474:	4601      	mov	r1, r0
   12476:	4663      	mov	r3, ip
   12478:	4152      	adcs	r2, r2
   1247a:	105b      	asrs	r3, r3, #1
   1247c:	4610      	mov	r0, r2
   1247e:	d301      	bcc.n	12484 <__aeabi_idiv+0x1b4>
   12480:	4240      	negs	r0, r0
   12482:	2b00      	cmp	r3, #0
   12484:	d500      	bpl.n	12488 <__aeabi_idiv+0x1b8>
   12486:	4249      	negs	r1, r1
   12488:	4770      	bx	lr
   1248a:	4663      	mov	r3, ip
   1248c:	105b      	asrs	r3, r3, #1
   1248e:	d300      	bcc.n	12492 <__aeabi_idiv+0x1c2>
   12490:	4240      	negs	r0, r0
   12492:	b501      	push	{r0, lr}
   12494:	2000      	movs	r0, #0
   12496:	f000 f805 	bl	124a4 <__aeabi_idiv0>
   1249a:	bd02      	pop	{r1, pc}

0001249c <__aeabi_idivmod>:
   1249c:	2900      	cmp	r1, #0
   1249e:	d0f8      	beq.n	12492 <__aeabi_idiv+0x1c2>
   124a0:	e716      	b.n	122d0 <__aeabi_idiv>
   124a2:	4770      	bx	lr

000124a4 <__aeabi_idiv0>:
   124a4:	4770      	bx	lr
   124a6:	46c0      	nop			; (mov r8, r8)

000124a8 <__clzsi2>:
   124a8:	211c      	movs	r1, #28
   124aa:	2301      	movs	r3, #1
   124ac:	041b      	lsls	r3, r3, #16
   124ae:	4298      	cmp	r0, r3
   124b0:	d301      	bcc.n	124b6 <__clzsi2+0xe>
   124b2:	0c00      	lsrs	r0, r0, #16
   124b4:	3910      	subs	r1, #16
   124b6:	0a1b      	lsrs	r3, r3, #8
   124b8:	4298      	cmp	r0, r3
   124ba:	d301      	bcc.n	124c0 <__clzsi2+0x18>
   124bc:	0a00      	lsrs	r0, r0, #8
   124be:	3908      	subs	r1, #8
   124c0:	091b      	lsrs	r3, r3, #4
   124c2:	4298      	cmp	r0, r3
   124c4:	d301      	bcc.n	124ca <__clzsi2+0x22>
   124c6:	0900      	lsrs	r0, r0, #4
   124c8:	3904      	subs	r1, #4
   124ca:	a202      	add	r2, pc, #8	; (adr r2, 124d4 <__clzsi2+0x2c>)
   124cc:	5c10      	ldrb	r0, [r2, r0]
   124ce:	1840      	adds	r0, r0, r1
   124d0:	4770      	bx	lr
   124d2:	46c0      	nop			; (mov r8, r8)
   124d4:	02020304 	.word	0x02020304
   124d8:	01010101 	.word	0x01010101
	...

000124e4 <__ctzsi2>:
   124e4:	4241      	negs	r1, r0
   124e6:	4008      	ands	r0, r1
   124e8:	211c      	movs	r1, #28
   124ea:	2301      	movs	r3, #1
   124ec:	041b      	lsls	r3, r3, #16
   124ee:	4298      	cmp	r0, r3
   124f0:	d301      	bcc.n	124f6 <__ctzsi2+0x12>
   124f2:	0c00      	lsrs	r0, r0, #16
   124f4:	3910      	subs	r1, #16
   124f6:	0a1b      	lsrs	r3, r3, #8
   124f8:	4298      	cmp	r0, r3
   124fa:	d301      	bcc.n	12500 <__ctzsi2+0x1c>
   124fc:	0a00      	lsrs	r0, r0, #8
   124fe:	3908      	subs	r1, #8
   12500:	091b      	lsrs	r3, r3, #4
   12502:	4298      	cmp	r0, r3
   12504:	d301      	bcc.n	1250a <__ctzsi2+0x26>
   12506:	0900      	lsrs	r0, r0, #4
   12508:	3904      	subs	r1, #4
   1250a:	a202      	add	r2, pc, #8	; (adr r2, 12514 <__ctzsi2+0x30>)
   1250c:	5c10      	ldrb	r0, [r2, r0]
   1250e:	1a40      	subs	r0, r0, r1
   12510:	4770      	bx	lr
   12512:	46c0      	nop			; (mov r8, r8)
   12514:	1d1d1c1b 	.word	0x1d1d1c1b
   12518:	1e1e1e1e 	.word	0x1e1e1e1e
   1251c:	1f1f1f1f 	.word	0x1f1f1f1f
   12520:	1f1f1f1f 	.word	0x1f1f1f1f

00012524 <__aeabi_uldivmod>:
   12524:	2b00      	cmp	r3, #0
   12526:	d111      	bne.n	1254c <__aeabi_uldivmod+0x28>
   12528:	2a00      	cmp	r2, #0
   1252a:	d10f      	bne.n	1254c <__aeabi_uldivmod+0x28>
   1252c:	2900      	cmp	r1, #0
   1252e:	d100      	bne.n	12532 <__aeabi_uldivmod+0xe>
   12530:	2800      	cmp	r0, #0
   12532:	d002      	beq.n	1253a <__aeabi_uldivmod+0x16>
   12534:	2100      	movs	r1, #0
   12536:	43c9      	mvns	r1, r1
   12538:	1c08      	adds	r0, r1, #0
   1253a:	b407      	push	{r0, r1, r2}
   1253c:	4802      	ldr	r0, [pc, #8]	; (12548 <__aeabi_uldivmod+0x24>)
   1253e:	a102      	add	r1, pc, #8	; (adr r1, 12548 <__aeabi_uldivmod+0x24>)
   12540:	1840      	adds	r0, r0, r1
   12542:	9002      	str	r0, [sp, #8]
   12544:	bd03      	pop	{r0, r1, pc}
   12546:	46c0      	nop			; (mov r8, r8)
   12548:	ffffff5d 	.word	0xffffff5d
   1254c:	b403      	push	{r0, r1}
   1254e:	4668      	mov	r0, sp
   12550:	b501      	push	{r0, lr}
   12552:	9802      	ldr	r0, [sp, #8]
   12554:	f000 f832 	bl	125bc <__udivmoddi4>
   12558:	9b01      	ldr	r3, [sp, #4]
   1255a:	469e      	mov	lr, r3
   1255c:	b002      	add	sp, #8
   1255e:	bc0c      	pop	{r2, r3}
   12560:	4770      	bx	lr
   12562:	46c0      	nop			; (mov r8, r8)

00012564 <__aeabi_lmul>:
   12564:	b5f0      	push	{r4, r5, r6, r7, lr}
   12566:	464f      	mov	r7, r9
   12568:	4646      	mov	r6, r8
   1256a:	b4c0      	push	{r6, r7}
   1256c:	0416      	lsls	r6, r2, #16
   1256e:	0c36      	lsrs	r6, r6, #16
   12570:	4699      	mov	r9, r3
   12572:	0033      	movs	r3, r6
   12574:	0405      	lsls	r5, r0, #16
   12576:	0c2c      	lsrs	r4, r5, #16
   12578:	0c07      	lsrs	r7, r0, #16
   1257a:	0c15      	lsrs	r5, r2, #16
   1257c:	4363      	muls	r3, r4
   1257e:	437e      	muls	r6, r7
   12580:	436f      	muls	r7, r5
   12582:	4365      	muls	r5, r4
   12584:	0c1c      	lsrs	r4, r3, #16
   12586:	19ad      	adds	r5, r5, r6
   12588:	1964      	adds	r4, r4, r5
   1258a:	469c      	mov	ip, r3
   1258c:	42a6      	cmp	r6, r4
   1258e:	d903      	bls.n	12598 <__aeabi_lmul+0x34>
   12590:	2380      	movs	r3, #128	; 0x80
   12592:	025b      	lsls	r3, r3, #9
   12594:	4698      	mov	r8, r3
   12596:	4447      	add	r7, r8
   12598:	4663      	mov	r3, ip
   1259a:	0c25      	lsrs	r5, r4, #16
   1259c:	19ef      	adds	r7, r5, r7
   1259e:	041d      	lsls	r5, r3, #16
   125a0:	464b      	mov	r3, r9
   125a2:	434a      	muls	r2, r1
   125a4:	4343      	muls	r3, r0
   125a6:	0c2d      	lsrs	r5, r5, #16
   125a8:	0424      	lsls	r4, r4, #16
   125aa:	1964      	adds	r4, r4, r5
   125ac:	1899      	adds	r1, r3, r2
   125ae:	19c9      	adds	r1, r1, r7
   125b0:	0020      	movs	r0, r4
   125b2:	bc0c      	pop	{r2, r3}
   125b4:	4690      	mov	r8, r2
   125b6:	4699      	mov	r9, r3
   125b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   125ba:	46c0      	nop			; (mov r8, r8)

000125bc <__udivmoddi4>:
   125bc:	b5f0      	push	{r4, r5, r6, r7, lr}
   125be:	464d      	mov	r5, r9
   125c0:	4656      	mov	r6, sl
   125c2:	4644      	mov	r4, r8
   125c4:	465f      	mov	r7, fp
   125c6:	b4f0      	push	{r4, r5, r6, r7}
   125c8:	4692      	mov	sl, r2
   125ca:	b083      	sub	sp, #12
   125cc:	0004      	movs	r4, r0
   125ce:	000d      	movs	r5, r1
   125d0:	4699      	mov	r9, r3
   125d2:	428b      	cmp	r3, r1
   125d4:	d82f      	bhi.n	12636 <__udivmoddi4+0x7a>
   125d6:	d02c      	beq.n	12632 <__udivmoddi4+0x76>
   125d8:	4649      	mov	r1, r9
   125da:	4650      	mov	r0, sl
   125dc:	f000 f8ae 	bl	1273c <__clzdi2>
   125e0:	0029      	movs	r1, r5
   125e2:	0006      	movs	r6, r0
   125e4:	0020      	movs	r0, r4
   125e6:	f000 f8a9 	bl	1273c <__clzdi2>
   125ea:	1a33      	subs	r3, r6, r0
   125ec:	4698      	mov	r8, r3
   125ee:	3b20      	subs	r3, #32
   125f0:	469b      	mov	fp, r3
   125f2:	d500      	bpl.n	125f6 <__udivmoddi4+0x3a>
   125f4:	e074      	b.n	126e0 <__udivmoddi4+0x124>
   125f6:	4653      	mov	r3, sl
   125f8:	465a      	mov	r2, fp
   125fa:	4093      	lsls	r3, r2
   125fc:	001f      	movs	r7, r3
   125fe:	4653      	mov	r3, sl
   12600:	4642      	mov	r2, r8
   12602:	4093      	lsls	r3, r2
   12604:	001e      	movs	r6, r3
   12606:	42af      	cmp	r7, r5
   12608:	d829      	bhi.n	1265e <__udivmoddi4+0xa2>
   1260a:	d026      	beq.n	1265a <__udivmoddi4+0x9e>
   1260c:	465b      	mov	r3, fp
   1260e:	1ba4      	subs	r4, r4, r6
   12610:	41bd      	sbcs	r5, r7
   12612:	2b00      	cmp	r3, #0
   12614:	da00      	bge.n	12618 <__udivmoddi4+0x5c>
   12616:	e079      	b.n	1270c <__udivmoddi4+0x150>
   12618:	2200      	movs	r2, #0
   1261a:	2300      	movs	r3, #0
   1261c:	9200      	str	r2, [sp, #0]
   1261e:	9301      	str	r3, [sp, #4]
   12620:	2301      	movs	r3, #1
   12622:	465a      	mov	r2, fp
   12624:	4093      	lsls	r3, r2
   12626:	9301      	str	r3, [sp, #4]
   12628:	2301      	movs	r3, #1
   1262a:	4642      	mov	r2, r8
   1262c:	4093      	lsls	r3, r2
   1262e:	9300      	str	r3, [sp, #0]
   12630:	e019      	b.n	12666 <__udivmoddi4+0xaa>
   12632:	4282      	cmp	r2, r0
   12634:	d9d0      	bls.n	125d8 <__udivmoddi4+0x1c>
   12636:	2200      	movs	r2, #0
   12638:	2300      	movs	r3, #0
   1263a:	9200      	str	r2, [sp, #0]
   1263c:	9301      	str	r3, [sp, #4]
   1263e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   12640:	2b00      	cmp	r3, #0
   12642:	d001      	beq.n	12648 <__udivmoddi4+0x8c>
   12644:	601c      	str	r4, [r3, #0]
   12646:	605d      	str	r5, [r3, #4]
   12648:	9800      	ldr	r0, [sp, #0]
   1264a:	9901      	ldr	r1, [sp, #4]
   1264c:	b003      	add	sp, #12
   1264e:	bc3c      	pop	{r2, r3, r4, r5}
   12650:	4690      	mov	r8, r2
   12652:	4699      	mov	r9, r3
   12654:	46a2      	mov	sl, r4
   12656:	46ab      	mov	fp, r5
   12658:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1265a:	42a3      	cmp	r3, r4
   1265c:	d9d6      	bls.n	1260c <__udivmoddi4+0x50>
   1265e:	2200      	movs	r2, #0
   12660:	2300      	movs	r3, #0
   12662:	9200      	str	r2, [sp, #0]
   12664:	9301      	str	r3, [sp, #4]
   12666:	4643      	mov	r3, r8
   12668:	2b00      	cmp	r3, #0
   1266a:	d0e8      	beq.n	1263e <__udivmoddi4+0x82>
   1266c:	07fb      	lsls	r3, r7, #31
   1266e:	0872      	lsrs	r2, r6, #1
   12670:	431a      	orrs	r2, r3
   12672:	4646      	mov	r6, r8
   12674:	087b      	lsrs	r3, r7, #1
   12676:	e00e      	b.n	12696 <__udivmoddi4+0xda>
   12678:	42ab      	cmp	r3, r5
   1267a:	d101      	bne.n	12680 <__udivmoddi4+0xc4>
   1267c:	42a2      	cmp	r2, r4
   1267e:	d80c      	bhi.n	1269a <__udivmoddi4+0xde>
   12680:	1aa4      	subs	r4, r4, r2
   12682:	419d      	sbcs	r5, r3
   12684:	2001      	movs	r0, #1
   12686:	1924      	adds	r4, r4, r4
   12688:	416d      	adcs	r5, r5
   1268a:	2100      	movs	r1, #0
   1268c:	3e01      	subs	r6, #1
   1268e:	1824      	adds	r4, r4, r0
   12690:	414d      	adcs	r5, r1
   12692:	2e00      	cmp	r6, #0
   12694:	d006      	beq.n	126a4 <__udivmoddi4+0xe8>
   12696:	42ab      	cmp	r3, r5
   12698:	d9ee      	bls.n	12678 <__udivmoddi4+0xbc>
   1269a:	3e01      	subs	r6, #1
   1269c:	1924      	adds	r4, r4, r4
   1269e:	416d      	adcs	r5, r5
   126a0:	2e00      	cmp	r6, #0
   126a2:	d1f8      	bne.n	12696 <__udivmoddi4+0xda>
   126a4:	465b      	mov	r3, fp
   126a6:	9800      	ldr	r0, [sp, #0]
   126a8:	9901      	ldr	r1, [sp, #4]
   126aa:	1900      	adds	r0, r0, r4
   126ac:	4169      	adcs	r1, r5
   126ae:	2b00      	cmp	r3, #0
   126b0:	db22      	blt.n	126f8 <__udivmoddi4+0x13c>
   126b2:	002b      	movs	r3, r5
   126b4:	465a      	mov	r2, fp
   126b6:	40d3      	lsrs	r3, r2
   126b8:	002a      	movs	r2, r5
   126ba:	4644      	mov	r4, r8
   126bc:	40e2      	lsrs	r2, r4
   126be:	001c      	movs	r4, r3
   126c0:	465b      	mov	r3, fp
   126c2:	0015      	movs	r5, r2
   126c4:	2b00      	cmp	r3, #0
   126c6:	db2c      	blt.n	12722 <__udivmoddi4+0x166>
   126c8:	0026      	movs	r6, r4
   126ca:	409e      	lsls	r6, r3
   126cc:	0033      	movs	r3, r6
   126ce:	0026      	movs	r6, r4
   126d0:	4647      	mov	r7, r8
   126d2:	40be      	lsls	r6, r7
   126d4:	0032      	movs	r2, r6
   126d6:	1a80      	subs	r0, r0, r2
   126d8:	4199      	sbcs	r1, r3
   126da:	9000      	str	r0, [sp, #0]
   126dc:	9101      	str	r1, [sp, #4]
   126de:	e7ae      	b.n	1263e <__udivmoddi4+0x82>
   126e0:	4642      	mov	r2, r8
   126e2:	2320      	movs	r3, #32
   126e4:	1a9b      	subs	r3, r3, r2
   126e6:	4652      	mov	r2, sl
   126e8:	40da      	lsrs	r2, r3
   126ea:	4641      	mov	r1, r8
   126ec:	0013      	movs	r3, r2
   126ee:	464a      	mov	r2, r9
   126f0:	408a      	lsls	r2, r1
   126f2:	0017      	movs	r7, r2
   126f4:	431f      	orrs	r7, r3
   126f6:	e782      	b.n	125fe <__udivmoddi4+0x42>
   126f8:	4642      	mov	r2, r8
   126fa:	2320      	movs	r3, #32
   126fc:	1a9b      	subs	r3, r3, r2
   126fe:	002a      	movs	r2, r5
   12700:	4646      	mov	r6, r8
   12702:	409a      	lsls	r2, r3
   12704:	0023      	movs	r3, r4
   12706:	40f3      	lsrs	r3, r6
   12708:	4313      	orrs	r3, r2
   1270a:	e7d5      	b.n	126b8 <__udivmoddi4+0xfc>
   1270c:	4642      	mov	r2, r8
   1270e:	2320      	movs	r3, #32
   12710:	2100      	movs	r1, #0
   12712:	1a9b      	subs	r3, r3, r2
   12714:	2200      	movs	r2, #0
   12716:	9100      	str	r1, [sp, #0]
   12718:	9201      	str	r2, [sp, #4]
   1271a:	2201      	movs	r2, #1
   1271c:	40da      	lsrs	r2, r3
   1271e:	9201      	str	r2, [sp, #4]
   12720:	e782      	b.n	12628 <__udivmoddi4+0x6c>
   12722:	4642      	mov	r2, r8
   12724:	2320      	movs	r3, #32
   12726:	0026      	movs	r6, r4
   12728:	1a9b      	subs	r3, r3, r2
   1272a:	40de      	lsrs	r6, r3
   1272c:	002f      	movs	r7, r5
   1272e:	46b4      	mov	ip, r6
   12730:	4097      	lsls	r7, r2
   12732:	4666      	mov	r6, ip
   12734:	003b      	movs	r3, r7
   12736:	4333      	orrs	r3, r6
   12738:	e7c9      	b.n	126ce <__udivmoddi4+0x112>
   1273a:	46c0      	nop			; (mov r8, r8)

0001273c <__clzdi2>:
   1273c:	b510      	push	{r4, lr}
   1273e:	2900      	cmp	r1, #0
   12740:	d103      	bne.n	1274a <__clzdi2+0xe>
   12742:	f7ff feb1 	bl	124a8 <__clzsi2>
   12746:	3020      	adds	r0, #32
   12748:	e002      	b.n	12750 <__clzdi2+0x14>
   1274a:	1c08      	adds	r0, r1, #0
   1274c:	f7ff feac 	bl	124a8 <__clzsi2>
   12750:	bd10      	pop	{r4, pc}
   12752:	46c0      	nop			; (mov r8, r8)

00012754 <__libc_init_array>:
   12754:	4b0e      	ldr	r3, [pc, #56]	; (12790 <__libc_init_array+0x3c>)
   12756:	b570      	push	{r4, r5, r6, lr}
   12758:	2500      	movs	r5, #0
   1275a:	001e      	movs	r6, r3
   1275c:	4c0d      	ldr	r4, [pc, #52]	; (12794 <__libc_init_array+0x40>)
   1275e:	1ae4      	subs	r4, r4, r3
   12760:	10a4      	asrs	r4, r4, #2
   12762:	42a5      	cmp	r5, r4
   12764:	d004      	beq.n	12770 <__libc_init_array+0x1c>
   12766:	00ab      	lsls	r3, r5, #2
   12768:	58f3      	ldr	r3, [r6, r3]
   1276a:	4798      	blx	r3
   1276c:	3501      	adds	r5, #1
   1276e:	e7f8      	b.n	12762 <__libc_init_array+0xe>
   12770:	f003 fa52 	bl	15c18 <_init>
   12774:	4b08      	ldr	r3, [pc, #32]	; (12798 <__libc_init_array+0x44>)
   12776:	2500      	movs	r5, #0
   12778:	001e      	movs	r6, r3
   1277a:	4c08      	ldr	r4, [pc, #32]	; (1279c <__libc_init_array+0x48>)
   1277c:	1ae4      	subs	r4, r4, r3
   1277e:	10a4      	asrs	r4, r4, #2
   12780:	42a5      	cmp	r5, r4
   12782:	d004      	beq.n	1278e <__libc_init_array+0x3a>
   12784:	00ab      	lsls	r3, r5, #2
   12786:	58f3      	ldr	r3, [r6, r3]
   12788:	4798      	blx	r3
   1278a:	3501      	adds	r5, #1
   1278c:	e7f8      	b.n	12780 <__libc_init_array+0x2c>
   1278e:	bd70      	pop	{r4, r5, r6, pc}
   12790:	00015c24 	.word	0x00015c24
   12794:	00015c24 	.word	0x00015c24
   12798:	00015c24 	.word	0x00015c24
   1279c:	00015c28 	.word	0x00015c28

000127a0 <malloc>:
   127a0:	b510      	push	{r4, lr}
   127a2:	4b03      	ldr	r3, [pc, #12]	; (127b0 <malloc+0x10>)
   127a4:	0001      	movs	r1, r0
   127a6:	6818      	ldr	r0, [r3, #0]
   127a8:	f000 f88a 	bl	128c0 <_malloc_r>
   127ac:	bd10      	pop	{r4, pc}
   127ae:	46c0      	nop			; (mov r8, r8)
   127b0:	200001e0 	.word	0x200001e0

000127b4 <free>:
   127b4:	b510      	push	{r4, lr}
   127b6:	4b03      	ldr	r3, [pc, #12]	; (127c4 <free+0x10>)
   127b8:	0001      	movs	r1, r0
   127ba:	6818      	ldr	r0, [r3, #0]
   127bc:	f000 f83a 	bl	12834 <_free_r>
   127c0:	bd10      	pop	{r4, pc}
   127c2:	46c0      	nop			; (mov r8, r8)
   127c4:	200001e0 	.word	0x200001e0

000127c8 <memcmp>:
   127c8:	b530      	push	{r4, r5, lr}
   127ca:	2400      	movs	r4, #0
   127cc:	42a2      	cmp	r2, r4
   127ce:	d008      	beq.n	127e2 <memcmp+0x1a>
   127d0:	5d03      	ldrb	r3, [r0, r4]
   127d2:	1c65      	adds	r5, r4, #1
   127d4:	5d0c      	ldrb	r4, [r1, r4]
   127d6:	42a3      	cmp	r3, r4
   127d8:	d001      	beq.n	127de <memcmp+0x16>
   127da:	1b18      	subs	r0, r3, r4
   127dc:	e002      	b.n	127e4 <memcmp+0x1c>
   127de:	002c      	movs	r4, r5
   127e0:	e7f4      	b.n	127cc <memcmp+0x4>
   127e2:	2000      	movs	r0, #0
   127e4:	bd30      	pop	{r4, r5, pc}

000127e6 <memcpy>:
   127e6:	2300      	movs	r3, #0
   127e8:	b510      	push	{r4, lr}
   127ea:	429a      	cmp	r2, r3
   127ec:	d003      	beq.n	127f6 <memcpy+0x10>
   127ee:	5ccc      	ldrb	r4, [r1, r3]
   127f0:	54c4      	strb	r4, [r0, r3]
   127f2:	3301      	adds	r3, #1
   127f4:	e7f9      	b.n	127ea <memcpy+0x4>
   127f6:	bd10      	pop	{r4, pc}

000127f8 <memmove>:
   127f8:	b510      	push	{r4, lr}
   127fa:	4288      	cmp	r0, r1
   127fc:	d902      	bls.n	12804 <memmove+0xc>
   127fe:	188b      	adds	r3, r1, r2
   12800:	4298      	cmp	r0, r3
   12802:	d301      	bcc.n	12808 <memmove+0x10>
   12804:	2300      	movs	r3, #0
   12806:	e005      	b.n	12814 <memmove+0x1c>
   12808:	1a9b      	subs	r3, r3, r2
   1280a:	3a01      	subs	r2, #1
   1280c:	d308      	bcc.n	12820 <memmove+0x28>
   1280e:	5c99      	ldrb	r1, [r3, r2]
   12810:	5481      	strb	r1, [r0, r2]
   12812:	e7fa      	b.n	1280a <memmove+0x12>
   12814:	4293      	cmp	r3, r2
   12816:	d003      	beq.n	12820 <memmove+0x28>
   12818:	5ccc      	ldrb	r4, [r1, r3]
   1281a:	54c4      	strb	r4, [r0, r3]
   1281c:	3301      	adds	r3, #1
   1281e:	e7f9      	b.n	12814 <memmove+0x1c>
   12820:	bd10      	pop	{r4, pc}

00012822 <memset>:
   12822:	0003      	movs	r3, r0
   12824:	1882      	adds	r2, r0, r2
   12826:	4293      	cmp	r3, r2
   12828:	d002      	beq.n	12830 <memset+0xe>
   1282a:	7019      	strb	r1, [r3, #0]
   1282c:	3301      	adds	r3, #1
   1282e:	e7fa      	b.n	12826 <memset+0x4>
   12830:	4770      	bx	lr
	...

00012834 <_free_r>:
   12834:	b530      	push	{r4, r5, lr}
   12836:	2900      	cmp	r1, #0
   12838:	d03e      	beq.n	128b8 <_free_r+0x84>
   1283a:	3904      	subs	r1, #4
   1283c:	680b      	ldr	r3, [r1, #0]
   1283e:	2b00      	cmp	r3, #0
   12840:	da00      	bge.n	12844 <_free_r+0x10>
   12842:	18c9      	adds	r1, r1, r3
   12844:	4a1d      	ldr	r2, [pc, #116]	; (128bc <_free_r+0x88>)
   12846:	6813      	ldr	r3, [r2, #0]
   12848:	0014      	movs	r4, r2
   1284a:	2b00      	cmp	r3, #0
   1284c:	d102      	bne.n	12854 <_free_r+0x20>
   1284e:	604b      	str	r3, [r1, #4]
   12850:	6011      	str	r1, [r2, #0]
   12852:	e031      	b.n	128b8 <_free_r+0x84>
   12854:	428b      	cmp	r3, r1
   12856:	d90d      	bls.n	12874 <_free_r+0x40>
   12858:	680a      	ldr	r2, [r1, #0]
   1285a:	1888      	adds	r0, r1, r2
   1285c:	4283      	cmp	r3, r0
   1285e:	d103      	bne.n	12868 <_free_r+0x34>
   12860:	6818      	ldr	r0, [r3, #0]
   12862:	685b      	ldr	r3, [r3, #4]
   12864:	1882      	adds	r2, r0, r2
   12866:	600a      	str	r2, [r1, #0]
   12868:	604b      	str	r3, [r1, #4]
   1286a:	6021      	str	r1, [r4, #0]
   1286c:	e024      	b.n	128b8 <_free_r+0x84>
   1286e:	428a      	cmp	r2, r1
   12870:	d803      	bhi.n	1287a <_free_r+0x46>
   12872:	0013      	movs	r3, r2
   12874:	685a      	ldr	r2, [r3, #4]
   12876:	2a00      	cmp	r2, #0
   12878:	d1f9      	bne.n	1286e <_free_r+0x3a>
   1287a:	681d      	ldr	r5, [r3, #0]
   1287c:	195c      	adds	r4, r3, r5
   1287e:	428c      	cmp	r4, r1
   12880:	d10b      	bne.n	1289a <_free_r+0x66>
   12882:	6809      	ldr	r1, [r1, #0]
   12884:	1869      	adds	r1, r5, r1
   12886:	1858      	adds	r0, r3, r1
   12888:	6019      	str	r1, [r3, #0]
   1288a:	4282      	cmp	r2, r0
   1288c:	d114      	bne.n	128b8 <_free_r+0x84>
   1288e:	6810      	ldr	r0, [r2, #0]
   12890:	6852      	ldr	r2, [r2, #4]
   12892:	1841      	adds	r1, r0, r1
   12894:	6019      	str	r1, [r3, #0]
   12896:	605a      	str	r2, [r3, #4]
   12898:	e00e      	b.n	128b8 <_free_r+0x84>
   1289a:	428c      	cmp	r4, r1
   1289c:	d902      	bls.n	128a4 <_free_r+0x70>
   1289e:	230c      	movs	r3, #12
   128a0:	6003      	str	r3, [r0, #0]
   128a2:	e009      	b.n	128b8 <_free_r+0x84>
   128a4:	6808      	ldr	r0, [r1, #0]
   128a6:	180c      	adds	r4, r1, r0
   128a8:	42a2      	cmp	r2, r4
   128aa:	d103      	bne.n	128b4 <_free_r+0x80>
   128ac:	6814      	ldr	r4, [r2, #0]
   128ae:	6852      	ldr	r2, [r2, #4]
   128b0:	1820      	adds	r0, r4, r0
   128b2:	6008      	str	r0, [r1, #0]
   128b4:	604a      	str	r2, [r1, #4]
   128b6:	6059      	str	r1, [r3, #4]
   128b8:	bd30      	pop	{r4, r5, pc}
   128ba:	46c0      	nop			; (mov r8, r8)
   128bc:	20000968 	.word	0x20000968

000128c0 <_malloc_r>:
   128c0:	2303      	movs	r3, #3
   128c2:	b570      	push	{r4, r5, r6, lr}
   128c4:	1ccd      	adds	r5, r1, #3
   128c6:	439d      	bics	r5, r3
   128c8:	3508      	adds	r5, #8
   128ca:	0006      	movs	r6, r0
   128cc:	2d0c      	cmp	r5, #12
   128ce:	d201      	bcs.n	128d4 <_malloc_r+0x14>
   128d0:	250c      	movs	r5, #12
   128d2:	e005      	b.n	128e0 <_malloc_r+0x20>
   128d4:	2d00      	cmp	r5, #0
   128d6:	da03      	bge.n	128e0 <_malloc_r+0x20>
   128d8:	230c      	movs	r3, #12
   128da:	2000      	movs	r0, #0
   128dc:	6033      	str	r3, [r6, #0]
   128de:	e040      	b.n	12962 <_malloc_r+0xa2>
   128e0:	42a9      	cmp	r1, r5
   128e2:	d8f9      	bhi.n	128d8 <_malloc_r+0x18>
   128e4:	4b1f      	ldr	r3, [pc, #124]	; (12964 <_malloc_r+0xa4>)
   128e6:	681c      	ldr	r4, [r3, #0]
   128e8:	001a      	movs	r2, r3
   128ea:	0021      	movs	r1, r4
   128ec:	2900      	cmp	r1, #0
   128ee:	d013      	beq.n	12918 <_malloc_r+0x58>
   128f0:	680b      	ldr	r3, [r1, #0]
   128f2:	1b5b      	subs	r3, r3, r5
   128f4:	d40d      	bmi.n	12912 <_malloc_r+0x52>
   128f6:	2b0b      	cmp	r3, #11
   128f8:	d902      	bls.n	12900 <_malloc_r+0x40>
   128fa:	600b      	str	r3, [r1, #0]
   128fc:	18cc      	adds	r4, r1, r3
   128fe:	e01e      	b.n	1293e <_malloc_r+0x7e>
   12900:	428c      	cmp	r4, r1
   12902:	d102      	bne.n	1290a <_malloc_r+0x4a>
   12904:	6863      	ldr	r3, [r4, #4]
   12906:	6013      	str	r3, [r2, #0]
   12908:	e01a      	b.n	12940 <_malloc_r+0x80>
   1290a:	684b      	ldr	r3, [r1, #4]
   1290c:	6063      	str	r3, [r4, #4]
   1290e:	000c      	movs	r4, r1
   12910:	e016      	b.n	12940 <_malloc_r+0x80>
   12912:	000c      	movs	r4, r1
   12914:	6849      	ldr	r1, [r1, #4]
   12916:	e7e9      	b.n	128ec <_malloc_r+0x2c>
   12918:	4c13      	ldr	r4, [pc, #76]	; (12968 <_malloc_r+0xa8>)
   1291a:	6823      	ldr	r3, [r4, #0]
   1291c:	2b00      	cmp	r3, #0
   1291e:	d103      	bne.n	12928 <_malloc_r+0x68>
   12920:	0030      	movs	r0, r6
   12922:	f000 f8bd 	bl	12aa0 <_sbrk_r>
   12926:	6020      	str	r0, [r4, #0]
   12928:	0029      	movs	r1, r5
   1292a:	0030      	movs	r0, r6
   1292c:	f000 f8b8 	bl	12aa0 <_sbrk_r>
   12930:	1c43      	adds	r3, r0, #1
   12932:	d0d1      	beq.n	128d8 <_malloc_r+0x18>
   12934:	2303      	movs	r3, #3
   12936:	1cc4      	adds	r4, r0, #3
   12938:	439c      	bics	r4, r3
   1293a:	42a0      	cmp	r0, r4
   1293c:	d10a      	bne.n	12954 <_malloc_r+0x94>
   1293e:	6025      	str	r5, [r4, #0]
   12940:	0020      	movs	r0, r4
   12942:	2207      	movs	r2, #7
   12944:	300b      	adds	r0, #11
   12946:	1d23      	adds	r3, r4, #4
   12948:	4390      	bics	r0, r2
   1294a:	1ac3      	subs	r3, r0, r3
   1294c:	d009      	beq.n	12962 <_malloc_r+0xa2>
   1294e:	425a      	negs	r2, r3
   12950:	50e2      	str	r2, [r4, r3]
   12952:	e006      	b.n	12962 <_malloc_r+0xa2>
   12954:	1a21      	subs	r1, r4, r0
   12956:	0030      	movs	r0, r6
   12958:	f000 f8a2 	bl	12aa0 <_sbrk_r>
   1295c:	1c43      	adds	r3, r0, #1
   1295e:	d1ee      	bne.n	1293e <_malloc_r+0x7e>
   12960:	e7ba      	b.n	128d8 <_malloc_r+0x18>
   12962:	bd70      	pop	{r4, r5, r6, pc}
   12964:	20000968 	.word	0x20000968
   12968:	20000964 	.word	0x20000964

0001296c <iprintf>:
   1296c:	b40f      	push	{r0, r1, r2, r3}
   1296e:	4b0b      	ldr	r3, [pc, #44]	; (1299c <iprintf+0x30>)
   12970:	b513      	push	{r0, r1, r4, lr}
   12972:	681c      	ldr	r4, [r3, #0]
   12974:	2c00      	cmp	r4, #0
   12976:	d005      	beq.n	12984 <iprintf+0x18>
   12978:	69a3      	ldr	r3, [r4, #24]
   1297a:	2b00      	cmp	r3, #0
   1297c:	d102      	bne.n	12984 <iprintf+0x18>
   1297e:	0020      	movs	r0, r4
   12980:	f000 fc00 	bl	13184 <__sinit>
   12984:	ab05      	add	r3, sp, #20
   12986:	9a04      	ldr	r2, [sp, #16]
   12988:	68a1      	ldr	r1, [r4, #8]
   1298a:	0020      	movs	r0, r4
   1298c:	9301      	str	r3, [sp, #4]
   1298e:	f000 fea9 	bl	136e4 <_vfiprintf_r>
   12992:	bc16      	pop	{r1, r2, r4}
   12994:	bc08      	pop	{r3}
   12996:	b004      	add	sp, #16
   12998:	4718      	bx	r3
   1299a:	46c0      	nop			; (mov r8, r8)
   1299c:	200001e0 	.word	0x200001e0

000129a0 <putchar>:
   129a0:	4b08      	ldr	r3, [pc, #32]	; (129c4 <putchar+0x24>)
   129a2:	b570      	push	{r4, r5, r6, lr}
   129a4:	681c      	ldr	r4, [r3, #0]
   129a6:	0005      	movs	r5, r0
   129a8:	2c00      	cmp	r4, #0
   129aa:	d005      	beq.n	129b8 <putchar+0x18>
   129ac:	69a3      	ldr	r3, [r4, #24]
   129ae:	2b00      	cmp	r3, #0
   129b0:	d102      	bne.n	129b8 <putchar+0x18>
   129b2:	0020      	movs	r0, r4
   129b4:	f000 fbe6 	bl	13184 <__sinit>
   129b8:	0029      	movs	r1, r5
   129ba:	68a2      	ldr	r2, [r4, #8]
   129bc:	0020      	movs	r0, r4
   129be:	f001 fc45 	bl	1424c <_putc_r>
   129c2:	bd70      	pop	{r4, r5, r6, pc}
   129c4:	200001e0 	.word	0x200001e0

000129c8 <_puts_r>:
   129c8:	b570      	push	{r4, r5, r6, lr}
   129ca:	0005      	movs	r5, r0
   129cc:	000e      	movs	r6, r1
   129ce:	2800      	cmp	r0, #0
   129d0:	d004      	beq.n	129dc <_puts_r+0x14>
   129d2:	6983      	ldr	r3, [r0, #24]
   129d4:	2b00      	cmp	r3, #0
   129d6:	d101      	bne.n	129dc <_puts_r+0x14>
   129d8:	f000 fbd4 	bl	13184 <__sinit>
   129dc:	69ab      	ldr	r3, [r5, #24]
   129de:	68ac      	ldr	r4, [r5, #8]
   129e0:	2b00      	cmp	r3, #0
   129e2:	d102      	bne.n	129ea <_puts_r+0x22>
   129e4:	0028      	movs	r0, r5
   129e6:	f000 fbcd 	bl	13184 <__sinit>
   129ea:	4b25      	ldr	r3, [pc, #148]	; (12a80 <_puts_r+0xb8>)
   129ec:	429c      	cmp	r4, r3
   129ee:	d101      	bne.n	129f4 <_puts_r+0x2c>
   129f0:	686c      	ldr	r4, [r5, #4]
   129f2:	e008      	b.n	12a06 <_puts_r+0x3e>
   129f4:	4b23      	ldr	r3, [pc, #140]	; (12a84 <_puts_r+0xbc>)
   129f6:	429c      	cmp	r4, r3
   129f8:	d101      	bne.n	129fe <_puts_r+0x36>
   129fa:	68ac      	ldr	r4, [r5, #8]
   129fc:	e003      	b.n	12a06 <_puts_r+0x3e>
   129fe:	4b22      	ldr	r3, [pc, #136]	; (12a88 <_puts_r+0xc0>)
   12a00:	429c      	cmp	r4, r3
   12a02:	d100      	bne.n	12a06 <_puts_r+0x3e>
   12a04:	68ec      	ldr	r4, [r5, #12]
   12a06:	89a3      	ldrh	r3, [r4, #12]
   12a08:	071b      	lsls	r3, r3, #28
   12a0a:	d502      	bpl.n	12a12 <_puts_r+0x4a>
   12a0c:	6923      	ldr	r3, [r4, #16]
   12a0e:	2b00      	cmp	r3, #0
   12a10:	d111      	bne.n	12a36 <_puts_r+0x6e>
   12a12:	0021      	movs	r1, r4
   12a14:	0028      	movs	r0, r5
   12a16:	f000 fa25 	bl	12e64 <__swsetup_r>
   12a1a:	2800      	cmp	r0, #0
   12a1c:	d00b      	beq.n	12a36 <_puts_r+0x6e>
   12a1e:	2001      	movs	r0, #1
   12a20:	4240      	negs	r0, r0
   12a22:	e02b      	b.n	12a7c <_puts_r+0xb4>
   12a24:	3b01      	subs	r3, #1
   12a26:	3601      	adds	r6, #1
   12a28:	60a3      	str	r3, [r4, #8]
   12a2a:	2b00      	cmp	r3, #0
   12a2c:	db08      	blt.n	12a40 <_puts_r+0x78>
   12a2e:	6823      	ldr	r3, [r4, #0]
   12a30:	1c5a      	adds	r2, r3, #1
   12a32:	6022      	str	r2, [r4, #0]
   12a34:	7019      	strb	r1, [r3, #0]
   12a36:	7831      	ldrb	r1, [r6, #0]
   12a38:	68a3      	ldr	r3, [r4, #8]
   12a3a:	2900      	cmp	r1, #0
   12a3c:	d1f2      	bne.n	12a24 <_puts_r+0x5c>
   12a3e:	e00b      	b.n	12a58 <_puts_r+0x90>
   12a40:	69a2      	ldr	r2, [r4, #24]
   12a42:	4293      	cmp	r3, r2
   12a44:	db01      	blt.n	12a4a <_puts_r+0x82>
   12a46:	290a      	cmp	r1, #10
   12a48:	d1f1      	bne.n	12a2e <_puts_r+0x66>
   12a4a:	0022      	movs	r2, r4
   12a4c:	0028      	movs	r0, r5
   12a4e:	f000 f99d 	bl	12d8c <__swbuf_r>
   12a52:	1c43      	adds	r3, r0, #1
   12a54:	d1ef      	bne.n	12a36 <_puts_r+0x6e>
   12a56:	e7e2      	b.n	12a1e <_puts_r+0x56>
   12a58:	3b01      	subs	r3, #1
   12a5a:	60a3      	str	r3, [r4, #8]
   12a5c:	2b00      	cmp	r3, #0
   12a5e:	da08      	bge.n	12a72 <_puts_r+0xaa>
   12a60:	0022      	movs	r2, r4
   12a62:	310a      	adds	r1, #10
   12a64:	0028      	movs	r0, r5
   12a66:	f000 f991 	bl	12d8c <__swbuf_r>
   12a6a:	1c43      	adds	r3, r0, #1
   12a6c:	d0d7      	beq.n	12a1e <_puts_r+0x56>
   12a6e:	200a      	movs	r0, #10
   12a70:	e004      	b.n	12a7c <_puts_r+0xb4>
   12a72:	200a      	movs	r0, #10
   12a74:	6823      	ldr	r3, [r4, #0]
   12a76:	1c5a      	adds	r2, r3, #1
   12a78:	6022      	str	r2, [r4, #0]
   12a7a:	7018      	strb	r0, [r3, #0]
   12a7c:	bd70      	pop	{r4, r5, r6, pc}
   12a7e:	46c0      	nop			; (mov r8, r8)
   12a80:	00015a5c 	.word	0x00015a5c
   12a84:	00015a7c 	.word	0x00015a7c
   12a88:	00015a9c 	.word	0x00015a9c

00012a8c <puts>:
   12a8c:	b510      	push	{r4, lr}
   12a8e:	4b03      	ldr	r3, [pc, #12]	; (12a9c <puts+0x10>)
   12a90:	0001      	movs	r1, r0
   12a92:	6818      	ldr	r0, [r3, #0]
   12a94:	f7ff ff98 	bl	129c8 <_puts_r>
   12a98:	bd10      	pop	{r4, pc}
   12a9a:	46c0      	nop			; (mov r8, r8)
   12a9c:	200001e0 	.word	0x200001e0

00012aa0 <_sbrk_r>:
   12aa0:	2300      	movs	r3, #0
   12aa2:	b570      	push	{r4, r5, r6, lr}
   12aa4:	4c06      	ldr	r4, [pc, #24]	; (12ac0 <_sbrk_r+0x20>)
   12aa6:	0005      	movs	r5, r0
   12aa8:	0008      	movs	r0, r1
   12aaa:	6023      	str	r3, [r4, #0]
   12aac:	f7ff fae4 	bl	12078 <_sbrk>
   12ab0:	1c43      	adds	r3, r0, #1
   12ab2:	d103      	bne.n	12abc <_sbrk_r+0x1c>
   12ab4:	6823      	ldr	r3, [r4, #0]
   12ab6:	2b00      	cmp	r3, #0
   12ab8:	d000      	beq.n	12abc <_sbrk_r+0x1c>
   12aba:	602b      	str	r3, [r5, #0]
   12abc:	bd70      	pop	{r4, r5, r6, pc}
   12abe:	46c0      	nop			; (mov r8, r8)
   12ac0:	20001880 	.word	0x20001880

00012ac4 <iscanf>:
   12ac4:	b40f      	push	{r0, r1, r2, r3}
   12ac6:	4b0b      	ldr	r3, [pc, #44]	; (12af4 <iscanf+0x30>)
   12ac8:	b513      	push	{r0, r1, r4, lr}
   12aca:	681c      	ldr	r4, [r3, #0]
   12acc:	2c00      	cmp	r4, #0
   12ace:	d005      	beq.n	12adc <iscanf+0x18>
   12ad0:	69a3      	ldr	r3, [r4, #24]
   12ad2:	2b00      	cmp	r3, #0
   12ad4:	d102      	bne.n	12adc <iscanf+0x18>
   12ad6:	0020      	movs	r0, r4
   12ad8:	f000 fb54 	bl	13184 <__sinit>
   12adc:	ab05      	add	r3, sp, #20
   12ade:	9a04      	ldr	r2, [sp, #16]
   12ae0:	6861      	ldr	r1, [r4, #4]
   12ae2:	0020      	movs	r0, r4
   12ae4:	9301      	str	r3, [sp, #4]
   12ae6:	f001 fa27 	bl	13f38 <_vfiscanf_r>
   12aea:	bc16      	pop	{r1, r2, r4}
   12aec:	bc08      	pop	{r3}
   12aee:	b004      	add	sp, #16
   12af0:	4718      	bx	r3
   12af2:	46c0      	nop			; (mov r8, r8)
   12af4:	200001e0 	.word	0x200001e0

00012af8 <setbuf>:
   12af8:	424a      	negs	r2, r1
   12afa:	414a      	adcs	r2, r1
   12afc:	2380      	movs	r3, #128	; 0x80
   12afe:	b510      	push	{r4, lr}
   12b00:	0052      	lsls	r2, r2, #1
   12b02:	00db      	lsls	r3, r3, #3
   12b04:	f000 f802 	bl	12b0c <setvbuf>
   12b08:	bd10      	pop	{r4, pc}
	...

00012b0c <setvbuf>:
   12b0c:	b5f0      	push	{r4, r5, r6, r7, lr}
   12b0e:	001d      	movs	r5, r3
   12b10:	4b51      	ldr	r3, [pc, #324]	; (12c58 <setvbuf+0x14c>)
   12b12:	b085      	sub	sp, #20
   12b14:	681e      	ldr	r6, [r3, #0]
   12b16:	0004      	movs	r4, r0
   12b18:	000f      	movs	r7, r1
   12b1a:	9200      	str	r2, [sp, #0]
   12b1c:	2e00      	cmp	r6, #0
   12b1e:	d005      	beq.n	12b2c <setvbuf+0x20>
   12b20:	69b3      	ldr	r3, [r6, #24]
   12b22:	2b00      	cmp	r3, #0
   12b24:	d102      	bne.n	12b2c <setvbuf+0x20>
   12b26:	0030      	movs	r0, r6
   12b28:	f000 fb2c 	bl	13184 <__sinit>
   12b2c:	4b4b      	ldr	r3, [pc, #300]	; (12c5c <setvbuf+0x150>)
   12b2e:	429c      	cmp	r4, r3
   12b30:	d101      	bne.n	12b36 <setvbuf+0x2a>
   12b32:	6874      	ldr	r4, [r6, #4]
   12b34:	e008      	b.n	12b48 <setvbuf+0x3c>
   12b36:	4b4a      	ldr	r3, [pc, #296]	; (12c60 <setvbuf+0x154>)
   12b38:	429c      	cmp	r4, r3
   12b3a:	d101      	bne.n	12b40 <setvbuf+0x34>
   12b3c:	68b4      	ldr	r4, [r6, #8]
   12b3e:	e003      	b.n	12b48 <setvbuf+0x3c>
   12b40:	4b48      	ldr	r3, [pc, #288]	; (12c64 <setvbuf+0x158>)
   12b42:	429c      	cmp	r4, r3
   12b44:	d100      	bne.n	12b48 <setvbuf+0x3c>
   12b46:	68f4      	ldr	r4, [r6, #12]
   12b48:	9b00      	ldr	r3, [sp, #0]
   12b4a:	2b02      	cmp	r3, #2
   12b4c:	d005      	beq.n	12b5a <setvbuf+0x4e>
   12b4e:	2b01      	cmp	r3, #1
   12b50:	d900      	bls.n	12b54 <setvbuf+0x48>
   12b52:	e07c      	b.n	12c4e <setvbuf+0x142>
   12b54:	2d00      	cmp	r5, #0
   12b56:	da00      	bge.n	12b5a <setvbuf+0x4e>
   12b58:	e079      	b.n	12c4e <setvbuf+0x142>
   12b5a:	0021      	movs	r1, r4
   12b5c:	0030      	movs	r0, r6
   12b5e:	f000 fa8f 	bl	13080 <_fflush_r>
   12b62:	6b61      	ldr	r1, [r4, #52]	; 0x34
   12b64:	2900      	cmp	r1, #0
   12b66:	d008      	beq.n	12b7a <setvbuf+0x6e>
   12b68:	0023      	movs	r3, r4
   12b6a:	3344      	adds	r3, #68	; 0x44
   12b6c:	4299      	cmp	r1, r3
   12b6e:	d002      	beq.n	12b76 <setvbuf+0x6a>
   12b70:	0030      	movs	r0, r6
   12b72:	f7ff fe5f 	bl	12834 <_free_r>
   12b76:	2300      	movs	r3, #0
   12b78:	6363      	str	r3, [r4, #52]	; 0x34
   12b7a:	2300      	movs	r3, #0
   12b7c:	61a3      	str	r3, [r4, #24]
   12b7e:	6063      	str	r3, [r4, #4]
   12b80:	89a3      	ldrh	r3, [r4, #12]
   12b82:	061b      	lsls	r3, r3, #24
   12b84:	d503      	bpl.n	12b8e <setvbuf+0x82>
   12b86:	6921      	ldr	r1, [r4, #16]
   12b88:	0030      	movs	r0, r6
   12b8a:	f7ff fe53 	bl	12834 <_free_r>
   12b8e:	89a2      	ldrh	r2, [r4, #12]
   12b90:	4b35      	ldr	r3, [pc, #212]	; (12c68 <setvbuf+0x15c>)
   12b92:	4013      	ands	r3, r2
   12b94:	81a3      	strh	r3, [r4, #12]
   12b96:	9b00      	ldr	r3, [sp, #0]
   12b98:	2b02      	cmp	r3, #2
   12b9a:	d021      	beq.n	12be0 <setvbuf+0xd4>
   12b9c:	ab03      	add	r3, sp, #12
   12b9e:	aa02      	add	r2, sp, #8
   12ba0:	0021      	movs	r1, r4
   12ba2:	0030      	movs	r0, r6
   12ba4:	f000 fbb2 	bl	1330c <__swhatbuf_r>
   12ba8:	89a3      	ldrh	r3, [r4, #12]
   12baa:	4318      	orrs	r0, r3
   12bac:	81a0      	strh	r0, [r4, #12]
   12bae:	2d00      	cmp	r5, #0
   12bb0:	d101      	bne.n	12bb6 <setvbuf+0xaa>
   12bb2:	9d02      	ldr	r5, [sp, #8]
   12bb4:	e001      	b.n	12bba <setvbuf+0xae>
   12bb6:	2f00      	cmp	r7, #0
   12bb8:	d125      	bne.n	12c06 <setvbuf+0xfa>
   12bba:	0028      	movs	r0, r5
   12bbc:	f7ff fdf0 	bl	127a0 <malloc>
   12bc0:	9501      	str	r5, [sp, #4]
   12bc2:	1e07      	subs	r7, r0, #0
   12bc4:	d11a      	bne.n	12bfc <setvbuf+0xf0>
   12bc6:	9b02      	ldr	r3, [sp, #8]
   12bc8:	9301      	str	r3, [sp, #4]
   12bca:	42ab      	cmp	r3, r5
   12bcc:	d102      	bne.n	12bd4 <setvbuf+0xc8>
   12bce:	2001      	movs	r0, #1
   12bd0:	4240      	negs	r0, r0
   12bd2:	e006      	b.n	12be2 <setvbuf+0xd6>
   12bd4:	9801      	ldr	r0, [sp, #4]
   12bd6:	f7ff fde3 	bl	127a0 <malloc>
   12bda:	1e07      	subs	r7, r0, #0
   12bdc:	d10e      	bne.n	12bfc <setvbuf+0xf0>
   12bde:	e7f6      	b.n	12bce <setvbuf+0xc2>
   12be0:	2000      	movs	r0, #0
   12be2:	2202      	movs	r2, #2
   12be4:	89a3      	ldrh	r3, [r4, #12]
   12be6:	4313      	orrs	r3, r2
   12be8:	81a3      	strh	r3, [r4, #12]
   12bea:	2300      	movs	r3, #0
   12bec:	60a3      	str	r3, [r4, #8]
   12bee:	0023      	movs	r3, r4
   12bf0:	3347      	adds	r3, #71	; 0x47
   12bf2:	6023      	str	r3, [r4, #0]
   12bf4:	6123      	str	r3, [r4, #16]
   12bf6:	2301      	movs	r3, #1
   12bf8:	6163      	str	r3, [r4, #20]
   12bfa:	e02a      	b.n	12c52 <setvbuf+0x146>
   12bfc:	2280      	movs	r2, #128	; 0x80
   12bfe:	89a3      	ldrh	r3, [r4, #12]
   12c00:	9d01      	ldr	r5, [sp, #4]
   12c02:	4313      	orrs	r3, r2
   12c04:	81a3      	strh	r3, [r4, #12]
   12c06:	69b3      	ldr	r3, [r6, #24]
   12c08:	2b00      	cmp	r3, #0
   12c0a:	d102      	bne.n	12c12 <setvbuf+0x106>
   12c0c:	0030      	movs	r0, r6
   12c0e:	f000 fab9 	bl	13184 <__sinit>
   12c12:	9b00      	ldr	r3, [sp, #0]
   12c14:	2b01      	cmp	r3, #1
   12c16:	d103      	bne.n	12c20 <setvbuf+0x114>
   12c18:	89a3      	ldrh	r3, [r4, #12]
   12c1a:	9a00      	ldr	r2, [sp, #0]
   12c1c:	431a      	orrs	r2, r3
   12c1e:	81a2      	strh	r2, [r4, #12]
   12c20:	2308      	movs	r3, #8
   12c22:	89a2      	ldrh	r2, [r4, #12]
   12c24:	6027      	str	r7, [r4, #0]
   12c26:	4013      	ands	r3, r2
   12c28:	6127      	str	r7, [r4, #16]
   12c2a:	6165      	str	r5, [r4, #20]
   12c2c:	1e18      	subs	r0, r3, #0
   12c2e:	d00c      	beq.n	12c4a <setvbuf+0x13e>
   12c30:	2301      	movs	r3, #1
   12c32:	401a      	ands	r2, r3
   12c34:	2300      	movs	r3, #0
   12c36:	1e10      	subs	r0, r2, #0
   12c38:	4298      	cmp	r0, r3
   12c3a:	d004      	beq.n	12c46 <setvbuf+0x13a>
   12c3c:	426d      	negs	r5, r5
   12c3e:	60a3      	str	r3, [r4, #8]
   12c40:	61a5      	str	r5, [r4, #24]
   12c42:	0018      	movs	r0, r3
   12c44:	e005      	b.n	12c52 <setvbuf+0x146>
   12c46:	60a5      	str	r5, [r4, #8]
   12c48:	e003      	b.n	12c52 <setvbuf+0x146>
   12c4a:	60a3      	str	r3, [r4, #8]
   12c4c:	e001      	b.n	12c52 <setvbuf+0x146>
   12c4e:	2001      	movs	r0, #1
   12c50:	4240      	negs	r0, r0
   12c52:	b005      	add	sp, #20
   12c54:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12c56:	46c0      	nop			; (mov r8, r8)
   12c58:	200001e0 	.word	0x200001e0
   12c5c:	00015a5c 	.word	0x00015a5c
   12c60:	00015a7c 	.word	0x00015a7c
   12c64:	00015a9c 	.word	0x00015a9c
   12c68:	fffff35c 	.word	0xfffff35c

00012c6c <siprintf>:
   12c6c:	b40e      	push	{r1, r2, r3}
   12c6e:	b510      	push	{r4, lr}
   12c70:	b09d      	sub	sp, #116	; 0x74
   12c72:	a902      	add	r1, sp, #8
   12c74:	9002      	str	r0, [sp, #8]
   12c76:	6108      	str	r0, [r1, #16]
   12c78:	480b      	ldr	r0, [pc, #44]	; (12ca8 <siprintf+0x3c>)
   12c7a:	2482      	movs	r4, #130	; 0x82
   12c7c:	6088      	str	r0, [r1, #8]
   12c7e:	6148      	str	r0, [r1, #20]
   12c80:	2001      	movs	r0, #1
   12c82:	4240      	negs	r0, r0
   12c84:	ab1f      	add	r3, sp, #124	; 0x7c
   12c86:	81c8      	strh	r0, [r1, #14]
   12c88:	4808      	ldr	r0, [pc, #32]	; (12cac <siprintf+0x40>)
   12c8a:	cb04      	ldmia	r3!, {r2}
   12c8c:	00a4      	lsls	r4, r4, #2
   12c8e:	6800      	ldr	r0, [r0, #0]
   12c90:	9301      	str	r3, [sp, #4]
   12c92:	818c      	strh	r4, [r1, #12]
   12c94:	f000 fc00 	bl	13498 <_svfiprintf_r>
   12c98:	2300      	movs	r3, #0
   12c9a:	9a02      	ldr	r2, [sp, #8]
   12c9c:	7013      	strb	r3, [r2, #0]
   12c9e:	b01d      	add	sp, #116	; 0x74
   12ca0:	bc10      	pop	{r4}
   12ca2:	bc08      	pop	{r3}
   12ca4:	b003      	add	sp, #12
   12ca6:	4718      	bx	r3
   12ca8:	7fffffff 	.word	0x7fffffff
   12cac:	200001e0 	.word	0x200001e0

00012cb0 <__sread>:
   12cb0:	b570      	push	{r4, r5, r6, lr}
   12cb2:	000c      	movs	r4, r1
   12cb4:	250e      	movs	r5, #14
   12cb6:	5f49      	ldrsh	r1, [r1, r5]
   12cb8:	f001 fafe 	bl	142b8 <_read_r>
   12cbc:	2800      	cmp	r0, #0
   12cbe:	db03      	blt.n	12cc8 <__sread+0x18>
   12cc0:	6d63      	ldr	r3, [r4, #84]	; 0x54
   12cc2:	181b      	adds	r3, r3, r0
   12cc4:	6563      	str	r3, [r4, #84]	; 0x54
   12cc6:	e003      	b.n	12cd0 <__sread+0x20>
   12cc8:	89a2      	ldrh	r2, [r4, #12]
   12cca:	4b02      	ldr	r3, [pc, #8]	; (12cd4 <__sread+0x24>)
   12ccc:	4013      	ands	r3, r2
   12cce:	81a3      	strh	r3, [r4, #12]
   12cd0:	bd70      	pop	{r4, r5, r6, pc}
   12cd2:	46c0      	nop			; (mov r8, r8)
   12cd4:	ffffefff 	.word	0xffffefff

00012cd8 <__swrite>:
   12cd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12cda:	001f      	movs	r7, r3
   12cdc:	898b      	ldrh	r3, [r1, #12]
   12cde:	0005      	movs	r5, r0
   12ce0:	000c      	movs	r4, r1
   12ce2:	0016      	movs	r6, r2
   12ce4:	05db      	lsls	r3, r3, #23
   12ce6:	d505      	bpl.n	12cf4 <__swrite+0x1c>
   12ce8:	230e      	movs	r3, #14
   12cea:	5ec9      	ldrsh	r1, [r1, r3]
   12cec:	2200      	movs	r2, #0
   12cee:	2302      	movs	r3, #2
   12cf0:	f000 faf8 	bl	132e4 <_lseek_r>
   12cf4:	89a2      	ldrh	r2, [r4, #12]
   12cf6:	4b05      	ldr	r3, [pc, #20]	; (12d0c <__swrite+0x34>)
   12cf8:	0028      	movs	r0, r5
   12cfa:	4013      	ands	r3, r2
   12cfc:	81a3      	strh	r3, [r4, #12]
   12cfe:	0032      	movs	r2, r6
   12d00:	230e      	movs	r3, #14
   12d02:	5ee1      	ldrsh	r1, [r4, r3]
   12d04:	003b      	movs	r3, r7
   12d06:	f000 f899 	bl	12e3c <_write_r>
   12d0a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   12d0c:	ffffefff 	.word	0xffffefff

00012d10 <__sseek>:
   12d10:	b570      	push	{r4, r5, r6, lr}
   12d12:	000c      	movs	r4, r1
   12d14:	250e      	movs	r5, #14
   12d16:	5f49      	ldrsh	r1, [r1, r5]
   12d18:	f000 fae4 	bl	132e4 <_lseek_r>
   12d1c:	89a3      	ldrh	r3, [r4, #12]
   12d1e:	1c42      	adds	r2, r0, #1
   12d20:	d103      	bne.n	12d2a <__sseek+0x1a>
   12d22:	4a05      	ldr	r2, [pc, #20]	; (12d38 <__sseek+0x28>)
   12d24:	4013      	ands	r3, r2
   12d26:	81a3      	strh	r3, [r4, #12]
   12d28:	e004      	b.n	12d34 <__sseek+0x24>
   12d2a:	2280      	movs	r2, #128	; 0x80
   12d2c:	0152      	lsls	r2, r2, #5
   12d2e:	4313      	orrs	r3, r2
   12d30:	81a3      	strh	r3, [r4, #12]
   12d32:	6560      	str	r0, [r4, #84]	; 0x54
   12d34:	bd70      	pop	{r4, r5, r6, pc}
   12d36:	46c0      	nop			; (mov r8, r8)
   12d38:	ffffefff 	.word	0xffffefff

00012d3c <__sclose>:
   12d3c:	b510      	push	{r4, lr}
   12d3e:	230e      	movs	r3, #14
   12d40:	5ec9      	ldrsh	r1, [r1, r3]
   12d42:	f000 f905 	bl	12f50 <_close_r>
   12d46:	bd10      	pop	{r4, pc}

00012d48 <strlen>:
   12d48:	2300      	movs	r3, #0
   12d4a:	5cc2      	ldrb	r2, [r0, r3]
   12d4c:	3301      	adds	r3, #1
   12d4e:	2a00      	cmp	r2, #0
   12d50:	d1fb      	bne.n	12d4a <strlen+0x2>
   12d52:	1e58      	subs	r0, r3, #1
   12d54:	4770      	bx	lr

00012d56 <strstr>:
   12d56:	b510      	push	{r4, lr}
   12d58:	7803      	ldrb	r3, [r0, #0]
   12d5a:	0002      	movs	r2, r0
   12d5c:	2b00      	cmp	r3, #0
   12d5e:	d105      	bne.n	12d6c <strstr+0x16>
   12d60:	7809      	ldrb	r1, [r1, #0]
   12d62:	0018      	movs	r0, r3
   12d64:	2900      	cmp	r1, #0
   12d66:	d00d      	beq.n	12d84 <strstr+0x2e>
   12d68:	e00f      	b.n	12d8a <strstr+0x34>
   12d6a:	3201      	adds	r2, #1
   12d6c:	7813      	ldrb	r3, [r2, #0]
   12d6e:	2b00      	cmp	r3, #0
   12d70:	d00a      	beq.n	12d88 <strstr+0x32>
   12d72:	2300      	movs	r3, #0
   12d74:	5cc8      	ldrb	r0, [r1, r3]
   12d76:	2800      	cmp	r0, #0
   12d78:	d004      	beq.n	12d84 <strstr+0x2e>
   12d7a:	5cd4      	ldrb	r4, [r2, r3]
   12d7c:	4284      	cmp	r4, r0
   12d7e:	d1f4      	bne.n	12d6a <strstr+0x14>
   12d80:	3301      	adds	r3, #1
   12d82:	e7f7      	b.n	12d74 <strstr+0x1e>
   12d84:	0010      	movs	r0, r2
   12d86:	e000      	b.n	12d8a <strstr+0x34>
   12d88:	0018      	movs	r0, r3
   12d8a:	bd10      	pop	{r4, pc}

00012d8c <__swbuf_r>:
   12d8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12d8e:	0005      	movs	r5, r0
   12d90:	000f      	movs	r7, r1
   12d92:	0014      	movs	r4, r2
   12d94:	2800      	cmp	r0, #0
   12d96:	d004      	beq.n	12da2 <__swbuf_r+0x16>
   12d98:	6983      	ldr	r3, [r0, #24]
   12d9a:	2b00      	cmp	r3, #0
   12d9c:	d101      	bne.n	12da2 <__swbuf_r+0x16>
   12d9e:	f000 f9f1 	bl	13184 <__sinit>
   12da2:	4b23      	ldr	r3, [pc, #140]	; (12e30 <__swbuf_r+0xa4>)
   12da4:	429c      	cmp	r4, r3
   12da6:	d101      	bne.n	12dac <__swbuf_r+0x20>
   12da8:	686c      	ldr	r4, [r5, #4]
   12daa:	e008      	b.n	12dbe <__swbuf_r+0x32>
   12dac:	4b21      	ldr	r3, [pc, #132]	; (12e34 <__swbuf_r+0xa8>)
   12dae:	429c      	cmp	r4, r3
   12db0:	d101      	bne.n	12db6 <__swbuf_r+0x2a>
   12db2:	68ac      	ldr	r4, [r5, #8]
   12db4:	e003      	b.n	12dbe <__swbuf_r+0x32>
   12db6:	4b20      	ldr	r3, [pc, #128]	; (12e38 <__swbuf_r+0xac>)
   12db8:	429c      	cmp	r4, r3
   12dba:	d100      	bne.n	12dbe <__swbuf_r+0x32>
   12dbc:	68ec      	ldr	r4, [r5, #12]
   12dbe:	69a3      	ldr	r3, [r4, #24]
   12dc0:	60a3      	str	r3, [r4, #8]
   12dc2:	89a3      	ldrh	r3, [r4, #12]
   12dc4:	071b      	lsls	r3, r3, #28
   12dc6:	d50a      	bpl.n	12dde <__swbuf_r+0x52>
   12dc8:	6923      	ldr	r3, [r4, #16]
   12dca:	2b00      	cmp	r3, #0
   12dcc:	d007      	beq.n	12dde <__swbuf_r+0x52>
   12dce:	6823      	ldr	r3, [r4, #0]
   12dd0:	6922      	ldr	r2, [r4, #16]
   12dd2:	b2fe      	uxtb	r6, r7
   12dd4:	1a98      	subs	r0, r3, r2
   12dd6:	6963      	ldr	r3, [r4, #20]
   12dd8:	4298      	cmp	r0, r3
   12dda:	db0f      	blt.n	12dfc <__swbuf_r+0x70>
   12ddc:	e008      	b.n	12df0 <__swbuf_r+0x64>
   12dde:	0021      	movs	r1, r4
   12de0:	0028      	movs	r0, r5
   12de2:	f000 f83f 	bl	12e64 <__swsetup_r>
   12de6:	2800      	cmp	r0, #0
   12de8:	d0f1      	beq.n	12dce <__swbuf_r+0x42>
   12dea:	2001      	movs	r0, #1
   12dec:	4240      	negs	r0, r0
   12dee:	e01d      	b.n	12e2c <__swbuf_r+0xa0>
   12df0:	0021      	movs	r1, r4
   12df2:	0028      	movs	r0, r5
   12df4:	f000 f944 	bl	13080 <_fflush_r>
   12df8:	2800      	cmp	r0, #0
   12dfa:	d1f6      	bne.n	12dea <__swbuf_r+0x5e>
   12dfc:	68a3      	ldr	r3, [r4, #8]
   12dfe:	3001      	adds	r0, #1
   12e00:	3b01      	subs	r3, #1
   12e02:	60a3      	str	r3, [r4, #8]
   12e04:	6823      	ldr	r3, [r4, #0]
   12e06:	1c5a      	adds	r2, r3, #1
   12e08:	6022      	str	r2, [r4, #0]
   12e0a:	701f      	strb	r7, [r3, #0]
   12e0c:	6963      	ldr	r3, [r4, #20]
   12e0e:	4298      	cmp	r0, r3
   12e10:	d005      	beq.n	12e1e <__swbuf_r+0x92>
   12e12:	89a3      	ldrh	r3, [r4, #12]
   12e14:	0030      	movs	r0, r6
   12e16:	07db      	lsls	r3, r3, #31
   12e18:	d508      	bpl.n	12e2c <__swbuf_r+0xa0>
   12e1a:	2e0a      	cmp	r6, #10
   12e1c:	d106      	bne.n	12e2c <__swbuf_r+0xa0>
   12e1e:	0021      	movs	r1, r4
   12e20:	0028      	movs	r0, r5
   12e22:	f000 f92d 	bl	13080 <_fflush_r>
   12e26:	2800      	cmp	r0, #0
   12e28:	d1df      	bne.n	12dea <__swbuf_r+0x5e>
   12e2a:	0030      	movs	r0, r6
   12e2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   12e2e:	46c0      	nop			; (mov r8, r8)
   12e30:	00015a5c 	.word	0x00015a5c
   12e34:	00015a7c 	.word	0x00015a7c
   12e38:	00015a9c 	.word	0x00015a9c

00012e3c <_write_r>:
   12e3c:	b570      	push	{r4, r5, r6, lr}
   12e3e:	0005      	movs	r5, r0
   12e40:	0008      	movs	r0, r1
   12e42:	0011      	movs	r1, r2
   12e44:	2200      	movs	r2, #0
   12e46:	4c06      	ldr	r4, [pc, #24]	; (12e60 <_write_r+0x24>)
   12e48:	6022      	str	r2, [r4, #0]
   12e4a:	001a      	movs	r2, r3
   12e4c:	f7f2 fdc6 	bl	59dc <_write>
   12e50:	1c43      	adds	r3, r0, #1
   12e52:	d103      	bne.n	12e5c <_write_r+0x20>
   12e54:	6823      	ldr	r3, [r4, #0]
   12e56:	2b00      	cmp	r3, #0
   12e58:	d000      	beq.n	12e5c <_write_r+0x20>
   12e5a:	602b      	str	r3, [r5, #0]
   12e5c:	bd70      	pop	{r4, r5, r6, pc}
   12e5e:	46c0      	nop			; (mov r8, r8)
   12e60:	20001880 	.word	0x20001880

00012e64 <__swsetup_r>:
   12e64:	4b36      	ldr	r3, [pc, #216]	; (12f40 <__swsetup_r+0xdc>)
   12e66:	b570      	push	{r4, r5, r6, lr}
   12e68:	681d      	ldr	r5, [r3, #0]
   12e6a:	0006      	movs	r6, r0
   12e6c:	000c      	movs	r4, r1
   12e6e:	2d00      	cmp	r5, #0
   12e70:	d005      	beq.n	12e7e <__swsetup_r+0x1a>
   12e72:	69ab      	ldr	r3, [r5, #24]
   12e74:	2b00      	cmp	r3, #0
   12e76:	d102      	bne.n	12e7e <__swsetup_r+0x1a>
   12e78:	0028      	movs	r0, r5
   12e7a:	f000 f983 	bl	13184 <__sinit>
   12e7e:	4b31      	ldr	r3, [pc, #196]	; (12f44 <__swsetup_r+0xe0>)
   12e80:	429c      	cmp	r4, r3
   12e82:	d101      	bne.n	12e88 <__swsetup_r+0x24>
   12e84:	686c      	ldr	r4, [r5, #4]
   12e86:	e008      	b.n	12e9a <__swsetup_r+0x36>
   12e88:	4b2f      	ldr	r3, [pc, #188]	; (12f48 <__swsetup_r+0xe4>)
   12e8a:	429c      	cmp	r4, r3
   12e8c:	d101      	bne.n	12e92 <__swsetup_r+0x2e>
   12e8e:	68ac      	ldr	r4, [r5, #8]
   12e90:	e003      	b.n	12e9a <__swsetup_r+0x36>
   12e92:	4b2e      	ldr	r3, [pc, #184]	; (12f4c <__swsetup_r+0xe8>)
   12e94:	429c      	cmp	r4, r3
   12e96:	d100      	bne.n	12e9a <__swsetup_r+0x36>
   12e98:	68ec      	ldr	r4, [r5, #12]
   12e9a:	220c      	movs	r2, #12
   12e9c:	5ea3      	ldrsh	r3, [r4, r2]
   12e9e:	b29a      	uxth	r2, r3
   12ea0:	0711      	lsls	r1, r2, #28
   12ea2:	d423      	bmi.n	12eec <__swsetup_r+0x88>
   12ea4:	06d1      	lsls	r1, r2, #27
   12ea6:	d407      	bmi.n	12eb8 <__swsetup_r+0x54>
   12ea8:	2209      	movs	r2, #9
   12eaa:	2001      	movs	r0, #1
   12eac:	6032      	str	r2, [r6, #0]
   12eae:	3237      	adds	r2, #55	; 0x37
   12eb0:	4313      	orrs	r3, r2
   12eb2:	81a3      	strh	r3, [r4, #12]
   12eb4:	4240      	negs	r0, r0
   12eb6:	e042      	b.n	12f3e <__swsetup_r+0xda>
   12eb8:	0753      	lsls	r3, r2, #29
   12eba:	d513      	bpl.n	12ee4 <__swsetup_r+0x80>
   12ebc:	6b61      	ldr	r1, [r4, #52]	; 0x34
   12ebe:	2900      	cmp	r1, #0
   12ec0:	d008      	beq.n	12ed4 <__swsetup_r+0x70>
   12ec2:	0023      	movs	r3, r4
   12ec4:	3344      	adds	r3, #68	; 0x44
   12ec6:	4299      	cmp	r1, r3
   12ec8:	d002      	beq.n	12ed0 <__swsetup_r+0x6c>
   12eca:	0030      	movs	r0, r6
   12ecc:	f7ff fcb2 	bl	12834 <_free_r>
   12ed0:	2300      	movs	r3, #0
   12ed2:	6363      	str	r3, [r4, #52]	; 0x34
   12ed4:	2224      	movs	r2, #36	; 0x24
   12ed6:	89a3      	ldrh	r3, [r4, #12]
   12ed8:	4393      	bics	r3, r2
   12eda:	81a3      	strh	r3, [r4, #12]
   12edc:	2300      	movs	r3, #0
   12ede:	6063      	str	r3, [r4, #4]
   12ee0:	6923      	ldr	r3, [r4, #16]
   12ee2:	6023      	str	r3, [r4, #0]
   12ee4:	2208      	movs	r2, #8
   12ee6:	89a3      	ldrh	r3, [r4, #12]
   12ee8:	4313      	orrs	r3, r2
   12eea:	81a3      	strh	r3, [r4, #12]
   12eec:	6923      	ldr	r3, [r4, #16]
   12eee:	2b00      	cmp	r3, #0
   12ef0:	d10b      	bne.n	12f0a <__swsetup_r+0xa6>
   12ef2:	23a0      	movs	r3, #160	; 0xa0
   12ef4:	89a2      	ldrh	r2, [r4, #12]
   12ef6:	009b      	lsls	r3, r3, #2
   12ef8:	4013      	ands	r3, r2
   12efa:	2280      	movs	r2, #128	; 0x80
   12efc:	0092      	lsls	r2, r2, #2
   12efe:	4293      	cmp	r3, r2
   12f00:	d003      	beq.n	12f0a <__swsetup_r+0xa6>
   12f02:	0021      	movs	r1, r4
   12f04:	0030      	movs	r0, r6
   12f06:	f000 fa27 	bl	13358 <__smakebuf_r>
   12f0a:	2301      	movs	r3, #1
   12f0c:	89a2      	ldrh	r2, [r4, #12]
   12f0e:	4013      	ands	r3, r2
   12f10:	d005      	beq.n	12f1e <__swsetup_r+0xba>
   12f12:	2300      	movs	r3, #0
   12f14:	60a3      	str	r3, [r4, #8]
   12f16:	6963      	ldr	r3, [r4, #20]
   12f18:	425b      	negs	r3, r3
   12f1a:	61a3      	str	r3, [r4, #24]
   12f1c:	e003      	b.n	12f26 <__swsetup_r+0xc2>
   12f1e:	0792      	lsls	r2, r2, #30
   12f20:	d400      	bmi.n	12f24 <__swsetup_r+0xc0>
   12f22:	6963      	ldr	r3, [r4, #20]
   12f24:	60a3      	str	r3, [r4, #8]
   12f26:	2000      	movs	r0, #0
   12f28:	6923      	ldr	r3, [r4, #16]
   12f2a:	4283      	cmp	r3, r0
   12f2c:	d107      	bne.n	12f3e <__swsetup_r+0xda>
   12f2e:	220c      	movs	r2, #12
   12f30:	5ea3      	ldrsh	r3, [r4, r2]
   12f32:	061a      	lsls	r2, r3, #24
   12f34:	d503      	bpl.n	12f3e <__swsetup_r+0xda>
   12f36:	2240      	movs	r2, #64	; 0x40
   12f38:	4313      	orrs	r3, r2
   12f3a:	81a3      	strh	r3, [r4, #12]
   12f3c:	3801      	subs	r0, #1
   12f3e:	bd70      	pop	{r4, r5, r6, pc}
   12f40:	200001e0 	.word	0x200001e0
   12f44:	00015a5c 	.word	0x00015a5c
   12f48:	00015a7c 	.word	0x00015a7c
   12f4c:	00015a9c 	.word	0x00015a9c

00012f50 <_close_r>:
   12f50:	2300      	movs	r3, #0
   12f52:	b570      	push	{r4, r5, r6, lr}
   12f54:	4c06      	ldr	r4, [pc, #24]	; (12f70 <_close_r+0x20>)
   12f56:	0005      	movs	r5, r0
   12f58:	0008      	movs	r0, r1
   12f5a:	6023      	str	r3, [r4, #0]
   12f5c:	f7ff f8aa 	bl	120b4 <_close>
   12f60:	1c43      	adds	r3, r0, #1
   12f62:	d103      	bne.n	12f6c <_close_r+0x1c>
   12f64:	6823      	ldr	r3, [r4, #0]
   12f66:	2b00      	cmp	r3, #0
   12f68:	d000      	beq.n	12f6c <_close_r+0x1c>
   12f6a:	602b      	str	r3, [r5, #0]
   12f6c:	bd70      	pop	{r4, r5, r6, pc}
   12f6e:	46c0      	nop			; (mov r8, r8)
   12f70:	20001880 	.word	0x20001880

00012f74 <__sflush_r>:
   12f74:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   12f76:	898a      	ldrh	r2, [r1, #12]
   12f78:	0005      	movs	r5, r0
   12f7a:	000c      	movs	r4, r1
   12f7c:	0713      	lsls	r3, r2, #28
   12f7e:	d45a      	bmi.n	13036 <__sflush_r+0xc2>
   12f80:	684b      	ldr	r3, [r1, #4]
   12f82:	2b00      	cmp	r3, #0
   12f84:	dc02      	bgt.n	12f8c <__sflush_r+0x18>
   12f86:	6c0b      	ldr	r3, [r1, #64]	; 0x40
   12f88:	2b00      	cmp	r3, #0
   12f8a:	dd19      	ble.n	12fc0 <__sflush_r+0x4c>
   12f8c:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
   12f8e:	2f00      	cmp	r7, #0
   12f90:	d016      	beq.n	12fc0 <__sflush_r+0x4c>
   12f92:	2300      	movs	r3, #0
   12f94:	682e      	ldr	r6, [r5, #0]
   12f96:	602b      	str	r3, [r5, #0]
   12f98:	2380      	movs	r3, #128	; 0x80
   12f9a:	015b      	lsls	r3, r3, #5
   12f9c:	401a      	ands	r2, r3
   12f9e:	d001      	beq.n	12fa4 <__sflush_r+0x30>
   12fa0:	6d60      	ldr	r0, [r4, #84]	; 0x54
   12fa2:	e014      	b.n	12fce <__sflush_r+0x5a>
   12fa4:	2301      	movs	r3, #1
   12fa6:	6a21      	ldr	r1, [r4, #32]
   12fa8:	0028      	movs	r0, r5
   12faa:	47b8      	blx	r7
   12fac:	1c43      	adds	r3, r0, #1
   12fae:	d10e      	bne.n	12fce <__sflush_r+0x5a>
   12fb0:	682b      	ldr	r3, [r5, #0]
   12fb2:	2b00      	cmp	r3, #0
   12fb4:	d00b      	beq.n	12fce <__sflush_r+0x5a>
   12fb6:	2b1d      	cmp	r3, #29
   12fb8:	d001      	beq.n	12fbe <__sflush_r+0x4a>
   12fba:	2b16      	cmp	r3, #22
   12fbc:	d102      	bne.n	12fc4 <__sflush_r+0x50>
   12fbe:	602e      	str	r6, [r5, #0]
   12fc0:	2000      	movs	r0, #0
   12fc2:	e05a      	b.n	1307a <__sflush_r+0x106>
   12fc4:	2240      	movs	r2, #64	; 0x40
   12fc6:	89a3      	ldrh	r3, [r4, #12]
   12fc8:	4313      	orrs	r3, r2
   12fca:	81a3      	strh	r3, [r4, #12]
   12fcc:	e055      	b.n	1307a <__sflush_r+0x106>
   12fce:	89a3      	ldrh	r3, [r4, #12]
   12fd0:	075b      	lsls	r3, r3, #29
   12fd2:	d506      	bpl.n	12fe2 <__sflush_r+0x6e>
   12fd4:	6863      	ldr	r3, [r4, #4]
   12fd6:	1ac0      	subs	r0, r0, r3
   12fd8:	6b63      	ldr	r3, [r4, #52]	; 0x34
   12fda:	2b00      	cmp	r3, #0
   12fdc:	d001      	beq.n	12fe2 <__sflush_r+0x6e>
   12fde:	6c23      	ldr	r3, [r4, #64]	; 0x40
   12fe0:	1ac0      	subs	r0, r0, r3
   12fe2:	2300      	movs	r3, #0
   12fe4:	0002      	movs	r2, r0
   12fe6:	6a21      	ldr	r1, [r4, #32]
   12fe8:	0028      	movs	r0, r5
   12fea:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
   12fec:	47b8      	blx	r7
   12fee:	89a3      	ldrh	r3, [r4, #12]
   12ff0:	1c42      	adds	r2, r0, #1
   12ff2:	d106      	bne.n	13002 <__sflush_r+0x8e>
   12ff4:	6829      	ldr	r1, [r5, #0]
   12ff6:	291d      	cmp	r1, #29
   12ff8:	d83a      	bhi.n	13070 <__sflush_r+0xfc>
   12ffa:	4a20      	ldr	r2, [pc, #128]	; (1307c <__sflush_r+0x108>)
   12ffc:	40ca      	lsrs	r2, r1
   12ffe:	07d2      	lsls	r2, r2, #31
   13000:	d536      	bpl.n	13070 <__sflush_r+0xfc>
   13002:	2200      	movs	r2, #0
   13004:	6062      	str	r2, [r4, #4]
   13006:	6922      	ldr	r2, [r4, #16]
   13008:	6022      	str	r2, [r4, #0]
   1300a:	04db      	lsls	r3, r3, #19
   1300c:	d505      	bpl.n	1301a <__sflush_r+0xa6>
   1300e:	1c43      	adds	r3, r0, #1
   13010:	d102      	bne.n	13018 <__sflush_r+0xa4>
   13012:	682b      	ldr	r3, [r5, #0]
   13014:	2b00      	cmp	r3, #0
   13016:	d100      	bne.n	1301a <__sflush_r+0xa6>
   13018:	6560      	str	r0, [r4, #84]	; 0x54
   1301a:	6b61      	ldr	r1, [r4, #52]	; 0x34
   1301c:	602e      	str	r6, [r5, #0]
   1301e:	2900      	cmp	r1, #0
   13020:	d0ce      	beq.n	12fc0 <__sflush_r+0x4c>
   13022:	0023      	movs	r3, r4
   13024:	3344      	adds	r3, #68	; 0x44
   13026:	4299      	cmp	r1, r3
   13028:	d002      	beq.n	13030 <__sflush_r+0xbc>
   1302a:	0028      	movs	r0, r5
   1302c:	f7ff fc02 	bl	12834 <_free_r>
   13030:	2000      	movs	r0, #0
   13032:	6360      	str	r0, [r4, #52]	; 0x34
   13034:	e021      	b.n	1307a <__sflush_r+0x106>
   13036:	690f      	ldr	r7, [r1, #16]
   13038:	2f00      	cmp	r7, #0
   1303a:	d0c1      	beq.n	12fc0 <__sflush_r+0x4c>
   1303c:	680b      	ldr	r3, [r1, #0]
   1303e:	600f      	str	r7, [r1, #0]
   13040:	1bdb      	subs	r3, r3, r7
   13042:	9301      	str	r3, [sp, #4]
   13044:	2300      	movs	r3, #0
   13046:	0792      	lsls	r2, r2, #30
   13048:	d100      	bne.n	1304c <__sflush_r+0xd8>
   1304a:	694b      	ldr	r3, [r1, #20]
   1304c:	60a3      	str	r3, [r4, #8]
   1304e:	e003      	b.n	13058 <__sflush_r+0xe4>
   13050:	9b01      	ldr	r3, [sp, #4]
   13052:	183f      	adds	r7, r7, r0
   13054:	1a1b      	subs	r3, r3, r0
   13056:	9301      	str	r3, [sp, #4]
   13058:	9b01      	ldr	r3, [sp, #4]
   1305a:	2b00      	cmp	r3, #0
   1305c:	ddb0      	ble.n	12fc0 <__sflush_r+0x4c>
   1305e:	9b01      	ldr	r3, [sp, #4]
   13060:	003a      	movs	r2, r7
   13062:	6a21      	ldr	r1, [r4, #32]
   13064:	0028      	movs	r0, r5
   13066:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   13068:	47b0      	blx	r6
   1306a:	2800      	cmp	r0, #0
   1306c:	dcf0      	bgt.n	13050 <__sflush_r+0xdc>
   1306e:	89a3      	ldrh	r3, [r4, #12]
   13070:	2240      	movs	r2, #64	; 0x40
   13072:	2001      	movs	r0, #1
   13074:	4313      	orrs	r3, r2
   13076:	81a3      	strh	r3, [r4, #12]
   13078:	4240      	negs	r0, r0
   1307a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1307c:	20400001 	.word	0x20400001

00013080 <_fflush_r>:
   13080:	690b      	ldr	r3, [r1, #16]
   13082:	b570      	push	{r4, r5, r6, lr}
   13084:	0005      	movs	r5, r0
   13086:	000c      	movs	r4, r1
   13088:	2b00      	cmp	r3, #0
   1308a:	d101      	bne.n	13090 <_fflush_r+0x10>
   1308c:	2000      	movs	r0, #0
   1308e:	e01c      	b.n	130ca <_fflush_r+0x4a>
   13090:	2800      	cmp	r0, #0
   13092:	d004      	beq.n	1309e <_fflush_r+0x1e>
   13094:	6983      	ldr	r3, [r0, #24]
   13096:	2b00      	cmp	r3, #0
   13098:	d101      	bne.n	1309e <_fflush_r+0x1e>
   1309a:	f000 f873 	bl	13184 <__sinit>
   1309e:	4b0b      	ldr	r3, [pc, #44]	; (130cc <_fflush_r+0x4c>)
   130a0:	429c      	cmp	r4, r3
   130a2:	d101      	bne.n	130a8 <_fflush_r+0x28>
   130a4:	686c      	ldr	r4, [r5, #4]
   130a6:	e008      	b.n	130ba <_fflush_r+0x3a>
   130a8:	4b09      	ldr	r3, [pc, #36]	; (130d0 <_fflush_r+0x50>)
   130aa:	429c      	cmp	r4, r3
   130ac:	d101      	bne.n	130b2 <_fflush_r+0x32>
   130ae:	68ac      	ldr	r4, [r5, #8]
   130b0:	e003      	b.n	130ba <_fflush_r+0x3a>
   130b2:	4b08      	ldr	r3, [pc, #32]	; (130d4 <_fflush_r+0x54>)
   130b4:	429c      	cmp	r4, r3
   130b6:	d100      	bne.n	130ba <_fflush_r+0x3a>
   130b8:	68ec      	ldr	r4, [r5, #12]
   130ba:	220c      	movs	r2, #12
   130bc:	5ea3      	ldrsh	r3, [r4, r2]
   130be:	2b00      	cmp	r3, #0
   130c0:	d0e4      	beq.n	1308c <_fflush_r+0xc>
   130c2:	0021      	movs	r1, r4
   130c4:	0028      	movs	r0, r5
   130c6:	f7ff ff55 	bl	12f74 <__sflush_r>
   130ca:	bd70      	pop	{r4, r5, r6, pc}
   130cc:	00015a5c 	.word	0x00015a5c
   130d0:	00015a7c 	.word	0x00015a7c
   130d4:	00015a9c 	.word	0x00015a9c

000130d8 <fflush>:
   130d8:	b510      	push	{r4, lr}
   130da:	1e01      	subs	r1, r0, #0
   130dc:	d105      	bne.n	130ea <fflush+0x12>
   130de:	4b05      	ldr	r3, [pc, #20]	; (130f4 <fflush+0x1c>)
   130e0:	4905      	ldr	r1, [pc, #20]	; (130f8 <fflush+0x20>)
   130e2:	6818      	ldr	r0, [r3, #0]
   130e4:	f000 f8dc 	bl	132a0 <_fwalk_reent>
   130e8:	e003      	b.n	130f2 <fflush+0x1a>
   130ea:	4b04      	ldr	r3, [pc, #16]	; (130fc <fflush+0x24>)
   130ec:	6818      	ldr	r0, [r3, #0]
   130ee:	f7ff ffc7 	bl	13080 <_fflush_r>
   130f2:	bd10      	pop	{r4, pc}
   130f4:	00015a58 	.word	0x00015a58
   130f8:	00013081 	.word	0x00013081
   130fc:	200001e0 	.word	0x200001e0

00013100 <_cleanup_r>:
   13100:	b510      	push	{r4, lr}
   13102:	4902      	ldr	r1, [pc, #8]	; (1310c <_cleanup_r+0xc>)
   13104:	f000 f8cc 	bl	132a0 <_fwalk_reent>
   13108:	bd10      	pop	{r4, pc}
   1310a:	46c0      	nop			; (mov r8, r8)
   1310c:	00013081 	.word	0x00013081

00013110 <std.isra.0>:
   13110:	2300      	movs	r3, #0
   13112:	b510      	push	{r4, lr}
   13114:	0004      	movs	r4, r0
   13116:	6003      	str	r3, [r0, #0]
   13118:	6043      	str	r3, [r0, #4]
   1311a:	6083      	str	r3, [r0, #8]
   1311c:	8181      	strh	r1, [r0, #12]
   1311e:	6643      	str	r3, [r0, #100]	; 0x64
   13120:	81c2      	strh	r2, [r0, #14]
   13122:	6103      	str	r3, [r0, #16]
   13124:	6143      	str	r3, [r0, #20]
   13126:	6183      	str	r3, [r0, #24]
   13128:	0019      	movs	r1, r3
   1312a:	2208      	movs	r2, #8
   1312c:	305c      	adds	r0, #92	; 0x5c
   1312e:	f7ff fb78 	bl	12822 <memset>
   13132:	4b05      	ldr	r3, [pc, #20]	; (13148 <std.isra.0+0x38>)
   13134:	6224      	str	r4, [r4, #32]
   13136:	6263      	str	r3, [r4, #36]	; 0x24
   13138:	4b04      	ldr	r3, [pc, #16]	; (1314c <std.isra.0+0x3c>)
   1313a:	62a3      	str	r3, [r4, #40]	; 0x28
   1313c:	4b04      	ldr	r3, [pc, #16]	; (13150 <std.isra.0+0x40>)
   1313e:	62e3      	str	r3, [r4, #44]	; 0x2c
   13140:	4b04      	ldr	r3, [pc, #16]	; (13154 <std.isra.0+0x44>)
   13142:	6323      	str	r3, [r4, #48]	; 0x30
   13144:	bd10      	pop	{r4, pc}
   13146:	46c0      	nop			; (mov r8, r8)
   13148:	00012cb1 	.word	0x00012cb1
   1314c:	00012cd9 	.word	0x00012cd9
   13150:	00012d11 	.word	0x00012d11
   13154:	00012d3d 	.word	0x00012d3d

00013158 <__sfmoreglue>:
   13158:	b570      	push	{r4, r5, r6, lr}
   1315a:	2568      	movs	r5, #104	; 0x68
   1315c:	1e4b      	subs	r3, r1, #1
   1315e:	435d      	muls	r5, r3
   13160:	000e      	movs	r6, r1
   13162:	0029      	movs	r1, r5
   13164:	3174      	adds	r1, #116	; 0x74
   13166:	f7ff fbab 	bl	128c0 <_malloc_r>
   1316a:	1e04      	subs	r4, r0, #0
   1316c:	d008      	beq.n	13180 <__sfmoreglue+0x28>
   1316e:	2100      	movs	r1, #0
   13170:	002a      	movs	r2, r5
   13172:	6001      	str	r1, [r0, #0]
   13174:	6046      	str	r6, [r0, #4]
   13176:	300c      	adds	r0, #12
   13178:	60a0      	str	r0, [r4, #8]
   1317a:	3268      	adds	r2, #104	; 0x68
   1317c:	f7ff fb51 	bl	12822 <memset>
   13180:	0020      	movs	r0, r4
   13182:	bd70      	pop	{r4, r5, r6, pc}

00013184 <__sinit>:
   13184:	6983      	ldr	r3, [r0, #24]
   13186:	b513      	push	{r0, r1, r4, lr}
   13188:	0004      	movs	r4, r0
   1318a:	2b00      	cmp	r3, #0
   1318c:	d128      	bne.n	131e0 <__sinit+0x5c>
   1318e:	6483      	str	r3, [r0, #72]	; 0x48
   13190:	64c3      	str	r3, [r0, #76]	; 0x4c
   13192:	6503      	str	r3, [r0, #80]	; 0x50
   13194:	4b13      	ldr	r3, [pc, #76]	; (131e4 <__sinit+0x60>)
   13196:	4a14      	ldr	r2, [pc, #80]	; (131e8 <__sinit+0x64>)
   13198:	681b      	ldr	r3, [r3, #0]
   1319a:	6282      	str	r2, [r0, #40]	; 0x28
   1319c:	9301      	str	r3, [sp, #4]
   1319e:	4298      	cmp	r0, r3
   131a0:	d101      	bne.n	131a6 <__sinit+0x22>
   131a2:	2301      	movs	r3, #1
   131a4:	6183      	str	r3, [r0, #24]
   131a6:	0020      	movs	r0, r4
   131a8:	f000 f820 	bl	131ec <__sfp>
   131ac:	6060      	str	r0, [r4, #4]
   131ae:	0020      	movs	r0, r4
   131b0:	f000 f81c 	bl	131ec <__sfp>
   131b4:	60a0      	str	r0, [r4, #8]
   131b6:	0020      	movs	r0, r4
   131b8:	f000 f818 	bl	131ec <__sfp>
   131bc:	2200      	movs	r2, #0
   131be:	60e0      	str	r0, [r4, #12]
   131c0:	2104      	movs	r1, #4
   131c2:	6860      	ldr	r0, [r4, #4]
   131c4:	f7ff ffa4 	bl	13110 <std.isra.0>
   131c8:	2201      	movs	r2, #1
   131ca:	2109      	movs	r1, #9
   131cc:	68a0      	ldr	r0, [r4, #8]
   131ce:	f7ff ff9f 	bl	13110 <std.isra.0>
   131d2:	2202      	movs	r2, #2
   131d4:	2112      	movs	r1, #18
   131d6:	68e0      	ldr	r0, [r4, #12]
   131d8:	f7ff ff9a 	bl	13110 <std.isra.0>
   131dc:	2301      	movs	r3, #1
   131de:	61a3      	str	r3, [r4, #24]
   131e0:	bd13      	pop	{r0, r1, r4, pc}
   131e2:	46c0      	nop			; (mov r8, r8)
   131e4:	00015a58 	.word	0x00015a58
   131e8:	00013101 	.word	0x00013101

000131ec <__sfp>:
   131ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   131ee:	4b1d      	ldr	r3, [pc, #116]	; (13264 <__sfp+0x78>)
   131f0:	0006      	movs	r6, r0
   131f2:	681d      	ldr	r5, [r3, #0]
   131f4:	69ab      	ldr	r3, [r5, #24]
   131f6:	2b00      	cmp	r3, #0
   131f8:	d102      	bne.n	13200 <__sfp+0x14>
   131fa:	0028      	movs	r0, r5
   131fc:	f7ff ffc2 	bl	13184 <__sinit>
   13200:	3548      	adds	r5, #72	; 0x48
   13202:	68ac      	ldr	r4, [r5, #8]
   13204:	686b      	ldr	r3, [r5, #4]
   13206:	3b01      	subs	r3, #1
   13208:	d405      	bmi.n	13216 <__sfp+0x2a>
   1320a:	220c      	movs	r2, #12
   1320c:	5ea7      	ldrsh	r7, [r4, r2]
   1320e:	2f00      	cmp	r7, #0
   13210:	d010      	beq.n	13234 <__sfp+0x48>
   13212:	3468      	adds	r4, #104	; 0x68
   13214:	e7f7      	b.n	13206 <__sfp+0x1a>
   13216:	682b      	ldr	r3, [r5, #0]
   13218:	2b00      	cmp	r3, #0
   1321a:	d001      	beq.n	13220 <__sfp+0x34>
   1321c:	682d      	ldr	r5, [r5, #0]
   1321e:	e7f0      	b.n	13202 <__sfp+0x16>
   13220:	2104      	movs	r1, #4
   13222:	0030      	movs	r0, r6
   13224:	f7ff ff98 	bl	13158 <__sfmoreglue>
   13228:	6028      	str	r0, [r5, #0]
   1322a:	2800      	cmp	r0, #0
   1322c:	d1f6      	bne.n	1321c <__sfp+0x30>
   1322e:	230c      	movs	r3, #12
   13230:	6033      	str	r3, [r6, #0]
   13232:	e016      	b.n	13262 <__sfp+0x76>
   13234:	2301      	movs	r3, #1
   13236:	0020      	movs	r0, r4
   13238:	425b      	negs	r3, r3
   1323a:	81e3      	strh	r3, [r4, #14]
   1323c:	3302      	adds	r3, #2
   1323e:	81a3      	strh	r3, [r4, #12]
   13240:	6667      	str	r7, [r4, #100]	; 0x64
   13242:	6027      	str	r7, [r4, #0]
   13244:	60a7      	str	r7, [r4, #8]
   13246:	6067      	str	r7, [r4, #4]
   13248:	6127      	str	r7, [r4, #16]
   1324a:	6167      	str	r7, [r4, #20]
   1324c:	61a7      	str	r7, [r4, #24]
   1324e:	305c      	adds	r0, #92	; 0x5c
   13250:	2208      	movs	r2, #8
   13252:	0039      	movs	r1, r7
   13254:	f7ff fae5 	bl	12822 <memset>
   13258:	0020      	movs	r0, r4
   1325a:	6367      	str	r7, [r4, #52]	; 0x34
   1325c:	63a7      	str	r7, [r4, #56]	; 0x38
   1325e:	64a7      	str	r7, [r4, #72]	; 0x48
   13260:	64e7      	str	r7, [r4, #76]	; 0x4c
   13262:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   13264:	00015a58 	.word	0x00015a58

00013268 <_fwalk>:
   13268:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1326a:	3048      	adds	r0, #72	; 0x48
   1326c:	0004      	movs	r4, r0
   1326e:	2600      	movs	r6, #0
   13270:	9101      	str	r1, [sp, #4]
   13272:	2c00      	cmp	r4, #0
   13274:	d012      	beq.n	1329c <_fwalk+0x34>
   13276:	68a5      	ldr	r5, [r4, #8]
   13278:	6867      	ldr	r7, [r4, #4]
   1327a:	3f01      	subs	r7, #1
   1327c:	d40c      	bmi.n	13298 <_fwalk+0x30>
   1327e:	89ab      	ldrh	r3, [r5, #12]
   13280:	2b01      	cmp	r3, #1
   13282:	d907      	bls.n	13294 <_fwalk+0x2c>
   13284:	220e      	movs	r2, #14
   13286:	5eab      	ldrsh	r3, [r5, r2]
   13288:	3301      	adds	r3, #1
   1328a:	d003      	beq.n	13294 <_fwalk+0x2c>
   1328c:	0028      	movs	r0, r5
   1328e:	9b01      	ldr	r3, [sp, #4]
   13290:	4798      	blx	r3
   13292:	4306      	orrs	r6, r0
   13294:	3568      	adds	r5, #104	; 0x68
   13296:	e7f0      	b.n	1327a <_fwalk+0x12>
   13298:	6824      	ldr	r4, [r4, #0]
   1329a:	e7ea      	b.n	13272 <_fwalk+0xa>
   1329c:	0030      	movs	r0, r6
   1329e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

000132a0 <_fwalk_reent>:
   132a0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   132a2:	0004      	movs	r4, r0
   132a4:	0007      	movs	r7, r0
   132a6:	2600      	movs	r6, #0
   132a8:	9101      	str	r1, [sp, #4]
   132aa:	3448      	adds	r4, #72	; 0x48
   132ac:	2c00      	cmp	r4, #0
   132ae:	d016      	beq.n	132de <_fwalk_reent+0x3e>
   132b0:	6863      	ldr	r3, [r4, #4]
   132b2:	68a5      	ldr	r5, [r4, #8]
   132b4:	9300      	str	r3, [sp, #0]
   132b6:	9b00      	ldr	r3, [sp, #0]
   132b8:	3b01      	subs	r3, #1
   132ba:	9300      	str	r3, [sp, #0]
   132bc:	d40d      	bmi.n	132da <_fwalk_reent+0x3a>
   132be:	89ab      	ldrh	r3, [r5, #12]
   132c0:	2b01      	cmp	r3, #1
   132c2:	d908      	bls.n	132d6 <_fwalk_reent+0x36>
   132c4:	220e      	movs	r2, #14
   132c6:	5eab      	ldrsh	r3, [r5, r2]
   132c8:	3301      	adds	r3, #1
   132ca:	d004      	beq.n	132d6 <_fwalk_reent+0x36>
   132cc:	0029      	movs	r1, r5
   132ce:	0038      	movs	r0, r7
   132d0:	9b01      	ldr	r3, [sp, #4]
   132d2:	4798      	blx	r3
   132d4:	4306      	orrs	r6, r0
   132d6:	3568      	adds	r5, #104	; 0x68
   132d8:	e7ed      	b.n	132b6 <_fwalk_reent+0x16>
   132da:	6824      	ldr	r4, [r4, #0]
   132dc:	e7e6      	b.n	132ac <_fwalk_reent+0xc>
   132de:	0030      	movs	r0, r6
   132e0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

000132e4 <_lseek_r>:
   132e4:	b570      	push	{r4, r5, r6, lr}
   132e6:	0005      	movs	r5, r0
   132e8:	0008      	movs	r0, r1
   132ea:	0011      	movs	r1, r2
   132ec:	2200      	movs	r2, #0
   132ee:	4c06      	ldr	r4, [pc, #24]	; (13308 <_lseek_r+0x24>)
   132f0:	6022      	str	r2, [r4, #0]
   132f2:	001a      	movs	r2, r3
   132f4:	f7fe ff00 	bl	120f8 <_lseek>
   132f8:	1c43      	adds	r3, r0, #1
   132fa:	d103      	bne.n	13304 <_lseek_r+0x20>
   132fc:	6823      	ldr	r3, [r4, #0]
   132fe:	2b00      	cmp	r3, #0
   13300:	d000      	beq.n	13304 <_lseek_r+0x20>
   13302:	602b      	str	r3, [r5, #0]
   13304:	bd70      	pop	{r4, r5, r6, pc}
   13306:	46c0      	nop			; (mov r8, r8)
   13308:	20001880 	.word	0x20001880

0001330c <__swhatbuf_r>:
   1330c:	b570      	push	{r4, r5, r6, lr}
   1330e:	000e      	movs	r6, r1
   13310:	001d      	movs	r5, r3
   13312:	230e      	movs	r3, #14
   13314:	5ec9      	ldrsh	r1, [r1, r3]
   13316:	b090      	sub	sp, #64	; 0x40
   13318:	0014      	movs	r4, r2
   1331a:	2900      	cmp	r1, #0
   1331c:	da06      	bge.n	1332c <__swhatbuf_r+0x20>
   1331e:	2300      	movs	r3, #0
   13320:	602b      	str	r3, [r5, #0]
   13322:	89b3      	ldrh	r3, [r6, #12]
   13324:	061b      	lsls	r3, r3, #24
   13326:	d50f      	bpl.n	13348 <__swhatbuf_r+0x3c>
   13328:	2340      	movs	r3, #64	; 0x40
   1332a:	e00f      	b.n	1334c <__swhatbuf_r+0x40>
   1332c:	aa01      	add	r2, sp, #4
   1332e:	f001 fa6d 	bl	1480c <_fstat_r>
   13332:	2800      	cmp	r0, #0
   13334:	dbf3      	blt.n	1331e <__swhatbuf_r+0x12>
   13336:	23f0      	movs	r3, #240	; 0xf0
   13338:	9a02      	ldr	r2, [sp, #8]
   1333a:	021b      	lsls	r3, r3, #8
   1333c:	4013      	ands	r3, r2
   1333e:	4a05      	ldr	r2, [pc, #20]	; (13354 <__swhatbuf_r+0x48>)
   13340:	189b      	adds	r3, r3, r2
   13342:	425a      	negs	r2, r3
   13344:	4153      	adcs	r3, r2
   13346:	602b      	str	r3, [r5, #0]
   13348:	2380      	movs	r3, #128	; 0x80
   1334a:	00db      	lsls	r3, r3, #3
   1334c:	2000      	movs	r0, #0
   1334e:	6023      	str	r3, [r4, #0]
   13350:	b010      	add	sp, #64	; 0x40
   13352:	bd70      	pop	{r4, r5, r6, pc}
   13354:	ffffe000 	.word	0xffffe000

00013358 <__smakebuf_r>:
   13358:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1335a:	2602      	movs	r6, #2
   1335c:	898b      	ldrh	r3, [r1, #12]
   1335e:	0005      	movs	r5, r0
   13360:	000c      	movs	r4, r1
   13362:	4233      	tst	r3, r6
   13364:	d110      	bne.n	13388 <__smakebuf_r+0x30>
   13366:	ab01      	add	r3, sp, #4
   13368:	466a      	mov	r2, sp
   1336a:	f7ff ffcf 	bl	1330c <__swhatbuf_r>
   1336e:	9900      	ldr	r1, [sp, #0]
   13370:	0007      	movs	r7, r0
   13372:	0028      	movs	r0, r5
   13374:	f7ff faa4 	bl	128c0 <_malloc_r>
   13378:	2800      	cmp	r0, #0
   1337a:	d10c      	bne.n	13396 <__smakebuf_r+0x3e>
   1337c:	220c      	movs	r2, #12
   1337e:	5ea3      	ldrsh	r3, [r4, r2]
   13380:	059a      	lsls	r2, r3, #22
   13382:	d423      	bmi.n	133cc <__smakebuf_r+0x74>
   13384:	4333      	orrs	r3, r6
   13386:	81a3      	strh	r3, [r4, #12]
   13388:	0023      	movs	r3, r4
   1338a:	3347      	adds	r3, #71	; 0x47
   1338c:	6023      	str	r3, [r4, #0]
   1338e:	6123      	str	r3, [r4, #16]
   13390:	2301      	movs	r3, #1
   13392:	6163      	str	r3, [r4, #20]
   13394:	e01a      	b.n	133cc <__smakebuf_r+0x74>
   13396:	2280      	movs	r2, #128	; 0x80
   13398:	4b0d      	ldr	r3, [pc, #52]	; (133d0 <__smakebuf_r+0x78>)
   1339a:	62ab      	str	r3, [r5, #40]	; 0x28
   1339c:	89a3      	ldrh	r3, [r4, #12]
   1339e:	6020      	str	r0, [r4, #0]
   133a0:	4313      	orrs	r3, r2
   133a2:	81a3      	strh	r3, [r4, #12]
   133a4:	9b00      	ldr	r3, [sp, #0]
   133a6:	6120      	str	r0, [r4, #16]
   133a8:	6163      	str	r3, [r4, #20]
   133aa:	9b01      	ldr	r3, [sp, #4]
   133ac:	2b00      	cmp	r3, #0
   133ae:	d00a      	beq.n	133c6 <__smakebuf_r+0x6e>
   133b0:	230e      	movs	r3, #14
   133b2:	5ee1      	ldrsh	r1, [r4, r3]
   133b4:	0028      	movs	r0, r5
   133b6:	f001 fa3b 	bl	14830 <_isatty_r>
   133ba:	2800      	cmp	r0, #0
   133bc:	d003      	beq.n	133c6 <__smakebuf_r+0x6e>
   133be:	2201      	movs	r2, #1
   133c0:	89a3      	ldrh	r3, [r4, #12]
   133c2:	4313      	orrs	r3, r2
   133c4:	81a3      	strh	r3, [r4, #12]
   133c6:	89a3      	ldrh	r3, [r4, #12]
   133c8:	431f      	orrs	r7, r3
   133ca:	81a7      	strh	r7, [r4, #12]
   133cc:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   133ce:	46c0      	nop			; (mov r8, r8)
   133d0:	00013101 	.word	0x00013101

000133d4 <__ssputs_r>:
   133d4:	b5f0      	push	{r4, r5, r6, r7, lr}
   133d6:	688e      	ldr	r6, [r1, #8]
   133d8:	b085      	sub	sp, #20
   133da:	0007      	movs	r7, r0
   133dc:	000c      	movs	r4, r1
   133de:	9203      	str	r2, [sp, #12]
   133e0:	9301      	str	r3, [sp, #4]
   133e2:	429e      	cmp	r6, r3
   133e4:	d843      	bhi.n	1346e <__ssputs_r+0x9a>
   133e6:	2390      	movs	r3, #144	; 0x90
   133e8:	898a      	ldrh	r2, [r1, #12]
   133ea:	00db      	lsls	r3, r3, #3
   133ec:	421a      	tst	r2, r3
   133ee:	d03e      	beq.n	1346e <__ssputs_r+0x9a>
   133f0:	2503      	movs	r5, #3
   133f2:	6909      	ldr	r1, [r1, #16]
   133f4:	6823      	ldr	r3, [r4, #0]
   133f6:	9801      	ldr	r0, [sp, #4]
   133f8:	1a5b      	subs	r3, r3, r1
   133fa:	9302      	str	r3, [sp, #8]
   133fc:	6963      	ldr	r3, [r4, #20]
   133fe:	435d      	muls	r5, r3
   13400:	0feb      	lsrs	r3, r5, #31
   13402:	195d      	adds	r5, r3, r5
   13404:	9b02      	ldr	r3, [sp, #8]
   13406:	106d      	asrs	r5, r5, #1
   13408:	3301      	adds	r3, #1
   1340a:	181b      	adds	r3, r3, r0
   1340c:	42ab      	cmp	r3, r5
   1340e:	d900      	bls.n	13412 <__ssputs_r+0x3e>
   13410:	001d      	movs	r5, r3
   13412:	0553      	lsls	r3, r2, #21
   13414:	d510      	bpl.n	13438 <__ssputs_r+0x64>
   13416:	0029      	movs	r1, r5
   13418:	0038      	movs	r0, r7
   1341a:	f7ff fa51 	bl	128c0 <_malloc_r>
   1341e:	1e06      	subs	r6, r0, #0
   13420:	d014      	beq.n	1344c <__ssputs_r+0x78>
   13422:	9a02      	ldr	r2, [sp, #8]
   13424:	6921      	ldr	r1, [r4, #16]
   13426:	f7ff f9de 	bl	127e6 <memcpy>
   1342a:	89a2      	ldrh	r2, [r4, #12]
   1342c:	4b19      	ldr	r3, [pc, #100]	; (13494 <__ssputs_r+0xc0>)
   1342e:	4013      	ands	r3, r2
   13430:	2280      	movs	r2, #128	; 0x80
   13432:	4313      	orrs	r3, r2
   13434:	81a3      	strh	r3, [r4, #12]
   13436:	e012      	b.n	1345e <__ssputs_r+0x8a>
   13438:	002a      	movs	r2, r5
   1343a:	0038      	movs	r0, r7
   1343c:	f001 fa15 	bl	1486a <_realloc_r>
   13440:	1e06      	subs	r6, r0, #0
   13442:	d10c      	bne.n	1345e <__ssputs_r+0x8a>
   13444:	6921      	ldr	r1, [r4, #16]
   13446:	0038      	movs	r0, r7
   13448:	f7ff f9f4 	bl	12834 <_free_r>
   1344c:	230c      	movs	r3, #12
   1344e:	2240      	movs	r2, #64	; 0x40
   13450:	2001      	movs	r0, #1
   13452:	603b      	str	r3, [r7, #0]
   13454:	89a3      	ldrh	r3, [r4, #12]
   13456:	4240      	negs	r0, r0
   13458:	4313      	orrs	r3, r2
   1345a:	81a3      	strh	r3, [r4, #12]
   1345c:	e017      	b.n	1348e <__ssputs_r+0xba>
   1345e:	9b02      	ldr	r3, [sp, #8]
   13460:	6126      	str	r6, [r4, #16]
   13462:	18f6      	adds	r6, r6, r3
   13464:	6026      	str	r6, [r4, #0]
   13466:	6165      	str	r5, [r4, #20]
   13468:	9e01      	ldr	r6, [sp, #4]
   1346a:	1aed      	subs	r5, r5, r3
   1346c:	60a5      	str	r5, [r4, #8]
   1346e:	9b01      	ldr	r3, [sp, #4]
   13470:	42b3      	cmp	r3, r6
   13472:	d200      	bcs.n	13476 <__ssputs_r+0xa2>
   13474:	001e      	movs	r6, r3
   13476:	0032      	movs	r2, r6
   13478:	9903      	ldr	r1, [sp, #12]
   1347a:	6820      	ldr	r0, [r4, #0]
   1347c:	f7ff f9bc 	bl	127f8 <memmove>
   13480:	2000      	movs	r0, #0
   13482:	68a3      	ldr	r3, [r4, #8]
   13484:	1b9b      	subs	r3, r3, r6
   13486:	60a3      	str	r3, [r4, #8]
   13488:	6823      	ldr	r3, [r4, #0]
   1348a:	199e      	adds	r6, r3, r6
   1348c:	6026      	str	r6, [r4, #0]
   1348e:	b005      	add	sp, #20
   13490:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13492:	46c0      	nop			; (mov r8, r8)
   13494:	fffffb7f 	.word	0xfffffb7f

00013498 <_svfiprintf_r>:
   13498:	b5f0      	push	{r4, r5, r6, r7, lr}
   1349a:	b09f      	sub	sp, #124	; 0x7c
   1349c:	9002      	str	r0, [sp, #8]
   1349e:	9305      	str	r3, [sp, #20]
   134a0:	898b      	ldrh	r3, [r1, #12]
   134a2:	000f      	movs	r7, r1
   134a4:	0016      	movs	r6, r2
   134a6:	061b      	lsls	r3, r3, #24
   134a8:	d510      	bpl.n	134cc <_svfiprintf_r+0x34>
   134aa:	690b      	ldr	r3, [r1, #16]
   134ac:	2b00      	cmp	r3, #0
   134ae:	d10d      	bne.n	134cc <_svfiprintf_r+0x34>
   134b0:	2140      	movs	r1, #64	; 0x40
   134b2:	f7ff fa05 	bl	128c0 <_malloc_r>
   134b6:	6038      	str	r0, [r7, #0]
   134b8:	6138      	str	r0, [r7, #16]
   134ba:	2800      	cmp	r0, #0
   134bc:	d104      	bne.n	134c8 <_svfiprintf_r+0x30>
   134be:	230c      	movs	r3, #12
   134c0:	9a02      	ldr	r2, [sp, #8]
   134c2:	3801      	subs	r0, #1
   134c4:	6013      	str	r3, [r2, #0]
   134c6:	e0d8      	b.n	1367a <_svfiprintf_r+0x1e2>
   134c8:	2340      	movs	r3, #64	; 0x40
   134ca:	617b      	str	r3, [r7, #20]
   134cc:	2300      	movs	r3, #0
   134ce:	ad06      	add	r5, sp, #24
   134d0:	616b      	str	r3, [r5, #20]
   134d2:	3320      	adds	r3, #32
   134d4:	766b      	strb	r3, [r5, #25]
   134d6:	3310      	adds	r3, #16
   134d8:	76ab      	strb	r3, [r5, #26]
   134da:	0034      	movs	r4, r6
   134dc:	7823      	ldrb	r3, [r4, #0]
   134de:	2b00      	cmp	r3, #0
   134e0:	d103      	bne.n	134ea <_svfiprintf_r+0x52>
   134e2:	1ba3      	subs	r3, r4, r6
   134e4:	9304      	str	r3, [sp, #16]
   134e6:	d012      	beq.n	1350e <_svfiprintf_r+0x76>
   134e8:	e003      	b.n	134f2 <_svfiprintf_r+0x5a>
   134ea:	2b25      	cmp	r3, #37	; 0x25
   134ec:	d0f9      	beq.n	134e2 <_svfiprintf_r+0x4a>
   134ee:	3401      	adds	r4, #1
   134f0:	e7f4      	b.n	134dc <_svfiprintf_r+0x44>
   134f2:	1ba3      	subs	r3, r4, r6
   134f4:	0032      	movs	r2, r6
   134f6:	0039      	movs	r1, r7
   134f8:	9802      	ldr	r0, [sp, #8]
   134fa:	f7ff ff6b 	bl	133d4 <__ssputs_r>
   134fe:	1c43      	adds	r3, r0, #1
   13500:	d100      	bne.n	13504 <_svfiprintf_r+0x6c>
   13502:	e0b4      	b.n	1366e <_svfiprintf_r+0x1d6>
   13504:	696a      	ldr	r2, [r5, #20]
   13506:	9b04      	ldr	r3, [sp, #16]
   13508:	4694      	mov	ip, r2
   1350a:	4463      	add	r3, ip
   1350c:	616b      	str	r3, [r5, #20]
   1350e:	7823      	ldrb	r3, [r4, #0]
   13510:	2b00      	cmp	r3, #0
   13512:	d100      	bne.n	13516 <_svfiprintf_r+0x7e>
   13514:	e0ab      	b.n	1366e <_svfiprintf_r+0x1d6>
   13516:	2201      	movs	r2, #1
   13518:	2300      	movs	r3, #0
   1351a:	4252      	negs	r2, r2
   1351c:	606a      	str	r2, [r5, #4]
   1351e:	a902      	add	r1, sp, #8
   13520:	3254      	adds	r2, #84	; 0x54
   13522:	1852      	adds	r2, r2, r1
   13524:	3401      	adds	r4, #1
   13526:	602b      	str	r3, [r5, #0]
   13528:	60eb      	str	r3, [r5, #12]
   1352a:	60ab      	str	r3, [r5, #8]
   1352c:	7013      	strb	r3, [r2, #0]
   1352e:	65ab      	str	r3, [r5, #88]	; 0x58
   13530:	4e53      	ldr	r6, [pc, #332]	; (13680 <_svfiprintf_r+0x1e8>)
   13532:	7821      	ldrb	r1, [r4, #0]
   13534:	2205      	movs	r2, #5
   13536:	0030      	movs	r0, r6
   13538:	f001 f98c 	bl	14854 <memchr>
   1353c:	2800      	cmp	r0, #0
   1353e:	d007      	beq.n	13550 <_svfiprintf_r+0xb8>
   13540:	2301      	movs	r3, #1
   13542:	1b80      	subs	r0, r0, r6
   13544:	4083      	lsls	r3, r0
   13546:	682a      	ldr	r2, [r5, #0]
   13548:	3401      	adds	r4, #1
   1354a:	4313      	orrs	r3, r2
   1354c:	602b      	str	r3, [r5, #0]
   1354e:	e7ef      	b.n	13530 <_svfiprintf_r+0x98>
   13550:	682b      	ldr	r3, [r5, #0]
   13552:	06da      	lsls	r2, r3, #27
   13554:	d504      	bpl.n	13560 <_svfiprintf_r+0xc8>
   13556:	2253      	movs	r2, #83	; 0x53
   13558:	2120      	movs	r1, #32
   1355a:	a802      	add	r0, sp, #8
   1355c:	1812      	adds	r2, r2, r0
   1355e:	7011      	strb	r1, [r2, #0]
   13560:	071a      	lsls	r2, r3, #28
   13562:	d504      	bpl.n	1356e <_svfiprintf_r+0xd6>
   13564:	2253      	movs	r2, #83	; 0x53
   13566:	212b      	movs	r1, #43	; 0x2b
   13568:	a802      	add	r0, sp, #8
   1356a:	1812      	adds	r2, r2, r0
   1356c:	7011      	strb	r1, [r2, #0]
   1356e:	7822      	ldrb	r2, [r4, #0]
   13570:	2a2a      	cmp	r2, #42	; 0x2a
   13572:	d003      	beq.n	1357c <_svfiprintf_r+0xe4>
   13574:	9b09      	ldr	r3, [sp, #36]	; 0x24
   13576:	2000      	movs	r0, #0
   13578:	210a      	movs	r1, #10
   1357a:	e00e      	b.n	1359a <_svfiprintf_r+0x102>
   1357c:	9a05      	ldr	r2, [sp, #20]
   1357e:	1d11      	adds	r1, r2, #4
   13580:	6812      	ldr	r2, [r2, #0]
   13582:	9105      	str	r1, [sp, #20]
   13584:	2a00      	cmp	r2, #0
   13586:	db01      	blt.n	1358c <_svfiprintf_r+0xf4>
   13588:	9209      	str	r2, [sp, #36]	; 0x24
   1358a:	e004      	b.n	13596 <_svfiprintf_r+0xfe>
   1358c:	4252      	negs	r2, r2
   1358e:	60ea      	str	r2, [r5, #12]
   13590:	2202      	movs	r2, #2
   13592:	4313      	orrs	r3, r2
   13594:	602b      	str	r3, [r5, #0]
   13596:	3401      	adds	r4, #1
   13598:	e00b      	b.n	135b2 <_svfiprintf_r+0x11a>
   1359a:	7822      	ldrb	r2, [r4, #0]
   1359c:	3a30      	subs	r2, #48	; 0x30
   1359e:	2a09      	cmp	r2, #9
   135a0:	d804      	bhi.n	135ac <_svfiprintf_r+0x114>
   135a2:	434b      	muls	r3, r1
   135a4:	3401      	adds	r4, #1
   135a6:	189b      	adds	r3, r3, r2
   135a8:	2001      	movs	r0, #1
   135aa:	e7f6      	b.n	1359a <_svfiprintf_r+0x102>
   135ac:	2800      	cmp	r0, #0
   135ae:	d000      	beq.n	135b2 <_svfiprintf_r+0x11a>
   135b0:	9309      	str	r3, [sp, #36]	; 0x24
   135b2:	7823      	ldrb	r3, [r4, #0]
   135b4:	2b2e      	cmp	r3, #46	; 0x2e
   135b6:	d11e      	bne.n	135f6 <_svfiprintf_r+0x15e>
   135b8:	7863      	ldrb	r3, [r4, #1]
   135ba:	2b2a      	cmp	r3, #42	; 0x2a
   135bc:	d10a      	bne.n	135d4 <_svfiprintf_r+0x13c>
   135be:	9b05      	ldr	r3, [sp, #20]
   135c0:	3402      	adds	r4, #2
   135c2:	1d1a      	adds	r2, r3, #4
   135c4:	681b      	ldr	r3, [r3, #0]
   135c6:	9205      	str	r2, [sp, #20]
   135c8:	2b00      	cmp	r3, #0
   135ca:	da01      	bge.n	135d0 <_svfiprintf_r+0x138>
   135cc:	2301      	movs	r3, #1
   135ce:	425b      	negs	r3, r3
   135d0:	9307      	str	r3, [sp, #28]
   135d2:	e010      	b.n	135f6 <_svfiprintf_r+0x15e>
   135d4:	2300      	movs	r3, #0
   135d6:	200a      	movs	r0, #10
   135d8:	001a      	movs	r2, r3
   135da:	3401      	adds	r4, #1
   135dc:	606b      	str	r3, [r5, #4]
   135de:	7821      	ldrb	r1, [r4, #0]
   135e0:	3930      	subs	r1, #48	; 0x30
   135e2:	2909      	cmp	r1, #9
   135e4:	d804      	bhi.n	135f0 <_svfiprintf_r+0x158>
   135e6:	4342      	muls	r2, r0
   135e8:	3401      	adds	r4, #1
   135ea:	1852      	adds	r2, r2, r1
   135ec:	2301      	movs	r3, #1
   135ee:	e7f6      	b.n	135de <_svfiprintf_r+0x146>
   135f0:	2b00      	cmp	r3, #0
   135f2:	d000      	beq.n	135f6 <_svfiprintf_r+0x15e>
   135f4:	9207      	str	r2, [sp, #28]
   135f6:	4e23      	ldr	r6, [pc, #140]	; (13684 <_svfiprintf_r+0x1ec>)
   135f8:	7821      	ldrb	r1, [r4, #0]
   135fa:	2203      	movs	r2, #3
   135fc:	0030      	movs	r0, r6
   135fe:	f001 f929 	bl	14854 <memchr>
   13602:	2800      	cmp	r0, #0
   13604:	d006      	beq.n	13614 <_svfiprintf_r+0x17c>
   13606:	2340      	movs	r3, #64	; 0x40
   13608:	1b80      	subs	r0, r0, r6
   1360a:	4083      	lsls	r3, r0
   1360c:	682a      	ldr	r2, [r5, #0]
   1360e:	3401      	adds	r4, #1
   13610:	4313      	orrs	r3, r2
   13612:	602b      	str	r3, [r5, #0]
   13614:	7821      	ldrb	r1, [r4, #0]
   13616:	2206      	movs	r2, #6
   13618:	481b      	ldr	r0, [pc, #108]	; (13688 <_svfiprintf_r+0x1f0>)
   1361a:	1c66      	adds	r6, r4, #1
   1361c:	7629      	strb	r1, [r5, #24]
   1361e:	f001 f919 	bl	14854 <memchr>
   13622:	2800      	cmp	r0, #0
   13624:	d012      	beq.n	1364c <_svfiprintf_r+0x1b4>
   13626:	4b19      	ldr	r3, [pc, #100]	; (1368c <_svfiprintf_r+0x1f4>)
   13628:	2b00      	cmp	r3, #0
   1362a:	d106      	bne.n	1363a <_svfiprintf_r+0x1a2>
   1362c:	2207      	movs	r2, #7
   1362e:	9b05      	ldr	r3, [sp, #20]
   13630:	3307      	adds	r3, #7
   13632:	4393      	bics	r3, r2
   13634:	3308      	adds	r3, #8
   13636:	9305      	str	r3, [sp, #20]
   13638:	e014      	b.n	13664 <_svfiprintf_r+0x1cc>
   1363a:	ab05      	add	r3, sp, #20
   1363c:	9300      	str	r3, [sp, #0]
   1363e:	003a      	movs	r2, r7
   13640:	4b13      	ldr	r3, [pc, #76]	; (13690 <_svfiprintf_r+0x1f8>)
   13642:	0029      	movs	r1, r5
   13644:	9802      	ldr	r0, [sp, #8]
   13646:	e000      	b.n	1364a <_svfiprintf_r+0x1b2>
   13648:	bf00      	nop
   1364a:	e007      	b.n	1365c <_svfiprintf_r+0x1c4>
   1364c:	ab05      	add	r3, sp, #20
   1364e:	9300      	str	r3, [sp, #0]
   13650:	003a      	movs	r2, r7
   13652:	4b0f      	ldr	r3, [pc, #60]	; (13690 <_svfiprintf_r+0x1f8>)
   13654:	0029      	movs	r1, r5
   13656:	9802      	ldr	r0, [sp, #8]
   13658:	f000 f9ce 	bl	139f8 <_printf_i>
   1365c:	9003      	str	r0, [sp, #12]
   1365e:	9b03      	ldr	r3, [sp, #12]
   13660:	3301      	adds	r3, #1
   13662:	d004      	beq.n	1366e <_svfiprintf_r+0x1d6>
   13664:	696b      	ldr	r3, [r5, #20]
   13666:	9a03      	ldr	r2, [sp, #12]
   13668:	189b      	adds	r3, r3, r2
   1366a:	616b      	str	r3, [r5, #20]
   1366c:	e735      	b.n	134da <_svfiprintf_r+0x42>
   1366e:	89bb      	ldrh	r3, [r7, #12]
   13670:	980b      	ldr	r0, [sp, #44]	; 0x2c
   13672:	065b      	lsls	r3, r3, #25
   13674:	d501      	bpl.n	1367a <_svfiprintf_r+0x1e2>
   13676:	2001      	movs	r0, #1
   13678:	4240      	negs	r0, r0
   1367a:	b01f      	add	sp, #124	; 0x7c
   1367c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1367e:	46c0      	nop			; (mov r8, r8)
   13680:	00015abc 	.word	0x00015abc
   13684:	00015ac2 	.word	0x00015ac2
   13688:	00015ac6 	.word	0x00015ac6
   1368c:	00000000 	.word	0x00000000
   13690:	000133d5 	.word	0x000133d5

00013694 <__sfputc_r>:
   13694:	6893      	ldr	r3, [r2, #8]
   13696:	b510      	push	{r4, lr}
   13698:	3b01      	subs	r3, #1
   1369a:	6093      	str	r3, [r2, #8]
   1369c:	2b00      	cmp	r3, #0
   1369e:	da05      	bge.n	136ac <__sfputc_r+0x18>
   136a0:	6994      	ldr	r4, [r2, #24]
   136a2:	42a3      	cmp	r3, r4
   136a4:	db08      	blt.n	136b8 <__sfputc_r+0x24>
   136a6:	b2cb      	uxtb	r3, r1
   136a8:	2b0a      	cmp	r3, #10
   136aa:	d005      	beq.n	136b8 <__sfputc_r+0x24>
   136ac:	6813      	ldr	r3, [r2, #0]
   136ae:	1c58      	adds	r0, r3, #1
   136b0:	6010      	str	r0, [r2, #0]
   136b2:	7019      	strb	r1, [r3, #0]
   136b4:	b2c8      	uxtb	r0, r1
   136b6:	e001      	b.n	136bc <__sfputc_r+0x28>
   136b8:	f7ff fb68 	bl	12d8c <__swbuf_r>
   136bc:	bd10      	pop	{r4, pc}

000136be <__sfputs_r>:
   136be:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   136c0:	0006      	movs	r6, r0
   136c2:	000f      	movs	r7, r1
   136c4:	0014      	movs	r4, r2
   136c6:	18d5      	adds	r5, r2, r3
   136c8:	42ac      	cmp	r4, r5
   136ca:	d008      	beq.n	136de <__sfputs_r+0x20>
   136cc:	7821      	ldrb	r1, [r4, #0]
   136ce:	003a      	movs	r2, r7
   136d0:	0030      	movs	r0, r6
   136d2:	f7ff ffdf 	bl	13694 <__sfputc_r>
   136d6:	3401      	adds	r4, #1
   136d8:	1c43      	adds	r3, r0, #1
   136da:	d1f5      	bne.n	136c8 <__sfputs_r+0xa>
   136dc:	e000      	b.n	136e0 <__sfputs_r+0x22>
   136de:	2000      	movs	r0, #0
   136e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

000136e4 <_vfiprintf_r>:
   136e4:	b5f0      	push	{r4, r5, r6, r7, lr}
   136e6:	b09f      	sub	sp, #124	; 0x7c
   136e8:	0006      	movs	r6, r0
   136ea:	000f      	movs	r7, r1
   136ec:	9202      	str	r2, [sp, #8]
   136ee:	9305      	str	r3, [sp, #20]
   136f0:	2800      	cmp	r0, #0
   136f2:	d004      	beq.n	136fe <_vfiprintf_r+0x1a>
   136f4:	6983      	ldr	r3, [r0, #24]
   136f6:	2b00      	cmp	r3, #0
   136f8:	d101      	bne.n	136fe <_vfiprintf_r+0x1a>
   136fa:	f7ff fd43 	bl	13184 <__sinit>
   136fe:	4b7f      	ldr	r3, [pc, #508]	; (138fc <_vfiprintf_r+0x218>)
   13700:	429f      	cmp	r7, r3
   13702:	d101      	bne.n	13708 <_vfiprintf_r+0x24>
   13704:	6877      	ldr	r7, [r6, #4]
   13706:	e008      	b.n	1371a <_vfiprintf_r+0x36>
   13708:	4b7d      	ldr	r3, [pc, #500]	; (13900 <_vfiprintf_r+0x21c>)
   1370a:	429f      	cmp	r7, r3
   1370c:	d101      	bne.n	13712 <_vfiprintf_r+0x2e>
   1370e:	68b7      	ldr	r7, [r6, #8]
   13710:	e003      	b.n	1371a <_vfiprintf_r+0x36>
   13712:	4b7c      	ldr	r3, [pc, #496]	; (13904 <_vfiprintf_r+0x220>)
   13714:	429f      	cmp	r7, r3
   13716:	d100      	bne.n	1371a <_vfiprintf_r+0x36>
   13718:	68f7      	ldr	r7, [r6, #12]
   1371a:	89bb      	ldrh	r3, [r7, #12]
   1371c:	071b      	lsls	r3, r3, #28
   1371e:	d50a      	bpl.n	13736 <_vfiprintf_r+0x52>
   13720:	693b      	ldr	r3, [r7, #16]
   13722:	2b00      	cmp	r3, #0
   13724:	d007      	beq.n	13736 <_vfiprintf_r+0x52>
   13726:	2300      	movs	r3, #0
   13728:	ad06      	add	r5, sp, #24
   1372a:	616b      	str	r3, [r5, #20]
   1372c:	3320      	adds	r3, #32
   1372e:	766b      	strb	r3, [r5, #25]
   13730:	3310      	adds	r3, #16
   13732:	76ab      	strb	r3, [r5, #26]
   13734:	e03d      	b.n	137b2 <_vfiprintf_r+0xce>
   13736:	0039      	movs	r1, r7
   13738:	0030      	movs	r0, r6
   1373a:	f7ff fb93 	bl	12e64 <__swsetup_r>
   1373e:	2800      	cmp	r0, #0
   13740:	d0f1      	beq.n	13726 <_vfiprintf_r+0x42>
   13742:	2001      	movs	r0, #1
   13744:	4240      	negs	r0, r0
   13746:	e0d6      	b.n	138f6 <_vfiprintf_r+0x212>
   13748:	9a05      	ldr	r2, [sp, #20]
   1374a:	1d11      	adds	r1, r2, #4
   1374c:	6812      	ldr	r2, [r2, #0]
   1374e:	9105      	str	r1, [sp, #20]
   13750:	2a00      	cmp	r2, #0
   13752:	da00      	bge.n	13756 <_vfiprintf_r+0x72>
   13754:	e07f      	b.n	13856 <_vfiprintf_r+0x172>
   13756:	9209      	str	r2, [sp, #36]	; 0x24
   13758:	3401      	adds	r4, #1
   1375a:	7823      	ldrb	r3, [r4, #0]
   1375c:	2b2e      	cmp	r3, #46	; 0x2e
   1375e:	d100      	bne.n	13762 <_vfiprintf_r+0x7e>
   13760:	e08d      	b.n	1387e <_vfiprintf_r+0x19a>
   13762:	7821      	ldrb	r1, [r4, #0]
   13764:	2203      	movs	r2, #3
   13766:	4868      	ldr	r0, [pc, #416]	; (13908 <_vfiprintf_r+0x224>)
   13768:	f001 f874 	bl	14854 <memchr>
   1376c:	2800      	cmp	r0, #0
   1376e:	d007      	beq.n	13780 <_vfiprintf_r+0x9c>
   13770:	4b65      	ldr	r3, [pc, #404]	; (13908 <_vfiprintf_r+0x224>)
   13772:	682a      	ldr	r2, [r5, #0]
   13774:	1ac0      	subs	r0, r0, r3
   13776:	2340      	movs	r3, #64	; 0x40
   13778:	4083      	lsls	r3, r0
   1377a:	4313      	orrs	r3, r2
   1377c:	602b      	str	r3, [r5, #0]
   1377e:	3401      	adds	r4, #1
   13780:	7821      	ldrb	r1, [r4, #0]
   13782:	1c63      	adds	r3, r4, #1
   13784:	2206      	movs	r2, #6
   13786:	4861      	ldr	r0, [pc, #388]	; (1390c <_vfiprintf_r+0x228>)
   13788:	9302      	str	r3, [sp, #8]
   1378a:	7629      	strb	r1, [r5, #24]
   1378c:	f001 f862 	bl	14854 <memchr>
   13790:	2800      	cmp	r0, #0
   13792:	d100      	bne.n	13796 <_vfiprintf_r+0xb2>
   13794:	e09d      	b.n	138d2 <_vfiprintf_r+0x1ee>
   13796:	4b5e      	ldr	r3, [pc, #376]	; (13910 <_vfiprintf_r+0x22c>)
   13798:	2b00      	cmp	r3, #0
   1379a:	d000      	beq.n	1379e <_vfiprintf_r+0xba>
   1379c:	e090      	b.n	138c0 <_vfiprintf_r+0x1dc>
   1379e:	2207      	movs	r2, #7
   137a0:	9b05      	ldr	r3, [sp, #20]
   137a2:	3307      	adds	r3, #7
   137a4:	4393      	bics	r3, r2
   137a6:	3308      	adds	r3, #8
   137a8:	9305      	str	r3, [sp, #20]
   137aa:	696b      	ldr	r3, [r5, #20]
   137ac:	9a03      	ldr	r2, [sp, #12]
   137ae:	189b      	adds	r3, r3, r2
   137b0:	616b      	str	r3, [r5, #20]
   137b2:	9c02      	ldr	r4, [sp, #8]
   137b4:	7823      	ldrb	r3, [r4, #0]
   137b6:	2b00      	cmp	r3, #0
   137b8:	d104      	bne.n	137c4 <_vfiprintf_r+0xe0>
   137ba:	9b02      	ldr	r3, [sp, #8]
   137bc:	1ae3      	subs	r3, r4, r3
   137be:	9304      	str	r3, [sp, #16]
   137c0:	d012      	beq.n	137e8 <_vfiprintf_r+0x104>
   137c2:	e003      	b.n	137cc <_vfiprintf_r+0xe8>
   137c4:	2b25      	cmp	r3, #37	; 0x25
   137c6:	d0f8      	beq.n	137ba <_vfiprintf_r+0xd6>
   137c8:	3401      	adds	r4, #1
   137ca:	e7f3      	b.n	137b4 <_vfiprintf_r+0xd0>
   137cc:	9b04      	ldr	r3, [sp, #16]
   137ce:	9a02      	ldr	r2, [sp, #8]
   137d0:	0039      	movs	r1, r7
   137d2:	0030      	movs	r0, r6
   137d4:	f7ff ff73 	bl	136be <__sfputs_r>
   137d8:	1c43      	adds	r3, r0, #1
   137da:	d100      	bne.n	137de <_vfiprintf_r+0xfa>
   137dc:	e086      	b.n	138ec <_vfiprintf_r+0x208>
   137de:	696a      	ldr	r2, [r5, #20]
   137e0:	9b04      	ldr	r3, [sp, #16]
   137e2:	4694      	mov	ip, r2
   137e4:	4463      	add	r3, ip
   137e6:	616b      	str	r3, [r5, #20]
   137e8:	7823      	ldrb	r3, [r4, #0]
   137ea:	2b00      	cmp	r3, #0
   137ec:	d07e      	beq.n	138ec <_vfiprintf_r+0x208>
   137ee:	2201      	movs	r2, #1
   137f0:	2300      	movs	r3, #0
   137f2:	4252      	negs	r2, r2
   137f4:	606a      	str	r2, [r5, #4]
   137f6:	a902      	add	r1, sp, #8
   137f8:	3254      	adds	r2, #84	; 0x54
   137fa:	1852      	adds	r2, r2, r1
   137fc:	3401      	adds	r4, #1
   137fe:	602b      	str	r3, [r5, #0]
   13800:	60eb      	str	r3, [r5, #12]
   13802:	60ab      	str	r3, [r5, #8]
   13804:	7013      	strb	r3, [r2, #0]
   13806:	65ab      	str	r3, [r5, #88]	; 0x58
   13808:	7821      	ldrb	r1, [r4, #0]
   1380a:	2205      	movs	r2, #5
   1380c:	4841      	ldr	r0, [pc, #260]	; (13914 <_vfiprintf_r+0x230>)
   1380e:	f001 f821 	bl	14854 <memchr>
   13812:	2800      	cmp	r0, #0
   13814:	d008      	beq.n	13828 <_vfiprintf_r+0x144>
   13816:	4b3f      	ldr	r3, [pc, #252]	; (13914 <_vfiprintf_r+0x230>)
   13818:	682a      	ldr	r2, [r5, #0]
   1381a:	1ac0      	subs	r0, r0, r3
   1381c:	2301      	movs	r3, #1
   1381e:	4083      	lsls	r3, r0
   13820:	4313      	orrs	r3, r2
   13822:	602b      	str	r3, [r5, #0]
   13824:	3401      	adds	r4, #1
   13826:	e7ef      	b.n	13808 <_vfiprintf_r+0x124>
   13828:	682b      	ldr	r3, [r5, #0]
   1382a:	06da      	lsls	r2, r3, #27
   1382c:	d504      	bpl.n	13838 <_vfiprintf_r+0x154>
   1382e:	2253      	movs	r2, #83	; 0x53
   13830:	2120      	movs	r1, #32
   13832:	a802      	add	r0, sp, #8
   13834:	1812      	adds	r2, r2, r0
   13836:	7011      	strb	r1, [r2, #0]
   13838:	071a      	lsls	r2, r3, #28
   1383a:	d504      	bpl.n	13846 <_vfiprintf_r+0x162>
   1383c:	2253      	movs	r2, #83	; 0x53
   1383e:	212b      	movs	r1, #43	; 0x2b
   13840:	a802      	add	r0, sp, #8
   13842:	1812      	adds	r2, r2, r0
   13844:	7011      	strb	r1, [r2, #0]
   13846:	7822      	ldrb	r2, [r4, #0]
   13848:	2a2a      	cmp	r2, #42	; 0x2a
   1384a:	d100      	bne.n	1384e <_vfiprintf_r+0x16a>
   1384c:	e77c      	b.n	13748 <_vfiprintf_r+0x64>
   1384e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   13850:	2000      	movs	r0, #0
   13852:	210a      	movs	r1, #10
   13854:	e005      	b.n	13862 <_vfiprintf_r+0x17e>
   13856:	4252      	negs	r2, r2
   13858:	60ea      	str	r2, [r5, #12]
   1385a:	2202      	movs	r2, #2
   1385c:	4313      	orrs	r3, r2
   1385e:	602b      	str	r3, [r5, #0]
   13860:	e77a      	b.n	13758 <_vfiprintf_r+0x74>
   13862:	7822      	ldrb	r2, [r4, #0]
   13864:	3a30      	subs	r2, #48	; 0x30
   13866:	2a09      	cmp	r2, #9
   13868:	d804      	bhi.n	13874 <_vfiprintf_r+0x190>
   1386a:	434b      	muls	r3, r1
   1386c:	3401      	adds	r4, #1
   1386e:	189b      	adds	r3, r3, r2
   13870:	2001      	movs	r0, #1
   13872:	e7f6      	b.n	13862 <_vfiprintf_r+0x17e>
   13874:	2800      	cmp	r0, #0
   13876:	d100      	bne.n	1387a <_vfiprintf_r+0x196>
   13878:	e76f      	b.n	1375a <_vfiprintf_r+0x76>
   1387a:	9309      	str	r3, [sp, #36]	; 0x24
   1387c:	e76d      	b.n	1375a <_vfiprintf_r+0x76>
   1387e:	7863      	ldrb	r3, [r4, #1]
   13880:	2b2a      	cmp	r3, #42	; 0x2a
   13882:	d10a      	bne.n	1389a <_vfiprintf_r+0x1b6>
   13884:	9b05      	ldr	r3, [sp, #20]
   13886:	3402      	adds	r4, #2
   13888:	1d1a      	adds	r2, r3, #4
   1388a:	681b      	ldr	r3, [r3, #0]
   1388c:	9205      	str	r2, [sp, #20]
   1388e:	2b00      	cmp	r3, #0
   13890:	da01      	bge.n	13896 <_vfiprintf_r+0x1b2>
   13892:	2301      	movs	r3, #1
   13894:	425b      	negs	r3, r3
   13896:	9307      	str	r3, [sp, #28]
   13898:	e763      	b.n	13762 <_vfiprintf_r+0x7e>
   1389a:	2300      	movs	r3, #0
   1389c:	200a      	movs	r0, #10
   1389e:	001a      	movs	r2, r3
   138a0:	3401      	adds	r4, #1
   138a2:	606b      	str	r3, [r5, #4]
   138a4:	7821      	ldrb	r1, [r4, #0]
   138a6:	3930      	subs	r1, #48	; 0x30
   138a8:	2909      	cmp	r1, #9
   138aa:	d804      	bhi.n	138b6 <_vfiprintf_r+0x1d2>
   138ac:	4342      	muls	r2, r0
   138ae:	3401      	adds	r4, #1
   138b0:	1852      	adds	r2, r2, r1
   138b2:	2301      	movs	r3, #1
   138b4:	e7f6      	b.n	138a4 <_vfiprintf_r+0x1c0>
   138b6:	2b00      	cmp	r3, #0
   138b8:	d100      	bne.n	138bc <_vfiprintf_r+0x1d8>
   138ba:	e752      	b.n	13762 <_vfiprintf_r+0x7e>
   138bc:	9207      	str	r2, [sp, #28]
   138be:	e750      	b.n	13762 <_vfiprintf_r+0x7e>
   138c0:	ab05      	add	r3, sp, #20
   138c2:	9300      	str	r3, [sp, #0]
   138c4:	003a      	movs	r2, r7
   138c6:	4b14      	ldr	r3, [pc, #80]	; (13918 <_vfiprintf_r+0x234>)
   138c8:	0029      	movs	r1, r5
   138ca:	0030      	movs	r0, r6
   138cc:	e000      	b.n	138d0 <_vfiprintf_r+0x1ec>
   138ce:	bf00      	nop
   138d0:	e007      	b.n	138e2 <_vfiprintf_r+0x1fe>
   138d2:	ab05      	add	r3, sp, #20
   138d4:	9300      	str	r3, [sp, #0]
   138d6:	003a      	movs	r2, r7
   138d8:	4b0f      	ldr	r3, [pc, #60]	; (13918 <_vfiprintf_r+0x234>)
   138da:	0029      	movs	r1, r5
   138dc:	0030      	movs	r0, r6
   138de:	f000 f88b 	bl	139f8 <_printf_i>
   138e2:	9003      	str	r0, [sp, #12]
   138e4:	9b03      	ldr	r3, [sp, #12]
   138e6:	3301      	adds	r3, #1
   138e8:	d000      	beq.n	138ec <_vfiprintf_r+0x208>
   138ea:	e75e      	b.n	137aa <_vfiprintf_r+0xc6>
   138ec:	89bb      	ldrh	r3, [r7, #12]
   138ee:	065b      	lsls	r3, r3, #25
   138f0:	d500      	bpl.n	138f4 <_vfiprintf_r+0x210>
   138f2:	e726      	b.n	13742 <_vfiprintf_r+0x5e>
   138f4:	980b      	ldr	r0, [sp, #44]	; 0x2c
   138f6:	b01f      	add	sp, #124	; 0x7c
   138f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   138fa:	46c0      	nop			; (mov r8, r8)
   138fc:	00015a5c 	.word	0x00015a5c
   13900:	00015a7c 	.word	0x00015a7c
   13904:	00015a9c 	.word	0x00015a9c
   13908:	00015ac2 	.word	0x00015ac2
   1390c:	00015ac6 	.word	0x00015ac6
   13910:	00000000 	.word	0x00000000
   13914:	00015abc 	.word	0x00015abc
   13918:	000136bf 	.word	0x000136bf

0001391c <_printf_common>:
   1391c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1391e:	0017      	movs	r7, r2
   13920:	9301      	str	r3, [sp, #4]
   13922:	688a      	ldr	r2, [r1, #8]
   13924:	690b      	ldr	r3, [r1, #16]
   13926:	9000      	str	r0, [sp, #0]
   13928:	000c      	movs	r4, r1
   1392a:	4293      	cmp	r3, r2
   1392c:	da00      	bge.n	13930 <_printf_common+0x14>
   1392e:	0013      	movs	r3, r2
   13930:	0022      	movs	r2, r4
   13932:	603b      	str	r3, [r7, #0]
   13934:	3243      	adds	r2, #67	; 0x43
   13936:	7812      	ldrb	r2, [r2, #0]
   13938:	2a00      	cmp	r2, #0
   1393a:	d001      	beq.n	13940 <_printf_common+0x24>
   1393c:	3301      	adds	r3, #1
   1393e:	603b      	str	r3, [r7, #0]
   13940:	6823      	ldr	r3, [r4, #0]
   13942:	069b      	lsls	r3, r3, #26
   13944:	d502      	bpl.n	1394c <_printf_common+0x30>
   13946:	683b      	ldr	r3, [r7, #0]
   13948:	3302      	adds	r3, #2
   1394a:	603b      	str	r3, [r7, #0]
   1394c:	2506      	movs	r5, #6
   1394e:	6823      	ldr	r3, [r4, #0]
   13950:	401d      	ands	r5, r3
   13952:	d01e      	beq.n	13992 <_printf_common+0x76>
   13954:	0023      	movs	r3, r4
   13956:	3343      	adds	r3, #67	; 0x43
   13958:	781b      	ldrb	r3, [r3, #0]
   1395a:	1e5a      	subs	r2, r3, #1
   1395c:	4193      	sbcs	r3, r2
   1395e:	6822      	ldr	r2, [r4, #0]
   13960:	0692      	lsls	r2, r2, #26
   13962:	d51c      	bpl.n	1399e <_printf_common+0x82>
   13964:	2030      	movs	r0, #48	; 0x30
   13966:	18e1      	adds	r1, r4, r3
   13968:	3143      	adds	r1, #67	; 0x43
   1396a:	7008      	strb	r0, [r1, #0]
   1396c:	0021      	movs	r1, r4
   1396e:	1c5a      	adds	r2, r3, #1
   13970:	3145      	adds	r1, #69	; 0x45
   13972:	7809      	ldrb	r1, [r1, #0]
   13974:	18a2      	adds	r2, r4, r2
   13976:	3243      	adds	r2, #67	; 0x43
   13978:	3302      	adds	r3, #2
   1397a:	7011      	strb	r1, [r2, #0]
   1397c:	e00f      	b.n	1399e <_printf_common+0x82>
   1397e:	0022      	movs	r2, r4
   13980:	2301      	movs	r3, #1
   13982:	3219      	adds	r2, #25
   13984:	9901      	ldr	r1, [sp, #4]
   13986:	9800      	ldr	r0, [sp, #0]
   13988:	9e08      	ldr	r6, [sp, #32]
   1398a:	47b0      	blx	r6
   1398c:	1c43      	adds	r3, r0, #1
   1398e:	d00e      	beq.n	139ae <_printf_common+0x92>
   13990:	3501      	adds	r5, #1
   13992:	68e3      	ldr	r3, [r4, #12]
   13994:	683a      	ldr	r2, [r7, #0]
   13996:	1a9b      	subs	r3, r3, r2
   13998:	429d      	cmp	r5, r3
   1399a:	dbf0      	blt.n	1397e <_printf_common+0x62>
   1399c:	e7da      	b.n	13954 <_printf_common+0x38>
   1399e:	0022      	movs	r2, r4
   139a0:	9901      	ldr	r1, [sp, #4]
   139a2:	3243      	adds	r2, #67	; 0x43
   139a4:	9800      	ldr	r0, [sp, #0]
   139a6:	9d08      	ldr	r5, [sp, #32]
   139a8:	47a8      	blx	r5
   139aa:	1c43      	adds	r3, r0, #1
   139ac:	d102      	bne.n	139b4 <_printf_common+0x98>
   139ae:	2001      	movs	r0, #1
   139b0:	4240      	negs	r0, r0
   139b2:	e020      	b.n	139f6 <_printf_common+0xda>
   139b4:	2306      	movs	r3, #6
   139b6:	6820      	ldr	r0, [r4, #0]
   139b8:	68e1      	ldr	r1, [r4, #12]
   139ba:	683a      	ldr	r2, [r7, #0]
   139bc:	4003      	ands	r3, r0
   139be:	2500      	movs	r5, #0
   139c0:	2b04      	cmp	r3, #4
   139c2:	d103      	bne.n	139cc <_printf_common+0xb0>
   139c4:	1a8d      	subs	r5, r1, r2
   139c6:	43eb      	mvns	r3, r5
   139c8:	17db      	asrs	r3, r3, #31
   139ca:	401d      	ands	r5, r3
   139cc:	68a3      	ldr	r3, [r4, #8]
   139ce:	6922      	ldr	r2, [r4, #16]
   139d0:	4293      	cmp	r3, r2
   139d2:	dd01      	ble.n	139d8 <_printf_common+0xbc>
   139d4:	1a9b      	subs	r3, r3, r2
   139d6:	18ed      	adds	r5, r5, r3
   139d8:	2700      	movs	r7, #0
   139da:	42bd      	cmp	r5, r7
   139dc:	d00a      	beq.n	139f4 <_printf_common+0xd8>
   139de:	0022      	movs	r2, r4
   139e0:	2301      	movs	r3, #1
   139e2:	321a      	adds	r2, #26
   139e4:	9901      	ldr	r1, [sp, #4]
   139e6:	9800      	ldr	r0, [sp, #0]
   139e8:	9e08      	ldr	r6, [sp, #32]
   139ea:	47b0      	blx	r6
   139ec:	1c43      	adds	r3, r0, #1
   139ee:	d0de      	beq.n	139ae <_printf_common+0x92>
   139f0:	3701      	adds	r7, #1
   139f2:	e7f2      	b.n	139da <_printf_common+0xbe>
   139f4:	2000      	movs	r0, #0
   139f6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

000139f8 <_printf_i>:
   139f8:	b5f0      	push	{r4, r5, r6, r7, lr}
   139fa:	b08b      	sub	sp, #44	; 0x2c
   139fc:	9206      	str	r2, [sp, #24]
   139fe:	000a      	movs	r2, r1
   13a00:	3243      	adds	r2, #67	; 0x43
   13a02:	9307      	str	r3, [sp, #28]
   13a04:	9005      	str	r0, [sp, #20]
   13a06:	9204      	str	r2, [sp, #16]
   13a08:	7e0a      	ldrb	r2, [r1, #24]
   13a0a:	000c      	movs	r4, r1
   13a0c:	9b10      	ldr	r3, [sp, #64]	; 0x40
   13a0e:	2a6e      	cmp	r2, #110	; 0x6e
   13a10:	d100      	bne.n	13a14 <_printf_i+0x1c>
   13a12:	e0ab      	b.n	13b6c <_printf_i+0x174>
   13a14:	d811      	bhi.n	13a3a <_printf_i+0x42>
   13a16:	2a63      	cmp	r2, #99	; 0x63
   13a18:	d022      	beq.n	13a60 <_printf_i+0x68>
   13a1a:	d809      	bhi.n	13a30 <_printf_i+0x38>
   13a1c:	2a00      	cmp	r2, #0
   13a1e:	d100      	bne.n	13a22 <_printf_i+0x2a>
   13a20:	e0b5      	b.n	13b8e <_printf_i+0x196>
   13a22:	2a58      	cmp	r2, #88	; 0x58
   13a24:	d000      	beq.n	13a28 <_printf_i+0x30>
   13a26:	e0c5      	b.n	13bb4 <_printf_i+0x1bc>
   13a28:	3145      	adds	r1, #69	; 0x45
   13a2a:	700a      	strb	r2, [r1, #0]
   13a2c:	4a81      	ldr	r2, [pc, #516]	; (13c34 <_printf_i+0x23c>)
   13a2e:	e04f      	b.n	13ad0 <_printf_i+0xd8>
   13a30:	2a64      	cmp	r2, #100	; 0x64
   13a32:	d01d      	beq.n	13a70 <_printf_i+0x78>
   13a34:	2a69      	cmp	r2, #105	; 0x69
   13a36:	d01b      	beq.n	13a70 <_printf_i+0x78>
   13a38:	e0bc      	b.n	13bb4 <_printf_i+0x1bc>
   13a3a:	2a73      	cmp	r2, #115	; 0x73
   13a3c:	d100      	bne.n	13a40 <_printf_i+0x48>
   13a3e:	e0aa      	b.n	13b96 <_printf_i+0x19e>
   13a40:	d809      	bhi.n	13a56 <_printf_i+0x5e>
   13a42:	2a6f      	cmp	r2, #111	; 0x6f
   13a44:	d029      	beq.n	13a9a <_printf_i+0xa2>
   13a46:	2a70      	cmp	r2, #112	; 0x70
   13a48:	d000      	beq.n	13a4c <_printf_i+0x54>
   13a4a:	e0b3      	b.n	13bb4 <_printf_i+0x1bc>
   13a4c:	2220      	movs	r2, #32
   13a4e:	6809      	ldr	r1, [r1, #0]
   13a50:	430a      	orrs	r2, r1
   13a52:	6022      	str	r2, [r4, #0]
   13a54:	e037      	b.n	13ac6 <_printf_i+0xce>
   13a56:	2a75      	cmp	r2, #117	; 0x75
   13a58:	d01f      	beq.n	13a9a <_printf_i+0xa2>
   13a5a:	2a78      	cmp	r2, #120	; 0x78
   13a5c:	d033      	beq.n	13ac6 <_printf_i+0xce>
   13a5e:	e0a9      	b.n	13bb4 <_printf_i+0x1bc>
   13a60:	000e      	movs	r6, r1
   13a62:	681a      	ldr	r2, [r3, #0]
   13a64:	3642      	adds	r6, #66	; 0x42
   13a66:	1d11      	adds	r1, r2, #4
   13a68:	6019      	str	r1, [r3, #0]
   13a6a:	6813      	ldr	r3, [r2, #0]
   13a6c:	7033      	strb	r3, [r6, #0]
   13a6e:	e0a4      	b.n	13bba <_printf_i+0x1c2>
   13a70:	6821      	ldr	r1, [r4, #0]
   13a72:	681a      	ldr	r2, [r3, #0]
   13a74:	0608      	lsls	r0, r1, #24
   13a76:	d406      	bmi.n	13a86 <_printf_i+0x8e>
   13a78:	0649      	lsls	r1, r1, #25
   13a7a:	d504      	bpl.n	13a86 <_printf_i+0x8e>
   13a7c:	1d11      	adds	r1, r2, #4
   13a7e:	6019      	str	r1, [r3, #0]
   13a80:	2300      	movs	r3, #0
   13a82:	5ed5      	ldrsh	r5, [r2, r3]
   13a84:	e002      	b.n	13a8c <_printf_i+0x94>
   13a86:	1d11      	adds	r1, r2, #4
   13a88:	6019      	str	r1, [r3, #0]
   13a8a:	6815      	ldr	r5, [r2, #0]
   13a8c:	2d00      	cmp	r5, #0
   13a8e:	da3b      	bge.n	13b08 <_printf_i+0x110>
   13a90:	232d      	movs	r3, #45	; 0x2d
   13a92:	9a04      	ldr	r2, [sp, #16]
   13a94:	426d      	negs	r5, r5
   13a96:	7013      	strb	r3, [r2, #0]
   13a98:	e036      	b.n	13b08 <_printf_i+0x110>
   13a9a:	6821      	ldr	r1, [r4, #0]
   13a9c:	681a      	ldr	r2, [r3, #0]
   13a9e:	0608      	lsls	r0, r1, #24
   13aa0:	d406      	bmi.n	13ab0 <_printf_i+0xb8>
   13aa2:	0649      	lsls	r1, r1, #25
   13aa4:	d504      	bpl.n	13ab0 <_printf_i+0xb8>
   13aa6:	6815      	ldr	r5, [r2, #0]
   13aa8:	1d11      	adds	r1, r2, #4
   13aaa:	6019      	str	r1, [r3, #0]
   13aac:	b2ad      	uxth	r5, r5
   13aae:	e002      	b.n	13ab6 <_printf_i+0xbe>
   13ab0:	1d11      	adds	r1, r2, #4
   13ab2:	6019      	str	r1, [r3, #0]
   13ab4:	6815      	ldr	r5, [r2, #0]
   13ab6:	4b5f      	ldr	r3, [pc, #380]	; (13c34 <_printf_i+0x23c>)
   13ab8:	7e22      	ldrb	r2, [r4, #24]
   13aba:	9303      	str	r3, [sp, #12]
   13abc:	2708      	movs	r7, #8
   13abe:	2a6f      	cmp	r2, #111	; 0x6f
   13ac0:	d01d      	beq.n	13afe <_printf_i+0x106>
   13ac2:	270a      	movs	r7, #10
   13ac4:	e01b      	b.n	13afe <_printf_i+0x106>
   13ac6:	0022      	movs	r2, r4
   13ac8:	2178      	movs	r1, #120	; 0x78
   13aca:	3245      	adds	r2, #69	; 0x45
   13acc:	7011      	strb	r1, [r2, #0]
   13ace:	4a5a      	ldr	r2, [pc, #360]	; (13c38 <_printf_i+0x240>)
   13ad0:	6819      	ldr	r1, [r3, #0]
   13ad2:	9203      	str	r2, [sp, #12]
   13ad4:	1d08      	adds	r0, r1, #4
   13ad6:	6822      	ldr	r2, [r4, #0]
   13ad8:	6018      	str	r0, [r3, #0]
   13ada:	680d      	ldr	r5, [r1, #0]
   13adc:	0610      	lsls	r0, r2, #24
   13ade:	d402      	bmi.n	13ae6 <_printf_i+0xee>
   13ae0:	0650      	lsls	r0, r2, #25
   13ae2:	d500      	bpl.n	13ae6 <_printf_i+0xee>
   13ae4:	b2ad      	uxth	r5, r5
   13ae6:	07d3      	lsls	r3, r2, #31
   13ae8:	d502      	bpl.n	13af0 <_printf_i+0xf8>
   13aea:	2320      	movs	r3, #32
   13aec:	431a      	orrs	r2, r3
   13aee:	6022      	str	r2, [r4, #0]
   13af0:	2710      	movs	r7, #16
   13af2:	2d00      	cmp	r5, #0
   13af4:	d103      	bne.n	13afe <_printf_i+0x106>
   13af6:	2320      	movs	r3, #32
   13af8:	6822      	ldr	r2, [r4, #0]
   13afa:	439a      	bics	r2, r3
   13afc:	6022      	str	r2, [r4, #0]
   13afe:	0023      	movs	r3, r4
   13b00:	2200      	movs	r2, #0
   13b02:	3343      	adds	r3, #67	; 0x43
   13b04:	701a      	strb	r2, [r3, #0]
   13b06:	e002      	b.n	13b0e <_printf_i+0x116>
   13b08:	270a      	movs	r7, #10
   13b0a:	4b4a      	ldr	r3, [pc, #296]	; (13c34 <_printf_i+0x23c>)
   13b0c:	9303      	str	r3, [sp, #12]
   13b0e:	6863      	ldr	r3, [r4, #4]
   13b10:	60a3      	str	r3, [r4, #8]
   13b12:	2b00      	cmp	r3, #0
   13b14:	db09      	blt.n	13b2a <_printf_i+0x132>
   13b16:	2204      	movs	r2, #4
   13b18:	6821      	ldr	r1, [r4, #0]
   13b1a:	4391      	bics	r1, r2
   13b1c:	6021      	str	r1, [r4, #0]
   13b1e:	2d00      	cmp	r5, #0
   13b20:	d105      	bne.n	13b2e <_printf_i+0x136>
   13b22:	9e04      	ldr	r6, [sp, #16]
   13b24:	2b00      	cmp	r3, #0
   13b26:	d011      	beq.n	13b4c <_printf_i+0x154>
   13b28:	e07b      	b.n	13c22 <_printf_i+0x22a>
   13b2a:	2d00      	cmp	r5, #0
   13b2c:	d079      	beq.n	13c22 <_printf_i+0x22a>
   13b2e:	9e04      	ldr	r6, [sp, #16]
   13b30:	0028      	movs	r0, r5
   13b32:	0039      	movs	r1, r7
   13b34:	f7fe fbc8 	bl	122c8 <__aeabi_uidivmod>
   13b38:	9b03      	ldr	r3, [sp, #12]
   13b3a:	3e01      	subs	r6, #1
   13b3c:	5c5b      	ldrb	r3, [r3, r1]
   13b3e:	0028      	movs	r0, r5
   13b40:	7033      	strb	r3, [r6, #0]
   13b42:	0039      	movs	r1, r7
   13b44:	f7fe fb3a 	bl	121bc <__aeabi_uidiv>
   13b48:	1e05      	subs	r5, r0, #0
   13b4a:	d1f1      	bne.n	13b30 <_printf_i+0x138>
   13b4c:	2f08      	cmp	r7, #8
   13b4e:	d109      	bne.n	13b64 <_printf_i+0x16c>
   13b50:	6823      	ldr	r3, [r4, #0]
   13b52:	07db      	lsls	r3, r3, #31
   13b54:	d506      	bpl.n	13b64 <_printf_i+0x16c>
   13b56:	6863      	ldr	r3, [r4, #4]
   13b58:	6922      	ldr	r2, [r4, #16]
   13b5a:	4293      	cmp	r3, r2
   13b5c:	dc02      	bgt.n	13b64 <_printf_i+0x16c>
   13b5e:	2330      	movs	r3, #48	; 0x30
   13b60:	3e01      	subs	r6, #1
   13b62:	7033      	strb	r3, [r6, #0]
   13b64:	9b04      	ldr	r3, [sp, #16]
   13b66:	1b9b      	subs	r3, r3, r6
   13b68:	6123      	str	r3, [r4, #16]
   13b6a:	e02b      	b.n	13bc4 <_printf_i+0x1cc>
   13b6c:	6809      	ldr	r1, [r1, #0]
   13b6e:	681a      	ldr	r2, [r3, #0]
   13b70:	0608      	lsls	r0, r1, #24
   13b72:	d407      	bmi.n	13b84 <_printf_i+0x18c>
   13b74:	0649      	lsls	r1, r1, #25
   13b76:	d505      	bpl.n	13b84 <_printf_i+0x18c>
   13b78:	1d11      	adds	r1, r2, #4
   13b7a:	6019      	str	r1, [r3, #0]
   13b7c:	6813      	ldr	r3, [r2, #0]
   13b7e:	8aa2      	ldrh	r2, [r4, #20]
   13b80:	801a      	strh	r2, [r3, #0]
   13b82:	e004      	b.n	13b8e <_printf_i+0x196>
   13b84:	1d11      	adds	r1, r2, #4
   13b86:	6019      	str	r1, [r3, #0]
   13b88:	6813      	ldr	r3, [r2, #0]
   13b8a:	6962      	ldr	r2, [r4, #20]
   13b8c:	601a      	str	r2, [r3, #0]
   13b8e:	2300      	movs	r3, #0
   13b90:	9e04      	ldr	r6, [sp, #16]
   13b92:	6123      	str	r3, [r4, #16]
   13b94:	e016      	b.n	13bc4 <_printf_i+0x1cc>
   13b96:	681a      	ldr	r2, [r3, #0]
   13b98:	1d11      	adds	r1, r2, #4
   13b9a:	6019      	str	r1, [r3, #0]
   13b9c:	6816      	ldr	r6, [r2, #0]
   13b9e:	2100      	movs	r1, #0
   13ba0:	6862      	ldr	r2, [r4, #4]
   13ba2:	0030      	movs	r0, r6
   13ba4:	f000 fe56 	bl	14854 <memchr>
   13ba8:	2800      	cmp	r0, #0
   13baa:	d001      	beq.n	13bb0 <_printf_i+0x1b8>
   13bac:	1b80      	subs	r0, r0, r6
   13bae:	6060      	str	r0, [r4, #4]
   13bb0:	6863      	ldr	r3, [r4, #4]
   13bb2:	e003      	b.n	13bbc <_printf_i+0x1c4>
   13bb4:	0026      	movs	r6, r4
   13bb6:	3642      	adds	r6, #66	; 0x42
   13bb8:	7032      	strb	r2, [r6, #0]
   13bba:	2301      	movs	r3, #1
   13bbc:	6123      	str	r3, [r4, #16]
   13bbe:	2300      	movs	r3, #0
   13bc0:	9a04      	ldr	r2, [sp, #16]
   13bc2:	7013      	strb	r3, [r2, #0]
   13bc4:	9b07      	ldr	r3, [sp, #28]
   13bc6:	aa09      	add	r2, sp, #36	; 0x24
   13bc8:	9300      	str	r3, [sp, #0]
   13bca:	0021      	movs	r1, r4
   13bcc:	9b06      	ldr	r3, [sp, #24]
   13bce:	9805      	ldr	r0, [sp, #20]
   13bd0:	f7ff fea4 	bl	1391c <_printf_common>
   13bd4:	1c43      	adds	r3, r0, #1
   13bd6:	d102      	bne.n	13bde <_printf_i+0x1e6>
   13bd8:	2001      	movs	r0, #1
   13bda:	4240      	negs	r0, r0
   13bdc:	e027      	b.n	13c2e <_printf_i+0x236>
   13bde:	6923      	ldr	r3, [r4, #16]
   13be0:	0032      	movs	r2, r6
   13be2:	9906      	ldr	r1, [sp, #24]
   13be4:	9805      	ldr	r0, [sp, #20]
   13be6:	9d07      	ldr	r5, [sp, #28]
   13be8:	47a8      	blx	r5
   13bea:	1c43      	adds	r3, r0, #1
   13bec:	d0f4      	beq.n	13bd8 <_printf_i+0x1e0>
   13bee:	6823      	ldr	r3, [r4, #0]
   13bf0:	2500      	movs	r5, #0
   13bf2:	079b      	lsls	r3, r3, #30
   13bf4:	d40f      	bmi.n	13c16 <_printf_i+0x21e>
   13bf6:	9b09      	ldr	r3, [sp, #36]	; 0x24
   13bf8:	68e0      	ldr	r0, [r4, #12]
   13bfa:	4298      	cmp	r0, r3
   13bfc:	da17      	bge.n	13c2e <_printf_i+0x236>
   13bfe:	0018      	movs	r0, r3
   13c00:	e015      	b.n	13c2e <_printf_i+0x236>
   13c02:	0022      	movs	r2, r4
   13c04:	2301      	movs	r3, #1
   13c06:	3219      	adds	r2, #25
   13c08:	9906      	ldr	r1, [sp, #24]
   13c0a:	9805      	ldr	r0, [sp, #20]
   13c0c:	9e07      	ldr	r6, [sp, #28]
   13c0e:	47b0      	blx	r6
   13c10:	1c43      	adds	r3, r0, #1
   13c12:	d0e1      	beq.n	13bd8 <_printf_i+0x1e0>
   13c14:	3501      	adds	r5, #1
   13c16:	68e3      	ldr	r3, [r4, #12]
   13c18:	9a09      	ldr	r2, [sp, #36]	; 0x24
   13c1a:	1a9b      	subs	r3, r3, r2
   13c1c:	429d      	cmp	r5, r3
   13c1e:	dbf0      	blt.n	13c02 <_printf_i+0x20a>
   13c20:	e7e9      	b.n	13bf6 <_printf_i+0x1fe>
   13c22:	0026      	movs	r6, r4
   13c24:	9b03      	ldr	r3, [sp, #12]
   13c26:	3642      	adds	r6, #66	; 0x42
   13c28:	781b      	ldrb	r3, [r3, #0]
   13c2a:	7033      	strb	r3, [r6, #0]
   13c2c:	e78e      	b.n	13b4c <_printf_i+0x154>
   13c2e:	b00b      	add	sp, #44	; 0x2c
   13c30:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13c32:	46c0      	nop			; (mov r8, r8)
   13c34:	00015acd 	.word	0x00015acd
   13c38:	00015ade 	.word	0x00015ade

00013c3c <__svfiscanf_r>:
   13c3c:	b5f0      	push	{r4, r5, r6, r7, lr}
   13c3e:	4cb8      	ldr	r4, [pc, #736]	; (13f20 <__svfiscanf_r+0x2e4>)
   13c40:	000d      	movs	r5, r1
   13c42:	44a5      	add	sp, r4
   13c44:	9303      	str	r3, [sp, #12]
   13c46:	2300      	movs	r3, #0
   13c48:	9000      	str	r0, [sp, #0]
   13c4a:	9348      	str	r3, [sp, #288]	; 0x120
   13c4c:	9349      	str	r3, [sp, #292]	; 0x124
   13c4e:	2086      	movs	r0, #134	; 0x86
   13c50:	ab05      	add	r3, sp, #20
   13c52:	934a      	str	r3, [sp, #296]	; 0x128
   13c54:	23be      	movs	r3, #190	; 0xbe
   13c56:	0040      	lsls	r0, r0, #1
   13c58:	9201      	str	r2, [sp, #4]
   13c5a:	a902      	add	r1, sp, #8
   13c5c:	4ab1      	ldr	r2, [pc, #708]	; (13f24 <__svfiscanf_r+0x2e8>)
   13c5e:	005b      	lsls	r3, r3, #1
   13c60:	1809      	adds	r1, r1, r0
   13c62:	50ca      	str	r2, [r1, r3]
   13c64:	3304      	adds	r3, #4
   13c66:	001e      	movs	r6, r3
   13c68:	4aaf      	ldr	r2, [pc, #700]	; (13f28 <__svfiscanf_r+0x2ec>)
   13c6a:	a902      	add	r1, sp, #8
   13c6c:	1809      	adds	r1, r1, r0
   13c6e:	50ca      	str	r2, [r1, r3]
   13c70:	9b01      	ldr	r3, [sp, #4]
   13c72:	781a      	ldrb	r2, [r3, #0]
   13c74:	2a00      	cmp	r2, #0
   13c76:	d100      	bne.n	13c7a <__svfiscanf_r+0x3e>
   13c78:	e149      	b.n	13f0e <__svfiscanf_r+0x2d2>
   13c7a:	2108      	movs	r1, #8
   13c7c:	4cab      	ldr	r4, [pc, #684]	; (13f2c <__svfiscanf_r+0x2f0>)
   13c7e:	6823      	ldr	r3, [r4, #0]
   13c80:	189b      	adds	r3, r3, r2
   13c82:	785b      	ldrb	r3, [r3, #1]
   13c84:	400b      	ands	r3, r1
   13c86:	d023      	beq.n	13cd0 <__svfiscanf_r+0x94>
   13c88:	686b      	ldr	r3, [r5, #4]
   13c8a:	2b00      	cmp	r3, #0
   13c8c:	dd11      	ble.n	13cb2 <__svfiscanf_r+0x76>
   13c8e:	682b      	ldr	r3, [r5, #0]
   13c90:	6821      	ldr	r1, [r4, #0]
   13c92:	781a      	ldrb	r2, [r3, #0]
   13c94:	188a      	adds	r2, r1, r2
   13c96:	2108      	movs	r1, #8
   13c98:	7852      	ldrb	r2, [r2, #1]
   13c9a:	420a      	tst	r2, r1
   13c9c:	d014      	beq.n	13cc8 <__svfiscanf_r+0x8c>
   13c9e:	9a49      	ldr	r2, [sp, #292]	; 0x124
   13ca0:	3301      	adds	r3, #1
   13ca2:	9202      	str	r2, [sp, #8]
   13ca4:	3201      	adds	r2, #1
   13ca6:	9249      	str	r2, [sp, #292]	; 0x124
   13ca8:	686a      	ldr	r2, [r5, #4]
   13caa:	602b      	str	r3, [r5, #0]
   13cac:	3a01      	subs	r2, #1
   13cae:	606a      	str	r2, [r5, #4]
   13cb0:	e7ea      	b.n	13c88 <__svfiscanf_r+0x4c>
   13cb2:	2286      	movs	r2, #134	; 0x86
   13cb4:	ab02      	add	r3, sp, #8
   13cb6:	0052      	lsls	r2, r2, #1
   13cb8:	189b      	adds	r3, r3, r2
   13cba:	599b      	ldr	r3, [r3, r6]
   13cbc:	0029      	movs	r1, r5
   13cbe:	9800      	ldr	r0, [sp, #0]
   13cc0:	9302      	str	r3, [sp, #8]
   13cc2:	4798      	blx	r3
   13cc4:	2800      	cmp	r0, #0
   13cc6:	d0e2      	beq.n	13c8e <__svfiscanf_r+0x52>
   13cc8:	9f01      	ldr	r7, [sp, #4]
   13cca:	3701      	adds	r7, #1
   13ccc:	9701      	str	r7, [sp, #4]
   13cce:	e7cf      	b.n	13c70 <__svfiscanf_r+0x34>
   13cd0:	9901      	ldr	r1, [sp, #4]
   13cd2:	0014      	movs	r4, r2
   13cd4:	1c4f      	adds	r7, r1, #1
   13cd6:	2a25      	cmp	r2, #37	; 0x25
   13cd8:	d155      	bne.n	13d86 <__svfiscanf_r+0x14a>
   13cda:	9347      	str	r3, [sp, #284]	; 0x11c
   13cdc:	9345      	str	r3, [sp, #276]	; 0x114
   13cde:	784b      	ldrb	r3, [r1, #1]
   13ce0:	2b2a      	cmp	r3, #42	; 0x2a
   13ce2:	d102      	bne.n	13cea <__svfiscanf_r+0xae>
   13ce4:	3b1a      	subs	r3, #26
   13ce6:	9345      	str	r3, [sp, #276]	; 0x114
   13ce8:	3701      	adds	r7, #1
   13cea:	003c      	movs	r4, r7
   13cec:	220a      	movs	r2, #10
   13cee:	7821      	ldrb	r1, [r4, #0]
   13cf0:	000b      	movs	r3, r1
   13cf2:	3b30      	subs	r3, #48	; 0x30
   13cf4:	2b09      	cmp	r3, #9
   13cf6:	d807      	bhi.n	13d08 <__svfiscanf_r+0xcc>
   13cf8:	9b47      	ldr	r3, [sp, #284]	; 0x11c
   13cfa:	3401      	adds	r4, #1
   13cfc:	9301      	str	r3, [sp, #4]
   13cfe:	4353      	muls	r3, r2
   13d00:	3b30      	subs	r3, #48	; 0x30
   13d02:	1859      	adds	r1, r3, r1
   13d04:	9147      	str	r1, [sp, #284]	; 0x11c
   13d06:	e7f2      	b.n	13cee <__svfiscanf_r+0xb2>
   13d08:	4f89      	ldr	r7, [pc, #548]	; (13f30 <__svfiscanf_r+0x2f4>)
   13d0a:	2203      	movs	r2, #3
   13d0c:	0038      	movs	r0, r7
   13d0e:	f000 fda1 	bl	14854 <memchr>
   13d12:	2800      	cmp	r0, #0
   13d14:	d007      	beq.n	13d26 <__svfiscanf_r+0xea>
   13d16:	2301      	movs	r3, #1
   13d18:	1bc0      	subs	r0, r0, r7
   13d1a:	4083      	lsls	r3, r0
   13d1c:	9a45      	ldr	r2, [sp, #276]	; 0x114
   13d1e:	3401      	adds	r4, #1
   13d20:	4313      	orrs	r3, r2
   13d22:	9201      	str	r2, [sp, #4]
   13d24:	9345      	str	r3, [sp, #276]	; 0x114
   13d26:	1c67      	adds	r7, r4, #1
   13d28:	7824      	ldrb	r4, [r4, #0]
   13d2a:	2c67      	cmp	r4, #103	; 0x67
   13d2c:	d818      	bhi.n	13d60 <__svfiscanf_r+0x124>
   13d2e:	2c65      	cmp	r4, #101	; 0x65
   13d30:	d300      	bcc.n	13d34 <__svfiscanf_r+0xf8>
   13d32:	e08b      	b.n	13e4c <__svfiscanf_r+0x210>
   13d34:	2c47      	cmp	r4, #71	; 0x47
   13d36:	d808      	bhi.n	13d4a <__svfiscanf_r+0x10e>
   13d38:	2c45      	cmp	r4, #69	; 0x45
   13d3a:	d300      	bcc.n	13d3e <__svfiscanf_r+0x102>
   13d3c:	e086      	b.n	13e4c <__svfiscanf_r+0x210>
   13d3e:	2c00      	cmp	r4, #0
   13d40:	d100      	bne.n	13d44 <__svfiscanf_r+0x108>
   13d42:	e0e6      	b.n	13f12 <__svfiscanf_r+0x2d6>
   13d44:	2c25      	cmp	r4, #37	; 0x25
   13d46:	d01e      	beq.n	13d86 <__svfiscanf_r+0x14a>
   13d48:	e082      	b.n	13e50 <__svfiscanf_r+0x214>
   13d4a:	2c5b      	cmp	r4, #91	; 0x5b
   13d4c:	d056      	beq.n	13dfc <__svfiscanf_r+0x1c0>
   13d4e:	d802      	bhi.n	13d56 <__svfiscanf_r+0x11a>
   13d50:	2c58      	cmp	r4, #88	; 0x58
   13d52:	d041      	beq.n	13dd8 <__svfiscanf_r+0x19c>
   13d54:	e07c      	b.n	13e50 <__svfiscanf_r+0x214>
   13d56:	2c63      	cmp	r4, #99	; 0x63
   13d58:	d05e      	beq.n	13e18 <__svfiscanf_r+0x1dc>
   13d5a:	2c64      	cmp	r4, #100	; 0x64
   13d5c:	d045      	beq.n	13dea <__svfiscanf_r+0x1ae>
   13d5e:	e077      	b.n	13e50 <__svfiscanf_r+0x214>
   13d60:	2c70      	cmp	r4, #112	; 0x70
   13d62:	d033      	beq.n	13dcc <__svfiscanf_r+0x190>
   13d64:	d807      	bhi.n	13d76 <__svfiscanf_r+0x13a>
   13d66:	2c6e      	cmp	r4, #110	; 0x6e
   13d68:	d05e      	beq.n	13e28 <__svfiscanf_r+0x1ec>
   13d6a:	d840      	bhi.n	13dee <__svfiscanf_r+0x1b2>
   13d6c:	2c69      	cmp	r4, #105	; 0x69
   13d6e:	d16f      	bne.n	13e50 <__svfiscanf_r+0x214>
   13d70:	2300      	movs	r3, #0
   13d72:	9346      	str	r3, [sp, #280]	; 0x118
   13d74:	e040      	b.n	13df8 <__svfiscanf_r+0x1bc>
   13d76:	2c75      	cmp	r4, #117	; 0x75
   13d78:	d037      	beq.n	13dea <__svfiscanf_r+0x1ae>
   13d7a:	2c78      	cmp	r4, #120	; 0x78
   13d7c:	d02c      	beq.n	13dd8 <__svfiscanf_r+0x19c>
   13d7e:	2302      	movs	r3, #2
   13d80:	2c73      	cmp	r4, #115	; 0x73
   13d82:	d047      	beq.n	13e14 <__svfiscanf_r+0x1d8>
   13d84:	e064      	b.n	13e50 <__svfiscanf_r+0x214>
   13d86:	686b      	ldr	r3, [r5, #4]
   13d88:	2b00      	cmp	r3, #0
   13d8a:	dd0e      	ble.n	13daa <__svfiscanf_r+0x16e>
   13d8c:	682b      	ldr	r3, [r5, #0]
   13d8e:	781a      	ldrb	r2, [r3, #0]
   13d90:	4294      	cmp	r4, r2
   13d92:	d000      	beq.n	13d96 <__svfiscanf_r+0x15a>
   13d94:	e0bb      	b.n	13f0e <__svfiscanf_r+0x2d2>
   13d96:	3301      	adds	r3, #1
   13d98:	686a      	ldr	r2, [r5, #4]
   13d9a:	602b      	str	r3, [r5, #0]
   13d9c:	9b49      	ldr	r3, [sp, #292]	; 0x124
   13d9e:	3a01      	subs	r2, #1
   13da0:	9301      	str	r3, [sp, #4]
   13da2:	3301      	adds	r3, #1
   13da4:	606a      	str	r2, [r5, #4]
   13da6:	9349      	str	r3, [sp, #292]	; 0x124
   13da8:	e790      	b.n	13ccc <__svfiscanf_r+0x90>
   13daa:	2286      	movs	r2, #134	; 0x86
   13dac:	ab02      	add	r3, sp, #8
   13dae:	0052      	lsls	r2, r2, #1
   13db0:	189b      	adds	r3, r3, r2
   13db2:	599b      	ldr	r3, [r3, r6]
   13db4:	0029      	movs	r1, r5
   13db6:	9800      	ldr	r0, [sp, #0]
   13db8:	9301      	str	r3, [sp, #4]
   13dba:	4798      	blx	r3
   13dbc:	2800      	cmp	r0, #0
   13dbe:	d0e5      	beq.n	13d8c <__svfiscanf_r+0x150>
   13dc0:	9848      	ldr	r0, [sp, #288]	; 0x120
   13dc2:	2800      	cmp	r0, #0
   13dc4:	d000      	beq.n	13dc8 <__svfiscanf_r+0x18c>
   13dc6:	e09e      	b.n	13f06 <__svfiscanf_r+0x2ca>
   13dc8:	3801      	subs	r0, #1
   13dca:	e0a4      	b.n	13f16 <__svfiscanf_r+0x2da>
   13dcc:	9b45      	ldr	r3, [sp, #276]	; 0x114
   13dce:	9301      	str	r3, [sp, #4]
   13dd0:	2320      	movs	r3, #32
   13dd2:	9a01      	ldr	r2, [sp, #4]
   13dd4:	4313      	orrs	r3, r2
   13dd6:	9345      	str	r3, [sp, #276]	; 0x114
   13dd8:	9b45      	ldr	r3, [sp, #276]	; 0x114
   13dda:	9301      	str	r3, [sp, #4]
   13ddc:	2380      	movs	r3, #128	; 0x80
   13dde:	9a01      	ldr	r2, [sp, #4]
   13de0:	009b      	lsls	r3, r3, #2
   13de2:	4313      	orrs	r3, r2
   13de4:	9345      	str	r3, [sp, #276]	; 0x114
   13de6:	2310      	movs	r3, #16
   13de8:	e002      	b.n	13df0 <__svfiscanf_r+0x1b4>
   13dea:	230a      	movs	r3, #10
   13dec:	e000      	b.n	13df0 <__svfiscanf_r+0x1b4>
   13dee:	2308      	movs	r3, #8
   13df0:	9346      	str	r3, [sp, #280]	; 0x118
   13df2:	2304      	movs	r3, #4
   13df4:	2c6e      	cmp	r4, #110	; 0x6e
   13df6:	dc0d      	bgt.n	13e14 <__svfiscanf_r+0x1d8>
   13df8:	2303      	movs	r3, #3
   13dfa:	e00b      	b.n	13e14 <__svfiscanf_r+0x1d8>
   13dfc:	0039      	movs	r1, r7
   13dfe:	a805      	add	r0, sp, #20
   13e00:	f000 fb0c 	bl	1441c <__sccl>
   13e04:	9b45      	ldr	r3, [sp, #276]	; 0x114
   13e06:	0007      	movs	r7, r0
   13e08:	9301      	str	r3, [sp, #4]
   13e0a:	2340      	movs	r3, #64	; 0x40
   13e0c:	9a01      	ldr	r2, [sp, #4]
   13e0e:	4313      	orrs	r3, r2
   13e10:	9345      	str	r3, [sp, #276]	; 0x114
   13e12:	2301      	movs	r3, #1
   13e14:	934b      	str	r3, [sp, #300]	; 0x12c
   13e16:	e01f      	b.n	13e58 <__svfiscanf_r+0x21c>
   13e18:	9b45      	ldr	r3, [sp, #276]	; 0x114
   13e1a:	9301      	str	r3, [sp, #4]
   13e1c:	2340      	movs	r3, #64	; 0x40
   13e1e:	9a01      	ldr	r2, [sp, #4]
   13e20:	4313      	orrs	r3, r2
   13e22:	9345      	str	r3, [sp, #276]	; 0x114
   13e24:	2300      	movs	r3, #0
   13e26:	e7f5      	b.n	13e14 <__svfiscanf_r+0x1d8>
   13e28:	9945      	ldr	r1, [sp, #276]	; 0x114
   13e2a:	06cb      	lsls	r3, r1, #27
   13e2c:	d500      	bpl.n	13e30 <__svfiscanf_r+0x1f4>
   13e2e:	e74d      	b.n	13ccc <__svfiscanf_r+0x90>
   13e30:	9b03      	ldr	r3, [sp, #12]
   13e32:	9a49      	ldr	r2, [sp, #292]	; 0x124
   13e34:	07c8      	lsls	r0, r1, #31
   13e36:	d504      	bpl.n	13e42 <__svfiscanf_r+0x206>
   13e38:	1d19      	adds	r1, r3, #4
   13e3a:	9103      	str	r1, [sp, #12]
   13e3c:	681b      	ldr	r3, [r3, #0]
   13e3e:	801a      	strh	r2, [r3, #0]
   13e40:	e744      	b.n	13ccc <__svfiscanf_r+0x90>
   13e42:	1d19      	adds	r1, r3, #4
   13e44:	9103      	str	r1, [sp, #12]
   13e46:	681b      	ldr	r3, [r3, #0]
   13e48:	601a      	str	r2, [r3, #0]
   13e4a:	e73f      	b.n	13ccc <__svfiscanf_r+0x90>
   13e4c:	2305      	movs	r3, #5
   13e4e:	e7e1      	b.n	13e14 <__svfiscanf_r+0x1d8>
   13e50:	2303      	movs	r3, #3
   13e52:	934b      	str	r3, [sp, #300]	; 0x12c
   13e54:	3307      	adds	r3, #7
   13e56:	9346      	str	r3, [sp, #280]	; 0x118
   13e58:	686b      	ldr	r3, [r5, #4]
   13e5a:	2b00      	cmp	r3, #0
   13e5c:	dd04      	ble.n	13e68 <__svfiscanf_r+0x22c>
   13e5e:	9b45      	ldr	r3, [sp, #276]	; 0x114
   13e60:	9301      	str	r3, [sp, #4]
   13e62:	065b      	lsls	r3, r3, #25
   13e64:	d517      	bpl.n	13e96 <__svfiscanf_r+0x25a>
   13e66:	e01f      	b.n	13ea8 <__svfiscanf_r+0x26c>
   13e68:	2286      	movs	r2, #134	; 0x86
   13e6a:	ab02      	add	r3, sp, #8
   13e6c:	0052      	lsls	r2, r2, #1
   13e6e:	189b      	adds	r3, r3, r2
   13e70:	599b      	ldr	r3, [r3, r6]
   13e72:	0029      	movs	r1, r5
   13e74:	9800      	ldr	r0, [sp, #0]
   13e76:	9301      	str	r3, [sp, #4]
   13e78:	4798      	blx	r3
   13e7a:	2800      	cmp	r0, #0
   13e7c:	d0ef      	beq.n	13e5e <__svfiscanf_r+0x222>
   13e7e:	e79f      	b.n	13dc0 <__svfiscanf_r+0x184>
   13e80:	9a49      	ldr	r2, [sp, #292]	; 0x124
   13e82:	9201      	str	r2, [sp, #4]
   13e84:	3201      	adds	r2, #1
   13e86:	9249      	str	r2, [sp, #292]	; 0x124
   13e88:	686a      	ldr	r2, [r5, #4]
   13e8a:	3a01      	subs	r2, #1
   13e8c:	606a      	str	r2, [r5, #4]
   13e8e:	2a00      	cmp	r2, #0
   13e90:	dd14      	ble.n	13ebc <__svfiscanf_r+0x280>
   13e92:	3301      	adds	r3, #1
   13e94:	602b      	str	r3, [r5, #0]
   13e96:	682b      	ldr	r3, [r5, #0]
   13e98:	4924      	ldr	r1, [pc, #144]	; (13f2c <__svfiscanf_r+0x2f0>)
   13e9a:	781a      	ldrb	r2, [r3, #0]
   13e9c:	6809      	ldr	r1, [r1, #0]
   13e9e:	188a      	adds	r2, r1, r2
   13ea0:	2108      	movs	r1, #8
   13ea2:	7852      	ldrb	r2, [r2, #1]
   13ea4:	420a      	tst	r2, r1
   13ea6:	d1eb      	bne.n	13e80 <__svfiscanf_r+0x244>
   13ea8:	9b4b      	ldr	r3, [sp, #300]	; 0x12c
   13eaa:	2b02      	cmp	r3, #2
   13eac:	dc12      	bgt.n	13ed4 <__svfiscanf_r+0x298>
   13eae:	ab03      	add	r3, sp, #12
   13eb0:	002a      	movs	r2, r5
   13eb2:	a945      	add	r1, sp, #276	; 0x114
   13eb4:	9800      	ldr	r0, [sp, #0]
   13eb6:	f000 f867 	bl	13f88 <_scanf_chars>
   13eba:	e01e      	b.n	13efa <__svfiscanf_r+0x2be>
   13ebc:	2286      	movs	r2, #134	; 0x86
   13ebe:	ab02      	add	r3, sp, #8
   13ec0:	0052      	lsls	r2, r2, #1
   13ec2:	189b      	adds	r3, r3, r2
   13ec4:	599b      	ldr	r3, [r3, r6]
   13ec6:	0029      	movs	r1, r5
   13ec8:	9800      	ldr	r0, [sp, #0]
   13eca:	9301      	str	r3, [sp, #4]
   13ecc:	4798      	blx	r3
   13ece:	2800      	cmp	r0, #0
   13ed0:	d0e1      	beq.n	13e96 <__svfiscanf_r+0x25a>
   13ed2:	e775      	b.n	13dc0 <__svfiscanf_r+0x184>
   13ed4:	2b04      	cmp	r3, #4
   13ed6:	dc06      	bgt.n	13ee6 <__svfiscanf_r+0x2aa>
   13ed8:	ab03      	add	r3, sp, #12
   13eda:	002a      	movs	r2, r5
   13edc:	a945      	add	r1, sp, #276	; 0x114
   13ede:	9800      	ldr	r0, [sp, #0]
   13ee0:	f000 f8b4 	bl	1404c <_scanf_i>
   13ee4:	e009      	b.n	13efa <__svfiscanf_r+0x2be>
   13ee6:	4b13      	ldr	r3, [pc, #76]	; (13f34 <__svfiscanf_r+0x2f8>)
   13ee8:	2b00      	cmp	r3, #0
   13eea:	d100      	bne.n	13eee <__svfiscanf_r+0x2b2>
   13eec:	e6ee      	b.n	13ccc <__svfiscanf_r+0x90>
   13eee:	ab03      	add	r3, sp, #12
   13ef0:	002a      	movs	r2, r5
   13ef2:	a945      	add	r1, sp, #276	; 0x114
   13ef4:	9800      	ldr	r0, [sp, #0]
   13ef6:	e000      	b.n	13efa <__svfiscanf_r+0x2be>
   13ef8:	bf00      	nop
   13efa:	2801      	cmp	r0, #1
   13efc:	d007      	beq.n	13f0e <__svfiscanf_r+0x2d2>
   13efe:	2802      	cmp	r0, #2
   13f00:	d000      	beq.n	13f04 <__svfiscanf_r+0x2c8>
   13f02:	e6e3      	b.n	13ccc <__svfiscanf_r+0x90>
   13f04:	e75c      	b.n	13dc0 <__svfiscanf_r+0x184>
   13f06:	89ab      	ldrh	r3, [r5, #12]
   13f08:	065b      	lsls	r3, r3, #25
   13f0a:	d504      	bpl.n	13f16 <__svfiscanf_r+0x2da>
   13f0c:	e001      	b.n	13f12 <__svfiscanf_r+0x2d6>
   13f0e:	9848      	ldr	r0, [sp, #288]	; 0x120
   13f10:	e001      	b.n	13f16 <__svfiscanf_r+0x2da>
   13f12:	2001      	movs	r0, #1
   13f14:	4240      	negs	r0, r0
   13f16:	23a7      	movs	r3, #167	; 0xa7
   13f18:	009b      	lsls	r3, r3, #2
   13f1a:	449d      	add	sp, r3
   13f1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13f1e:	46c0      	nop			; (mov r8, r8)
   13f20:	fffffd64 	.word	0xfffffd64
   13f24:	00014729 	.word	0x00014729
   13f28:	000142f9 	.word	0x000142f9
   13f2c:	200001e4 	.word	0x200001e4
   13f30:	00015ac2 	.word	0x00015ac2
   13f34:	00000000 	.word	0x00000000

00013f38 <_vfiscanf_r>:
   13f38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13f3a:	0004      	movs	r4, r0
   13f3c:	000d      	movs	r5, r1
   13f3e:	0016      	movs	r6, r2
   13f40:	001f      	movs	r7, r3
   13f42:	2800      	cmp	r0, #0
   13f44:	d004      	beq.n	13f50 <_vfiscanf_r+0x18>
   13f46:	6983      	ldr	r3, [r0, #24]
   13f48:	2b00      	cmp	r3, #0
   13f4a:	d101      	bne.n	13f50 <_vfiscanf_r+0x18>
   13f4c:	f7ff f91a 	bl	13184 <__sinit>
   13f50:	4b0a      	ldr	r3, [pc, #40]	; (13f7c <_vfiscanf_r+0x44>)
   13f52:	429d      	cmp	r5, r3
   13f54:	d101      	bne.n	13f5a <_vfiscanf_r+0x22>
   13f56:	6865      	ldr	r5, [r4, #4]
   13f58:	e008      	b.n	13f6c <_vfiscanf_r+0x34>
   13f5a:	4b09      	ldr	r3, [pc, #36]	; (13f80 <_vfiscanf_r+0x48>)
   13f5c:	429d      	cmp	r5, r3
   13f5e:	d101      	bne.n	13f64 <_vfiscanf_r+0x2c>
   13f60:	68a5      	ldr	r5, [r4, #8]
   13f62:	e003      	b.n	13f6c <_vfiscanf_r+0x34>
   13f64:	4b07      	ldr	r3, [pc, #28]	; (13f84 <_vfiscanf_r+0x4c>)
   13f66:	429d      	cmp	r5, r3
   13f68:	d100      	bne.n	13f6c <_vfiscanf_r+0x34>
   13f6a:	68e5      	ldr	r5, [r4, #12]
   13f6c:	003b      	movs	r3, r7
   13f6e:	0032      	movs	r2, r6
   13f70:	0029      	movs	r1, r5
   13f72:	0020      	movs	r0, r4
   13f74:	f7ff fe62 	bl	13c3c <__svfiscanf_r>
   13f78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   13f7a:	46c0      	nop			; (mov r8, r8)
   13f7c:	00015a5c 	.word	0x00015a5c
   13f80:	00015a7c 	.word	0x00015a7c
   13f84:	00015a9c 	.word	0x00015a9c

00013f88 <_scanf_chars>:
   13f88:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   13f8a:	0015      	movs	r5, r2
   13f8c:	688a      	ldr	r2, [r1, #8]
   13f8e:	9001      	str	r0, [sp, #4]
   13f90:	000c      	movs	r4, r1
   13f92:	2a00      	cmp	r2, #0
   13f94:	d106      	bne.n	13fa4 <_scanf_chars+0x1c>
   13f96:	698a      	ldr	r2, [r1, #24]
   13f98:	1e51      	subs	r1, r2, #1
   13f9a:	418a      	sbcs	r2, r1
   13f9c:	2101      	movs	r1, #1
   13f9e:	4252      	negs	r2, r2
   13fa0:	430a      	orrs	r2, r1
   13fa2:	60a2      	str	r2, [r4, #8]
   13fa4:	6822      	ldr	r2, [r4, #0]
   13fa6:	06d2      	lsls	r2, r2, #27
   13fa8:	d403      	bmi.n	13fb2 <_scanf_chars+0x2a>
   13faa:	681a      	ldr	r2, [r3, #0]
   13fac:	1d11      	adds	r1, r2, #4
   13fae:	6019      	str	r1, [r3, #0]
   13fb0:	6817      	ldr	r7, [r2, #0]
   13fb2:	2600      	movs	r6, #0
   13fb4:	69a0      	ldr	r0, [r4, #24]
   13fb6:	2800      	cmp	r0, #0
   13fb8:	d11e      	bne.n	13ff8 <_scanf_chars+0x70>
   13fba:	2210      	movs	r2, #16
   13fbc:	6823      	ldr	r3, [r4, #0]
   13fbe:	3601      	adds	r6, #1
   13fc0:	4213      	tst	r3, r2
   13fc2:	d103      	bne.n	13fcc <_scanf_chars+0x44>
   13fc4:	682b      	ldr	r3, [r5, #0]
   13fc6:	781b      	ldrb	r3, [r3, #0]
   13fc8:	703b      	strb	r3, [r7, #0]
   13fca:	3701      	adds	r7, #1
   13fcc:	682a      	ldr	r2, [r5, #0]
   13fce:	686b      	ldr	r3, [r5, #4]
   13fd0:	3201      	adds	r2, #1
   13fd2:	602a      	str	r2, [r5, #0]
   13fd4:	68a2      	ldr	r2, [r4, #8]
   13fd6:	3b01      	subs	r3, #1
   13fd8:	3a01      	subs	r2, #1
   13fda:	606b      	str	r3, [r5, #4]
   13fdc:	60a2      	str	r2, [r4, #8]
   13fde:	2a00      	cmp	r2, #0
   13fe0:	d01e      	beq.n	14020 <_scanf_chars+0x98>
   13fe2:	2b00      	cmp	r3, #0
   13fe4:	dce6      	bgt.n	13fb4 <_scanf_chars+0x2c>
   13fe6:	23c0      	movs	r3, #192	; 0xc0
   13fe8:	005b      	lsls	r3, r3, #1
   13fea:	58e3      	ldr	r3, [r4, r3]
   13fec:	0029      	movs	r1, r5
   13fee:	9801      	ldr	r0, [sp, #4]
   13ff0:	4798      	blx	r3
   13ff2:	2800      	cmp	r0, #0
   13ff4:	d0de      	beq.n	13fb4 <_scanf_chars+0x2c>
   13ff6:	e013      	b.n	14020 <_scanf_chars+0x98>
   13ff8:	2801      	cmp	r0, #1
   13ffa:	d106      	bne.n	1400a <_scanf_chars+0x82>
   13ffc:	682b      	ldr	r3, [r5, #0]
   13ffe:	6962      	ldr	r2, [r4, #20]
   14000:	781b      	ldrb	r3, [r3, #0]
   14002:	5cd3      	ldrb	r3, [r2, r3]
   14004:	2b00      	cmp	r3, #0
   14006:	d1d8      	bne.n	13fba <_scanf_chars+0x32>
   14008:	e01a      	b.n	14040 <_scanf_chars+0xb8>
   1400a:	2802      	cmp	r0, #2
   1400c:	d108      	bne.n	14020 <_scanf_chars+0x98>
   1400e:	682b      	ldr	r3, [r5, #0]
   14010:	4a0d      	ldr	r2, [pc, #52]	; (14048 <_scanf_chars+0xc0>)
   14012:	781b      	ldrb	r3, [r3, #0]
   14014:	6812      	ldr	r2, [r2, #0]
   14016:	18d3      	adds	r3, r2, r3
   14018:	2208      	movs	r2, #8
   1401a:	785b      	ldrb	r3, [r3, #1]
   1401c:	4213      	tst	r3, r2
   1401e:	d0cc      	beq.n	13fba <_scanf_chars+0x32>
   14020:	2310      	movs	r3, #16
   14022:	6822      	ldr	r2, [r4, #0]
   14024:	4013      	ands	r3, r2
   14026:	d106      	bne.n	14036 <_scanf_chars+0xae>
   14028:	68e2      	ldr	r2, [r4, #12]
   1402a:	3201      	adds	r2, #1
   1402c:	60e2      	str	r2, [r4, #12]
   1402e:	69a2      	ldr	r2, [r4, #24]
   14030:	2a00      	cmp	r2, #0
   14032:	d000      	beq.n	14036 <_scanf_chars+0xae>
   14034:	703b      	strb	r3, [r7, #0]
   14036:	6923      	ldr	r3, [r4, #16]
   14038:	2000      	movs	r0, #0
   1403a:	199e      	adds	r6, r3, r6
   1403c:	6126      	str	r6, [r4, #16]
   1403e:	e001      	b.n	14044 <_scanf_chars+0xbc>
   14040:	2e00      	cmp	r6, #0
   14042:	d1ed      	bne.n	14020 <_scanf_chars+0x98>
   14044:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   14046:	46c0      	nop			; (mov r8, r8)
   14048:	200001e4 	.word	0x200001e4

0001404c <_scanf_i>:
   1404c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1404e:	000c      	movs	r4, r1
   14050:	b08d      	sub	sp, #52	; 0x34
   14052:	9302      	str	r3, [sp, #8]
   14054:	4b77      	ldr	r3, [pc, #476]	; (14234 <_scanf_i+0x1e8>)
   14056:	9005      	str	r0, [sp, #20]
   14058:	0016      	movs	r6, r2
   1405a:	aa09      	add	r2, sp, #36	; 0x24
   1405c:	cb23      	ldmia	r3!, {r0, r1, r5}
   1405e:	c223      	stmia	r2!, {r0, r1, r5}
   14060:	4b75      	ldr	r3, [pc, #468]	; (14238 <_scanf_i+0x1ec>)
   14062:	9306      	str	r3, [sp, #24]
   14064:	69a3      	ldr	r3, [r4, #24]
   14066:	2b03      	cmp	r3, #3
   14068:	d001      	beq.n	1406e <_scanf_i+0x22>
   1406a:	4b74      	ldr	r3, [pc, #464]	; (1423c <_scanf_i+0x1f0>)
   1406c:	9306      	str	r3, [sp, #24]
   1406e:	2200      	movs	r2, #0
   14070:	68a3      	ldr	r3, [r4, #8]
   14072:	9204      	str	r2, [sp, #16]
   14074:	325d      	adds	r2, #93	; 0x5d
   14076:	1e59      	subs	r1, r3, #1
   14078:	32ff      	adds	r2, #255	; 0xff
   1407a:	4291      	cmp	r1, r2
   1407c:	d905      	bls.n	1408a <_scanf_i+0x3e>
   1407e:	3b5e      	subs	r3, #94	; 0x5e
   14080:	3bff      	subs	r3, #255	; 0xff
   14082:	9304      	str	r3, [sp, #16]
   14084:	235e      	movs	r3, #94	; 0x5e
   14086:	33ff      	adds	r3, #255	; 0xff
   14088:	60a3      	str	r3, [r4, #8]
   1408a:	0023      	movs	r3, r4
   1408c:	331c      	adds	r3, #28
   1408e:	9301      	str	r3, [sp, #4]
   14090:	23d0      	movs	r3, #208	; 0xd0
   14092:	2700      	movs	r7, #0
   14094:	6822      	ldr	r2, [r4, #0]
   14096:	011b      	lsls	r3, r3, #4
   14098:	4313      	orrs	r3, r2
   1409a:	6023      	str	r3, [r4, #0]
   1409c:	9b01      	ldr	r3, [sp, #4]
   1409e:	9303      	str	r3, [sp, #12]
   140a0:	6833      	ldr	r3, [r6, #0]
   140a2:	a809      	add	r0, sp, #36	; 0x24
   140a4:	7819      	ldrb	r1, [r3, #0]
   140a6:	00bb      	lsls	r3, r7, #2
   140a8:	2202      	movs	r2, #2
   140aa:	5818      	ldr	r0, [r3, r0]
   140ac:	f000 fbd2 	bl	14854 <memchr>
   140b0:	2800      	cmp	r0, #0
   140b2:	d03b      	beq.n	1412c <_scanf_i+0xe0>
   140b4:	2f01      	cmp	r7, #1
   140b6:	d10d      	bne.n	140d4 <_scanf_i+0x88>
   140b8:	6863      	ldr	r3, [r4, #4]
   140ba:	2b00      	cmp	r3, #0
   140bc:	d106      	bne.n	140cc <_scanf_i+0x80>
   140be:	3308      	adds	r3, #8
   140c0:	6822      	ldr	r2, [r4, #0]
   140c2:	6063      	str	r3, [r4, #4]
   140c4:	33f9      	adds	r3, #249	; 0xf9
   140c6:	33ff      	adds	r3, #255	; 0xff
   140c8:	4313      	orrs	r3, r2
   140ca:	6023      	str	r3, [r4, #0]
   140cc:	4b5c      	ldr	r3, [pc, #368]	; (14240 <_scanf_i+0x1f4>)
   140ce:	6822      	ldr	r2, [r4, #0]
   140d0:	4013      	ands	r3, r2
   140d2:	e00e      	b.n	140f2 <_scanf_i+0xa6>
   140d4:	2f02      	cmp	r7, #2
   140d6:	d10d      	bne.n	140f4 <_scanf_i+0xa8>
   140d8:	21c0      	movs	r1, #192	; 0xc0
   140da:	2280      	movs	r2, #128	; 0x80
   140dc:	6823      	ldr	r3, [r4, #0]
   140de:	00c9      	lsls	r1, r1, #3
   140e0:	4019      	ands	r1, r3
   140e2:	0092      	lsls	r2, r2, #2
   140e4:	4291      	cmp	r1, r2
   140e6:	d124      	bne.n	14132 <_scanf_i+0xe6>
   140e8:	3af1      	subs	r2, #241	; 0xf1
   140ea:	3aff      	subs	r2, #255	; 0xff
   140ec:	6062      	str	r2, [r4, #4]
   140ee:	32f0      	adds	r2, #240	; 0xf0
   140f0:	4313      	orrs	r3, r2
   140f2:	6023      	str	r3, [r4, #0]
   140f4:	68a3      	ldr	r3, [r4, #8]
   140f6:	1e5a      	subs	r2, r3, #1
   140f8:	60a2      	str	r2, [r4, #8]
   140fa:	2b00      	cmp	r3, #0
   140fc:	d016      	beq.n	1412c <_scanf_i+0xe0>
   140fe:	9b03      	ldr	r3, [sp, #12]
   14100:	1c5d      	adds	r5, r3, #1
   14102:	6833      	ldr	r3, [r6, #0]
   14104:	1c5a      	adds	r2, r3, #1
   14106:	6032      	str	r2, [r6, #0]
   14108:	781b      	ldrb	r3, [r3, #0]
   1410a:	9a03      	ldr	r2, [sp, #12]
   1410c:	9503      	str	r5, [sp, #12]
   1410e:	7013      	strb	r3, [r2, #0]
   14110:	6873      	ldr	r3, [r6, #4]
   14112:	3b01      	subs	r3, #1
   14114:	6073      	str	r3, [r6, #4]
   14116:	2b00      	cmp	r3, #0
   14118:	dc08      	bgt.n	1412c <_scanf_i+0xe0>
   1411a:	23c0      	movs	r3, #192	; 0xc0
   1411c:	005b      	lsls	r3, r3, #1
   1411e:	58e3      	ldr	r3, [r4, r3]
   14120:	0031      	movs	r1, r6
   14122:	9805      	ldr	r0, [sp, #20]
   14124:	9307      	str	r3, [sp, #28]
   14126:	4798      	blx	r3
   14128:	2800      	cmp	r0, #0
   1412a:	d147      	bne.n	141bc <_scanf_i+0x170>
   1412c:	3701      	adds	r7, #1
   1412e:	2f03      	cmp	r7, #3
   14130:	d1b6      	bne.n	140a0 <_scanf_i+0x54>
   14132:	6863      	ldr	r3, [r4, #4]
   14134:	2b00      	cmp	r3, #0
   14136:	d101      	bne.n	1413c <_scanf_i+0xf0>
   14138:	330a      	adds	r3, #10
   1413a:	6063      	str	r3, [r4, #4]
   1413c:	2110      	movs	r1, #16
   1413e:	2700      	movs	r7, #0
   14140:	6863      	ldr	r3, [r4, #4]
   14142:	6960      	ldr	r0, [r4, #20]
   14144:	1ac9      	subs	r1, r1, r3
   14146:	4b3f      	ldr	r3, [pc, #252]	; (14244 <_scanf_i+0x1f8>)
   14148:	18c9      	adds	r1, r1, r3
   1414a:	f000 f967 	bl	1441c <__sccl>
   1414e:	9d03      	ldr	r5, [sp, #12]
   14150:	68a3      	ldr	r3, [r4, #8]
   14152:	2b00      	cmp	r3, #0
   14154:	d033      	beq.n	141be <_scanf_i+0x172>
   14156:	6832      	ldr	r2, [r6, #0]
   14158:	6960      	ldr	r0, [r4, #20]
   1415a:	7811      	ldrb	r1, [r2, #0]
   1415c:	5c40      	ldrb	r0, [r0, r1]
   1415e:	2800      	cmp	r0, #0
   14160:	d02d      	beq.n	141be <_scanf_i+0x172>
   14162:	2930      	cmp	r1, #48	; 0x30
   14164:	d10d      	bne.n	14182 <_scanf_i+0x136>
   14166:	2080      	movs	r0, #128	; 0x80
   14168:	6821      	ldr	r1, [r4, #0]
   1416a:	0100      	lsls	r0, r0, #4
   1416c:	4201      	tst	r1, r0
   1416e:	d008      	beq.n	14182 <_scanf_i+0x136>
   14170:	9a04      	ldr	r2, [sp, #16]
   14172:	3701      	adds	r7, #1
   14174:	2a00      	cmp	r2, #0
   14176:	d00b      	beq.n	14190 <_scanf_i+0x144>
   14178:	3a01      	subs	r2, #1
   1417a:	3301      	adds	r3, #1
   1417c:	9204      	str	r2, [sp, #16]
   1417e:	60a3      	str	r3, [r4, #8]
   14180:	e006      	b.n	14190 <_scanf_i+0x144>
   14182:	6821      	ldr	r1, [r4, #0]
   14184:	4b30      	ldr	r3, [pc, #192]	; (14248 <_scanf_i+0x1fc>)
   14186:	400b      	ands	r3, r1
   14188:	6023      	str	r3, [r4, #0]
   1418a:	7813      	ldrb	r3, [r2, #0]
   1418c:	702b      	strb	r3, [r5, #0]
   1418e:	3501      	adds	r5, #1
   14190:	6873      	ldr	r3, [r6, #4]
   14192:	3b01      	subs	r3, #1
   14194:	6073      	str	r3, [r6, #4]
   14196:	2b00      	cmp	r3, #0
   14198:	dd03      	ble.n	141a2 <_scanf_i+0x156>
   1419a:	6833      	ldr	r3, [r6, #0]
   1419c:	3301      	adds	r3, #1
   1419e:	6033      	str	r3, [r6, #0]
   141a0:	e008      	b.n	141b4 <_scanf_i+0x168>
   141a2:	23c0      	movs	r3, #192	; 0xc0
   141a4:	005b      	lsls	r3, r3, #1
   141a6:	58e3      	ldr	r3, [r4, r3]
   141a8:	0031      	movs	r1, r6
   141aa:	9805      	ldr	r0, [sp, #20]
   141ac:	9303      	str	r3, [sp, #12]
   141ae:	4798      	blx	r3
   141b0:	2800      	cmp	r0, #0
   141b2:	d104      	bne.n	141be <_scanf_i+0x172>
   141b4:	68a3      	ldr	r3, [r4, #8]
   141b6:	3b01      	subs	r3, #1
   141b8:	60a3      	str	r3, [r4, #8]
   141ba:	e7c9      	b.n	14150 <_scanf_i+0x104>
   141bc:	2700      	movs	r7, #0
   141be:	6823      	ldr	r3, [r4, #0]
   141c0:	05db      	lsls	r3, r3, #23
   141c2:	d50e      	bpl.n	141e2 <_scanf_i+0x196>
   141c4:	9b01      	ldr	r3, [sp, #4]
   141c6:	429d      	cmp	r5, r3
   141c8:	d907      	bls.n	141da <_scanf_i+0x18e>
   141ca:	23be      	movs	r3, #190	; 0xbe
   141cc:	3d01      	subs	r5, #1
   141ce:	005b      	lsls	r3, r3, #1
   141d0:	7829      	ldrb	r1, [r5, #0]
   141d2:	58e3      	ldr	r3, [r4, r3]
   141d4:	0032      	movs	r2, r6
   141d6:	9805      	ldr	r0, [sp, #20]
   141d8:	4798      	blx	r3
   141da:	9b01      	ldr	r3, [sp, #4]
   141dc:	2001      	movs	r0, #1
   141de:	429d      	cmp	r5, r3
   141e0:	d025      	beq.n	1422e <_scanf_i+0x1e2>
   141e2:	2210      	movs	r2, #16
   141e4:	6823      	ldr	r3, [r4, #0]
   141e6:	401a      	ands	r2, r3
   141e8:	d11a      	bne.n	14220 <_scanf_i+0x1d4>
   141ea:	702a      	strb	r2, [r5, #0]
   141ec:	6863      	ldr	r3, [r4, #4]
   141ee:	9901      	ldr	r1, [sp, #4]
   141f0:	9805      	ldr	r0, [sp, #20]
   141f2:	9e06      	ldr	r6, [sp, #24]
   141f4:	47b0      	blx	r6
   141f6:	9b02      	ldr	r3, [sp, #8]
   141f8:	6822      	ldr	r2, [r4, #0]
   141fa:	681b      	ldr	r3, [r3, #0]
   141fc:	0691      	lsls	r1, r2, #26
   141fe:	d407      	bmi.n	14210 <_scanf_i+0x1c4>
   14200:	07d1      	lsls	r1, r2, #31
   14202:	d505      	bpl.n	14210 <_scanf_i+0x1c4>
   14204:	9902      	ldr	r1, [sp, #8]
   14206:	1d1a      	adds	r2, r3, #4
   14208:	600a      	str	r2, [r1, #0]
   1420a:	681b      	ldr	r3, [r3, #0]
   1420c:	8018      	strh	r0, [r3, #0]
   1420e:	e004      	b.n	1421a <_scanf_i+0x1ce>
   14210:	9902      	ldr	r1, [sp, #8]
   14212:	1d1a      	adds	r2, r3, #4
   14214:	600a      	str	r2, [r1, #0]
   14216:	681b      	ldr	r3, [r3, #0]
   14218:	6018      	str	r0, [r3, #0]
   1421a:	68e3      	ldr	r3, [r4, #12]
   1421c:	3301      	adds	r3, #1
   1421e:	60e3      	str	r3, [r4, #12]
   14220:	2000      	movs	r0, #0
   14222:	9b01      	ldr	r3, [sp, #4]
   14224:	1aed      	subs	r5, r5, r3
   14226:	6923      	ldr	r3, [r4, #16]
   14228:	19ed      	adds	r5, r5, r7
   1422a:	195d      	adds	r5, r3, r5
   1422c:	6125      	str	r5, [r4, #16]
   1422e:	b00d      	add	sp, #52	; 0x34
   14230:	bdf0      	pop	{r4, r5, r6, r7, pc}
   14232:	46c0      	nop			; (mov r8, r8)
   14234:	00015af0 	.word	0x00015af0
   14238:	00014481 	.word	0x00014481
   1423c:	000145a5 	.word	0x000145a5
   14240:	fffffaff 	.word	0xfffffaff
   14244:	00015afc 	.word	0x00015afc
   14248:	fffff6ff 	.word	0xfffff6ff

0001424c <_putc_r>:
   1424c:	b570      	push	{r4, r5, r6, lr}
   1424e:	0006      	movs	r6, r0
   14250:	000d      	movs	r5, r1
   14252:	0014      	movs	r4, r2
   14254:	2800      	cmp	r0, #0
   14256:	d004      	beq.n	14262 <_putc_r+0x16>
   14258:	6983      	ldr	r3, [r0, #24]
   1425a:	2b00      	cmp	r3, #0
   1425c:	d101      	bne.n	14262 <_putc_r+0x16>
   1425e:	f7fe ff91 	bl	13184 <__sinit>
   14262:	4b12      	ldr	r3, [pc, #72]	; (142ac <_putc_r+0x60>)
   14264:	429c      	cmp	r4, r3
   14266:	d101      	bne.n	1426c <_putc_r+0x20>
   14268:	6874      	ldr	r4, [r6, #4]
   1426a:	e008      	b.n	1427e <_putc_r+0x32>
   1426c:	4b10      	ldr	r3, [pc, #64]	; (142b0 <_putc_r+0x64>)
   1426e:	429c      	cmp	r4, r3
   14270:	d101      	bne.n	14276 <_putc_r+0x2a>
   14272:	68b4      	ldr	r4, [r6, #8]
   14274:	e003      	b.n	1427e <_putc_r+0x32>
   14276:	4b0f      	ldr	r3, [pc, #60]	; (142b4 <_putc_r+0x68>)
   14278:	429c      	cmp	r4, r3
   1427a:	d100      	bne.n	1427e <_putc_r+0x32>
   1427c:	68f4      	ldr	r4, [r6, #12]
   1427e:	68a3      	ldr	r3, [r4, #8]
   14280:	3b01      	subs	r3, #1
   14282:	60a3      	str	r3, [r4, #8]
   14284:	2b00      	cmp	r3, #0
   14286:	da05      	bge.n	14294 <_putc_r+0x48>
   14288:	69a2      	ldr	r2, [r4, #24]
   1428a:	4293      	cmp	r3, r2
   1428c:	db08      	blt.n	142a0 <_putc_r+0x54>
   1428e:	b2eb      	uxtb	r3, r5
   14290:	2b0a      	cmp	r3, #10
   14292:	d005      	beq.n	142a0 <_putc_r+0x54>
   14294:	6823      	ldr	r3, [r4, #0]
   14296:	b2e8      	uxtb	r0, r5
   14298:	1c5a      	adds	r2, r3, #1
   1429a:	6022      	str	r2, [r4, #0]
   1429c:	701d      	strb	r5, [r3, #0]
   1429e:	e004      	b.n	142aa <_putc_r+0x5e>
   142a0:	0022      	movs	r2, r4
   142a2:	0029      	movs	r1, r5
   142a4:	0030      	movs	r0, r6
   142a6:	f7fe fd71 	bl	12d8c <__swbuf_r>
   142aa:	bd70      	pop	{r4, r5, r6, pc}
   142ac:	00015a5c 	.word	0x00015a5c
   142b0:	00015a7c 	.word	0x00015a7c
   142b4:	00015a9c 	.word	0x00015a9c

000142b8 <_read_r>:
   142b8:	b570      	push	{r4, r5, r6, lr}
   142ba:	0005      	movs	r5, r0
   142bc:	0008      	movs	r0, r1
   142be:	0011      	movs	r1, r2
   142c0:	2200      	movs	r2, #0
   142c2:	4c06      	ldr	r4, [pc, #24]	; (142dc <_read_r+0x24>)
   142c4:	6022      	str	r2, [r4, #0]
   142c6:	001a      	movs	r2, r3
   142c8:	f7f1 fb5e 	bl	5988 <_read>
   142cc:	1c43      	adds	r3, r0, #1
   142ce:	d103      	bne.n	142d8 <_read_r+0x20>
   142d0:	6823      	ldr	r3, [r4, #0]
   142d2:	2b00      	cmp	r3, #0
   142d4:	d000      	beq.n	142d8 <_read_r+0x20>
   142d6:	602b      	str	r3, [r5, #0]
   142d8:	bd70      	pop	{r4, r5, r6, pc}
   142da:	46c0      	nop			; (mov r8, r8)
   142dc:	20001880 	.word	0x20001880

000142e0 <lflush>:
   142e0:	2309      	movs	r3, #9
   142e2:	b510      	push	{r4, lr}
   142e4:	8982      	ldrh	r2, [r0, #12]
   142e6:	4013      	ands	r3, r2
   142e8:	2200      	movs	r2, #0
   142ea:	2b09      	cmp	r3, #9
   142ec:	d102      	bne.n	142f4 <lflush+0x14>
   142ee:	f7fe fef3 	bl	130d8 <fflush>
   142f2:	0002      	movs	r2, r0
   142f4:	0010      	movs	r0, r2
   142f6:	bd10      	pop	{r4, pc}

000142f8 <__srefill_r>:
   142f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   142fa:	0005      	movs	r5, r0
   142fc:	000c      	movs	r4, r1
   142fe:	2800      	cmp	r0, #0
   14300:	d004      	beq.n	1430c <__srefill_r+0x14>
   14302:	6983      	ldr	r3, [r0, #24]
   14304:	2b00      	cmp	r3, #0
   14306:	d101      	bne.n	1430c <__srefill_r+0x14>
   14308:	f7fe ff3c 	bl	13184 <__sinit>
   1430c:	4b3e      	ldr	r3, [pc, #248]	; (14408 <__srefill_r+0x110>)
   1430e:	429c      	cmp	r4, r3
   14310:	d101      	bne.n	14316 <__srefill_r+0x1e>
   14312:	686c      	ldr	r4, [r5, #4]
   14314:	e008      	b.n	14328 <__srefill_r+0x30>
   14316:	4b3d      	ldr	r3, [pc, #244]	; (1440c <__srefill_r+0x114>)
   14318:	429c      	cmp	r4, r3
   1431a:	d101      	bne.n	14320 <__srefill_r+0x28>
   1431c:	68ac      	ldr	r4, [r5, #8]
   1431e:	e003      	b.n	14328 <__srefill_r+0x30>
   14320:	4b3b      	ldr	r3, [pc, #236]	; (14410 <__srefill_r+0x118>)
   14322:	429c      	cmp	r4, r3
   14324:	d100      	bne.n	14328 <__srefill_r+0x30>
   14326:	68ec      	ldr	r4, [r5, #12]
   14328:	2300      	movs	r3, #0
   1432a:	6063      	str	r3, [r4, #4]
   1432c:	230c      	movs	r3, #12
   1432e:	5ee2      	ldrsh	r2, [r4, r3]
   14330:	b293      	uxth	r3, r2
   14332:	0699      	lsls	r1, r3, #26
   14334:	d464      	bmi.n	14400 <__srefill_r+0x108>
   14336:	0759      	lsls	r1, r3, #29
   14338:	d41a      	bmi.n	14370 <__srefill_r+0x78>
   1433a:	06d9      	lsls	r1, r3, #27
   1433c:	d405      	bmi.n	1434a <__srefill_r+0x52>
   1433e:	2309      	movs	r3, #9
   14340:	602b      	str	r3, [r5, #0]
   14342:	3337      	adds	r3, #55	; 0x37
   14344:	431a      	orrs	r2, r3
   14346:	81a2      	strh	r2, [r4, #12]
   14348:	e05a      	b.n	14400 <__srefill_r+0x108>
   1434a:	2608      	movs	r6, #8
   1434c:	4233      	tst	r3, r6
   1434e:	d00a      	beq.n	14366 <__srefill_r+0x6e>
   14350:	0021      	movs	r1, r4
   14352:	0028      	movs	r0, r5
   14354:	f7fe fe94 	bl	13080 <_fflush_r>
   14358:	2800      	cmp	r0, #0
   1435a:	d151      	bne.n	14400 <__srefill_r+0x108>
   1435c:	89a3      	ldrh	r3, [r4, #12]
   1435e:	60a0      	str	r0, [r4, #8]
   14360:	43b3      	bics	r3, r6
   14362:	81a3      	strh	r3, [r4, #12]
   14364:	61a0      	str	r0, [r4, #24]
   14366:	2204      	movs	r2, #4
   14368:	89a3      	ldrh	r3, [r4, #12]
   1436a:	4313      	orrs	r3, r2
   1436c:	81a3      	strh	r3, [r4, #12]
   1436e:	e012      	b.n	14396 <__srefill_r+0x9e>
   14370:	6b61      	ldr	r1, [r4, #52]	; 0x34
   14372:	2900      	cmp	r1, #0
   14374:	d00f      	beq.n	14396 <__srefill_r+0x9e>
   14376:	0023      	movs	r3, r4
   14378:	3344      	adds	r3, #68	; 0x44
   1437a:	4299      	cmp	r1, r3
   1437c:	d002      	beq.n	14384 <__srefill_r+0x8c>
   1437e:	0028      	movs	r0, r5
   14380:	f7fe fa58 	bl	12834 <_free_r>
   14384:	2000      	movs	r0, #0
   14386:	6c23      	ldr	r3, [r4, #64]	; 0x40
   14388:	6360      	str	r0, [r4, #52]	; 0x34
   1438a:	6063      	str	r3, [r4, #4]
   1438c:	4283      	cmp	r3, r0
   1438e:	d002      	beq.n	14396 <__srefill_r+0x9e>
   14390:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   14392:	6023      	str	r3, [r4, #0]
   14394:	e036      	b.n	14404 <__srefill_r+0x10c>
   14396:	6923      	ldr	r3, [r4, #16]
   14398:	2b00      	cmp	r3, #0
   1439a:	d103      	bne.n	143a4 <__srefill_r+0xac>
   1439c:	0021      	movs	r1, r4
   1439e:	0028      	movs	r0, r5
   143a0:	f7fe ffda 	bl	13358 <__smakebuf_r>
   143a4:	230c      	movs	r3, #12
   143a6:	5ee7      	ldrsh	r7, [r4, r3]
   143a8:	b2be      	uxth	r6, r7
   143aa:	07b3      	lsls	r3, r6, #30
   143ac:	d00f      	beq.n	143ce <__srefill_r+0xd6>
   143ae:	2301      	movs	r3, #1
   143b0:	81a3      	strh	r3, [r4, #12]
   143b2:	4b18      	ldr	r3, [pc, #96]	; (14414 <__srefill_r+0x11c>)
   143b4:	4918      	ldr	r1, [pc, #96]	; (14418 <__srefill_r+0x120>)
   143b6:	6818      	ldr	r0, [r3, #0]
   143b8:	f7fe ff56 	bl	13268 <_fwalk>
   143bc:	2309      	movs	r3, #9
   143be:	81a7      	strh	r7, [r4, #12]
   143c0:	4033      	ands	r3, r6
   143c2:	2b09      	cmp	r3, #9
   143c4:	d103      	bne.n	143ce <__srefill_r+0xd6>
   143c6:	0021      	movs	r1, r4
   143c8:	0028      	movs	r0, r5
   143ca:	f7fe fdd3 	bl	12f74 <__sflush_r>
   143ce:	6923      	ldr	r3, [r4, #16]
   143d0:	6922      	ldr	r2, [r4, #16]
   143d2:	6023      	str	r3, [r4, #0]
   143d4:	0028      	movs	r0, r5
   143d6:	6963      	ldr	r3, [r4, #20]
   143d8:	6a21      	ldr	r1, [r4, #32]
   143da:	6a65      	ldr	r5, [r4, #36]	; 0x24
   143dc:	47a8      	blx	r5
   143de:	0002      	movs	r2, r0
   143e0:	6060      	str	r0, [r4, #4]
   143e2:	2000      	movs	r0, #0
   143e4:	4282      	cmp	r2, r0
   143e6:	dc0d      	bgt.n	14404 <__srefill_r+0x10c>
   143e8:	89a3      	ldrh	r3, [r4, #12]
   143ea:	4282      	cmp	r2, r0
   143ec:	d104      	bne.n	143f8 <__srefill_r+0x100>
   143ee:	2220      	movs	r2, #32
   143f0:	4313      	orrs	r3, r2
   143f2:	81a3      	strh	r3, [r4, #12]
   143f4:	3801      	subs	r0, #1
   143f6:	e005      	b.n	14404 <__srefill_r+0x10c>
   143f8:	2240      	movs	r2, #64	; 0x40
   143fa:	4313      	orrs	r3, r2
   143fc:	6060      	str	r0, [r4, #4]
   143fe:	81a3      	strh	r3, [r4, #12]
   14400:	2001      	movs	r0, #1
   14402:	4240      	negs	r0, r0
   14404:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   14406:	46c0      	nop			; (mov r8, r8)
   14408:	00015a5c 	.word	0x00015a5c
   1440c:	00015a7c 	.word	0x00015a7c
   14410:	00015a9c 	.word	0x00015a9c
   14414:	00015a58 	.word	0x00015a58
   14418:	000142e1 	.word	0x000142e1

0001441c <__sccl>:
   1441c:	b570      	push	{r4, r5, r6, lr}
   1441e:	780b      	ldrb	r3, [r1, #0]
   14420:	2b5e      	cmp	r3, #94	; 0x5e
   14422:	d002      	beq.n	1442a <__sccl+0xe>
   14424:	1c4a      	adds	r2, r1, #1
   14426:	2500      	movs	r5, #0
   14428:	e002      	b.n	14430 <__sccl+0x14>
   1442a:	2501      	movs	r5, #1
   1442c:	784b      	ldrb	r3, [r1, #1]
   1442e:	1c8a      	adds	r2, r1, #2
   14430:	0001      	movs	r1, r0
   14432:	1c44      	adds	r4, r0, #1
   14434:	34ff      	adds	r4, #255	; 0xff
   14436:	700d      	strb	r5, [r1, #0]
   14438:	3101      	adds	r1, #1
   1443a:	42a1      	cmp	r1, r4
   1443c:	d1fb      	bne.n	14436 <__sccl+0x1a>
   1443e:	2b00      	cmp	r3, #0
   14440:	d101      	bne.n	14446 <__sccl+0x2a>
   14442:	1e50      	subs	r0, r2, #1
   14444:	e01b      	b.n	1447e <__sccl+0x62>
   14446:	2101      	movs	r1, #1
   14448:	404d      	eors	r5, r1
   1444a:	0011      	movs	r1, r2
   1444c:	54c5      	strb	r5, [r0, r3]
   1444e:	780c      	ldrb	r4, [r1, #0]
   14450:	1c4a      	adds	r2, r1, #1
   14452:	2c2d      	cmp	r4, #45	; 0x2d
   14454:	d007      	beq.n	14466 <__sccl+0x4a>
   14456:	2c5d      	cmp	r4, #93	; 0x5d
   14458:	d010      	beq.n	1447c <__sccl+0x60>
   1445a:	2c00      	cmp	r4, #0
   1445c:	d001      	beq.n	14462 <__sccl+0x46>
   1445e:	0023      	movs	r3, r4
   14460:	e7f3      	b.n	1444a <__sccl+0x2e>
   14462:	0008      	movs	r0, r1
   14464:	e00b      	b.n	1447e <__sccl+0x62>
   14466:	784e      	ldrb	r6, [r1, #1]
   14468:	2e5d      	cmp	r6, #93	; 0x5d
   1446a:	d0f8      	beq.n	1445e <__sccl+0x42>
   1446c:	42b3      	cmp	r3, r6
   1446e:	dcf6      	bgt.n	1445e <__sccl+0x42>
   14470:	3102      	adds	r1, #2
   14472:	3301      	adds	r3, #1
   14474:	54c5      	strb	r5, [r0, r3]
   14476:	429e      	cmp	r6, r3
   14478:	dcfb      	bgt.n	14472 <__sccl+0x56>
   1447a:	e7e8      	b.n	1444e <__sccl+0x32>
   1447c:	0010      	movs	r0, r2
   1447e:	bd70      	pop	{r4, r5, r6, pc}

00014480 <_strtol_r>:
   14480:	b5f0      	push	{r4, r5, r6, r7, lr}
   14482:	001e      	movs	r6, r3
   14484:	4b45      	ldr	r3, [pc, #276]	; (1459c <_strtol_r+0x11c>)
   14486:	b087      	sub	sp, #28
   14488:	681b      	ldr	r3, [r3, #0]
   1448a:	9201      	str	r2, [sp, #4]
   1448c:	9302      	str	r3, [sp, #8]
   1448e:	2208      	movs	r2, #8
   14490:	000b      	movs	r3, r1
   14492:	9005      	str	r0, [sp, #20]
   14494:	9103      	str	r1, [sp, #12]
   14496:	781c      	ldrb	r4, [r3, #0]
   14498:	9902      	ldr	r1, [sp, #8]
   1449a:	1c5d      	adds	r5, r3, #1
   1449c:	1909      	adds	r1, r1, r4
   1449e:	7848      	ldrb	r0, [r1, #1]
   144a0:	4010      	ands	r0, r2
   144a2:	d001      	beq.n	144a8 <_strtol_r+0x28>
   144a4:	002b      	movs	r3, r5
   144a6:	e7f6      	b.n	14496 <_strtol_r+0x16>
   144a8:	2c2d      	cmp	r4, #45	; 0x2d
   144aa:	d104      	bne.n	144b6 <_strtol_r+0x36>
   144ac:	1c9d      	adds	r5, r3, #2
   144ae:	785c      	ldrb	r4, [r3, #1]
   144b0:	2301      	movs	r3, #1
   144b2:	9300      	str	r3, [sp, #0]
   144b4:	e004      	b.n	144c0 <_strtol_r+0x40>
   144b6:	9000      	str	r0, [sp, #0]
   144b8:	2c2b      	cmp	r4, #43	; 0x2b
   144ba:	d101      	bne.n	144c0 <_strtol_r+0x40>
   144bc:	785c      	ldrb	r4, [r3, #1]
   144be:	1c9d      	adds	r5, r3, #2
   144c0:	2e00      	cmp	r6, #0
   144c2:	d002      	beq.n	144ca <_strtol_r+0x4a>
   144c4:	2e10      	cmp	r6, #16
   144c6:	d10a      	bne.n	144de <_strtol_r+0x5e>
   144c8:	e062      	b.n	14590 <_strtol_r+0x110>
   144ca:	2c30      	cmp	r4, #48	; 0x30
   144cc:	d15e      	bne.n	1458c <_strtol_r+0x10c>
   144ce:	2220      	movs	r2, #32
   144d0:	782b      	ldrb	r3, [r5, #0]
   144d2:	4393      	bics	r3, r2
   144d4:	2b58      	cmp	r3, #88	; 0x58
   144d6:	d154      	bne.n	14582 <_strtol_r+0x102>
   144d8:	2610      	movs	r6, #16
   144da:	786c      	ldrb	r4, [r5, #1]
   144dc:	3502      	adds	r5, #2
   144de:	9f00      	ldr	r7, [sp, #0]
   144e0:	0031      	movs	r1, r6
   144e2:	1e7b      	subs	r3, r7, #1
   144e4:	419f      	sbcs	r7, r3
   144e6:	4b2e      	ldr	r3, [pc, #184]	; (145a0 <_strtol_r+0x120>)
   144e8:	18ff      	adds	r7, r7, r3
   144ea:	0038      	movs	r0, r7
   144ec:	f7fd feec 	bl	122c8 <__aeabi_uidivmod>
   144f0:	0038      	movs	r0, r7
   144f2:	9104      	str	r1, [sp, #16]
   144f4:	0031      	movs	r1, r6
   144f6:	f7fd fe61 	bl	121bc <__aeabi_uidiv>
   144fa:	2300      	movs	r3, #0
   144fc:	2203      	movs	r2, #3
   144fe:	0007      	movs	r7, r0
   14500:	4694      	mov	ip, r2
   14502:	0018      	movs	r0, r3
   14504:	9a02      	ldr	r2, [sp, #8]
   14506:	1912      	adds	r2, r2, r4
   14508:	7851      	ldrb	r1, [r2, #1]
   1450a:	2204      	movs	r2, #4
   1450c:	4211      	tst	r1, r2
   1450e:	d001      	beq.n	14514 <_strtol_r+0x94>
   14510:	3c30      	subs	r4, #48	; 0x30
   14512:	e007      	b.n	14524 <_strtol_r+0xa4>
   14514:	4662      	mov	r2, ip
   14516:	4011      	ands	r1, r2
   14518:	d017      	beq.n	1454a <_strtol_r+0xca>
   1451a:	2237      	movs	r2, #55	; 0x37
   1451c:	2901      	cmp	r1, #1
   1451e:	d000      	beq.n	14522 <_strtol_r+0xa2>
   14520:	3220      	adds	r2, #32
   14522:	1aa4      	subs	r4, r4, r2
   14524:	42a6      	cmp	r6, r4
   14526:	dd10      	ble.n	1454a <_strtol_r+0xca>
   14528:	1c5a      	adds	r2, r3, #1
   1452a:	d00b      	beq.n	14544 <_strtol_r+0xc4>
   1452c:	42b8      	cmp	r0, r7
   1452e:	d807      	bhi.n	14540 <_strtol_r+0xc0>
   14530:	d102      	bne.n	14538 <_strtol_r+0xb8>
   14532:	9b04      	ldr	r3, [sp, #16]
   14534:	429c      	cmp	r4, r3
   14536:	dc03      	bgt.n	14540 <_strtol_r+0xc0>
   14538:	4370      	muls	r0, r6
   1453a:	2301      	movs	r3, #1
   1453c:	1820      	adds	r0, r4, r0
   1453e:	e001      	b.n	14544 <_strtol_r+0xc4>
   14540:	2301      	movs	r3, #1
   14542:	425b      	negs	r3, r3
   14544:	782c      	ldrb	r4, [r5, #0]
   14546:	3501      	adds	r5, #1
   14548:	e7dc      	b.n	14504 <_strtol_r+0x84>
   1454a:	1c5a      	adds	r2, r3, #1
   1454c:	d10b      	bne.n	14566 <_strtol_r+0xe6>
   1454e:	9800      	ldr	r0, [sp, #0]
   14550:	9a05      	ldr	r2, [sp, #20]
   14552:	1e43      	subs	r3, r0, #1
   14554:	4198      	sbcs	r0, r3
   14556:	4b12      	ldr	r3, [pc, #72]	; (145a0 <_strtol_r+0x120>)
   14558:	18c0      	adds	r0, r0, r3
   1455a:	2322      	movs	r3, #34	; 0x22
   1455c:	6013      	str	r3, [r2, #0]
   1455e:	9b01      	ldr	r3, [sp, #4]
   14560:	2b00      	cmp	r3, #0
   14562:	d10a      	bne.n	1457a <_strtol_r+0xfa>
   14564:	e017      	b.n	14596 <_strtol_r+0x116>
   14566:	9a00      	ldr	r2, [sp, #0]
   14568:	2a00      	cmp	r2, #0
   1456a:	d000      	beq.n	1456e <_strtol_r+0xee>
   1456c:	4240      	negs	r0, r0
   1456e:	9a01      	ldr	r2, [sp, #4]
   14570:	2a00      	cmp	r2, #0
   14572:	d010      	beq.n	14596 <_strtol_r+0x116>
   14574:	9a03      	ldr	r2, [sp, #12]
   14576:	2b00      	cmp	r3, #0
   14578:	d000      	beq.n	1457c <_strtol_r+0xfc>
   1457a:	1e6a      	subs	r2, r5, #1
   1457c:	9b01      	ldr	r3, [sp, #4]
   1457e:	601a      	str	r2, [r3, #0]
   14580:	e009      	b.n	14596 <_strtol_r+0x116>
   14582:	2430      	movs	r4, #48	; 0x30
   14584:	2e00      	cmp	r6, #0
   14586:	d1aa      	bne.n	144de <_strtol_r+0x5e>
   14588:	2608      	movs	r6, #8
   1458a:	e7a8      	b.n	144de <_strtol_r+0x5e>
   1458c:	260a      	movs	r6, #10
   1458e:	e7a6      	b.n	144de <_strtol_r+0x5e>
   14590:	2c30      	cmp	r4, #48	; 0x30
   14592:	d09c      	beq.n	144ce <_strtol_r+0x4e>
   14594:	e7a3      	b.n	144de <_strtol_r+0x5e>
   14596:	b007      	add	sp, #28
   14598:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1459a:	46c0      	nop			; (mov r8, r8)
   1459c:	200001e4 	.word	0x200001e4
   145a0:	7fffffff 	.word	0x7fffffff

000145a4 <_strtoul_r>:
   145a4:	b5f0      	push	{r4, r5, r6, r7, lr}
   145a6:	001e      	movs	r6, r3
   145a8:	4b3f      	ldr	r3, [pc, #252]	; (146a8 <_strtoul_r+0x104>)
   145aa:	b087      	sub	sp, #28
   145ac:	681b      	ldr	r3, [r3, #0]
   145ae:	9104      	str	r1, [sp, #16]
   145b0:	9302      	str	r3, [sp, #8]
   145b2:	0017      	movs	r7, r2
   145b4:	000b      	movs	r3, r1
   145b6:	2108      	movs	r1, #8
   145b8:	9005      	str	r0, [sp, #20]
   145ba:	781c      	ldrb	r4, [r3, #0]
   145bc:	9a02      	ldr	r2, [sp, #8]
   145be:	1c5d      	adds	r5, r3, #1
   145c0:	1912      	adds	r2, r2, r4
   145c2:	7852      	ldrb	r2, [r2, #1]
   145c4:	400a      	ands	r2, r1
   145c6:	d001      	beq.n	145cc <_strtoul_r+0x28>
   145c8:	002b      	movs	r3, r5
   145ca:	e7f6      	b.n	145ba <_strtoul_r+0x16>
   145cc:	2c2d      	cmp	r4, #45	; 0x2d
   145ce:	d104      	bne.n	145da <_strtoul_r+0x36>
   145d0:	1c9d      	adds	r5, r3, #2
   145d2:	785c      	ldrb	r4, [r3, #1]
   145d4:	2301      	movs	r3, #1
   145d6:	9301      	str	r3, [sp, #4]
   145d8:	e004      	b.n	145e4 <_strtoul_r+0x40>
   145da:	9201      	str	r2, [sp, #4]
   145dc:	2c2b      	cmp	r4, #43	; 0x2b
   145de:	d101      	bne.n	145e4 <_strtoul_r+0x40>
   145e0:	785c      	ldrb	r4, [r3, #1]
   145e2:	1c9d      	adds	r5, r3, #2
   145e4:	2e00      	cmp	r6, #0
   145e6:	d002      	beq.n	145ee <_strtoul_r+0x4a>
   145e8:	2e10      	cmp	r6, #16
   145ea:	d10a      	bne.n	14602 <_strtoul_r+0x5e>
   145ec:	e057      	b.n	1469e <_strtoul_r+0xfa>
   145ee:	2c30      	cmp	r4, #48	; 0x30
   145f0:	d153      	bne.n	1469a <_strtoul_r+0xf6>
   145f2:	2220      	movs	r2, #32
   145f4:	782b      	ldrb	r3, [r5, #0]
   145f6:	4393      	bics	r3, r2
   145f8:	2b58      	cmp	r3, #88	; 0x58
   145fa:	d149      	bne.n	14690 <_strtoul_r+0xec>
   145fc:	2610      	movs	r6, #16
   145fe:	786c      	ldrb	r4, [r5, #1]
   14600:	3502      	adds	r5, #2
   14602:	2001      	movs	r0, #1
   14604:	0031      	movs	r1, r6
   14606:	4240      	negs	r0, r0
   14608:	f7fd fdd8 	bl	121bc <__aeabi_uidiv>
   1460c:	9003      	str	r0, [sp, #12]
   1460e:	2001      	movs	r0, #1
   14610:	0031      	movs	r1, r6
   14612:	4240      	negs	r0, r0
   14614:	f7fd fe58 	bl	122c8 <__aeabi_uidivmod>
   14618:	2300      	movs	r3, #0
   1461a:	468c      	mov	ip, r1
   1461c:	0018      	movs	r0, r3
   1461e:	9a02      	ldr	r2, [sp, #8]
   14620:	1912      	adds	r2, r2, r4
   14622:	7851      	ldrb	r1, [r2, #1]
   14624:	2204      	movs	r2, #4
   14626:	4211      	tst	r1, r2
   14628:	d001      	beq.n	1462e <_strtoul_r+0x8a>
   1462a:	3c30      	subs	r4, #48	; 0x30
   1462c:	e007      	b.n	1463e <_strtoul_r+0x9a>
   1462e:	2203      	movs	r2, #3
   14630:	4011      	ands	r1, r2
   14632:	d017      	beq.n	14664 <_strtoul_r+0xc0>
   14634:	3234      	adds	r2, #52	; 0x34
   14636:	2901      	cmp	r1, #1
   14638:	d000      	beq.n	1463c <_strtoul_r+0x98>
   1463a:	3220      	adds	r2, #32
   1463c:	1aa4      	subs	r4, r4, r2
   1463e:	42a6      	cmp	r6, r4
   14640:	dd10      	ble.n	14664 <_strtoul_r+0xc0>
   14642:	2b00      	cmp	r3, #0
   14644:	db09      	blt.n	1465a <_strtoul_r+0xb6>
   14646:	9b03      	ldr	r3, [sp, #12]
   14648:	4298      	cmp	r0, r3
   1464a:	d806      	bhi.n	1465a <_strtoul_r+0xb6>
   1464c:	d101      	bne.n	14652 <_strtoul_r+0xae>
   1464e:	4564      	cmp	r4, ip
   14650:	dc03      	bgt.n	1465a <_strtoul_r+0xb6>
   14652:	4370      	muls	r0, r6
   14654:	2301      	movs	r3, #1
   14656:	1820      	adds	r0, r4, r0
   14658:	e001      	b.n	1465e <_strtoul_r+0xba>
   1465a:	2301      	movs	r3, #1
   1465c:	425b      	negs	r3, r3
   1465e:	782c      	ldrb	r4, [r5, #0]
   14660:	3501      	adds	r5, #1
   14662:	e7dc      	b.n	1461e <_strtoul_r+0x7a>
   14664:	2b00      	cmp	r3, #0
   14666:	da07      	bge.n	14678 <_strtoul_r+0xd4>
   14668:	2322      	movs	r3, #34	; 0x22
   1466a:	2001      	movs	r0, #1
   1466c:	9a05      	ldr	r2, [sp, #20]
   1466e:	4240      	negs	r0, r0
   14670:	6013      	str	r3, [r2, #0]
   14672:	2f00      	cmp	r7, #0
   14674:	d109      	bne.n	1468a <_strtoul_r+0xe6>
   14676:	e015      	b.n	146a4 <_strtoul_r+0x100>
   14678:	9a01      	ldr	r2, [sp, #4]
   1467a:	2a00      	cmp	r2, #0
   1467c:	d000      	beq.n	14680 <_strtoul_r+0xdc>
   1467e:	4240      	negs	r0, r0
   14680:	2f00      	cmp	r7, #0
   14682:	d00f      	beq.n	146a4 <_strtoul_r+0x100>
   14684:	9a04      	ldr	r2, [sp, #16]
   14686:	2b00      	cmp	r3, #0
   14688:	d000      	beq.n	1468c <_strtoul_r+0xe8>
   1468a:	1e6a      	subs	r2, r5, #1
   1468c:	603a      	str	r2, [r7, #0]
   1468e:	e009      	b.n	146a4 <_strtoul_r+0x100>
   14690:	2430      	movs	r4, #48	; 0x30
   14692:	2e00      	cmp	r6, #0
   14694:	d1b5      	bne.n	14602 <_strtoul_r+0x5e>
   14696:	2608      	movs	r6, #8
   14698:	e7b3      	b.n	14602 <_strtoul_r+0x5e>
   1469a:	260a      	movs	r6, #10
   1469c:	e7b1      	b.n	14602 <_strtoul_r+0x5e>
   1469e:	2c30      	cmp	r4, #48	; 0x30
   146a0:	d0a7      	beq.n	145f2 <_strtoul_r+0x4e>
   146a2:	e7ae      	b.n	14602 <_strtoul_r+0x5e>
   146a4:	b007      	add	sp, #28
   146a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   146a8:	200001e4 	.word	0x200001e4

000146ac <__submore>:
   146ac:	000b      	movs	r3, r1
   146ae:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   146b0:	6b4d      	ldr	r5, [r1, #52]	; 0x34
   146b2:	3344      	adds	r3, #68	; 0x44
   146b4:	000c      	movs	r4, r1
   146b6:	429d      	cmp	r5, r3
   146b8:	d11b      	bne.n	146f2 <__submore+0x46>
   146ba:	2680      	movs	r6, #128	; 0x80
   146bc:	00f6      	lsls	r6, r6, #3
   146be:	0031      	movs	r1, r6
   146c0:	f7fe f8fe 	bl	128c0 <_malloc_r>
   146c4:	2800      	cmp	r0, #0
   146c6:	d102      	bne.n	146ce <__submore+0x22>
   146c8:	2001      	movs	r0, #1
   146ca:	4240      	negs	r0, r0
   146cc:	e025      	b.n	1471a <__submore+0x6e>
   146ce:	0023      	movs	r3, r4
   146d0:	6360      	str	r0, [r4, #52]	; 0x34
   146d2:	63a6      	str	r6, [r4, #56]	; 0x38
   146d4:	3346      	adds	r3, #70	; 0x46
   146d6:	781a      	ldrb	r2, [r3, #0]
   146d8:	4b10      	ldr	r3, [pc, #64]	; (1471c <__submore+0x70>)
   146da:	54c2      	strb	r2, [r0, r3]
   146dc:	0023      	movs	r3, r4
   146de:	3345      	adds	r3, #69	; 0x45
   146e0:	781a      	ldrb	r2, [r3, #0]
   146e2:	4b0f      	ldr	r3, [pc, #60]	; (14720 <__submore+0x74>)
   146e4:	54c2      	strb	r2, [r0, r3]
   146e6:	782a      	ldrb	r2, [r5, #0]
   146e8:	4b0e      	ldr	r3, [pc, #56]	; (14724 <__submore+0x78>)
   146ea:	54c2      	strb	r2, [r0, r3]
   146ec:	18c0      	adds	r0, r0, r3
   146ee:	6020      	str	r0, [r4, #0]
   146f0:	e012      	b.n	14718 <__submore+0x6c>
   146f2:	6b8e      	ldr	r6, [r1, #56]	; 0x38
   146f4:	0029      	movs	r1, r5
   146f6:	0073      	lsls	r3, r6, #1
   146f8:	001a      	movs	r2, r3
   146fa:	9301      	str	r3, [sp, #4]
   146fc:	f000 f8b5 	bl	1486a <_realloc_r>
   14700:	1e05      	subs	r5, r0, #0
   14702:	d0e1      	beq.n	146c8 <__submore+0x1c>
   14704:	1987      	adds	r7, r0, r6
   14706:	0001      	movs	r1, r0
   14708:	0032      	movs	r2, r6
   1470a:	0038      	movs	r0, r7
   1470c:	f7fe f86b 	bl	127e6 <memcpy>
   14710:	9b01      	ldr	r3, [sp, #4]
   14712:	6027      	str	r7, [r4, #0]
   14714:	6365      	str	r5, [r4, #52]	; 0x34
   14716:	63a3      	str	r3, [r4, #56]	; 0x38
   14718:	2000      	movs	r0, #0
   1471a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1471c:	000003ff 	.word	0x000003ff
   14720:	000003fe 	.word	0x000003fe
   14724:	000003fd 	.word	0x000003fd

00014728 <_ungetc_r>:
   14728:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1472a:	0005      	movs	r5, r0
   1472c:	000e      	movs	r6, r1
   1472e:	0014      	movs	r4, r2
   14730:	1c4b      	adds	r3, r1, #1
   14732:	d102      	bne.n	1473a <_ungetc_r+0x12>
   14734:	2001      	movs	r0, #1
   14736:	4240      	negs	r0, r0
   14738:	e060      	b.n	147fc <_ungetc_r+0xd4>
   1473a:	2800      	cmp	r0, #0
   1473c:	d004      	beq.n	14748 <_ungetc_r+0x20>
   1473e:	6983      	ldr	r3, [r0, #24]
   14740:	2b00      	cmp	r3, #0
   14742:	d101      	bne.n	14748 <_ungetc_r+0x20>
   14744:	f7fe fd1e 	bl	13184 <__sinit>
   14748:	4b2d      	ldr	r3, [pc, #180]	; (14800 <_ungetc_r+0xd8>)
   1474a:	429c      	cmp	r4, r3
   1474c:	d101      	bne.n	14752 <_ungetc_r+0x2a>
   1474e:	686c      	ldr	r4, [r5, #4]
   14750:	e008      	b.n	14764 <_ungetc_r+0x3c>
   14752:	4b2c      	ldr	r3, [pc, #176]	; (14804 <_ungetc_r+0xdc>)
   14754:	429c      	cmp	r4, r3
   14756:	d101      	bne.n	1475c <_ungetc_r+0x34>
   14758:	68ac      	ldr	r4, [r5, #8]
   1475a:	e003      	b.n	14764 <_ungetc_r+0x3c>
   1475c:	4b2a      	ldr	r3, [pc, #168]	; (14808 <_ungetc_r+0xe0>)
   1475e:	429c      	cmp	r4, r3
   14760:	d100      	bne.n	14764 <_ungetc_r+0x3c>
   14762:	68ec      	ldr	r4, [r5, #12]
   14764:	2220      	movs	r2, #32
   14766:	89a3      	ldrh	r3, [r4, #12]
   14768:	4393      	bics	r3, r2
   1476a:	b21b      	sxth	r3, r3
   1476c:	81a3      	strh	r3, [r4, #12]
   1476e:	b29b      	uxth	r3, r3
   14770:	075a      	lsls	r2, r3, #29
   14772:	d413      	bmi.n	1479c <_ungetc_r+0x74>
   14774:	06da      	lsls	r2, r3, #27
   14776:	d5dd      	bpl.n	14734 <_ungetc_r+0xc>
   14778:	2708      	movs	r7, #8
   1477a:	423b      	tst	r3, r7
   1477c:	d00a      	beq.n	14794 <_ungetc_r+0x6c>
   1477e:	0021      	movs	r1, r4
   14780:	0028      	movs	r0, r5
   14782:	f7fe fc7d 	bl	13080 <_fflush_r>
   14786:	2800      	cmp	r0, #0
   14788:	d1d4      	bne.n	14734 <_ungetc_r+0xc>
   1478a:	89a3      	ldrh	r3, [r4, #12]
   1478c:	60a0      	str	r0, [r4, #8]
   1478e:	43bb      	bics	r3, r7
   14790:	81a3      	strh	r3, [r4, #12]
   14792:	61a0      	str	r0, [r4, #24]
   14794:	2204      	movs	r2, #4
   14796:	89a3      	ldrh	r3, [r4, #12]
   14798:	4313      	orrs	r3, r2
   1479a:	81a3      	strh	r3, [r4, #12]
   1479c:	6b62      	ldr	r2, [r4, #52]	; 0x34
   1479e:	b2f7      	uxtb	r7, r6
   147a0:	6863      	ldr	r3, [r4, #4]
   147a2:	2a00      	cmp	r2, #0
   147a4:	d00f      	beq.n	147c6 <_ungetc_r+0x9e>
   147a6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   147a8:	4293      	cmp	r3, r2
   147aa:	da05      	bge.n	147b8 <_ungetc_r+0x90>
   147ac:	6823      	ldr	r3, [r4, #0]
   147ae:	3b01      	subs	r3, #1
   147b0:	6023      	str	r3, [r4, #0]
   147b2:	701e      	strb	r6, [r3, #0]
   147b4:	6863      	ldr	r3, [r4, #4]
   147b6:	e011      	b.n	147dc <_ungetc_r+0xb4>
   147b8:	0021      	movs	r1, r4
   147ba:	0028      	movs	r0, r5
   147bc:	f7ff ff76 	bl	146ac <__submore>
   147c0:	2800      	cmp	r0, #0
   147c2:	d0f3      	beq.n	147ac <_ungetc_r+0x84>
   147c4:	e7b6      	b.n	14734 <_ungetc_r+0xc>
   147c6:	6921      	ldr	r1, [r4, #16]
   147c8:	6822      	ldr	r2, [r4, #0]
   147ca:	2900      	cmp	r1, #0
   147cc:	d008      	beq.n	147e0 <_ungetc_r+0xb8>
   147ce:	4291      	cmp	r1, r2
   147d0:	d206      	bcs.n	147e0 <_ungetc_r+0xb8>
   147d2:	1e51      	subs	r1, r2, #1
   147d4:	7808      	ldrb	r0, [r1, #0]
   147d6:	4287      	cmp	r7, r0
   147d8:	d102      	bne.n	147e0 <_ungetc_r+0xb8>
   147da:	6021      	str	r1, [r4, #0]
   147dc:	3301      	adds	r3, #1
   147de:	e00b      	b.n	147f8 <_ungetc_r+0xd0>
   147e0:	6423      	str	r3, [r4, #64]	; 0x40
   147e2:	0023      	movs	r3, r4
   147e4:	3344      	adds	r3, #68	; 0x44
   147e6:	6363      	str	r3, [r4, #52]	; 0x34
   147e8:	2303      	movs	r3, #3
   147ea:	63a3      	str	r3, [r4, #56]	; 0x38
   147ec:	0023      	movs	r3, r4
   147ee:	3346      	adds	r3, #70	; 0x46
   147f0:	63e2      	str	r2, [r4, #60]	; 0x3c
   147f2:	701e      	strb	r6, [r3, #0]
   147f4:	6023      	str	r3, [r4, #0]
   147f6:	2301      	movs	r3, #1
   147f8:	0038      	movs	r0, r7
   147fa:	6063      	str	r3, [r4, #4]
   147fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   147fe:	46c0      	nop			; (mov r8, r8)
   14800:	00015a5c 	.word	0x00015a5c
   14804:	00015a7c 	.word	0x00015a7c
   14808:	00015a9c 	.word	0x00015a9c

0001480c <_fstat_r>:
   1480c:	2300      	movs	r3, #0
   1480e:	b570      	push	{r4, r5, r6, lr}
   14810:	4c06      	ldr	r4, [pc, #24]	; (1482c <_fstat_r+0x20>)
   14812:	0005      	movs	r5, r0
   14814:	0008      	movs	r0, r1
   14816:	0011      	movs	r1, r2
   14818:	6023      	str	r3, [r4, #0]
   1481a:	f7fd fc55 	bl	120c8 <_fstat>
   1481e:	1c43      	adds	r3, r0, #1
   14820:	d103      	bne.n	1482a <_fstat_r+0x1e>
   14822:	6823      	ldr	r3, [r4, #0]
   14824:	2b00      	cmp	r3, #0
   14826:	d000      	beq.n	1482a <_fstat_r+0x1e>
   14828:	602b      	str	r3, [r5, #0]
   1482a:	bd70      	pop	{r4, r5, r6, pc}
   1482c:	20001880 	.word	0x20001880

00014830 <_isatty_r>:
   14830:	2300      	movs	r3, #0
   14832:	b570      	push	{r4, r5, r6, lr}
   14834:	4c06      	ldr	r4, [pc, #24]	; (14850 <_isatty_r+0x20>)
   14836:	0005      	movs	r5, r0
   14838:	0008      	movs	r0, r1
   1483a:	6023      	str	r3, [r4, #0]
   1483c:	f7fd fc52 	bl	120e4 <_isatty>
   14840:	1c43      	adds	r3, r0, #1
   14842:	d103      	bne.n	1484c <_isatty_r+0x1c>
   14844:	6823      	ldr	r3, [r4, #0]
   14846:	2b00      	cmp	r3, #0
   14848:	d000      	beq.n	1484c <_isatty_r+0x1c>
   1484a:	602b      	str	r3, [r5, #0]
   1484c:	bd70      	pop	{r4, r5, r6, pc}
   1484e:	46c0      	nop			; (mov r8, r8)
   14850:	20001880 	.word	0x20001880

00014854 <memchr>:
   14854:	b2c9      	uxtb	r1, r1
   14856:	1882      	adds	r2, r0, r2
   14858:	4290      	cmp	r0, r2
   1485a:	d004      	beq.n	14866 <memchr+0x12>
   1485c:	7803      	ldrb	r3, [r0, #0]
   1485e:	428b      	cmp	r3, r1
   14860:	d002      	beq.n	14868 <memchr+0x14>
   14862:	3001      	adds	r0, #1
   14864:	e7f8      	b.n	14858 <memchr+0x4>
   14866:	2000      	movs	r0, #0
   14868:	4770      	bx	lr

0001486a <_realloc_r>:
   1486a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1486c:	0006      	movs	r6, r0
   1486e:	000c      	movs	r4, r1
   14870:	0015      	movs	r5, r2
   14872:	2900      	cmp	r1, #0
   14874:	d104      	bne.n	14880 <_realloc_r+0x16>
   14876:	0011      	movs	r1, r2
   14878:	f7fe f822 	bl	128c0 <_malloc_r>
   1487c:	0004      	movs	r4, r0
   1487e:	e018      	b.n	148b2 <_realloc_r+0x48>
   14880:	2a00      	cmp	r2, #0
   14882:	d103      	bne.n	1488c <_realloc_r+0x22>
   14884:	f7fd ffd6 	bl	12834 <_free_r>
   14888:	002c      	movs	r4, r5
   1488a:	e012      	b.n	148b2 <_realloc_r+0x48>
   1488c:	f000 f813 	bl	148b6 <_malloc_usable_size_r>
   14890:	4285      	cmp	r5, r0
   14892:	d90e      	bls.n	148b2 <_realloc_r+0x48>
   14894:	0029      	movs	r1, r5
   14896:	0030      	movs	r0, r6
   14898:	f7fe f812 	bl	128c0 <_malloc_r>
   1489c:	1e07      	subs	r7, r0, #0
   1489e:	d007      	beq.n	148b0 <_realloc_r+0x46>
   148a0:	0021      	movs	r1, r4
   148a2:	002a      	movs	r2, r5
   148a4:	f7fd ff9f 	bl	127e6 <memcpy>
   148a8:	0021      	movs	r1, r4
   148aa:	0030      	movs	r0, r6
   148ac:	f7fd ffc2 	bl	12834 <_free_r>
   148b0:	003c      	movs	r4, r7
   148b2:	0020      	movs	r0, r4
   148b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000148b6 <_malloc_usable_size_r>:
   148b6:	1f0b      	subs	r3, r1, #4
   148b8:	681a      	ldr	r2, [r3, #0]
   148ba:	1f10      	subs	r0, r2, #4
   148bc:	2a00      	cmp	r2, #0
   148be:	da04      	bge.n	148ca <_malloc_usable_size_r+0x14>
   148c0:	1889      	adds	r1, r1, r2
   148c2:	3904      	subs	r1, #4
   148c4:	680b      	ldr	r3, [r1, #0]
   148c6:	18d0      	adds	r0, r2, r3
   148c8:	3804      	subs	r0, #4
   148ca:	4770      	bx	lr

000148cc <g_cert_template_1_signer>:
   148cc:	8230 f001 8230 9701 03a0 0102 0202 6911     0...0..........i
   148dc:	508a 710d fca3 a537 1db8 0544 2fba 01c4     .P.q..7...D../..
   148ec:	0a30 0806 862a ce48 043d 0203 4330 1d31     0...*.H.=...0C1.
   148fc:	1b30 0306 0455 0c0a 4514 6178 706d 656c     0...U....Example
   1490c:	4f20 6772 6e61 7a69 7461 6f69 316e 3022      Organization1"0
   1491c:	0620 5503 0304 190c 7845 6d61 6c70 2065      ..U....Example 
   1492c:	5441 4345 3543 3830 2041 6f52 746f 4320     ATECC508A Root C
   1493c:	3041 1720 310d 3135 3132 3237 3033 3030     A0 ..15121723000
   1494c:	5a30 0f18 3939 3939 3231 3133 3332 3935     0Z..999912312359
   1495c:	3935 305a 3147 301d 061b 5503 0a04 140c     59Z0G1.0...U....
   1496c:	7845 6d61 6c70 2065 724f 6167 696e 617a     Example Organiza
   1497c:	6974 6e6f 2631 2430 0306 0455 0c03 451d     tion1&0$..U....E
   1498c:	6178 706d 656c 4120 4554 4343 3035 4138     xample ATECC508A
   1499c:	5320 6769 656e 2072 3030 3433 5930 1330      Signer 00340Y0.
   149ac:	0706 862a ce48 023d 0601 2a08 4886 3dce     ..*.H.=....*.H.=
   149bc:	0103 0307 0042 4404 e60a 5ec5 d53d 2abe     ....B..D...^=..*
   149cc:	49ce 4b00 8d1a 01f3 2c1b 2657 e186 9f95     .I.K.....,W&....
   149dc:	5cf1 1871 8e06 6dfc 1bb1 8c05 bde2 96ef     .\q....m........
   149ec:	54d9 0953 5781 f2b9 908a 8b40 7055 5283     .TS..W....@.Up.R
   149fc:	eba6 8b5a c17f a374 3066 3064 0612 5503     ..Z...t.f0d0...U
   14a0c:	131d 0101 04ff 3008 0106 ff01 0102 3000     .......0.......0
   14a1c:	060e 5503 0f1d 0101 04ff 0304 0202 3084     ...U...........0
   14a2c:	061d 5503 0e1d 1604 1404 cd04 19e7 832e     ...U............
   14a3c:	a465 3bc5 a9ae ac8c 1cd2 fbaf 2ccf 1f30     e..;.........,0.
   14a4c:	0306 1d55 0423 3018 8016 3714 a10a eb3a     ..U.#..0...7..:.
   14a5c:	cfeb 8909 8270 3a6b 74b2 96fb 6872 30d3     ....p.k:.t..rh.0
   14a6c:	060a 2a08 4886 3dce 0304 0302 0047 4430     ...*.H.=....G.0D
   14a7c:	2002 5e77 8a46 72a4 e823 1526 1f9f 71f2     . w^F..r#.&....q
   14a8c:	0be5 4a73 99a8 c4f4 56fe a765 f7e6 0b0a     ..sJ.....Ve.....
   14a9c:	cbe2 2002 981a ec24 51d0 980d 1fd2 88e9     ... ..$..Q......
   14aac:	4c83 5f1f cb75 d397 530c fb58 3058 ac0a     .L._u....SX.X0..
   14abc:	451b 1dba                                   .E..

00014ac0 <g_cert_def_1_signer>:
   14ac0:	0100 0000 070a 0000 0000 0000 0401 0004     ................
   14ad0:	019b 0200 000b 0000 0048 0c02 0000 4800     ........H......H
   14ae0:	f700 4000 ab00 4a01 7500 0d00 8400 0f00     ...@...J.u......
   14af0:	d800 0400 0f00 1000 8b00 1401 6a00 1401     .............j..
   14b00:	0000 0000 0000 48cc 0001 01f4               .......H....

00014b0c <g_cert_template_2_device>:
   14b0c:	8230 ae01 8230 5301 03a0 0102 0202 4011     0...0..S.......@
   14b1c:	0201 0403 0605 0807 0a09 0c0b 0e0d 020f     ................
   14b2c:	0a30 0806 862a ce48 043d 0203 4730 1d31     0...*.H.=...0G1.
   14b3c:	1b30 0306 0455 0c0a 4514 6178 706d 656c     0...U....Example
   14b4c:	4f20 6772 6e61 7a69 7461 6f69 316e 3026      Organization1&0
   14b5c:	0624 5503 0304 1d0c 7845 6d61 6c70 2065     $..U....Example 
   14b6c:	5441 4345 3543 3830 2041 6953 6e67 7265     ATECC508A Signer
   14b7c:	3020 3330 3034 1720 310d 3135 3132 3036      00340 ..1512160
   14b8c:	3532 3331 5a37 0f18 3939 3939 3231 3133     25137Z..99991231
   14b9c:	3332 3935 3935 305a 3142 301d 061b 5503     235959Z0B1.0...U
   14bac:	0a04 140c 7845 6d61 6c70 2065 724f 6167     ....Example Orga
   14bbc:	696e 617a 6974 6e6f 2131 1f30 0306 0455     nization1!0...U.
   14bcc:	0c03 4518 6178 706d 656c 4120 4554 4343     ...Example ATECC
   14bdc:	3035 4138 4420 7665 6369 3065 3059 0613     508A Device0Y0..
   14bec:	2a07 4886 3dce 0102 0806 862a ce48 033d     .*.H.=....*.H.=.
   14bfc:	0701 4203 0400 9a81 769b e323 e920 6d85     ...B.....v#. ..m
   14c0c:	ee74 94cc 0660 7edb e364 b386 f53b 4208     t...`..~d...;..B
   14c1c:	3947 5d8e 22d3 5baf 57dc c6bb d2c0 f818     G9.].".[.W......
   14c2c:	0182 1e2f da3b f2f7 22ed caaa f588 3a7c     ../.;...."....|:
   14c3c:	5aee 3e3c f51d 23a3 2130 1f30 0306 1d55     .Z<>...#0!0...U.
   14c4c:	0423 3018 8016 0414 e7cd 2e19 6583 c5a4     #..0.........e..
   14c5c:	ae3b 8ca9 d2ac af1c cffb 302c 060a 2a08     ;.........,0...*
   14c6c:	4886 3dce 0304 0302 0049 4630 2102 c300     .H.=....I.0F.!..
   14c7c:	5410 26b6 02e1 9e0b 02a8 a4e7 0f58 94c3     .T.&........X...
   14c8c:	a480 b264 0ac8 e250 7169 3287 c34b 02aa     ..d...P.iq.2K...
   14c9c:	0021 a284 ed28 1dab 9aa9 3616 2a77 e01e     !...(......6w*..
   14cac:	3bbb 4b1f bccf d26b ba54 5fb7 bb79 4456     .;.K..k.T.._y.VD
   14cbc:	e430 0000                                   0...

00014cc0 <g_cert_def_2_device>:
   14cc0:	0200 0000 070a 0000 0000 0000 0401 0004     ................
   14cd0:	0157 0200 0100 0000 0040 0a02 0000 4800     W.......@......H
   14ce0:	f600 4000 6700 4a01 7900 0d00 8800 0f00     ...@.g.J.y......
   14cf0:	7100 0400 0f00 1000 4700 1401 0000 0000     .q.......G......
   14d00:	0000 0000 0000 4b0c 0001 01b2               .......K....

00014d0c <k.4563>:
   14d0c:	2f98 428a 4491 7137 fbcf b5c0 dba5 e9b5     ./.B.D7q........
   14d1c:	c25b 3956 11f1 59f1 82a4 923f 5ed5 ab1c     [.V9...Y..?..^..
   14d2c:	aa98 d807 5b01 1283 85be 2431 7dc3 550c     .....[....1$.}.U
   14d3c:	5d74 72be b1fe 80de 06a7 9bdc f174 c19b     t].r........t...
   14d4c:	69c1 e49b 4786 efbe 9dc6 0fc1 a1cc 240c     .i...G.........$
   14d5c:	2c6f 2de9 84aa 4a74 a9dc 5cb0 88da 76f9     o,.-..tJ...\...v
   14d6c:	5152 983e c66d a831 27c8 b003 7fc7 bf59     RQ>.m.1..'....Y.
   14d7c:	0bf3 c6e0 9147 d5a7 6351 06ca 2967 1429     ....G...Qc..g)).
   14d8c:	0a85 27b7 2138 2e1b 6dfc 4d2c 0d13 5338     ...'8!...m,M..8S
   14d9c:	7354 650a 0abb 766a c92e 81c2 2c85 9272     Ts.e..jv.....,r.
   14dac:	e8a1 a2bf 664b a81a 8b70 c24b 51a3 c76c     ....Kf..p.K..Ql.
   14dbc:	e819 d192 0624 d699 3585 f40e a070 106a     ....$....5..p.j.
   14dcc:	c116 19a4 6c08 1e37 774c 2748 bcb5 34b0     .....l7.LwH'...4
   14ddc:	0cb3 391c aa4a 4ed8 ca4f 5b9c 6ff3 682e     ...9J..NO..[.o.h
   14dec:	82ee 748f 636f 78a5 7814 84c8 0208 8cc7     ...toc.x.x......
   14dfc:	fffa 90be 6ceb a450 a3f7 bef9 78f2 c671     .....lP......xq.

00014e0c <hash_init.4595>:
   14e0c:	e667 6a09 ae85 bb67 f372 3c6e f53a a54f     g..j..g.r.n<:.O.
   14e1c:	527f 510e 688c 9b05 d9ab 1f83 cd19 5be0     .R.Q.h.........[
   14e2c:	4c43 4549 544e 203a 6552 7562 6c69 2074     CLIENT: Rebuilt 
   14e3c:	6953 6e67 7265 4320 7265 6974 6966 6163     Signer Certifica
   14e4c:	6574 0d3a 250a 0d73 000a 0000 4c43 4549     te:..%s.....CLIE
   14e5c:	544e 203a 6552 7562 6c69 2074 6544 6976     NT: Rebuilt Devi
   14e6c:	6563 4320 7265 6974 6966 6163 6574 0d3a     ce Certificate:.
   14e7c:	250a 0d73 000a 0000 4f48 5453 203a 6953     .%s.....HOST: Si
   14e8c:	6e67 7265 6320 7265 6974 6966 6163 6574     gner certificate
   14e9c:	7620 7265 6669 6569 2064 6761 6961 736e      verified agains
   14eac:	2074 6973 6e67 7265 6320 7265 6974 6966     t signer certifi
   14ebc:	6163 6574 6120 7475 6f68 6972 7974 2820     cate authority (
   14ecc:	4143 2029 7570 6c62 6369 6b20 7965 0d21     CA) public key!.
   14edc:	0000 0000 4f48 5453 203a 6544 6976 6563     ....HOST: Device
   14eec:	6320 7265 6974 6966 6163 6574 7620 7265      certificate ver
   14efc:	6669 6569 2064 6761 6961 736e 2074 6973     ified against si
   14f0c:	6e67 7265 7020 6275 696c 2063 656b 2179     gner public key!
   14f1c:	000d 0000 4f48 5453 203a 6547 656e 6172     ....HOST: Genera
   14f2c:	6574 2064 6863 6c61 656c 676e 3a65 0a0d     ted challenge:..
   14f3c:	7325 0a0d 0000 0000 4c43 4549 544e 203a     %s......CLIENT: 
   14f4c:	6143 636c 6c75 7461 6465 7220 7365 6f70     Calculated respo
   14f5c:	736e 2065 6f74 6820 736f 2074 6863 6c61     nse to host chal
   14f6c:	656c 676e 3a65 0a0d 7325 0a0d 0000 0000     lenge:..%s......
   14f7c:	4f48 5453 203a 6544 6976 6563 7020 6275     HOST: Device pub
   14f8c:	696c 2063 656b 2079 7266 6d6f 6320 7265     lic key from cer
   14f9c:	6974 6966 6163 6574 0d3a 250a 0d73 000a     tificate:..%s...
   14fac:	4f48 5453 203a 6544 6976 6563 7220 7365     HOST: Device res
   14fbc:	6f70 736e 2065 6f74 6320 6168 6c6c 6e65     ponse to challen
   14fcc:	6567 7620 7265 6669 6569 2164 000d 0000     ge verified!....

00014fdc <g_ecc_configdata>:
   14fdc:	2301 0000 0000 0050 0504 0706 00ee 0001     .#....P.........
   14fec:	00c0 0055 208f 44c4 2087 44c4 0f8f 8f8f     ..U.. .D. .D....
   14ffc:	8f9f 6483 44c4 44c4 0f0f 0f0f 0f0f 0f0f     ...d.D.D........
   1500c:	0f0f 0f0f ffff ffff 0000 0000 ffff ffff     ................
   1501c:	0000 0000 ffff ffff ffff ffff ffff ffff     ................
   1502c:	ffff ffff 0000 0000 ffff 0000 0000 0000     ................
   1503c:	0033 001c 0013 001c 003c 001c 001c 0033     3.......<.....3.
   1504c:	001c 001c 003c 003c 003c 003c 003c 003c     ....<.<.<.<.<.<.

0001505c <g_signer_ca_private_key>:
   1505c:	0000 0000 0c49 091e 40e2 00af 6be9 3243     ....I....@...kC2
   1506c:	0e92 8f15 5869 d48e c725 8bf6 6a0c 5d52     ....iX..%....jR]
   1507c:	210d ee4f 6953 6e67 7265 4320 2041 6c73     .!O.Signer CA sl
   1508c:	746f 2520 2064 6f6e 2074 7661 6961 616c     ot %d not availa
   1509c:	6c62 2e65 5320 6769 656e 2072 4143 6120     ble. Signer CA a
   150ac:	646e 7320 6769 656e 2072 6977 6c6c 6220     nd signer will b
   150bc:	2065 6873 7261 6e69 2067 2061 656b 2e79     e sharing a key.
   150cc:	0a0d 0000 6953 6e67 7265 4320 2041 7550     ....Signer CA Pu
   150dc:	6c62 6369 4b20 7965 0d3a 250a 0d73 000a     blic Key:..%s...
   150ec:	6953 6e67 7265 5020 6275 696c 2063 654b     Signer Public Ke
   150fc:	3a79 0a0d 7325 0a0d 0000 0000 6544 6976     y:..%s......Devi
   1510c:	6563 5020 6275 696c 2063 654b 3a79 0a0d     ce Public Key:..
   1511c:	7325 0a0d 0000 0000 6953 6e67 7265 4320     %s......Signer C
   1512c:	7265 6974 6966 6163 6574 0d3a 250a 0d73     ertificate:..%s.
   1513c:	000a 0000 6544 6976 6563 4320 7265 6974     ....Device Certi
   1514c:	6966 6163 6574 0d3a 250a 0d73 000a 0000     ficate:..%s.....
   1515c:	8bc4 0000 0000 0000 0000 0000 0014 0000     ................
   1516c:	0002 0000 0007 0000 0072 0000 0000 0000     ........r.......
   1517c:	0000 0000 0015 0000 0003 0000 0008 0000     ................
   1518c:	0073 0000 1232 66d0 edf5 c752 9879 aaff     s...2..f..R.y...
   1519c:	43ac 6022 ffdd 109c 6f99 6641 603a fa23     .C"`.....oAf:`#.
   151ac:	aaf6 c53e                                   ..>.

000151b0 <access_key_slot.6209>:
   151b0:	0004 0000 311a 0000 3102 0000 311a 0000     .....1...1...1..
   151c0:	310a 0000 311a 0000 30fa 0000 311a 0000     .1...1...0...1..
   151d0:	311a 0000 311a 0000 3112 0000 0800 4200     .1...1...1.....B
   151e0:	0c00 4200 1000 4200 1400 4200 1800 4200     ...B...B...B...B
   151f0:	1c00 4200 0300 0102                         ...B....

000151f8 <ATCACERT_DATE_FORMAT_SIZES>:
   151f8:	0014 0000 000d 0000 0004 0000 0004 0000     ................
   15208:	000f 0000 5e7a 0000 5e8a 0000 5e9a 0000     ....z^...^...^..
   15218:	5eaa 0000 5eba 0000 5f48 0000 5f58 0000     .^...^..H_..X_..
   15228:	5f68 0000 5f78 0000 5f88 0000 5ff2 0000     h_..x_..._..._..
   15238:	6018 0000 603e 0000 6064 0000 608a 0000     .`..>`..d`...`..

00015248 <month_secs.4716>:
   15248:	de80 0028 ea00 0024 de80 0028 8d00 0027     ..(...$...(...'.
   15258:	de80 0028 8d00 0027 de80 0028 de80 0028     ..(...'...(...(.
   15268:	8d00 0027 de80 0028 8d00 0027 de80 0028     ..'...(...'...(.

00015278 <ATCACERT_DATE_FORMAT_SIZES>:
   15278:	0014 0000 000d 0000 0004 0000 0004 0000     ................
   15288:	000f 0000 910c 0000 9138 0000 9174 0000     ........8...t...
   15298:	928c 0000 9174 0000 928c 0000 9174 0000     ....t.......t...
   152a8:	928c 0000                                   ....

000152ac <device_sn_dev_loc.4981>:
   152ac:	0000 0000 0d00 0000 a69a 0000 a6a2 0000     ................
   152bc:	a6aa 0000 a6b2 0000 a6ba 0000 a6ba 0000     ................
   152cc:	a6ba 0000 a6b2 0000 0004 4003 0a0d 0000     ...........@....
   152dc:	3025 5832 0020 0000 3025 5832 0000 0000     %02X ...%02X....
   152ec:	7825 0000                                   %x..

000152f0 <hashContext_h_init.5733>:
   152f0:	2301 6745 ab89 efcd dcfe 98ba 5476 1032     .#Eg........vT2.
   15300:	e1f0 c3d2 da0c 0000 da4c 0000 da4c 0000     ........L...L...
   15310:	da4c 0000 da4c 0000 daa8 0000 daba 0000     L...L...........
   15320:	daba 0000 daba 0000 daba 0000 6170 6b63     ............pack
   15330:	7465 7320 6e65 2064 7265 6f72 0d72 0000     et send error...
   15340:	6f63 6d6d 6e61 2064 6572 7073 6e6f 6573     command response
   15350:	6520 7272 726f 000d 0080 0110 0200 0800      error..........
   15360:	0400 0005 1104 4333 dcd6 0000 dcec 0000     ......3C........
   15370:	dd02 0000 dd18 0000 dd2e 0000 dd44 0000     ............D...
   15380:	df98 0000 dfae 0000 dfc4 0000 dfda 0000     ................
   15390:	dff0 0000 e006 0000 0a0d 7355 6761 3a65     ..........Usage:
   153a0:	000d 0000 6c63 6569 746e 702d 6f72 6976     ....client-provi
   153b0:	6973 6e6f 2020 202d 6f43 666e 6769 7275     sion  - Configur
   153c0:	2065 6e61 2064 6f6c 6461 6320 7265 6974     e and load certi
   153d0:	6966 6163 6574 6420 7461 2061 6e6f 6f74     ficate data onto
   153e0:	4120 4554 4343 6420 7665 6369 2e65 000d      ATECC device...
   153f0:	6c63 6569 746e 622d 6975 646c 2020 2020     client-build    
   15400:	2020 202d 6552 6461 6320 7265 6974 6966       - Read certifi
   15410:	6163 6574 6420 7461 2061 666f 2066 5441     cate data off AT
   15420:	4345 2043 6564 6976 6563 6120 646e 7220     ECC device and r
   15430:	6265 6975 646c 6620 6c75 206c 6973 6e67     ebuild full sign
   15440:	7265 6120 646e 6420 7665 6369 2065 6563     er and device ce
   15450:	7472 6669 6369 7461 7365 0d2e 0000 0000     rtificates......
   15460:	6f68 7473 632d 6168 6e69 762d 7265 6669     host-chain-verif
   15470:	2079 202d 6556 6972 7966 7420 6568 6320     y - Verify the c
   15480:	7265 6974 6966 6163 6574 6320 6168 6e69     ertificate chain
   15490:	6620 6f72 206d 6874 2065 6c63 6569 746e      from the client
   154a0:	0d2e 0000 6f68 7473 672d 6e65 632d 6168     ....host-gen-cha
   154b0:	206c 2020 2020 202d 6547 656e 6172 6574     l     - Generate
   154c0:	6320 6168 6c6c 6e65 6567 6620 726f 7420      challenge for t
   154d0:	6568 6320 696c 6e65 2e74 000d 6c63 6569     he client...clie
   154e0:	746e 672d 6e65 722d 7365 2070 2020 202d     nt-gen-resp   - 
   154f0:	6547 656e 6172 6574 7220 7365 6f70 736e     Generate respons
   15500:	2065 6f74 6320 6168 6c6c 6e65 6567 6620     e to challenge f
   15510:	6f72 206d 6f68 7473 0d2e 0000 6f68 7473     rom host....host
   15520:	762d 7265 6669 2d79 6572 7073 2020 202d     -verify-resp  - 
   15530:	6556 6972 7966 7420 6568 6320 696c 6e65     Verify the clien
   15540:	2074 6572 7073 6e6f 6573 7420 206f 6874     t response to th
   15550:	2065 6863 6c61 656c 676e 2e65 000d 0000     e challenge.....
   15560:	7455 6c69 7469 2079 7566 636e 6974 6e6f     Utility function
   15570:	3a73 000d 6f6c 6b63 7473 7461 2d20 7a20     s:..lockstat - z
   15580:	6e6f 2065 6f6c 6b63 7320 6174 7574 0d73     one lock status.
   15590:	0000 0000 6f6c 6b63 6663 2067 2d20 6c20     ....lockcfg  - l
   155a0:	636f 206b 6f63 666e 6769 7a20 6e6f 0d65     ock config zone.
   155b0:	0000 0000 6f6c 6b63 6164 6174 2d20 6c20     ....lockdata - l
   155c0:	636f 206b 6164 6174 6120 646e 4f20 5054     ock data and OTP
   155d0:	7a20 6e6f 7365 000d 6e69 6f66 2020 2020      zones..info    
   155e0:	2d20 6720 7465 7420 6568 6320 6968 2070      - get the chip 
   155f0:	6572 6976 6973 6e6f 000d 0000 6573 6e72     revision....sern
   15600:	6d75 2020 2d20 6720 7465 7420 6568 6320     um   - get the c
   15610:	6968 2070 6573 6972 6c61 6e20 6d75 6562     hip serial numbe
   15620:	0d72 0000 7075 6f44 6e77 0909 202d 6177     r...upDown..- wa
   15630:	656b 2d20 6469 656c 772c 6b61 2c65 7320     ke -idle,wake, s
   15640:	656c 7061 0d20 0000 000d 0000 6163 276e     leap .......can'
   15650:	2074 6572 6461 6320 6766 6c20 636f 0d6b     t read cfg lock.
   15660:	0000 0000 6163 276e 2074 6572 6461 6420     ....can't read d
   15670:	7461 2061 6f6c 6b63 000d 0000 6f6c 6b63     ata lock....lock
   15680:	6465 0000 6e75 6f6c 6b63 6465 0000 0000     ed..unlocked....
   15690:	6f43 666e 6769 5a20 6e6f 2065 6f4c 6b63     Config Zone Lock
   156a0:	203a 7325 0a0d 0000 6144 6174 5a20 6e6f     : %s....Data Zon
   156b0:	2065 6f4c 6b63 2020 203a 7325 0a0d 0000     e Lock  : %s....
   156c0:	6568 706c 0000 0000 6f6c 6b63 7473 7461     help....lockstat
   156d0:	0000 0000 6f6c 6b63 6663 0067 6f43 6c75     ....lockcfg.Coul
   156e0:	2064 6f6e 2074 6f6c 6b63 6320 6e6f 6966     d not lock confi
   156f0:	2067 6f7a 656e 000d 6f6c 6b63 6164 6174     g zone..lockdata
   15700:	0000 0000 6f43 6c75 2064 6f6e 2074 6f6c     ....Could not lo
   15710:	6b63 6420 7461 2061 6f7a 656e 000d 0000     ck data zone....
   15720:	6e69 6f66 0000 0000 0a0d 6572 6976 6973     info......revisi
   15730:	6e6f 0d3a 250a 0d73 000a 0000 7075 6f44     on:..%s.....upDo
   15740:	6e77 0000 6152 646e 6d6f 4e20 3a72 0a0d     wn..Random Nr:..
   15750:	7325 0a0d 0000 0000 6e65 3a64 7520 4470     %s......end: upD
   15760:	776f 0d6e 0000 0000 6573 6e72 6d75 0000     own.....sernum..
   15770:	0a0d 6573 6972 6c61 6e20 6d75 6562 3a72     ..serial number:
   15780:	0a0d 7325 0a0d 0000 6c63 6569 746e 702d     ..%s....client-p
   15790:	6f72 6976 6973 6e6f 0000 0000 6c63 6569     rovision....clie
   157a0:	746e 705f 6f72 6976 6973 6e6f 6620 6961     nt_provision fai
   157b0:	656c 2064 6977 6874 6520 7272 726f 6320     led with error c
   157c0:	646f 2065 5825 0a0d 0000 0000 6c63 6569     ode %X......clie
   157d0:	746e 622d 6975 646c 0000 0000 6c63 6569     nt-build....clie
   157e0:	746e 725f 6265 6975 646c 635f 7265 7374     nt_rebuild_certs
   157f0:	6620 6961 656c 2064 6977 6874 6520 7272      failed with err
   15800:	726f 6320 646f 2065 5825 0a0d 0000 0000     or code %X......
   15810:	6f68 7473 632d 6168 6e69 762d 7265 6669     host-chain-verif
   15820:	0079 0000 6f68 7473 765f 7265 6669 5f79     y...host_verify_
   15830:	6563 7472 635f 6168 6e69 6620 6961 656c     cert_chain faile
   15840:	2064 6977 6874 6520 7272 726f 6320 646f     d with error cod
   15850:	2065 5825 0a0d 0000 6f68 7473 672d 6e65     e %X....host-gen
   15860:	632d 6168 006c 0000 6f68 7473 675f 6e65     -chal...host_gen
   15870:	7265 7461 5f65 6863 6c61 656c 676e 2065     erate_challenge 
   15880:	6166 6c69 6465 7720 7469 2068 7265 6f72     failed with erro
   15890:	2072 6f63 6564 2520 0d58 000a 6c63 6569     r code %X...clie
   158a0:	746e 672d 6e65 722d 7365 0070 6c63 6569     nt-gen-resp.clie
   158b0:	746e 675f 6e65 7265 7461 5f65 6572 7073     nt_generate_resp
   158c0:	6e6f 6573 6620 6961 656c 2064 6977 6874     onse failed with
   158d0:	6520 7272 726f 6320 646f 2065 5825 0a0d      error code %X..
   158e0:	0000 0000 6f68 7473 762d 7265 6669 2d79     ....host-verify-
   158f0:	6572 7073 0000 0000 6576 6972 7966 725f     resp....verify_r
   15900:	7365 6f70 736e 2065 6166 6c69 6465 7720     esponse failed w
   15910:	7469 2068 7265 6f72 2072 6f63 6564 2520     ith error code %
   15920:	0d58 000a 0a0d 7973 746e 7861 6520 7272     X.....syntax err
   15930:	726f 6920 206e 6f63 6d6d 6e61 3a64 2520     or in command: %
   15940:	0d73 000a 2024 0000                         s...$ ..

00015948 <_usb_device_irq_bits>:
   15948:	0004 0008 0070 0080 0001 0100 0200 0000     ....p...........

00015958 <_usb_endpoint_irq_bits>:
   15958:	0c03 6010 fc36 0000 fc4c 0000 fdb8 0000     ...`6...L.......
   15968:	fe86 0000 ff54 0000 13fa 0001 1472 0001     ....T.......r...
   15978:	1472 0001 1418 0001 1412 0001 141e 0001     r...............
   15988:	1400 0001 1424 0001 1458 0001 1600 0001     ....$...X.......
   15998:	1650 0001 1650 0001 164c 0001 15f2 0001     P...P...L.......
   159a8:	1612 0001 15e2 0001 1624 0001 1636 0001     ........$...6...
   159b8:	169e 0001 16cc 0001 16cc 0001 16c8 0001     ................
   159c8:	1698 0001 16a4 0001 1692 0001 16aa 0001     ................
   159d8:	16b0 0001 6163 276e 2074 6572 6461 6320     ....can't read c
   159e8:	6766 6c20 636f 0d6b 0000 0000 6163 276e     fg lock.....can'
   159f8:	2074 6572 6461 6420 7461 2061 6f6c 6b63     t read data lock
   15a08:	000d 0000 6f6c 6b63 6465 0000 6e75 6f6c     ....locked..unlo
   15a18:	6b63 6465 0000 0000 6f43 666e 6769 5a20     cked....Config Z
   15a28:	6e6f 2065 6f4c 6b63 203a 7325 0a0d 0000     one Lock: %s....
   15a38:	6144 6174 5a20 6e6f 2065 6f4c 6b63 2020     Data Zone Lock  
   15a48:	203a 7325 0a0d 0000 6325 4300 0000 0000     : %s....%c.C....

00015a58 <_global_impure_ptr>:
   15a58:	0180 2000                                   ... 

00015a5c <__sf_fake_stdin>:
	...

00015a7c <__sf_fake_stdout>:
	...

00015a9c <__sf_fake_stderr>:
	...
   15abc:	2d23 2b30 0020 6c68 004c 6665 4567 4746     #-0+ .hlL.efgEFG
   15acc:	3000 3231 3433 3635 3837 4139 4342 4544     .0123456789ABCDE
   15adc:	0046 3130 3332 3534 3736 3938 6261 6463     F.0123456789abcd
   15aec:	6665 0000 5b0e 0001 5b11 0001 5b14 0001     ef...[...[...[..
   15afc:	2d41 6146 662d 3938 3130 3332 3534 3736     A-Fa-f8901234567
   15b0c:	005d 2d2b 3000 0030 5878 0000                    ].+-.00.xX.

00015b17 <_ctype_>:
   15b17:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
   15b27:	2020 2020 2020 2020 2020 2020 2020 2020                     
   15b37:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
   15b47:	0410 0404 0404 0404 0404 1004 1010 1010     ................
   15b57:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
   15b67:	0101 0101 0101 0101 0101 0101 1010 1010     ................
   15b77:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
   15b87:	0202 0202 0202 0202 0202 0202 1010 1010     ................
   15b97:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...

00015c18 <_init>:
   15c18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15c1a:	46c0      	nop			; (mov r8, r8)
   15c1c:	bcf8      	pop	{r3, r4, r5, r6, r7}
   15c1e:	bc08      	pop	{r3}
   15c20:	469e      	mov	lr, r3
   15c22:	4770      	bx	lr

00015c24 <__init_array_start>:
   15c24:	000000d9 	.word	0x000000d9

00015c28 <_fini>:
   15c28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15c2a:	46c0      	nop			; (mov r8, r8)
   15c2c:	bcf8      	pop	{r3, r4, r5, r6, r7}
   15c2e:	bc08      	pop	{r3}
   15c30:	469e      	mov	lr, r3
   15c32:	4770      	bx	lr

00015c34 <__fini_array_start>:
   15c34:	000000b1 	.word	0x000000b1

Disassembly of section .relocate:

20000000 <portable_delay_cycles>:

// Delay loop is put to SRAM so that FWS will not affect delay time
OPTIMIZE_HIGH
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
20000000:	b580      	push	{r7, lr}
20000002:	b082      	sub	sp, #8
20000004:	af00      	add	r7, sp, #0
20000006:	6078      	str	r0, [r7, #4]

20000008 <loop>:
	UNUSED(n);

	__asm (
20000008:	f3bf 8f5f 	dmb	sy
2000000c:	3801      	subs	r0, #1
2000000e:	2800      	cmp	r0, #0
20000010:	d1fa      	bne.n	20000008 <loop>
		"SUB r0, r0, #1 \n"
#endif
		"CMP r0, #0  \n"
		"BNE loop         "
	);
}
20000012:	46c0      	nop			; (mov r8, r8)
20000014:	46bd      	mov	sp, r7
20000016:	b002      	add	sp, #8
20000018:	bd80      	pop	{r7, pc}
2000001a:	46c0      	nop			; (mov r8, r8)

2000001c <g_signer_cert_size>:
2000001c:	0400 0000                                   ....

20000020 <g_device_cert_size>:
20000020:	0400 0000                                   ....

20000024 <udi_api_cdc_comm>:
20000024:	19b5 0000 1c49 0000 1ca1 0000 1d79 0000     ....I.......y...
20000034:	0000 0000                                   ....

20000038 <udi_api_cdc_data>:
20000038:	1b31 0000 1c65 0000 1d6d 0000 1d79 0000     1...e...m...y...
20000048:	1d85 0000                                   ....

2000004c <udc_string_desc_languageid>:
2000004c:	0304 0409                                   ....

20000050 <udc_string_manufacturer_name>:
20000050:	5441 454d 204c 5341 0046 0000               ATMEL ASF...

2000005c <udc_string_product_name>:
2000005c:	4443 0043                                   CDC.

20000060 <udc_string_desc>:
20000060:	0300 0000 0000 0000 0000 0000 0000 0000     ................
20000070:	0000 0000                                   ....

20000074 <cfg_ateccx08a_i2c_default>:
20000074:	0200 0000 02c0 0000 1a80 0006 0000 0000     ................
	...
20000098:	0320 0000 0014 0000 0000 0000                ...........

200000a4 <exectimes_x08a>:
200000a4:	0001 000d 0014 0032 003a 000b 0073 0017     ......2.:...s...
200000b4:	0002 0020 000e 001d 0003 0030 0017 0001     .. .......0.....
200000c4:	0009 003c 000a 0048 001a 0000               ..<...H.....

200000d0 <exectimes_204a>:
200000d0:	0003 0026 0000 003e 0000 002b 0000 0045     ..&...>...+...E.
200000e0:	0002 0018 0023 003c 0002 0000 0032 0004     ....#.<.....2...
200000f0:	0016 0000 000c 0000 002a 0000               ........*...

200000fc <udc_device_desc>:
200000fc:	0112 0201 0002 4000 03eb 2404 0100 0201     .......@...$....
2000010c:	0100 0000                                   ....

20000110 <udc_device_lpm>:
20000110:	0f05 000c 0701 0210 0002 0000               ............

2000011c <udc_desc_fs>:
2000011c:	0209 0043 0102 c000 0932 0004 0100 0202     ..C.....2.......
2000012c:	0001 2405 1000 0401 0224 0502 0624 0100     ...$....$...$...
2000013c:	2405 0301 0701 8305 4003 1000 0409 0001     .$.......@......
2000014c:	0a02 0000 0700 8105 4002 0000 0507 0202     .........@......
2000015c:	0040 0000                                   @...

20000160 <udi_apis>:
20000160:	0024 2000 0038 2000                         $.. 8.. 

20000168 <udc_config_fs>:
20000168:	011c 2000 0160 2000                         ... `.. 

20000170 <udc_config>:
20000170:	00fc 2000 0168 2000 0110 2000               ... h.. ... 

2000017c <g_interrupt_enabled>:
2000017c:	0001 0000                                   ....

20000180 <impure_data>:
20000180:	0000 0000 5a5c 0001 5a7c 0001 5a9c 0001     ....\Z..|Z...Z..
	...
200001a0:	5a53 0001 0000 0000 0000 0000 0000 0000     SZ..............
	...

200001e0 <_impure_ptr>:
200001e0:	0180 2000                                   ... 

200001e4 <__ctype_ptr__>:
200001e4:	5b17 0001                                   .[..
